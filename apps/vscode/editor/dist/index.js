"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __pow = Math.pow;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a3, b3) => {
    for (var prop in b3 || (b3 = {}))
      if (__hasOwnProp.call(b3, prop))
        __defNormalProp(a3, prop, b3[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b3)) {
        if (__propIsEnum.call(b3, prop))
          __defNormalProp(a3, prop, b3[prop]);
      }
    return a3;
  };
  var __spreadProps = (a3, b3) => __defProps(a3, __getOwnPropDescs(b3));
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for (var i3 = decorators.length - 1, decorator; i3 >= 0; i3--)
      if (decorator = decorators[i3])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp(target, key, result);
    return result;
  };
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e2) {
          reject(e2);
        }
      };
      var step = (x3) => x3.done ? resolve(x3.value) : Promise.resolve(x3.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // ../../../node_modules/react/cjs/react.production.min.js
  var require_react_production_min = __commonJS({
    "../../../node_modules/react/cjs/react.production.min.js"(exports) {
      "use strict";
      var l3 = Symbol.for("react.element");
      var n3 = Symbol.for("react.portal");
      var p3 = Symbol.for("react.fragment");
      var q = Symbol.for("react.strict_mode");
      var r3 = Symbol.for("react.profiler");
      var t4 = Symbol.for("react.provider");
      var u3 = Symbol.for("react.context");
      var v3 = Symbol.for("react.forward_ref");
      var w3 = Symbol.for("react.suspense");
      var x3 = Symbol.for("react.memo");
      var y3 = Symbol.for("react.lazy");
      var z2 = Symbol.iterator;
      function A2(a3) {
        if (null === a3 || "object" !== typeof a3)
          return null;
        a3 = z2 && a3[z2] || a3["@@iterator"];
        return "function" === typeof a3 ? a3 : null;
      }
      var B = { isMounted: function() {
        return false;
      }, enqueueForceUpdate: function() {
      }, enqueueReplaceState: function() {
      }, enqueueSetState: function() {
      } };
      var C2 = Object.assign;
      var D3 = {};
      function E3(a3, b3, e2) {
        this.props = a3;
        this.context = b3;
        this.refs = D3;
        this.updater = e2 || B;
      }
      E3.prototype.isReactComponent = {};
      E3.prototype.setState = function(a3, b3) {
        if ("object" !== typeof a3 && "function" !== typeof a3 && null != a3)
          throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, a3, b3, "setState");
      };
      E3.prototype.forceUpdate = function(a3) {
        this.updater.enqueueForceUpdate(this, a3, "forceUpdate");
      };
      function F() {
      }
      F.prototype = E3.prototype;
      function G(a3, b3, e2) {
        this.props = a3;
        this.context = b3;
        this.refs = D3;
        this.updater = e2 || B;
      }
      var H2 = G.prototype = new F();
      H2.constructor = G;
      C2(H2, E3.prototype);
      H2.isPureReactComponent = true;
      var I = Array.isArray;
      var J = Object.prototype.hasOwnProperty;
      var K = { current: null };
      var L3 = { key: true, ref: true, __self: true, __source: true };
      function M(a3, b3, e2) {
        var d3, c3 = {}, k2 = null, h3 = null;
        if (null != b3)
          for (d3 in void 0 !== b3.ref && (h3 = b3.ref), void 0 !== b3.key && (k2 = "" + b3.key), b3)
            J.call(b3, d3) && !L3.hasOwnProperty(d3) && (c3[d3] = b3[d3]);
        var g3 = arguments.length - 2;
        if (1 === g3)
          c3.children = e2;
        else if (1 < g3) {
          for (var f3 = Array(g3), m3 = 0; m3 < g3; m3++)
            f3[m3] = arguments[m3 + 2];
          c3.children = f3;
        }
        if (a3 && a3.defaultProps)
          for (d3 in g3 = a3.defaultProps, g3)
            void 0 === c3[d3] && (c3[d3] = g3[d3]);
        return { $$typeof: l3, type: a3, key: k2, ref: h3, props: c3, _owner: K.current };
      }
      function N2(a3, b3) {
        return { $$typeof: l3, type: a3.type, key: b3, ref: a3.ref, props: a3.props, _owner: a3._owner };
      }
      function O2(a3) {
        return "object" === typeof a3 && null !== a3 && a3.$$typeof === l3;
      }
      function escape(a3) {
        var b3 = { "=": "=0", ":": "=2" };
        return "$" + a3.replace(/[=:]/g, function(a4) {
          return b3[a4];
        });
      }
      var P2 = /\/+/g;
      function Q(a3, b3) {
        return "object" === typeof a3 && null !== a3 && null != a3.key ? escape("" + a3.key) : b3.toString(36);
      }
      function R3(a3, b3, e2, d3, c3) {
        var k2 = typeof a3;
        if ("undefined" === k2 || "boolean" === k2)
          a3 = null;
        var h3 = false;
        if (null === a3)
          h3 = true;
        else
          switch (k2) {
            case "string":
            case "number":
              h3 = true;
              break;
            case "object":
              switch (a3.$$typeof) {
                case l3:
                case n3:
                  h3 = true;
              }
          }
        if (h3)
          return h3 = a3, c3 = c3(h3), a3 = "" === d3 ? "." + Q(h3, 0) : d3, I(c3) ? (e2 = "", null != a3 && (e2 = a3.replace(P2, "$&/") + "/"), R3(c3, b3, e2, "", function(a4) {
            return a4;
          })) : null != c3 && (O2(c3) && (c3 = N2(c3, e2 + (!c3.key || h3 && h3.key === c3.key ? "" : ("" + c3.key).replace(P2, "$&/") + "/") + a3)), b3.push(c3)), 1;
        h3 = 0;
        d3 = "" === d3 ? "." : d3 + ":";
        if (I(a3))
          for (var g3 = 0; g3 < a3.length; g3++) {
            k2 = a3[g3];
            var f3 = d3 + Q(k2, g3);
            h3 += R3(k2, b3, e2, f3, c3);
          }
        else if (f3 = A2(a3), "function" === typeof f3)
          for (a3 = f3.call(a3), g3 = 0; !(k2 = a3.next()).done; )
            k2 = k2.value, f3 = d3 + Q(k2, g3++), h3 += R3(k2, b3, e2, f3, c3);
        else if ("object" === k2)
          throw b3 = String(a3), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b3 ? "object with keys {" + Object.keys(a3).join(", ") + "}" : b3) + "). If you meant to render a collection of children, use an array instead.");
        return h3;
      }
      function S2(a3, b3, e2) {
        if (null == a3)
          return a3;
        var d3 = [], c3 = 0;
        R3(a3, d3, "", "", function(a4) {
          return b3.call(e2, a4, c3++);
        });
        return d3;
      }
      function T3(a3) {
        if (-1 === a3._status) {
          var b3 = a3._result;
          b3 = b3();
          b3.then(function(b4) {
            if (0 === a3._status || -1 === a3._status)
              a3._status = 1, a3._result = b4;
          }, function(b4) {
            if (0 === a3._status || -1 === a3._status)
              a3._status = 2, a3._result = b4;
          });
          -1 === a3._status && (a3._status = 0, a3._result = b3);
        }
        if (1 === a3._status)
          return a3._result.default;
        throw a3._result;
      }
      var U = { current: null };
      var V2 = { transition: null };
      var W2 = { ReactCurrentDispatcher: U, ReactCurrentBatchConfig: V2, ReactCurrentOwner: K };
      exports.Children = { map: S2, forEach: function(a3, b3, e2) {
        S2(a3, function() {
          b3.apply(this, arguments);
        }, e2);
      }, count: function(a3) {
        var b3 = 0;
        S2(a3, function() {
          b3++;
        });
        return b3;
      }, toArray: function(a3) {
        return S2(a3, function(a4) {
          return a4;
        }) || [];
      }, only: function(a3) {
        if (!O2(a3))
          throw Error("React.Children.only expected to receive a single React element child.");
        return a3;
      } };
      exports.Component = E3;
      exports.Fragment = p3;
      exports.Profiler = r3;
      exports.PureComponent = G;
      exports.StrictMode = q;
      exports.Suspense = w3;
      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W2;
      exports.cloneElement = function(a3, b3, e2) {
        if (null === a3 || void 0 === a3)
          throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a3 + ".");
        var d3 = C2({}, a3.props), c3 = a3.key, k2 = a3.ref, h3 = a3._owner;
        if (null != b3) {
          void 0 !== b3.ref && (k2 = b3.ref, h3 = K.current);
          void 0 !== b3.key && (c3 = "" + b3.key);
          if (a3.type && a3.type.defaultProps)
            var g3 = a3.type.defaultProps;
          for (f3 in b3)
            J.call(b3, f3) && !L3.hasOwnProperty(f3) && (d3[f3] = void 0 === b3[f3] && void 0 !== g3 ? g3[f3] : b3[f3]);
        }
        var f3 = arguments.length - 2;
        if (1 === f3)
          d3.children = e2;
        else if (1 < f3) {
          g3 = Array(f3);
          for (var m3 = 0; m3 < f3; m3++)
            g3[m3] = arguments[m3 + 2];
          d3.children = g3;
        }
        return { $$typeof: l3, type: a3.type, key: c3, ref: k2, props: d3, _owner: h3 };
      };
      exports.createContext = function(a3) {
        a3 = { $$typeof: u3, _currentValue: a3, _currentValue2: a3, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
        a3.Provider = { $$typeof: t4, _context: a3 };
        return a3.Consumer = a3;
      };
      exports.createElement = M;
      exports.createFactory = function(a3) {
        var b3 = M.bind(null, a3);
        b3.type = a3;
        return b3;
      };
      exports.createRef = function() {
        return { current: null };
      };
      exports.forwardRef = function(a3) {
        return { $$typeof: v3, render: a3 };
      };
      exports.isValidElement = O2;
      exports.lazy = function(a3) {
        return { $$typeof: y3, _payload: { _status: -1, _result: a3 }, _init: T3 };
      };
      exports.memo = function(a3, b3) {
        return { $$typeof: x3, type: a3, compare: void 0 === b3 ? null : b3 };
      };
      exports.startTransition = function(a3) {
        var b3 = V2.transition;
        V2.transition = {};
        try {
          a3();
        } finally {
          V2.transition = b3;
        }
      };
      exports.unstable_act = function() {
        throw Error("act(...) is not supported in production builds of React.");
      };
      exports.useCallback = function(a3, b3) {
        return U.current.useCallback(a3, b3);
      };
      exports.useContext = function(a3) {
        return U.current.useContext(a3);
      };
      exports.useDebugValue = function() {
      };
      exports.useDeferredValue = function(a3) {
        return U.current.useDeferredValue(a3);
      };
      exports.useEffect = function(a3, b3) {
        return U.current.useEffect(a3, b3);
      };
      exports.useId = function() {
        return U.current.useId();
      };
      exports.useImperativeHandle = function(a3, b3, e2) {
        return U.current.useImperativeHandle(a3, b3, e2);
      };
      exports.useInsertionEffect = function(a3, b3) {
        return U.current.useInsertionEffect(a3, b3);
      };
      exports.useLayoutEffect = function(a3, b3) {
        return U.current.useLayoutEffect(a3, b3);
      };
      exports.useMemo = function(a3, b3) {
        return U.current.useMemo(a3, b3);
      };
      exports.useReducer = function(a3, b3, e2) {
        return U.current.useReducer(a3, b3, e2);
      };
      exports.useRef = function(a3) {
        return U.current.useRef(a3);
      };
      exports.useState = function(a3) {
        return U.current.useState(a3);
      };
      exports.useSyncExternalStore = function(a3, b3, e2) {
        return U.current.useSyncExternalStore(a3, b3, e2);
      };
      exports.useTransition = function() {
        return U.current.useTransition();
      };
      exports.version = "18.2.0";
    }
  });

  // ../../../node_modules/react/index.js
  var require_react = __commonJS({
    "../../../node_modules/react/index.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_react_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // ../../../node_modules/scheduler/cjs/scheduler.production.min.js
  var require_scheduler_production_min = __commonJS({
    "../../../node_modules/scheduler/cjs/scheduler.production.min.js"(exports) {
      "use strict";
      function f3(a3, b3) {
        var c3 = a3.length;
        a3.push(b3);
        a:
          for (; 0 < c3; ) {
            var d3 = c3 - 1 >>> 1, e2 = a3[d3];
            if (0 < g3(e2, b3))
              a3[d3] = b3, a3[c3] = e2, c3 = d3;
            else
              break a;
          }
      }
      function h3(a3) {
        return 0 === a3.length ? null : a3[0];
      }
      function k2(a3) {
        if (0 === a3.length)
          return null;
        var b3 = a3[0], c3 = a3.pop();
        if (c3 !== b3) {
          a3[0] = c3;
          a:
            for (var d3 = 0, e2 = a3.length, w3 = e2 >>> 1; d3 < w3; ) {
              var m3 = 2 * (d3 + 1) - 1, C2 = a3[m3], n3 = m3 + 1, x3 = a3[n3];
              if (0 > g3(C2, c3))
                n3 < e2 && 0 > g3(x3, C2) ? (a3[d3] = x3, a3[n3] = c3, d3 = n3) : (a3[d3] = C2, a3[m3] = c3, d3 = m3);
              else if (n3 < e2 && 0 > g3(x3, c3))
                a3[d3] = x3, a3[n3] = c3, d3 = n3;
              else
                break a;
            }
        }
        return b3;
      }
      function g3(a3, b3) {
        var c3 = a3.sortIndex - b3.sortIndex;
        return 0 !== c3 ? c3 : a3.id - b3.id;
      }
      if ("object" === typeof performance && "function" === typeof performance.now) {
        l3 = performance;
        exports.unstable_now = function() {
          return l3.now();
        };
      } else {
        p3 = Date, q = p3.now();
        exports.unstable_now = function() {
          return p3.now() - q;
        };
      }
      var l3;
      var p3;
      var q;
      var r3 = [];
      var t4 = [];
      var u3 = 1;
      var v3 = null;
      var y3 = 3;
      var z2 = false;
      var A2 = false;
      var B = false;
      var D3 = "function" === typeof setTimeout ? setTimeout : null;
      var E3 = "function" === typeof clearTimeout ? clearTimeout : null;
      var F = "undefined" !== typeof setImmediate ? setImmediate : null;
      "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function G(a3) {
        for (var b3 = h3(t4); null !== b3; ) {
          if (null === b3.callback)
            k2(t4);
          else if (b3.startTime <= a3)
            k2(t4), b3.sortIndex = b3.expirationTime, f3(r3, b3);
          else
            break;
          b3 = h3(t4);
        }
      }
      function H2(a3) {
        B = false;
        G(a3);
        if (!A2)
          if (null !== h3(r3))
            A2 = true, I(J);
          else {
            var b3 = h3(t4);
            null !== b3 && K(H2, b3.startTime - a3);
          }
      }
      function J(a3, b3) {
        A2 = false;
        B && (B = false, E3(L3), L3 = -1);
        z2 = true;
        var c3 = y3;
        try {
          G(b3);
          for (v3 = h3(r3); null !== v3 && (!(v3.expirationTime > b3) || a3 && !M()); ) {
            var d3 = v3.callback;
            if ("function" === typeof d3) {
              v3.callback = null;
              y3 = v3.priorityLevel;
              var e2 = d3(v3.expirationTime <= b3);
              b3 = exports.unstable_now();
              "function" === typeof e2 ? v3.callback = e2 : v3 === h3(r3) && k2(r3);
              G(b3);
            } else
              k2(r3);
            v3 = h3(r3);
          }
          if (null !== v3)
            var w3 = true;
          else {
            var m3 = h3(t4);
            null !== m3 && K(H2, m3.startTime - b3);
            w3 = false;
          }
          return w3;
        } finally {
          v3 = null, y3 = c3, z2 = false;
        }
      }
      var N2 = false;
      var O2 = null;
      var L3 = -1;
      var P2 = 5;
      var Q = -1;
      function M() {
        return exports.unstable_now() - Q < P2 ? false : true;
      }
      function R3() {
        if (null !== O2) {
          var a3 = exports.unstable_now();
          Q = a3;
          var b3 = true;
          try {
            b3 = O2(true, a3);
          } finally {
            b3 ? S2() : (N2 = false, O2 = null);
          }
        } else
          N2 = false;
      }
      var S2;
      if ("function" === typeof F)
        S2 = function() {
          F(R3);
        };
      else if ("undefined" !== typeof MessageChannel) {
        T3 = new MessageChannel(), U = T3.port2;
        T3.port1.onmessage = R3;
        S2 = function() {
          U.postMessage(null);
        };
      } else
        S2 = function() {
          D3(R3, 0);
        };
      var T3;
      var U;
      function I(a3) {
        O2 = a3;
        N2 || (N2 = true, S2());
      }
      function K(a3, b3) {
        L3 = D3(function() {
          a3(exports.unstable_now());
        }, b3);
      }
      exports.unstable_IdlePriority = 5;
      exports.unstable_ImmediatePriority = 1;
      exports.unstable_LowPriority = 4;
      exports.unstable_NormalPriority = 3;
      exports.unstable_Profiling = null;
      exports.unstable_UserBlockingPriority = 2;
      exports.unstable_cancelCallback = function(a3) {
        a3.callback = null;
      };
      exports.unstable_continueExecution = function() {
        A2 || z2 || (A2 = true, I(J));
      };
      exports.unstable_forceFrameRate = function(a3) {
        0 > a3 || 125 < a3 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a3 ? Math.floor(1e3 / a3) : 5;
      };
      exports.unstable_getCurrentPriorityLevel = function() {
        return y3;
      };
      exports.unstable_getFirstCallbackNode = function() {
        return h3(r3);
      };
      exports.unstable_next = function(a3) {
        switch (y3) {
          case 1:
          case 2:
          case 3:
            var b3 = 3;
            break;
          default:
            b3 = y3;
        }
        var c3 = y3;
        y3 = b3;
        try {
          return a3();
        } finally {
          y3 = c3;
        }
      };
      exports.unstable_pauseExecution = function() {
      };
      exports.unstable_requestPaint = function() {
      };
      exports.unstable_runWithPriority = function(a3, b3) {
        switch (a3) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a3 = 3;
        }
        var c3 = y3;
        y3 = a3;
        try {
          return b3();
        } finally {
          y3 = c3;
        }
      };
      exports.unstable_scheduleCallback = function(a3, b3, c3) {
        var d3 = exports.unstable_now();
        "object" === typeof c3 && null !== c3 ? (c3 = c3.delay, c3 = "number" === typeof c3 && 0 < c3 ? d3 + c3 : d3) : c3 = d3;
        switch (a3) {
          case 1:
            var e2 = -1;
            break;
          case 2:
            e2 = 250;
            break;
          case 5:
            e2 = 1073741823;
            break;
          case 4:
            e2 = 1e4;
            break;
          default:
            e2 = 5e3;
        }
        e2 = c3 + e2;
        a3 = { id: u3++, callback: b3, priorityLevel: a3, startTime: c3, expirationTime: e2, sortIndex: -1 };
        c3 > d3 ? (a3.sortIndex = c3, f3(t4, a3), null === h3(r3) && a3 === h3(t4) && (B ? (E3(L3), L3 = -1) : B = true, K(H2, c3 - d3))) : (a3.sortIndex = e2, f3(r3, a3), A2 || z2 || (A2 = true, I(J)));
        return a3;
      };
      exports.unstable_shouldYield = M;
      exports.unstable_wrapCallback = function(a3) {
        var b3 = y3;
        return function() {
          var c3 = y3;
          y3 = b3;
          try {
            return a3.apply(this, arguments);
          } finally {
            y3 = c3;
          }
        };
      };
    }
  });

  // ../../../node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "../../../node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_scheduler_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // ../../../node_modules/react-dom/cjs/react-dom.production.min.js
  var require_react_dom_production_min = __commonJS({
    "../../../node_modules/react-dom/cjs/react-dom.production.min.js"(exports) {
      "use strict";
      var aa = require_react();
      var ca = require_scheduler();
      function p3(a3) {
        for (var b3 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a3, c3 = 1; c3 < arguments.length; c3++)
          b3 += "&args[]=" + encodeURIComponent(arguments[c3]);
        return "Minified React error #" + a3 + "; visit " + b3 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      var da = /* @__PURE__ */ new Set();
      var ea = {};
      function fa(a3, b3) {
        ha(a3, b3);
        ha(a3 + "Capture", b3);
      }
      function ha(a3, b3) {
        ea[a3] = b3;
        for (a3 = 0; a3 < b3.length; a3++)
          da.add(b3[a3]);
      }
      var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement);
      var ja = Object.prototype.hasOwnProperty;
      var ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/;
      var la = {};
      var ma = {};
      function oa(a3) {
        if (ja.call(ma, a3))
          return true;
        if (ja.call(la, a3))
          return false;
        if (ka.test(a3))
          return ma[a3] = true;
        la[a3] = true;
        return false;
      }
      function pa(a3, b3, c3, d3) {
        if (null !== c3 && 0 === c3.type)
          return false;
        switch (typeof b3) {
          case "function":
          case "symbol":
            return true;
          case "boolean":
            if (d3)
              return false;
            if (null !== c3)
              return !c3.acceptsBooleans;
            a3 = a3.toLowerCase().slice(0, 5);
            return "data-" !== a3 && "aria-" !== a3;
          default:
            return false;
        }
      }
      function qa(a3, b3, c3, d3) {
        if (null === b3 || "undefined" === typeof b3 || pa(a3, b3, c3, d3))
          return true;
        if (d3)
          return false;
        if (null !== c3)
          switch (c3.type) {
            case 3:
              return !b3;
            case 4:
              return false === b3;
            case 5:
              return isNaN(b3);
            case 6:
              return isNaN(b3) || 1 > b3;
          }
        return false;
      }
      function v3(a3, b3, c3, d3, e2, f3, g3) {
        this.acceptsBooleans = 2 === b3 || 3 === b3 || 4 === b3;
        this.attributeName = d3;
        this.attributeNamespace = e2;
        this.mustUseProperty = c3;
        this.propertyName = a3;
        this.type = b3;
        this.sanitizeURL = f3;
        this.removeEmptyString = g3;
      }
      var z2 = {};
      "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a3) {
        z2[a3] = new v3(a3, 0, false, a3, null, false, false);
      });
      [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a3) {
        var b3 = a3[0];
        z2[b3] = new v3(b3, 1, false, a3[1], null, false, false);
      });
      ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a3) {
        z2[a3] = new v3(a3, 2, false, a3.toLowerCase(), null, false, false);
      });
      ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a3) {
        z2[a3] = new v3(a3, 2, false, a3, null, false, false);
      });
      "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a3) {
        z2[a3] = new v3(a3, 3, false, a3.toLowerCase(), null, false, false);
      });
      ["checked", "multiple", "muted", "selected"].forEach(function(a3) {
        z2[a3] = new v3(a3, 3, true, a3, null, false, false);
      });
      ["capture", "download"].forEach(function(a3) {
        z2[a3] = new v3(a3, 4, false, a3, null, false, false);
      });
      ["cols", "rows", "size", "span"].forEach(function(a3) {
        z2[a3] = new v3(a3, 6, false, a3, null, false, false);
      });
      ["rowSpan", "start"].forEach(function(a3) {
        z2[a3] = new v3(a3, 5, false, a3.toLowerCase(), null, false, false);
      });
      var ra = /[\-:]([a-z])/g;
      function sa(a3) {
        return a3[1].toUpperCase();
      }
      "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a3) {
        var b3 = a3.replace(
          ra,
          sa
        );
        z2[b3] = new v3(b3, 1, false, a3, null, false, false);
      });
      "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a3) {
        var b3 = a3.replace(ra, sa);
        z2[b3] = new v3(b3, 1, false, a3, "http://www.w3.org/1999/xlink", false, false);
      });
      ["xml:base", "xml:lang", "xml:space"].forEach(function(a3) {
        var b3 = a3.replace(ra, sa);
        z2[b3] = new v3(b3, 1, false, a3, "http://www.w3.org/XML/1998/namespace", false, false);
      });
      ["tabIndex", "crossOrigin"].forEach(function(a3) {
        z2[a3] = new v3(a3, 1, false, a3.toLowerCase(), null, false, false);
      });
      z2.xlinkHref = new v3("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
      ["src", "href", "action", "formAction"].forEach(function(a3) {
        z2[a3] = new v3(a3, 1, false, a3.toLowerCase(), null, true, true);
      });
      function ta(a3, b3, c3, d3) {
        var e2 = z2.hasOwnProperty(b3) ? z2[b3] : null;
        if (null !== e2 ? 0 !== e2.type : d3 || !(2 < b3.length) || "o" !== b3[0] && "O" !== b3[0] || "n" !== b3[1] && "N" !== b3[1])
          qa(b3, c3, e2, d3) && (c3 = null), d3 || null === e2 ? oa(b3) && (null === c3 ? a3.removeAttribute(b3) : a3.setAttribute(b3, "" + c3)) : e2.mustUseProperty ? a3[e2.propertyName] = null === c3 ? 3 === e2.type ? false : "" : c3 : (b3 = e2.attributeName, d3 = e2.attributeNamespace, null === c3 ? a3.removeAttribute(b3) : (e2 = e2.type, c3 = 3 === e2 || 4 === e2 && true === c3 ? "" : "" + c3, d3 ? a3.setAttributeNS(d3, b3, c3) : a3.setAttribute(b3, c3)));
      }
      var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      var va = Symbol.for("react.element");
      var wa = Symbol.for("react.portal");
      var ya = Symbol.for("react.fragment");
      var za = Symbol.for("react.strict_mode");
      var Aa = Symbol.for("react.profiler");
      var Ba = Symbol.for("react.provider");
      var Ca = Symbol.for("react.context");
      var Da = Symbol.for("react.forward_ref");
      var Ea = Symbol.for("react.suspense");
      var Fa = Symbol.for("react.suspense_list");
      var Ga = Symbol.for("react.memo");
      var Ha = Symbol.for("react.lazy");
      Symbol.for("react.scope");
      Symbol.for("react.debug_trace_mode");
      var Ia = Symbol.for("react.offscreen");
      Symbol.for("react.legacy_hidden");
      Symbol.for("react.cache");
      Symbol.for("react.tracing_marker");
      var Ja = Symbol.iterator;
      function Ka(a3) {
        if (null === a3 || "object" !== typeof a3)
          return null;
        a3 = Ja && a3[Ja] || a3["@@iterator"];
        return "function" === typeof a3 ? a3 : null;
      }
      var A2 = Object.assign;
      var La;
      function Ma(a3) {
        if (void 0 === La)
          try {
            throw Error();
          } catch (c3) {
            var b3 = c3.stack.trim().match(/\n( *(at )?)/);
            La = b3 && b3[1] || "";
          }
        return "\n" + La + a3;
      }
      var Na = false;
      function Oa(a3, b3) {
        if (!a3 || Na)
          return "";
        Na = true;
        var c3 = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          if (b3)
            if (b3 = function() {
              throw Error();
            }, Object.defineProperty(b3.prototype, "props", { set: function() {
              throw Error();
            } }), "object" === typeof Reflect && Reflect.construct) {
              try {
                Reflect.construct(b3, []);
              } catch (l3) {
                var d3 = l3;
              }
              Reflect.construct(a3, [], b3);
            } else {
              try {
                b3.call();
              } catch (l3) {
                d3 = l3;
              }
              a3.call(b3.prototype);
            }
          else {
            try {
              throw Error();
            } catch (l3) {
              d3 = l3;
            }
            a3();
          }
        } catch (l3) {
          if (l3 && d3 && "string" === typeof l3.stack) {
            for (var e2 = l3.stack.split("\n"), f3 = d3.stack.split("\n"), g3 = e2.length - 1, h3 = f3.length - 1; 1 <= g3 && 0 <= h3 && e2[g3] !== f3[h3]; )
              h3--;
            for (; 1 <= g3 && 0 <= h3; g3--, h3--)
              if (e2[g3] !== f3[h3]) {
                if (1 !== g3 || 1 !== h3) {
                  do
                    if (g3--, h3--, 0 > h3 || e2[g3] !== f3[h3]) {
                      var k2 = "\n" + e2[g3].replace(" at new ", " at ");
                      a3.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a3.displayName));
                      return k2;
                    }
                  while (1 <= g3 && 0 <= h3);
                }
                break;
              }
          }
        } finally {
          Na = false, Error.prepareStackTrace = c3;
        }
        return (a3 = a3 ? a3.displayName || a3.name : "") ? Ma(a3) : "";
      }
      function Pa(a3) {
        switch (a3.tag) {
          case 5:
            return Ma(a3.type);
          case 16:
            return Ma("Lazy");
          case 13:
            return Ma("Suspense");
          case 19:
            return Ma("SuspenseList");
          case 0:
          case 2:
          case 15:
            return a3 = Oa(a3.type, false), a3;
          case 11:
            return a3 = Oa(a3.type.render, false), a3;
          case 1:
            return a3 = Oa(a3.type, true), a3;
          default:
            return "";
        }
      }
      function Qa(a3) {
        if (null == a3)
          return null;
        if ("function" === typeof a3)
          return a3.displayName || a3.name || null;
        if ("string" === typeof a3)
          return a3;
        switch (a3) {
          case ya:
            return "Fragment";
          case wa:
            return "Portal";
          case Aa:
            return "Profiler";
          case za:
            return "StrictMode";
          case Ea:
            return "Suspense";
          case Fa:
            return "SuspenseList";
        }
        if ("object" === typeof a3)
          switch (a3.$$typeof) {
            case Ca:
              return (a3.displayName || "Context") + ".Consumer";
            case Ba:
              return (a3._context.displayName || "Context") + ".Provider";
            case Da:
              var b3 = a3.render;
              a3 = a3.displayName;
              a3 || (a3 = b3.displayName || b3.name || "", a3 = "" !== a3 ? "ForwardRef(" + a3 + ")" : "ForwardRef");
              return a3;
            case Ga:
              return b3 = a3.displayName || null, null !== b3 ? b3 : Qa(a3.type) || "Memo";
            case Ha:
              b3 = a3._payload;
              a3 = a3._init;
              try {
                return Qa(a3(b3));
              } catch (c3) {
              }
          }
        return null;
      }
      function Ra(a3) {
        var b3 = a3.type;
        switch (a3.tag) {
          case 24:
            return "Cache";
          case 9:
            return (b3.displayName || "Context") + ".Consumer";
          case 10:
            return (b3._context.displayName || "Context") + ".Provider";
          case 18:
            return "DehydratedFragment";
          case 11:
            return a3 = b3.render, a3 = a3.displayName || a3.name || "", b3.displayName || ("" !== a3 ? "ForwardRef(" + a3 + ")" : "ForwardRef");
          case 7:
            return "Fragment";
          case 5:
            return b3;
          case 4:
            return "Portal";
          case 3:
            return "Root";
          case 6:
            return "Text";
          case 16:
            return Qa(b3);
          case 8:
            return b3 === za ? "StrictMode" : "Mode";
          case 22:
            return "Offscreen";
          case 12:
            return "Profiler";
          case 21:
            return "Scope";
          case 13:
            return "Suspense";
          case 19:
            return "SuspenseList";
          case 25:
            return "TracingMarker";
          case 1:
          case 0:
          case 17:
          case 2:
          case 14:
          case 15:
            if ("function" === typeof b3)
              return b3.displayName || b3.name || null;
            if ("string" === typeof b3)
              return b3;
        }
        return null;
      }
      function Sa(a3) {
        switch (typeof a3) {
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return a3;
          case "object":
            return a3;
          default:
            return "";
        }
      }
      function Ta(a3) {
        var b3 = a3.type;
        return (a3 = a3.nodeName) && "input" === a3.toLowerCase() && ("checkbox" === b3 || "radio" === b3);
      }
      function Ua(a3) {
        var b3 = Ta(a3) ? "checked" : "value", c3 = Object.getOwnPropertyDescriptor(a3.constructor.prototype, b3), d3 = "" + a3[b3];
        if (!a3.hasOwnProperty(b3) && "undefined" !== typeof c3 && "function" === typeof c3.get && "function" === typeof c3.set) {
          var e2 = c3.get, f3 = c3.set;
          Object.defineProperty(a3, b3, { configurable: true, get: function() {
            return e2.call(this);
          }, set: function(a4) {
            d3 = "" + a4;
            f3.call(this, a4);
          } });
          Object.defineProperty(a3, b3, { enumerable: c3.enumerable });
          return { getValue: function() {
            return d3;
          }, setValue: function(a4) {
            d3 = "" + a4;
          }, stopTracking: function() {
            a3._valueTracker = null;
            delete a3[b3];
          } };
        }
      }
      function Va(a3) {
        a3._valueTracker || (a3._valueTracker = Ua(a3));
      }
      function Wa(a3) {
        if (!a3)
          return false;
        var b3 = a3._valueTracker;
        if (!b3)
          return true;
        var c3 = b3.getValue();
        var d3 = "";
        a3 && (d3 = Ta(a3) ? a3.checked ? "true" : "false" : a3.value);
        a3 = d3;
        return a3 !== c3 ? (b3.setValue(a3), true) : false;
      }
      function Xa(a3) {
        a3 = a3 || ("undefined" !== typeof document ? document : void 0);
        if ("undefined" === typeof a3)
          return null;
        try {
          return a3.activeElement || a3.body;
        } catch (b3) {
          return a3.body;
        }
      }
      function Ya(a3, b3) {
        var c3 = b3.checked;
        return A2({}, b3, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c3 ? c3 : a3._wrapperState.initialChecked });
      }
      function Za(a3, b3) {
        var c3 = null == b3.defaultValue ? "" : b3.defaultValue, d3 = null != b3.checked ? b3.checked : b3.defaultChecked;
        c3 = Sa(null != b3.value ? b3.value : c3);
        a3._wrapperState = { initialChecked: d3, initialValue: c3, controlled: "checkbox" === b3.type || "radio" === b3.type ? null != b3.checked : null != b3.value };
      }
      function ab(a3, b3) {
        b3 = b3.checked;
        null != b3 && ta(a3, "checked", b3, false);
      }
      function bb(a3, b3) {
        ab(a3, b3);
        var c3 = Sa(b3.value), d3 = b3.type;
        if (null != c3)
          if ("number" === d3) {
            if (0 === c3 && "" === a3.value || a3.value != c3)
              a3.value = "" + c3;
          } else
            a3.value !== "" + c3 && (a3.value = "" + c3);
        else if ("submit" === d3 || "reset" === d3) {
          a3.removeAttribute("value");
          return;
        }
        b3.hasOwnProperty("value") ? cb(a3, b3.type, c3) : b3.hasOwnProperty("defaultValue") && cb(a3, b3.type, Sa(b3.defaultValue));
        null == b3.checked && null != b3.defaultChecked && (a3.defaultChecked = !!b3.defaultChecked);
      }
      function db(a3, b3, c3) {
        if (b3.hasOwnProperty("value") || b3.hasOwnProperty("defaultValue")) {
          var d3 = b3.type;
          if (!("submit" !== d3 && "reset" !== d3 || void 0 !== b3.value && null !== b3.value))
            return;
          b3 = "" + a3._wrapperState.initialValue;
          c3 || b3 === a3.value || (a3.value = b3);
          a3.defaultValue = b3;
        }
        c3 = a3.name;
        "" !== c3 && (a3.name = "");
        a3.defaultChecked = !!a3._wrapperState.initialChecked;
        "" !== c3 && (a3.name = c3);
      }
      function cb(a3, b3, c3) {
        if ("number" !== b3 || Xa(a3.ownerDocument) !== a3)
          null == c3 ? a3.defaultValue = "" + a3._wrapperState.initialValue : a3.defaultValue !== "" + c3 && (a3.defaultValue = "" + c3);
      }
      var eb = Array.isArray;
      function fb(a3, b3, c3, d3) {
        a3 = a3.options;
        if (b3) {
          b3 = {};
          for (var e2 = 0; e2 < c3.length; e2++)
            b3["$" + c3[e2]] = true;
          for (c3 = 0; c3 < a3.length; c3++)
            e2 = b3.hasOwnProperty("$" + a3[c3].value), a3[c3].selected !== e2 && (a3[c3].selected = e2), e2 && d3 && (a3[c3].defaultSelected = true);
        } else {
          c3 = "" + Sa(c3);
          b3 = null;
          for (e2 = 0; e2 < a3.length; e2++) {
            if (a3[e2].value === c3) {
              a3[e2].selected = true;
              d3 && (a3[e2].defaultSelected = true);
              return;
            }
            null !== b3 || a3[e2].disabled || (b3 = a3[e2]);
          }
          null !== b3 && (b3.selected = true);
        }
      }
      function gb(a3, b3) {
        if (null != b3.dangerouslySetInnerHTML)
          throw Error(p3(91));
        return A2({}, b3, { value: void 0, defaultValue: void 0, children: "" + a3._wrapperState.initialValue });
      }
      function hb(a3, b3) {
        var c3 = b3.value;
        if (null == c3) {
          c3 = b3.children;
          b3 = b3.defaultValue;
          if (null != c3) {
            if (null != b3)
              throw Error(p3(92));
            if (eb(c3)) {
              if (1 < c3.length)
                throw Error(p3(93));
              c3 = c3[0];
            }
            b3 = c3;
          }
          null == b3 && (b3 = "");
          c3 = b3;
        }
        a3._wrapperState = { initialValue: Sa(c3) };
      }
      function ib(a3, b3) {
        var c3 = Sa(b3.value), d3 = Sa(b3.defaultValue);
        null != c3 && (c3 = "" + c3, c3 !== a3.value && (a3.value = c3), null == b3.defaultValue && a3.defaultValue !== c3 && (a3.defaultValue = c3));
        null != d3 && (a3.defaultValue = "" + d3);
      }
      function jb(a3) {
        var b3 = a3.textContent;
        b3 === a3._wrapperState.initialValue && "" !== b3 && null !== b3 && (a3.value = b3);
      }
      function kb(a3) {
        switch (a3) {
          case "svg":
            return "http://www.w3.org/2000/svg";
          case "math":
            return "http://www.w3.org/1998/Math/MathML";
          default:
            return "http://www.w3.org/1999/xhtml";
        }
      }
      function lb(a3, b3) {
        return null == a3 || "http://www.w3.org/1999/xhtml" === a3 ? kb(b3) : "http://www.w3.org/2000/svg" === a3 && "foreignObject" === b3 ? "http://www.w3.org/1999/xhtml" : a3;
      }
      var mb;
      var nb = function(a3) {
        return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b3, c3, d3, e2) {
          MSApp.execUnsafeLocalFunction(function() {
            return a3(b3, c3, d3, e2);
          });
        } : a3;
      }(function(a3, b3) {
        if ("http://www.w3.org/2000/svg" !== a3.namespaceURI || "innerHTML" in a3)
          a3.innerHTML = b3;
        else {
          mb = mb || document.createElement("div");
          mb.innerHTML = "<svg>" + b3.valueOf().toString() + "</svg>";
          for (b3 = mb.firstChild; a3.firstChild; )
            a3.removeChild(a3.firstChild);
          for (; b3.firstChild; )
            a3.appendChild(b3.firstChild);
        }
      });
      function ob(a3, b3) {
        if (b3) {
          var c3 = a3.firstChild;
          if (c3 && c3 === a3.lastChild && 3 === c3.nodeType) {
            c3.nodeValue = b3;
            return;
          }
        }
        a3.textContent = b3;
      }
      var pb = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
      };
      var qb = ["Webkit", "ms", "Moz", "O"];
      Object.keys(pb).forEach(function(a3) {
        qb.forEach(function(b3) {
          b3 = b3 + a3.charAt(0).toUpperCase() + a3.substring(1);
          pb[b3] = pb[a3];
        });
      });
      function rb(a3, b3, c3) {
        return null == b3 || "boolean" === typeof b3 || "" === b3 ? "" : c3 || "number" !== typeof b3 || 0 === b3 || pb.hasOwnProperty(a3) && pb[a3] ? ("" + b3).trim() : b3 + "px";
      }
      function sb(a3, b3) {
        a3 = a3.style;
        for (var c3 in b3)
          if (b3.hasOwnProperty(c3)) {
            var d3 = 0 === c3.indexOf("--"), e2 = rb(c3, b3[c3], d3);
            "float" === c3 && (c3 = "cssFloat");
            d3 ? a3.setProperty(c3, e2) : a3[c3] = e2;
          }
      }
      var tb = A2({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
      function ub(a3, b3) {
        if (b3) {
          if (tb[a3] && (null != b3.children || null != b3.dangerouslySetInnerHTML))
            throw Error(p3(137, a3));
          if (null != b3.dangerouslySetInnerHTML) {
            if (null != b3.children)
              throw Error(p3(60));
            if ("object" !== typeof b3.dangerouslySetInnerHTML || !("__html" in b3.dangerouslySetInnerHTML))
              throw Error(p3(61));
          }
          if (null != b3.style && "object" !== typeof b3.style)
            throw Error(p3(62));
        }
      }
      function vb(a3, b3) {
        if (-1 === a3.indexOf("-"))
          return "string" === typeof b3.is;
        switch (a3) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var wb = null;
      function xb(a3) {
        a3 = a3.target || a3.srcElement || window;
        a3.correspondingUseElement && (a3 = a3.correspondingUseElement);
        return 3 === a3.nodeType ? a3.parentNode : a3;
      }
      var yb = null;
      var zb = null;
      var Ab = null;
      function Bb(a3) {
        if (a3 = Cb(a3)) {
          if ("function" !== typeof yb)
            throw Error(p3(280));
          var b3 = a3.stateNode;
          b3 && (b3 = Db(b3), yb(a3.stateNode, a3.type, b3));
        }
      }
      function Eb(a3) {
        zb ? Ab ? Ab.push(a3) : Ab = [a3] : zb = a3;
      }
      function Fb() {
        if (zb) {
          var a3 = zb, b3 = Ab;
          Ab = zb = null;
          Bb(a3);
          if (b3)
            for (a3 = 0; a3 < b3.length; a3++)
              Bb(b3[a3]);
        }
      }
      function Gb(a3, b3) {
        return a3(b3);
      }
      function Hb() {
      }
      var Ib = false;
      function Jb(a3, b3, c3) {
        if (Ib)
          return a3(b3, c3);
        Ib = true;
        try {
          return Gb(a3, b3, c3);
        } finally {
          if (Ib = false, null !== zb || null !== Ab)
            Hb(), Fb();
        }
      }
      function Kb(a3, b3) {
        var c3 = a3.stateNode;
        if (null === c3)
          return null;
        var d3 = Db(c3);
        if (null === d3)
          return null;
        c3 = d3[b3];
        a:
          switch (b3) {
            case "onClick":
            case "onClickCapture":
            case "onDoubleClick":
            case "onDoubleClickCapture":
            case "onMouseDown":
            case "onMouseDownCapture":
            case "onMouseMove":
            case "onMouseMoveCapture":
            case "onMouseUp":
            case "onMouseUpCapture":
            case "onMouseEnter":
              (d3 = !d3.disabled) || (a3 = a3.type, d3 = !("button" === a3 || "input" === a3 || "select" === a3 || "textarea" === a3));
              a3 = !d3;
              break a;
            default:
              a3 = false;
          }
        if (a3)
          return null;
        if (c3 && "function" !== typeof c3)
          throw Error(p3(231, b3, typeof c3));
        return c3;
      }
      var Lb = false;
      if (ia)
        try {
          Mb = {};
          Object.defineProperty(Mb, "passive", { get: function() {
            Lb = true;
          } });
          window.addEventListener("test", Mb, Mb);
          window.removeEventListener("test", Mb, Mb);
        } catch (a3) {
          Lb = false;
        }
      var Mb;
      function Nb(a3, b3, c3, d3, e2, f3, g3, h3, k2) {
        var l3 = Array.prototype.slice.call(arguments, 3);
        try {
          b3.apply(c3, l3);
        } catch (m3) {
          this.onError(m3);
        }
      }
      var Ob = false;
      var Pb = null;
      var Qb = false;
      var Rb = null;
      var Sb = { onError: function(a3) {
        Ob = true;
        Pb = a3;
      } };
      function Tb(a3, b3, c3, d3, e2, f3, g3, h3, k2) {
        Ob = false;
        Pb = null;
        Nb.apply(Sb, arguments);
      }
      function Ub(a3, b3, c3, d3, e2, f3, g3, h3, k2) {
        Tb.apply(this, arguments);
        if (Ob) {
          if (Ob) {
            var l3 = Pb;
            Ob = false;
            Pb = null;
          } else
            throw Error(p3(198));
          Qb || (Qb = true, Rb = l3);
        }
      }
      function Vb(a3) {
        var b3 = a3, c3 = a3;
        if (a3.alternate)
          for (; b3.return; )
            b3 = b3.return;
        else {
          a3 = b3;
          do
            b3 = a3, 0 !== (b3.flags & 4098) && (c3 = b3.return), a3 = b3.return;
          while (a3);
        }
        return 3 === b3.tag ? c3 : null;
      }
      function Wb(a3) {
        if (13 === a3.tag) {
          var b3 = a3.memoizedState;
          null === b3 && (a3 = a3.alternate, null !== a3 && (b3 = a3.memoizedState));
          if (null !== b3)
            return b3.dehydrated;
        }
        return null;
      }
      function Xb(a3) {
        if (Vb(a3) !== a3)
          throw Error(p3(188));
      }
      function Yb(a3) {
        var b3 = a3.alternate;
        if (!b3) {
          b3 = Vb(a3);
          if (null === b3)
            throw Error(p3(188));
          return b3 !== a3 ? null : a3;
        }
        for (var c3 = a3, d3 = b3; ; ) {
          var e2 = c3.return;
          if (null === e2)
            break;
          var f3 = e2.alternate;
          if (null === f3) {
            d3 = e2.return;
            if (null !== d3) {
              c3 = d3;
              continue;
            }
            break;
          }
          if (e2.child === f3.child) {
            for (f3 = e2.child; f3; ) {
              if (f3 === c3)
                return Xb(e2), a3;
              if (f3 === d3)
                return Xb(e2), b3;
              f3 = f3.sibling;
            }
            throw Error(p3(188));
          }
          if (c3.return !== d3.return)
            c3 = e2, d3 = f3;
          else {
            for (var g3 = false, h3 = e2.child; h3; ) {
              if (h3 === c3) {
                g3 = true;
                c3 = e2;
                d3 = f3;
                break;
              }
              if (h3 === d3) {
                g3 = true;
                d3 = e2;
                c3 = f3;
                break;
              }
              h3 = h3.sibling;
            }
            if (!g3) {
              for (h3 = f3.child; h3; ) {
                if (h3 === c3) {
                  g3 = true;
                  c3 = f3;
                  d3 = e2;
                  break;
                }
                if (h3 === d3) {
                  g3 = true;
                  d3 = f3;
                  c3 = e2;
                  break;
                }
                h3 = h3.sibling;
              }
              if (!g3)
                throw Error(p3(189));
            }
          }
          if (c3.alternate !== d3)
            throw Error(p3(190));
        }
        if (3 !== c3.tag)
          throw Error(p3(188));
        return c3.stateNode.current === c3 ? a3 : b3;
      }
      function Zb(a3) {
        a3 = Yb(a3);
        return null !== a3 ? $b(a3) : null;
      }
      function $b(a3) {
        if (5 === a3.tag || 6 === a3.tag)
          return a3;
        for (a3 = a3.child; null !== a3; ) {
          var b3 = $b(a3);
          if (null !== b3)
            return b3;
          a3 = a3.sibling;
        }
        return null;
      }
      var ac = ca.unstable_scheduleCallback;
      var bc = ca.unstable_cancelCallback;
      var cc = ca.unstable_shouldYield;
      var dc = ca.unstable_requestPaint;
      var B = ca.unstable_now;
      var ec = ca.unstable_getCurrentPriorityLevel;
      var fc = ca.unstable_ImmediatePriority;
      var gc = ca.unstable_UserBlockingPriority;
      var hc = ca.unstable_NormalPriority;
      var ic = ca.unstable_LowPriority;
      var jc = ca.unstable_IdlePriority;
      var kc = null;
      var lc = null;
      function mc(a3) {
        if (lc && "function" === typeof lc.onCommitFiberRoot)
          try {
            lc.onCommitFiberRoot(kc, a3, void 0, 128 === (a3.current.flags & 128));
          } catch (b3) {
          }
      }
      var oc = Math.clz32 ? Math.clz32 : nc;
      var pc = Math.log;
      var qc = Math.LN2;
      function nc(a3) {
        a3 >>>= 0;
        return 0 === a3 ? 32 : 31 - (pc(a3) / qc | 0) | 0;
      }
      var rc = 64;
      var sc = 4194304;
      function tc(a3) {
        switch (a3 & -a3) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return a3 & 4194240;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return a3 & 130023424;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 1073741824;
          default:
            return a3;
        }
      }
      function uc(a3, b3) {
        var c3 = a3.pendingLanes;
        if (0 === c3)
          return 0;
        var d3 = 0, e2 = a3.suspendedLanes, f3 = a3.pingedLanes, g3 = c3 & 268435455;
        if (0 !== g3) {
          var h3 = g3 & ~e2;
          0 !== h3 ? d3 = tc(h3) : (f3 &= g3, 0 !== f3 && (d3 = tc(f3)));
        } else
          g3 = c3 & ~e2, 0 !== g3 ? d3 = tc(g3) : 0 !== f3 && (d3 = tc(f3));
        if (0 === d3)
          return 0;
        if (0 !== b3 && b3 !== d3 && 0 === (b3 & e2) && (e2 = d3 & -d3, f3 = b3 & -b3, e2 >= f3 || 16 === e2 && 0 !== (f3 & 4194240)))
          return b3;
        0 !== (d3 & 4) && (d3 |= c3 & 16);
        b3 = a3.entangledLanes;
        if (0 !== b3)
          for (a3 = a3.entanglements, b3 &= d3; 0 < b3; )
            c3 = 31 - oc(b3), e2 = 1 << c3, d3 |= a3[c3], b3 &= ~e2;
        return d3;
      }
      function vc(a3, b3) {
        switch (a3) {
          case 1:
          case 2:
          case 4:
            return b3 + 250;
          case 8:
          case 16:
          case 32:
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return b3 + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return -1;
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function wc(a3, b3) {
        for (var c3 = a3.suspendedLanes, d3 = a3.pingedLanes, e2 = a3.expirationTimes, f3 = a3.pendingLanes; 0 < f3; ) {
          var g3 = 31 - oc(f3), h3 = 1 << g3, k2 = e2[g3];
          if (-1 === k2) {
            if (0 === (h3 & c3) || 0 !== (h3 & d3))
              e2[g3] = vc(h3, b3);
          } else
            k2 <= b3 && (a3.expiredLanes |= h3);
          f3 &= ~h3;
        }
      }
      function xc(a3) {
        a3 = a3.pendingLanes & -1073741825;
        return 0 !== a3 ? a3 : a3 & 1073741824 ? 1073741824 : 0;
      }
      function yc() {
        var a3 = rc;
        rc <<= 1;
        0 === (rc & 4194240) && (rc = 64);
        return a3;
      }
      function zc(a3) {
        for (var b3 = [], c3 = 0; 31 > c3; c3++)
          b3.push(a3);
        return b3;
      }
      function Ac(a3, b3, c3) {
        a3.pendingLanes |= b3;
        536870912 !== b3 && (a3.suspendedLanes = 0, a3.pingedLanes = 0);
        a3 = a3.eventTimes;
        b3 = 31 - oc(b3);
        a3[b3] = c3;
      }
      function Bc(a3, b3) {
        var c3 = a3.pendingLanes & ~b3;
        a3.pendingLanes = b3;
        a3.suspendedLanes = 0;
        a3.pingedLanes = 0;
        a3.expiredLanes &= b3;
        a3.mutableReadLanes &= b3;
        a3.entangledLanes &= b3;
        b3 = a3.entanglements;
        var d3 = a3.eventTimes;
        for (a3 = a3.expirationTimes; 0 < c3; ) {
          var e2 = 31 - oc(c3), f3 = 1 << e2;
          b3[e2] = 0;
          d3[e2] = -1;
          a3[e2] = -1;
          c3 &= ~f3;
        }
      }
      function Cc(a3, b3) {
        var c3 = a3.entangledLanes |= b3;
        for (a3 = a3.entanglements; c3; ) {
          var d3 = 31 - oc(c3), e2 = 1 << d3;
          e2 & b3 | a3[d3] & b3 && (a3[d3] |= b3);
          c3 &= ~e2;
        }
      }
      var C2 = 0;
      function Dc(a3) {
        a3 &= -a3;
        return 1 < a3 ? 4 < a3 ? 0 !== (a3 & 268435455) ? 16 : 536870912 : 4 : 1;
      }
      var Ec;
      var Fc;
      var Gc;
      var Hc;
      var Ic;
      var Jc = false;
      var Kc = [];
      var Lc = null;
      var Mc = null;
      var Nc = null;
      var Oc = /* @__PURE__ */ new Map();
      var Pc = /* @__PURE__ */ new Map();
      var Qc = [];
      var Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
      function Sc(a3, b3) {
        switch (a3) {
          case "focusin":
          case "focusout":
            Lc = null;
            break;
          case "dragenter":
          case "dragleave":
            Mc = null;
            break;
          case "mouseover":
          case "mouseout":
            Nc = null;
            break;
          case "pointerover":
          case "pointerout":
            Oc.delete(b3.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            Pc.delete(b3.pointerId);
        }
      }
      function Tc(a3, b3, c3, d3, e2, f3) {
        if (null === a3 || a3.nativeEvent !== f3)
          return a3 = { blockedOn: b3, domEventName: c3, eventSystemFlags: d3, nativeEvent: f3, targetContainers: [e2] }, null !== b3 && (b3 = Cb(b3), null !== b3 && Fc(b3)), a3;
        a3.eventSystemFlags |= d3;
        b3 = a3.targetContainers;
        null !== e2 && -1 === b3.indexOf(e2) && b3.push(e2);
        return a3;
      }
      function Uc(a3, b3, c3, d3, e2) {
        switch (b3) {
          case "focusin":
            return Lc = Tc(Lc, a3, b3, c3, d3, e2), true;
          case "dragenter":
            return Mc = Tc(Mc, a3, b3, c3, d3, e2), true;
          case "mouseover":
            return Nc = Tc(Nc, a3, b3, c3, d3, e2), true;
          case "pointerover":
            var f3 = e2.pointerId;
            Oc.set(f3, Tc(Oc.get(f3) || null, a3, b3, c3, d3, e2));
            return true;
          case "gotpointercapture":
            return f3 = e2.pointerId, Pc.set(f3, Tc(Pc.get(f3) || null, a3, b3, c3, d3, e2)), true;
        }
        return false;
      }
      function Vc(a3) {
        var b3 = Wc(a3.target);
        if (null !== b3) {
          var c3 = Vb(b3);
          if (null !== c3) {
            if (b3 = c3.tag, 13 === b3) {
              if (b3 = Wb(c3), null !== b3) {
                a3.blockedOn = b3;
                Ic(a3.priority, function() {
                  Gc(c3);
                });
                return;
              }
            } else if (3 === b3 && c3.stateNode.current.memoizedState.isDehydrated) {
              a3.blockedOn = 3 === c3.tag ? c3.stateNode.containerInfo : null;
              return;
            }
          }
        }
        a3.blockedOn = null;
      }
      function Xc(a3) {
        if (null !== a3.blockedOn)
          return false;
        for (var b3 = a3.targetContainers; 0 < b3.length; ) {
          var c3 = Yc(a3.domEventName, a3.eventSystemFlags, b3[0], a3.nativeEvent);
          if (null === c3) {
            c3 = a3.nativeEvent;
            var d3 = new c3.constructor(c3.type, c3);
            wb = d3;
            c3.target.dispatchEvent(d3);
            wb = null;
          } else
            return b3 = Cb(c3), null !== b3 && Fc(b3), a3.blockedOn = c3, false;
          b3.shift();
        }
        return true;
      }
      function Zc(a3, b3, c3) {
        Xc(a3) && c3.delete(b3);
      }
      function $c() {
        Jc = false;
        null !== Lc && Xc(Lc) && (Lc = null);
        null !== Mc && Xc(Mc) && (Mc = null);
        null !== Nc && Xc(Nc) && (Nc = null);
        Oc.forEach(Zc);
        Pc.forEach(Zc);
      }
      function ad(a3, b3) {
        a3.blockedOn === b3 && (a3.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
      }
      function bd(a3) {
        function b3(b4) {
          return ad(b4, a3);
        }
        if (0 < Kc.length) {
          ad(Kc[0], a3);
          for (var c3 = 1; c3 < Kc.length; c3++) {
            var d3 = Kc[c3];
            d3.blockedOn === a3 && (d3.blockedOn = null);
          }
        }
        null !== Lc && ad(Lc, a3);
        null !== Mc && ad(Mc, a3);
        null !== Nc && ad(Nc, a3);
        Oc.forEach(b3);
        Pc.forEach(b3);
        for (c3 = 0; c3 < Qc.length; c3++)
          d3 = Qc[c3], d3.blockedOn === a3 && (d3.blockedOn = null);
        for (; 0 < Qc.length && (c3 = Qc[0], null === c3.blockedOn); )
          Vc(c3), null === c3.blockedOn && Qc.shift();
      }
      var cd = ua.ReactCurrentBatchConfig;
      var dd = true;
      function ed(a3, b3, c3, d3) {
        var e2 = C2, f3 = cd.transition;
        cd.transition = null;
        try {
          C2 = 1, fd(a3, b3, c3, d3);
        } finally {
          C2 = e2, cd.transition = f3;
        }
      }
      function gd(a3, b3, c3, d3) {
        var e2 = C2, f3 = cd.transition;
        cd.transition = null;
        try {
          C2 = 4, fd(a3, b3, c3, d3);
        } finally {
          C2 = e2, cd.transition = f3;
        }
      }
      function fd(a3, b3, c3, d3) {
        if (dd) {
          var e2 = Yc(a3, b3, c3, d3);
          if (null === e2)
            hd(a3, b3, d3, id, c3), Sc(a3, d3);
          else if (Uc(e2, a3, b3, c3, d3))
            d3.stopPropagation();
          else if (Sc(a3, d3), b3 & 4 && -1 < Rc.indexOf(a3)) {
            for (; null !== e2; ) {
              var f3 = Cb(e2);
              null !== f3 && Ec(f3);
              f3 = Yc(a3, b3, c3, d3);
              null === f3 && hd(a3, b3, d3, id, c3);
              if (f3 === e2)
                break;
              e2 = f3;
            }
            null !== e2 && d3.stopPropagation();
          } else
            hd(a3, b3, d3, null, c3);
        }
      }
      var id = null;
      function Yc(a3, b3, c3, d3) {
        id = null;
        a3 = xb(d3);
        a3 = Wc(a3);
        if (null !== a3)
          if (b3 = Vb(a3), null === b3)
            a3 = null;
          else if (c3 = b3.tag, 13 === c3) {
            a3 = Wb(b3);
            if (null !== a3)
              return a3;
            a3 = null;
          } else if (3 === c3) {
            if (b3.stateNode.current.memoizedState.isDehydrated)
              return 3 === b3.tag ? b3.stateNode.containerInfo : null;
            a3 = null;
          } else
            b3 !== a3 && (a3 = null);
        id = a3;
        return null;
      }
      function jd(a3) {
        switch (a3) {
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 1;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "toggle":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 4;
          case "message":
            switch (ec()) {
              case fc:
                return 1;
              case gc:
                return 4;
              case hc:
              case ic:
                return 16;
              case jc:
                return 536870912;
              default:
                return 16;
            }
          default:
            return 16;
        }
      }
      var kd = null;
      var ld = null;
      var md = null;
      function nd() {
        if (md)
          return md;
        var a3, b3 = ld, c3 = b3.length, d3, e2 = "value" in kd ? kd.value : kd.textContent, f3 = e2.length;
        for (a3 = 0; a3 < c3 && b3[a3] === e2[a3]; a3++)
          ;
        var g3 = c3 - a3;
        for (d3 = 1; d3 <= g3 && b3[c3 - d3] === e2[f3 - d3]; d3++)
          ;
        return md = e2.slice(a3, 1 < d3 ? 1 - d3 : void 0);
      }
      function od(a3) {
        var b3 = a3.keyCode;
        "charCode" in a3 ? (a3 = a3.charCode, 0 === a3 && 13 === b3 && (a3 = 13)) : a3 = b3;
        10 === a3 && (a3 = 13);
        return 32 <= a3 || 13 === a3 ? a3 : 0;
      }
      function pd() {
        return true;
      }
      function qd() {
        return false;
      }
      function rd(a3) {
        function b3(b4, d3, e2, f3, g3) {
          this._reactName = b4;
          this._targetInst = e2;
          this.type = d3;
          this.nativeEvent = f3;
          this.target = g3;
          this.currentTarget = null;
          for (var c3 in a3)
            a3.hasOwnProperty(c3) && (b4 = a3[c3], this[c3] = b4 ? b4(f3) : f3[c3]);
          this.isDefaultPrevented = (null != f3.defaultPrevented ? f3.defaultPrevented : false === f3.returnValue) ? pd : qd;
          this.isPropagationStopped = qd;
          return this;
        }
        A2(b3.prototype, { preventDefault: function() {
          this.defaultPrevented = true;
          var a4 = this.nativeEvent;
          a4 && (a4.preventDefault ? a4.preventDefault() : "unknown" !== typeof a4.returnValue && (a4.returnValue = false), this.isDefaultPrevented = pd);
        }, stopPropagation: function() {
          var a4 = this.nativeEvent;
          a4 && (a4.stopPropagation ? a4.stopPropagation() : "unknown" !== typeof a4.cancelBubble && (a4.cancelBubble = true), this.isPropagationStopped = pd);
        }, persist: function() {
        }, isPersistent: pd });
        return b3;
      }
      var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a3) {
        return a3.timeStamp || Date.now();
      }, defaultPrevented: 0, isTrusted: 0 };
      var td = rd(sd);
      var ud = A2({}, sd, { view: 0, detail: 0 });
      var vd = rd(ud);
      var wd;
      var xd;
      var yd;
      var Ad = A2({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a3) {
        return void 0 === a3.relatedTarget ? a3.fromElement === a3.srcElement ? a3.toElement : a3.fromElement : a3.relatedTarget;
      }, movementX: function(a3) {
        if ("movementX" in a3)
          return a3.movementX;
        a3 !== yd && (yd && "mousemove" === a3.type ? (wd = a3.screenX - yd.screenX, xd = a3.screenY - yd.screenY) : xd = wd = 0, yd = a3);
        return wd;
      }, movementY: function(a3) {
        return "movementY" in a3 ? a3.movementY : xd;
      } });
      var Bd = rd(Ad);
      var Cd = A2({}, Ad, { dataTransfer: 0 });
      var Dd = rd(Cd);
      var Ed = A2({}, ud, { relatedTarget: 0 });
      var Fd = rd(Ed);
      var Gd = A2({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 });
      var Hd = rd(Gd);
      var Id = A2({}, sd, { clipboardData: function(a3) {
        return "clipboardData" in a3 ? a3.clipboardData : window.clipboardData;
      } });
      var Jd = rd(Id);
      var Kd = A2({}, sd, { data: 0 });
      var Ld = rd(Kd);
      var Md = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      };
      var Nd = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      };
      var Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
      function Pd(a3) {
        var b3 = this.nativeEvent;
        return b3.getModifierState ? b3.getModifierState(a3) : (a3 = Od[a3]) ? !!b3[a3] : false;
      }
      function zd() {
        return Pd;
      }
      var Qd = A2({}, ud, { key: function(a3) {
        if (a3.key) {
          var b3 = Md[a3.key] || a3.key;
          if ("Unidentified" !== b3)
            return b3;
        }
        return "keypress" === a3.type ? (a3 = od(a3), 13 === a3 ? "Enter" : String.fromCharCode(a3)) : "keydown" === a3.type || "keyup" === a3.type ? Nd[a3.keyCode] || "Unidentified" : "";
      }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a3) {
        return "keypress" === a3.type ? od(a3) : 0;
      }, keyCode: function(a3) {
        return "keydown" === a3.type || "keyup" === a3.type ? a3.keyCode : 0;
      }, which: function(a3) {
        return "keypress" === a3.type ? od(a3) : "keydown" === a3.type || "keyup" === a3.type ? a3.keyCode : 0;
      } });
      var Rd = rd(Qd);
      var Sd = A2({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 });
      var Td = rd(Sd);
      var Ud = A2({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd });
      var Vd = rd(Ud);
      var Wd = A2({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 });
      var Xd = rd(Wd);
      var Yd = A2({}, Ad, {
        deltaX: function(a3) {
          return "deltaX" in a3 ? a3.deltaX : "wheelDeltaX" in a3 ? -a3.wheelDeltaX : 0;
        },
        deltaY: function(a3) {
          return "deltaY" in a3 ? a3.deltaY : "wheelDeltaY" in a3 ? -a3.wheelDeltaY : "wheelDelta" in a3 ? -a3.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      });
      var Zd = rd(Yd);
      var $d = [9, 13, 27, 32];
      var ae = ia && "CompositionEvent" in window;
      var be = null;
      ia && "documentMode" in document && (be = document.documentMode);
      var ce = ia && "TextEvent" in window && !be;
      var de = ia && (!ae || be && 8 < be && 11 >= be);
      var ee = String.fromCharCode(32);
      var fe = false;
      function ge(a3, b3) {
        switch (a3) {
          case "keyup":
            return -1 !== $d.indexOf(b3.keyCode);
          case "keydown":
            return 229 !== b3.keyCode;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function he(a3) {
        a3 = a3.detail;
        return "object" === typeof a3 && "data" in a3 ? a3.data : null;
      }
      var ie = false;
      function je(a3, b3) {
        switch (a3) {
          case "compositionend":
            return he(b3);
          case "keypress":
            if (32 !== b3.which)
              return null;
            fe = true;
            return ee;
          case "textInput":
            return a3 = b3.data, a3 === ee && fe ? null : a3;
          default:
            return null;
        }
      }
      function ke(a3, b3) {
        if (ie)
          return "compositionend" === a3 || !ae && ge(a3, b3) ? (a3 = nd(), md = ld = kd = null, ie = false, a3) : null;
        switch (a3) {
          case "paste":
            return null;
          case "keypress":
            if (!(b3.ctrlKey || b3.altKey || b3.metaKey) || b3.ctrlKey && b3.altKey) {
              if (b3.char && 1 < b3.char.length)
                return b3.char;
              if (b3.which)
                return String.fromCharCode(b3.which);
            }
            return null;
          case "compositionend":
            return de && "ko" !== b3.locale ? null : b3.data;
          default:
            return null;
        }
      }
      var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
      function me(a3) {
        var b3 = a3 && a3.nodeName && a3.nodeName.toLowerCase();
        return "input" === b3 ? !!le[a3.type] : "textarea" === b3 ? true : false;
      }
      function ne(a3, b3, c3, d3) {
        Eb(d3);
        b3 = oe(b3, "onChange");
        0 < b3.length && (c3 = new td("onChange", "change", null, c3, d3), a3.push({ event: c3, listeners: b3 }));
      }
      var pe = null;
      var qe = null;
      function re(a3) {
        se(a3, 0);
      }
      function te(a3) {
        var b3 = ue(a3);
        if (Wa(b3))
          return a3;
      }
      function ve(a3, b3) {
        if ("change" === a3)
          return b3;
      }
      var we = false;
      if (ia) {
        if (ia) {
          ye = "oninput" in document;
          if (!ye) {
            ze = document.createElement("div");
            ze.setAttribute("oninput", "return;");
            ye = "function" === typeof ze.oninput;
          }
          xe = ye;
        } else
          xe = false;
        we = xe && (!document.documentMode || 9 < document.documentMode);
      }
      var xe;
      var ye;
      var ze;
      function Ae() {
        pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
      }
      function Be(a3) {
        if ("value" === a3.propertyName && te(qe)) {
          var b3 = [];
          ne(b3, qe, a3, xb(a3));
          Jb(re, b3);
        }
      }
      function Ce(a3, b3, c3) {
        "focusin" === a3 ? (Ae(), pe = b3, qe = c3, pe.attachEvent("onpropertychange", Be)) : "focusout" === a3 && Ae();
      }
      function De(a3) {
        if ("selectionchange" === a3 || "keyup" === a3 || "keydown" === a3)
          return te(qe);
      }
      function Ee(a3, b3) {
        if ("click" === a3)
          return te(b3);
      }
      function Fe(a3, b3) {
        if ("input" === a3 || "change" === a3)
          return te(b3);
      }
      function Ge(a3, b3) {
        return a3 === b3 && (0 !== a3 || 1 / a3 === 1 / b3) || a3 !== a3 && b3 !== b3;
      }
      var He = "function" === typeof Object.is ? Object.is : Ge;
      function Ie(a3, b3) {
        if (He(a3, b3))
          return true;
        if ("object" !== typeof a3 || null === a3 || "object" !== typeof b3 || null === b3)
          return false;
        var c3 = Object.keys(a3), d3 = Object.keys(b3);
        if (c3.length !== d3.length)
          return false;
        for (d3 = 0; d3 < c3.length; d3++) {
          var e2 = c3[d3];
          if (!ja.call(b3, e2) || !He(a3[e2], b3[e2]))
            return false;
        }
        return true;
      }
      function Je(a3) {
        for (; a3 && a3.firstChild; )
          a3 = a3.firstChild;
        return a3;
      }
      function Ke(a3, b3) {
        var c3 = Je(a3);
        a3 = 0;
        for (var d3; c3; ) {
          if (3 === c3.nodeType) {
            d3 = a3 + c3.textContent.length;
            if (a3 <= b3 && d3 >= b3)
              return { node: c3, offset: b3 - a3 };
            a3 = d3;
          }
          a: {
            for (; c3; ) {
              if (c3.nextSibling) {
                c3 = c3.nextSibling;
                break a;
              }
              c3 = c3.parentNode;
            }
            c3 = void 0;
          }
          c3 = Je(c3);
        }
      }
      function Le(a3, b3) {
        return a3 && b3 ? a3 === b3 ? true : a3 && 3 === a3.nodeType ? false : b3 && 3 === b3.nodeType ? Le(a3, b3.parentNode) : "contains" in a3 ? a3.contains(b3) : a3.compareDocumentPosition ? !!(a3.compareDocumentPosition(b3) & 16) : false : false;
      }
      function Me() {
        for (var a3 = window, b3 = Xa(); b3 instanceof a3.HTMLIFrameElement; ) {
          try {
            var c3 = "string" === typeof b3.contentWindow.location.href;
          } catch (d3) {
            c3 = false;
          }
          if (c3)
            a3 = b3.contentWindow;
          else
            break;
          b3 = Xa(a3.document);
        }
        return b3;
      }
      function Ne(a3) {
        var b3 = a3 && a3.nodeName && a3.nodeName.toLowerCase();
        return b3 && ("input" === b3 && ("text" === a3.type || "search" === a3.type || "tel" === a3.type || "url" === a3.type || "password" === a3.type) || "textarea" === b3 || "true" === a3.contentEditable);
      }
      function Oe(a3) {
        var b3 = Me(), c3 = a3.focusedElem, d3 = a3.selectionRange;
        if (b3 !== c3 && c3 && c3.ownerDocument && Le(c3.ownerDocument.documentElement, c3)) {
          if (null !== d3 && Ne(c3)) {
            if (b3 = d3.start, a3 = d3.end, void 0 === a3 && (a3 = b3), "selectionStart" in c3)
              c3.selectionStart = b3, c3.selectionEnd = Math.min(a3, c3.value.length);
            else if (a3 = (b3 = c3.ownerDocument || document) && b3.defaultView || window, a3.getSelection) {
              a3 = a3.getSelection();
              var e2 = c3.textContent.length, f3 = Math.min(d3.start, e2);
              d3 = void 0 === d3.end ? f3 : Math.min(d3.end, e2);
              !a3.extend && f3 > d3 && (e2 = d3, d3 = f3, f3 = e2);
              e2 = Ke(c3, f3);
              var g3 = Ke(
                c3,
                d3
              );
              e2 && g3 && (1 !== a3.rangeCount || a3.anchorNode !== e2.node || a3.anchorOffset !== e2.offset || a3.focusNode !== g3.node || a3.focusOffset !== g3.offset) && (b3 = b3.createRange(), b3.setStart(e2.node, e2.offset), a3.removeAllRanges(), f3 > d3 ? (a3.addRange(b3), a3.extend(g3.node, g3.offset)) : (b3.setEnd(g3.node, g3.offset), a3.addRange(b3)));
            }
          }
          b3 = [];
          for (a3 = c3; a3 = a3.parentNode; )
            1 === a3.nodeType && b3.push({ element: a3, left: a3.scrollLeft, top: a3.scrollTop });
          "function" === typeof c3.focus && c3.focus();
          for (c3 = 0; c3 < b3.length; c3++)
            a3 = b3[c3], a3.element.scrollLeft = a3.left, a3.element.scrollTop = a3.top;
        }
      }
      var Pe = ia && "documentMode" in document && 11 >= document.documentMode;
      var Qe = null;
      var Re = null;
      var Se = null;
      var Te = false;
      function Ue(a3, b3, c3) {
        var d3 = c3.window === c3 ? c3.document : 9 === c3.nodeType ? c3 : c3.ownerDocument;
        Te || null == Qe || Qe !== Xa(d3) || (d3 = Qe, "selectionStart" in d3 && Ne(d3) ? d3 = { start: d3.selectionStart, end: d3.selectionEnd } : (d3 = (d3.ownerDocument && d3.ownerDocument.defaultView || window).getSelection(), d3 = { anchorNode: d3.anchorNode, anchorOffset: d3.anchorOffset, focusNode: d3.focusNode, focusOffset: d3.focusOffset }), Se && Ie(Se, d3) || (Se = d3, d3 = oe(Re, "onSelect"), 0 < d3.length && (b3 = new td("onSelect", "select", null, b3, c3), a3.push({ event: b3, listeners: d3 }), b3.target = Qe)));
      }
      function Ve(a3, b3) {
        var c3 = {};
        c3[a3.toLowerCase()] = b3.toLowerCase();
        c3["Webkit" + a3] = "webkit" + b3;
        c3["Moz" + a3] = "moz" + b3;
        return c3;
      }
      var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") };
      var Xe = {};
      var Ye = {};
      ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
      function Ze(a3) {
        if (Xe[a3])
          return Xe[a3];
        if (!We[a3])
          return a3;
        var b3 = We[a3], c3;
        for (c3 in b3)
          if (b3.hasOwnProperty(c3) && c3 in Ye)
            return Xe[a3] = b3[c3];
        return a3;
      }
      var $e = Ze("animationend");
      var af = Ze("animationiteration");
      var bf = Ze("animationstart");
      var cf = Ze("transitionend");
      var df = /* @__PURE__ */ new Map();
      var ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
      function ff(a3, b3) {
        df.set(a3, b3);
        fa(b3, [a3]);
      }
      for (gf = 0; gf < ef.length; gf++) {
        hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
        ff(jf, "on" + kf);
      }
      var hf;
      var jf;
      var kf;
      var gf;
      ff($e, "onAnimationEnd");
      ff(af, "onAnimationIteration");
      ff(bf, "onAnimationStart");
      ff("dblclick", "onDoubleClick");
      ff("focusin", "onFocus");
      ff("focusout", "onBlur");
      ff(cf, "onTransitionEnd");
      ha("onMouseEnter", ["mouseout", "mouseover"]);
      ha("onMouseLeave", ["mouseout", "mouseover"]);
      ha("onPointerEnter", ["pointerout", "pointerover"]);
      ha("onPointerLeave", ["pointerout", "pointerover"]);
      fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
      fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
      fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
      fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
      fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
      fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
      var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ");
      var mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
      function nf(a3, b3, c3) {
        var d3 = a3.type || "unknown-event";
        a3.currentTarget = c3;
        Ub(d3, b3, void 0, a3);
        a3.currentTarget = null;
      }
      function se(a3, b3) {
        b3 = 0 !== (b3 & 4);
        for (var c3 = 0; c3 < a3.length; c3++) {
          var d3 = a3[c3], e2 = d3.event;
          d3 = d3.listeners;
          a: {
            var f3 = void 0;
            if (b3)
              for (var g3 = d3.length - 1; 0 <= g3; g3--) {
                var h3 = d3[g3], k2 = h3.instance, l3 = h3.currentTarget;
                h3 = h3.listener;
                if (k2 !== f3 && e2.isPropagationStopped())
                  break a;
                nf(e2, h3, l3);
                f3 = k2;
              }
            else
              for (g3 = 0; g3 < d3.length; g3++) {
                h3 = d3[g3];
                k2 = h3.instance;
                l3 = h3.currentTarget;
                h3 = h3.listener;
                if (k2 !== f3 && e2.isPropagationStopped())
                  break a;
                nf(e2, h3, l3);
                f3 = k2;
              }
          }
        }
        if (Qb)
          throw a3 = Rb, Qb = false, Rb = null, a3;
      }
      function D3(a3, b3) {
        var c3 = b3[of];
        void 0 === c3 && (c3 = b3[of] = /* @__PURE__ */ new Set());
        var d3 = a3 + "__bubble";
        c3.has(d3) || (pf(b3, a3, 2, false), c3.add(d3));
      }
      function qf(a3, b3, c3) {
        var d3 = 0;
        b3 && (d3 |= 4);
        pf(c3, a3, d3, b3);
      }
      var rf = "_reactListening" + Math.random().toString(36).slice(2);
      function sf(a3) {
        if (!a3[rf]) {
          a3[rf] = true;
          da.forEach(function(b4) {
            "selectionchange" !== b4 && (mf.has(b4) || qf(b4, false, a3), qf(b4, true, a3));
          });
          var b3 = 9 === a3.nodeType ? a3 : a3.ownerDocument;
          null === b3 || b3[rf] || (b3[rf] = true, qf("selectionchange", false, b3));
        }
      }
      function pf(a3, b3, c3, d3) {
        switch (jd(b3)) {
          case 1:
            var e2 = ed;
            break;
          case 4:
            e2 = gd;
            break;
          default:
            e2 = fd;
        }
        c3 = e2.bind(null, b3, c3, a3);
        e2 = void 0;
        !Lb || "touchstart" !== b3 && "touchmove" !== b3 && "wheel" !== b3 || (e2 = true);
        d3 ? void 0 !== e2 ? a3.addEventListener(b3, c3, { capture: true, passive: e2 }) : a3.addEventListener(b3, c3, true) : void 0 !== e2 ? a3.addEventListener(b3, c3, { passive: e2 }) : a3.addEventListener(b3, c3, false);
      }
      function hd(a3, b3, c3, d3, e2) {
        var f3 = d3;
        if (0 === (b3 & 1) && 0 === (b3 & 2) && null !== d3)
          a:
            for (; ; ) {
              if (null === d3)
                return;
              var g3 = d3.tag;
              if (3 === g3 || 4 === g3) {
                var h3 = d3.stateNode.containerInfo;
                if (h3 === e2 || 8 === h3.nodeType && h3.parentNode === e2)
                  break;
                if (4 === g3)
                  for (g3 = d3.return; null !== g3; ) {
                    var k2 = g3.tag;
                    if (3 === k2 || 4 === k2) {
                      if (k2 = g3.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                        return;
                    }
                    g3 = g3.return;
                  }
                for (; null !== h3; ) {
                  g3 = Wc(h3);
                  if (null === g3)
                    return;
                  k2 = g3.tag;
                  if (5 === k2 || 6 === k2) {
                    d3 = f3 = g3;
                    continue a;
                  }
                  h3 = h3.parentNode;
                }
              }
              d3 = d3.return;
            }
        Jb(function() {
          var d4 = f3, e3 = xb(c3), g4 = [];
          a: {
            var h4 = df.get(a3);
            if (void 0 !== h4) {
              var k3 = td, n3 = a3;
              switch (a3) {
                case "keypress":
                  if (0 === od(c3))
                    break a;
                case "keydown":
                case "keyup":
                  k3 = Rd;
                  break;
                case "focusin":
                  n3 = "focus";
                  k3 = Fd;
                  break;
                case "focusout":
                  n3 = "blur";
                  k3 = Fd;
                  break;
                case "beforeblur":
                case "afterblur":
                  k3 = Fd;
                  break;
                case "click":
                  if (2 === c3.button)
                    break a;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  k3 = Bd;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  k3 = Dd;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  k3 = Vd;
                  break;
                case $e:
                case af:
                case bf:
                  k3 = Hd;
                  break;
                case cf:
                  k3 = Xd;
                  break;
                case "scroll":
                  k3 = vd;
                  break;
                case "wheel":
                  k3 = Zd;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  k3 = Jd;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  k3 = Td;
              }
              var t4 = 0 !== (b3 & 4), J = !t4 && "scroll" === a3, x3 = t4 ? null !== h4 ? h4 + "Capture" : null : h4;
              t4 = [];
              for (var w3 = d4, u3; null !== w3; ) {
                u3 = w3;
                var F = u3.stateNode;
                5 === u3.tag && null !== F && (u3 = F, null !== x3 && (F = Kb(w3, x3), null != F && t4.push(tf(w3, F, u3))));
                if (J)
                  break;
                w3 = w3.return;
              }
              0 < t4.length && (h4 = new k3(h4, n3, null, c3, e3), g4.push({ event: h4, listeners: t4 }));
            }
          }
          if (0 === (b3 & 7)) {
            a: {
              h4 = "mouseover" === a3 || "pointerover" === a3;
              k3 = "mouseout" === a3 || "pointerout" === a3;
              if (h4 && c3 !== wb && (n3 = c3.relatedTarget || c3.fromElement) && (Wc(n3) || n3[uf]))
                break a;
              if (k3 || h4) {
                h4 = e3.window === e3 ? e3 : (h4 = e3.ownerDocument) ? h4.defaultView || h4.parentWindow : window;
                if (k3) {
                  if (n3 = c3.relatedTarget || c3.toElement, k3 = d4, n3 = n3 ? Wc(n3) : null, null !== n3 && (J = Vb(n3), n3 !== J || 5 !== n3.tag && 6 !== n3.tag))
                    n3 = null;
                } else
                  k3 = null, n3 = d4;
                if (k3 !== n3) {
                  t4 = Bd;
                  F = "onMouseLeave";
                  x3 = "onMouseEnter";
                  w3 = "mouse";
                  if ("pointerout" === a3 || "pointerover" === a3)
                    t4 = Td, F = "onPointerLeave", x3 = "onPointerEnter", w3 = "pointer";
                  J = null == k3 ? h4 : ue(k3);
                  u3 = null == n3 ? h4 : ue(n3);
                  h4 = new t4(F, w3 + "leave", k3, c3, e3);
                  h4.target = J;
                  h4.relatedTarget = u3;
                  F = null;
                  Wc(e3) === d4 && (t4 = new t4(x3, w3 + "enter", n3, c3, e3), t4.target = u3, t4.relatedTarget = J, F = t4);
                  J = F;
                  if (k3 && n3)
                    b: {
                      t4 = k3;
                      x3 = n3;
                      w3 = 0;
                      for (u3 = t4; u3; u3 = vf(u3))
                        w3++;
                      u3 = 0;
                      for (F = x3; F; F = vf(F))
                        u3++;
                      for (; 0 < w3 - u3; )
                        t4 = vf(t4), w3--;
                      for (; 0 < u3 - w3; )
                        x3 = vf(x3), u3--;
                      for (; w3--; ) {
                        if (t4 === x3 || null !== x3 && t4 === x3.alternate)
                          break b;
                        t4 = vf(t4);
                        x3 = vf(x3);
                      }
                      t4 = null;
                    }
                  else
                    t4 = null;
                  null !== k3 && wf(g4, h4, k3, t4, false);
                  null !== n3 && null !== J && wf(g4, J, n3, t4, true);
                }
              }
            }
            a: {
              h4 = d4 ? ue(d4) : window;
              k3 = h4.nodeName && h4.nodeName.toLowerCase();
              if ("select" === k3 || "input" === k3 && "file" === h4.type)
                var na = ve;
              else if (me(h4))
                if (we)
                  na = Fe;
                else {
                  na = De;
                  var xa = Ce;
                }
              else
                (k3 = h4.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h4.type || "radio" === h4.type) && (na = Ee);
              if (na && (na = na(a3, d4))) {
                ne(g4, na, c3, e3);
                break a;
              }
              xa && xa(a3, h4, d4);
              "focusout" === a3 && (xa = h4._wrapperState) && xa.controlled && "number" === h4.type && cb(h4, "number", h4.value);
            }
            xa = d4 ? ue(d4) : window;
            switch (a3) {
              case "focusin":
                if (me(xa) || "true" === xa.contentEditable)
                  Qe = xa, Re = d4, Se = null;
                break;
              case "focusout":
                Se = Re = Qe = null;
                break;
              case "mousedown":
                Te = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                Te = false;
                Ue(g4, c3, e3);
                break;
              case "selectionchange":
                if (Pe)
                  break;
              case "keydown":
              case "keyup":
                Ue(g4, c3, e3);
            }
            var $a;
            if (ae)
              b: {
                switch (a3) {
                  case "compositionstart":
                    var ba = "onCompositionStart";
                    break b;
                  case "compositionend":
                    ba = "onCompositionEnd";
                    break b;
                  case "compositionupdate":
                    ba = "onCompositionUpdate";
                    break b;
                }
                ba = void 0;
              }
            else
              ie ? ge(a3, c3) && (ba = "onCompositionEnd") : "keydown" === a3 && 229 === c3.keyCode && (ba = "onCompositionStart");
            ba && (de && "ko" !== c3.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d4, ba), 0 < xa.length && (ba = new Ld(ba, a3, null, c3, e3), g4.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c3), null !== $a && (ba.data = $a))));
            if ($a = ce ? je(a3, c3) : ke(a3, c3))
              d4 = oe(d4, "onBeforeInput"), 0 < d4.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c3, e3), g4.push({ event: e3, listeners: d4 }), e3.data = $a);
          }
          se(g4, b3);
        });
      }
      function tf(a3, b3, c3) {
        return { instance: a3, listener: b3, currentTarget: c3 };
      }
      function oe(a3, b3) {
        for (var c3 = b3 + "Capture", d3 = []; null !== a3; ) {
          var e2 = a3, f3 = e2.stateNode;
          5 === e2.tag && null !== f3 && (e2 = f3, f3 = Kb(a3, c3), null != f3 && d3.unshift(tf(a3, f3, e2)), f3 = Kb(a3, b3), null != f3 && d3.push(tf(a3, f3, e2)));
          a3 = a3.return;
        }
        return d3;
      }
      function vf(a3) {
        if (null === a3)
          return null;
        do
          a3 = a3.return;
        while (a3 && 5 !== a3.tag);
        return a3 ? a3 : null;
      }
      function wf(a3, b3, c3, d3, e2) {
        for (var f3 = b3._reactName, g3 = []; null !== c3 && c3 !== d3; ) {
          var h3 = c3, k2 = h3.alternate, l3 = h3.stateNode;
          if (null !== k2 && k2 === d3)
            break;
          5 === h3.tag && null !== l3 && (h3 = l3, e2 ? (k2 = Kb(c3, f3), null != k2 && g3.unshift(tf(c3, k2, h3))) : e2 || (k2 = Kb(c3, f3), null != k2 && g3.push(tf(c3, k2, h3))));
          c3 = c3.return;
        }
        0 !== g3.length && a3.push({ event: b3, listeners: g3 });
      }
      var xf = /\r\n?/g;
      var yf = /\u0000|\uFFFD/g;
      function zf(a3) {
        return ("string" === typeof a3 ? a3 : "" + a3).replace(xf, "\n").replace(yf, "");
      }
      function Af(a3, b3, c3) {
        b3 = zf(b3);
        if (zf(a3) !== b3 && c3)
          throw Error(p3(425));
      }
      function Bf() {
      }
      var Cf = null;
      var Df = null;
      function Ef(a3, b3) {
        return "textarea" === a3 || "noscript" === a3 || "string" === typeof b3.children || "number" === typeof b3.children || "object" === typeof b3.dangerouslySetInnerHTML && null !== b3.dangerouslySetInnerHTML && null != b3.dangerouslySetInnerHTML.__html;
      }
      var Ff = "function" === typeof setTimeout ? setTimeout : void 0;
      var Gf = "function" === typeof clearTimeout ? clearTimeout : void 0;
      var Hf = "function" === typeof Promise ? Promise : void 0;
      var Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a3) {
        return Hf.resolve(null).then(a3).catch(If);
      } : Ff;
      function If(a3) {
        setTimeout(function() {
          throw a3;
        });
      }
      function Kf(a3, b3) {
        var c3 = b3, d3 = 0;
        do {
          var e2 = c3.nextSibling;
          a3.removeChild(c3);
          if (e2 && 8 === e2.nodeType)
            if (c3 = e2.data, "/$" === c3) {
              if (0 === d3) {
                a3.removeChild(e2);
                bd(b3);
                return;
              }
              d3--;
            } else
              "$" !== c3 && "$?" !== c3 && "$!" !== c3 || d3++;
          c3 = e2;
        } while (c3);
        bd(b3);
      }
      function Lf(a3) {
        for (; null != a3; a3 = a3.nextSibling) {
          var b3 = a3.nodeType;
          if (1 === b3 || 3 === b3)
            break;
          if (8 === b3) {
            b3 = a3.data;
            if ("$" === b3 || "$!" === b3 || "$?" === b3)
              break;
            if ("/$" === b3)
              return null;
          }
        }
        return a3;
      }
      function Mf(a3) {
        a3 = a3.previousSibling;
        for (var b3 = 0; a3; ) {
          if (8 === a3.nodeType) {
            var c3 = a3.data;
            if ("$" === c3 || "$!" === c3 || "$?" === c3) {
              if (0 === b3)
                return a3;
              b3--;
            } else
              "/$" === c3 && b3++;
          }
          a3 = a3.previousSibling;
        }
        return null;
      }
      var Nf = Math.random().toString(36).slice(2);
      var Of = "__reactFiber$" + Nf;
      var Pf = "__reactProps$" + Nf;
      var uf = "__reactContainer$" + Nf;
      var of = "__reactEvents$" + Nf;
      var Qf = "__reactListeners$" + Nf;
      var Rf = "__reactHandles$" + Nf;
      function Wc(a3) {
        var b3 = a3[Of];
        if (b3)
          return b3;
        for (var c3 = a3.parentNode; c3; ) {
          if (b3 = c3[uf] || c3[Of]) {
            c3 = b3.alternate;
            if (null !== b3.child || null !== c3 && null !== c3.child)
              for (a3 = Mf(a3); null !== a3; ) {
                if (c3 = a3[Of])
                  return c3;
                a3 = Mf(a3);
              }
            return b3;
          }
          a3 = c3;
          c3 = a3.parentNode;
        }
        return null;
      }
      function Cb(a3) {
        a3 = a3[Of] || a3[uf];
        return !a3 || 5 !== a3.tag && 6 !== a3.tag && 13 !== a3.tag && 3 !== a3.tag ? null : a3;
      }
      function ue(a3) {
        if (5 === a3.tag || 6 === a3.tag)
          return a3.stateNode;
        throw Error(p3(33));
      }
      function Db(a3) {
        return a3[Pf] || null;
      }
      var Sf = [];
      var Tf = -1;
      function Uf(a3) {
        return { current: a3 };
      }
      function E3(a3) {
        0 > Tf || (a3.current = Sf[Tf], Sf[Tf] = null, Tf--);
      }
      function G(a3, b3) {
        Tf++;
        Sf[Tf] = a3.current;
        a3.current = b3;
      }
      var Vf = {};
      var H2 = Uf(Vf);
      var Wf = Uf(false);
      var Xf = Vf;
      function Yf(a3, b3) {
        var c3 = a3.type.contextTypes;
        if (!c3)
          return Vf;
        var d3 = a3.stateNode;
        if (d3 && d3.__reactInternalMemoizedUnmaskedChildContext === b3)
          return d3.__reactInternalMemoizedMaskedChildContext;
        var e2 = {}, f3;
        for (f3 in c3)
          e2[f3] = b3[f3];
        d3 && (a3 = a3.stateNode, a3.__reactInternalMemoizedUnmaskedChildContext = b3, a3.__reactInternalMemoizedMaskedChildContext = e2);
        return e2;
      }
      function Zf(a3) {
        a3 = a3.childContextTypes;
        return null !== a3 && void 0 !== a3;
      }
      function $f() {
        E3(Wf);
        E3(H2);
      }
      function ag(a3, b3, c3) {
        if (H2.current !== Vf)
          throw Error(p3(168));
        G(H2, b3);
        G(Wf, c3);
      }
      function bg(a3, b3, c3) {
        var d3 = a3.stateNode;
        b3 = b3.childContextTypes;
        if ("function" !== typeof d3.getChildContext)
          return c3;
        d3 = d3.getChildContext();
        for (var e2 in d3)
          if (!(e2 in b3))
            throw Error(p3(108, Ra(a3) || "Unknown", e2));
        return A2({}, c3, d3);
      }
      function cg(a3) {
        a3 = (a3 = a3.stateNode) && a3.__reactInternalMemoizedMergedChildContext || Vf;
        Xf = H2.current;
        G(H2, a3);
        G(Wf, Wf.current);
        return true;
      }
      function dg(a3, b3, c3) {
        var d3 = a3.stateNode;
        if (!d3)
          throw Error(p3(169));
        c3 ? (a3 = bg(a3, b3, Xf), d3.__reactInternalMemoizedMergedChildContext = a3, E3(Wf), E3(H2), G(H2, a3)) : E3(Wf);
        G(Wf, c3);
      }
      var eg = null;
      var fg = false;
      var gg = false;
      function hg(a3) {
        null === eg ? eg = [a3] : eg.push(a3);
      }
      function ig(a3) {
        fg = true;
        hg(a3);
      }
      function jg() {
        if (!gg && null !== eg) {
          gg = true;
          var a3 = 0, b3 = C2;
          try {
            var c3 = eg;
            for (C2 = 1; a3 < c3.length; a3++) {
              var d3 = c3[a3];
              do
                d3 = d3(true);
              while (null !== d3);
            }
            eg = null;
            fg = false;
          } catch (e2) {
            throw null !== eg && (eg = eg.slice(a3 + 1)), ac(fc, jg), e2;
          } finally {
            C2 = b3, gg = false;
          }
        }
        return null;
      }
      var kg = [];
      var lg = 0;
      var mg = null;
      var ng = 0;
      var og = [];
      var pg = 0;
      var qg = null;
      var rg = 1;
      var sg = "";
      function tg(a3, b3) {
        kg[lg++] = ng;
        kg[lg++] = mg;
        mg = a3;
        ng = b3;
      }
      function ug(a3, b3, c3) {
        og[pg++] = rg;
        og[pg++] = sg;
        og[pg++] = qg;
        qg = a3;
        var d3 = rg;
        a3 = sg;
        var e2 = 32 - oc(d3) - 1;
        d3 &= ~(1 << e2);
        c3 += 1;
        var f3 = 32 - oc(b3) + e2;
        if (30 < f3) {
          var g3 = e2 - e2 % 5;
          f3 = (d3 & (1 << g3) - 1).toString(32);
          d3 >>= g3;
          e2 -= g3;
          rg = 1 << 32 - oc(b3) + e2 | c3 << e2 | d3;
          sg = f3 + a3;
        } else
          rg = 1 << f3 | c3 << e2 | d3, sg = a3;
      }
      function vg(a3) {
        null !== a3.return && (tg(a3, 1), ug(a3, 1, 0));
      }
      function wg(a3) {
        for (; a3 === mg; )
          mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
        for (; a3 === qg; )
          qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
      }
      var xg = null;
      var yg = null;
      var I = false;
      var zg = null;
      function Ag(a3, b3) {
        var c3 = Bg(5, null, null, 0);
        c3.elementType = "DELETED";
        c3.stateNode = b3;
        c3.return = a3;
        b3 = a3.deletions;
        null === b3 ? (a3.deletions = [c3], a3.flags |= 16) : b3.push(c3);
      }
      function Cg(a3, b3) {
        switch (a3.tag) {
          case 5:
            var c3 = a3.type;
            b3 = 1 !== b3.nodeType || c3.toLowerCase() !== b3.nodeName.toLowerCase() ? null : b3;
            return null !== b3 ? (a3.stateNode = b3, xg = a3, yg = Lf(b3.firstChild), true) : false;
          case 6:
            return b3 = "" === a3.pendingProps || 3 !== b3.nodeType ? null : b3, null !== b3 ? (a3.stateNode = b3, xg = a3, yg = null, true) : false;
          case 13:
            return b3 = 8 !== b3.nodeType ? null : b3, null !== b3 ? (c3 = null !== qg ? { id: rg, overflow: sg } : null, a3.memoizedState = { dehydrated: b3, treeContext: c3, retryLane: 1073741824 }, c3 = Bg(18, null, null, 0), c3.stateNode = b3, c3.return = a3, a3.child = c3, xg = a3, yg = null, true) : false;
          default:
            return false;
        }
      }
      function Dg(a3) {
        return 0 !== (a3.mode & 1) && 0 === (a3.flags & 128);
      }
      function Eg(a3) {
        if (I) {
          var b3 = yg;
          if (b3) {
            var c3 = b3;
            if (!Cg(a3, b3)) {
              if (Dg(a3))
                throw Error(p3(418));
              b3 = Lf(c3.nextSibling);
              var d3 = xg;
              b3 && Cg(a3, b3) ? Ag(d3, c3) : (a3.flags = a3.flags & -4097 | 2, I = false, xg = a3);
            }
          } else {
            if (Dg(a3))
              throw Error(p3(418));
            a3.flags = a3.flags & -4097 | 2;
            I = false;
            xg = a3;
          }
        }
      }
      function Fg(a3) {
        for (a3 = a3.return; null !== a3 && 5 !== a3.tag && 3 !== a3.tag && 13 !== a3.tag; )
          a3 = a3.return;
        xg = a3;
      }
      function Gg(a3) {
        if (a3 !== xg)
          return false;
        if (!I)
          return Fg(a3), I = true, false;
        var b3;
        (b3 = 3 !== a3.tag) && !(b3 = 5 !== a3.tag) && (b3 = a3.type, b3 = "head" !== b3 && "body" !== b3 && !Ef(a3.type, a3.memoizedProps));
        if (b3 && (b3 = yg)) {
          if (Dg(a3))
            throw Hg(), Error(p3(418));
          for (; b3; )
            Ag(a3, b3), b3 = Lf(b3.nextSibling);
        }
        Fg(a3);
        if (13 === a3.tag) {
          a3 = a3.memoizedState;
          a3 = null !== a3 ? a3.dehydrated : null;
          if (!a3)
            throw Error(p3(317));
          a: {
            a3 = a3.nextSibling;
            for (b3 = 0; a3; ) {
              if (8 === a3.nodeType) {
                var c3 = a3.data;
                if ("/$" === c3) {
                  if (0 === b3) {
                    yg = Lf(a3.nextSibling);
                    break a;
                  }
                  b3--;
                } else
                  "$" !== c3 && "$!" !== c3 && "$?" !== c3 || b3++;
              }
              a3 = a3.nextSibling;
            }
            yg = null;
          }
        } else
          yg = xg ? Lf(a3.stateNode.nextSibling) : null;
        return true;
      }
      function Hg() {
        for (var a3 = yg; a3; )
          a3 = Lf(a3.nextSibling);
      }
      function Ig() {
        yg = xg = null;
        I = false;
      }
      function Jg(a3) {
        null === zg ? zg = [a3] : zg.push(a3);
      }
      var Kg = ua.ReactCurrentBatchConfig;
      function Lg(a3, b3) {
        if (a3 && a3.defaultProps) {
          b3 = A2({}, b3);
          a3 = a3.defaultProps;
          for (var c3 in a3)
            void 0 === b3[c3] && (b3[c3] = a3[c3]);
          return b3;
        }
        return b3;
      }
      var Mg = Uf(null);
      var Ng = null;
      var Og = null;
      var Pg = null;
      function Qg() {
        Pg = Og = Ng = null;
      }
      function Rg(a3) {
        var b3 = Mg.current;
        E3(Mg);
        a3._currentValue = b3;
      }
      function Sg(a3, b3, c3) {
        for (; null !== a3; ) {
          var d3 = a3.alternate;
          (a3.childLanes & b3) !== b3 ? (a3.childLanes |= b3, null !== d3 && (d3.childLanes |= b3)) : null !== d3 && (d3.childLanes & b3) !== b3 && (d3.childLanes |= b3);
          if (a3 === c3)
            break;
          a3 = a3.return;
        }
      }
      function Tg(a3, b3) {
        Ng = a3;
        Pg = Og = null;
        a3 = a3.dependencies;
        null !== a3 && null !== a3.firstContext && (0 !== (a3.lanes & b3) && (Ug = true), a3.firstContext = null);
      }
      function Vg(a3) {
        var b3 = a3._currentValue;
        if (Pg !== a3)
          if (a3 = { context: a3, memoizedValue: b3, next: null }, null === Og) {
            if (null === Ng)
              throw Error(p3(308));
            Og = a3;
            Ng.dependencies = { lanes: 0, firstContext: a3 };
          } else
            Og = Og.next = a3;
        return b3;
      }
      var Wg = null;
      function Xg(a3) {
        null === Wg ? Wg = [a3] : Wg.push(a3);
      }
      function Yg(a3, b3, c3, d3) {
        var e2 = b3.interleaved;
        null === e2 ? (c3.next = c3, Xg(b3)) : (c3.next = e2.next, e2.next = c3);
        b3.interleaved = c3;
        return Zg(a3, d3);
      }
      function Zg(a3, b3) {
        a3.lanes |= b3;
        var c3 = a3.alternate;
        null !== c3 && (c3.lanes |= b3);
        c3 = a3;
        for (a3 = a3.return; null !== a3; )
          a3.childLanes |= b3, c3 = a3.alternate, null !== c3 && (c3.childLanes |= b3), c3 = a3, a3 = a3.return;
        return 3 === c3.tag ? c3.stateNode : null;
      }
      var $g = false;
      function ah(a3) {
        a3.updateQueue = { baseState: a3.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
      }
      function bh(a3, b3) {
        a3 = a3.updateQueue;
        b3.updateQueue === a3 && (b3.updateQueue = { baseState: a3.baseState, firstBaseUpdate: a3.firstBaseUpdate, lastBaseUpdate: a3.lastBaseUpdate, shared: a3.shared, effects: a3.effects });
      }
      function ch(a3, b3) {
        return { eventTime: a3, lane: b3, tag: 0, payload: null, callback: null, next: null };
      }
      function dh(a3, b3, c3) {
        var d3 = a3.updateQueue;
        if (null === d3)
          return null;
        d3 = d3.shared;
        if (0 !== (K & 2)) {
          var e2 = d3.pending;
          null === e2 ? b3.next = b3 : (b3.next = e2.next, e2.next = b3);
          d3.pending = b3;
          return Zg(a3, c3);
        }
        e2 = d3.interleaved;
        null === e2 ? (b3.next = b3, Xg(d3)) : (b3.next = e2.next, e2.next = b3);
        d3.interleaved = b3;
        return Zg(a3, c3);
      }
      function eh(a3, b3, c3) {
        b3 = b3.updateQueue;
        if (null !== b3 && (b3 = b3.shared, 0 !== (c3 & 4194240))) {
          var d3 = b3.lanes;
          d3 &= a3.pendingLanes;
          c3 |= d3;
          b3.lanes = c3;
          Cc(a3, c3);
        }
      }
      function fh(a3, b3) {
        var c3 = a3.updateQueue, d3 = a3.alternate;
        if (null !== d3 && (d3 = d3.updateQueue, c3 === d3)) {
          var e2 = null, f3 = null;
          c3 = c3.firstBaseUpdate;
          if (null !== c3) {
            do {
              var g3 = { eventTime: c3.eventTime, lane: c3.lane, tag: c3.tag, payload: c3.payload, callback: c3.callback, next: null };
              null === f3 ? e2 = f3 = g3 : f3 = f3.next = g3;
              c3 = c3.next;
            } while (null !== c3);
            null === f3 ? e2 = f3 = b3 : f3 = f3.next = b3;
          } else
            e2 = f3 = b3;
          c3 = { baseState: d3.baseState, firstBaseUpdate: e2, lastBaseUpdate: f3, shared: d3.shared, effects: d3.effects };
          a3.updateQueue = c3;
          return;
        }
        a3 = c3.lastBaseUpdate;
        null === a3 ? c3.firstBaseUpdate = b3 : a3.next = b3;
        c3.lastBaseUpdate = b3;
      }
      function gh(a3, b3, c3, d3) {
        var e2 = a3.updateQueue;
        $g = false;
        var f3 = e2.firstBaseUpdate, g3 = e2.lastBaseUpdate, h3 = e2.shared.pending;
        if (null !== h3) {
          e2.shared.pending = null;
          var k2 = h3, l3 = k2.next;
          k2.next = null;
          null === g3 ? f3 = l3 : g3.next = l3;
          g3 = k2;
          var m3 = a3.alternate;
          null !== m3 && (m3 = m3.updateQueue, h3 = m3.lastBaseUpdate, h3 !== g3 && (null === h3 ? m3.firstBaseUpdate = l3 : h3.next = l3, m3.lastBaseUpdate = k2));
        }
        if (null !== f3) {
          var q = e2.baseState;
          g3 = 0;
          m3 = l3 = k2 = null;
          h3 = f3;
          do {
            var r3 = h3.lane, y3 = h3.eventTime;
            if ((d3 & r3) === r3) {
              null !== m3 && (m3 = m3.next = {
                eventTime: y3,
                lane: 0,
                tag: h3.tag,
                payload: h3.payload,
                callback: h3.callback,
                next: null
              });
              a: {
                var n3 = a3, t4 = h3;
                r3 = b3;
                y3 = c3;
                switch (t4.tag) {
                  case 1:
                    n3 = t4.payload;
                    if ("function" === typeof n3) {
                      q = n3.call(y3, q, r3);
                      break a;
                    }
                    q = n3;
                    break a;
                  case 3:
                    n3.flags = n3.flags & -65537 | 128;
                  case 0:
                    n3 = t4.payload;
                    r3 = "function" === typeof n3 ? n3.call(y3, q, r3) : n3;
                    if (null === r3 || void 0 === r3)
                      break a;
                    q = A2({}, q, r3);
                    break a;
                  case 2:
                    $g = true;
                }
              }
              null !== h3.callback && 0 !== h3.lane && (a3.flags |= 64, r3 = e2.effects, null === r3 ? e2.effects = [h3] : r3.push(h3));
            } else
              y3 = { eventTime: y3, lane: r3, tag: h3.tag, payload: h3.payload, callback: h3.callback, next: null }, null === m3 ? (l3 = m3 = y3, k2 = q) : m3 = m3.next = y3, g3 |= r3;
            h3 = h3.next;
            if (null === h3)
              if (h3 = e2.shared.pending, null === h3)
                break;
              else
                r3 = h3, h3 = r3.next, r3.next = null, e2.lastBaseUpdate = r3, e2.shared.pending = null;
          } while (1);
          null === m3 && (k2 = q);
          e2.baseState = k2;
          e2.firstBaseUpdate = l3;
          e2.lastBaseUpdate = m3;
          b3 = e2.shared.interleaved;
          if (null !== b3) {
            e2 = b3;
            do
              g3 |= e2.lane, e2 = e2.next;
            while (e2 !== b3);
          } else
            null === f3 && (e2.shared.lanes = 0);
          hh |= g3;
          a3.lanes = g3;
          a3.memoizedState = q;
        }
      }
      function ih(a3, b3, c3) {
        a3 = b3.effects;
        b3.effects = null;
        if (null !== a3)
          for (b3 = 0; b3 < a3.length; b3++) {
            var d3 = a3[b3], e2 = d3.callback;
            if (null !== e2) {
              d3.callback = null;
              d3 = c3;
              if ("function" !== typeof e2)
                throw Error(p3(191, e2));
              e2.call(d3);
            }
          }
      }
      var jh = new aa.Component().refs;
      function kh(a3, b3, c3, d3) {
        b3 = a3.memoizedState;
        c3 = c3(d3, b3);
        c3 = null === c3 || void 0 === c3 ? b3 : A2({}, b3, c3);
        a3.memoizedState = c3;
        0 === a3.lanes && (a3.updateQueue.baseState = c3);
      }
      var nh = { isMounted: function(a3) {
        return (a3 = a3._reactInternals) ? Vb(a3) === a3 : false;
      }, enqueueSetState: function(a3, b3, c3) {
        a3 = a3._reactInternals;
        var d3 = L3(), e2 = lh(a3), f3 = ch(d3, e2);
        f3.payload = b3;
        void 0 !== c3 && null !== c3 && (f3.callback = c3);
        b3 = dh(a3, f3, e2);
        null !== b3 && (mh(b3, a3, e2, d3), eh(b3, a3, e2));
      }, enqueueReplaceState: function(a3, b3, c3) {
        a3 = a3._reactInternals;
        var d3 = L3(), e2 = lh(a3), f3 = ch(d3, e2);
        f3.tag = 1;
        f3.payload = b3;
        void 0 !== c3 && null !== c3 && (f3.callback = c3);
        b3 = dh(a3, f3, e2);
        null !== b3 && (mh(b3, a3, e2, d3), eh(b3, a3, e2));
      }, enqueueForceUpdate: function(a3, b3) {
        a3 = a3._reactInternals;
        var c3 = L3(), d3 = lh(a3), e2 = ch(c3, d3);
        e2.tag = 2;
        void 0 !== b3 && null !== b3 && (e2.callback = b3);
        b3 = dh(a3, e2, d3);
        null !== b3 && (mh(b3, a3, d3, c3), eh(b3, a3, d3));
      } };
      function oh(a3, b3, c3, d3, e2, f3, g3) {
        a3 = a3.stateNode;
        return "function" === typeof a3.shouldComponentUpdate ? a3.shouldComponentUpdate(d3, f3, g3) : b3.prototype && b3.prototype.isPureReactComponent ? !Ie(c3, d3) || !Ie(e2, f3) : true;
      }
      function ph(a3, b3, c3) {
        var d3 = false, e2 = Vf;
        var f3 = b3.contextType;
        "object" === typeof f3 && null !== f3 ? f3 = Vg(f3) : (e2 = Zf(b3) ? Xf : H2.current, d3 = b3.contextTypes, f3 = (d3 = null !== d3 && void 0 !== d3) ? Yf(a3, e2) : Vf);
        b3 = new b3(c3, f3);
        a3.memoizedState = null !== b3.state && void 0 !== b3.state ? b3.state : null;
        b3.updater = nh;
        a3.stateNode = b3;
        b3._reactInternals = a3;
        d3 && (a3 = a3.stateNode, a3.__reactInternalMemoizedUnmaskedChildContext = e2, a3.__reactInternalMemoizedMaskedChildContext = f3);
        return b3;
      }
      function qh(a3, b3, c3, d3) {
        a3 = b3.state;
        "function" === typeof b3.componentWillReceiveProps && b3.componentWillReceiveProps(c3, d3);
        "function" === typeof b3.UNSAFE_componentWillReceiveProps && b3.UNSAFE_componentWillReceiveProps(c3, d3);
        b3.state !== a3 && nh.enqueueReplaceState(b3, b3.state, null);
      }
      function rh(a3, b3, c3, d3) {
        var e2 = a3.stateNode;
        e2.props = c3;
        e2.state = a3.memoizedState;
        e2.refs = jh;
        ah(a3);
        var f3 = b3.contextType;
        "object" === typeof f3 && null !== f3 ? e2.context = Vg(f3) : (f3 = Zf(b3) ? Xf : H2.current, e2.context = Yf(a3, f3));
        e2.state = a3.memoizedState;
        f3 = b3.getDerivedStateFromProps;
        "function" === typeof f3 && (kh(a3, b3, f3, c3), e2.state = a3.memoizedState);
        "function" === typeof b3.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b3 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b3 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a3, c3, e2, d3), e2.state = a3.memoizedState);
        "function" === typeof e2.componentDidMount && (a3.flags |= 4194308);
      }
      function sh(a3, b3, c3) {
        a3 = c3.ref;
        if (null !== a3 && "function" !== typeof a3 && "object" !== typeof a3) {
          if (c3._owner) {
            c3 = c3._owner;
            if (c3) {
              if (1 !== c3.tag)
                throw Error(p3(309));
              var d3 = c3.stateNode;
            }
            if (!d3)
              throw Error(p3(147, a3));
            var e2 = d3, f3 = "" + a3;
            if (null !== b3 && null !== b3.ref && "function" === typeof b3.ref && b3.ref._stringRef === f3)
              return b3.ref;
            b3 = function(a4) {
              var b4 = e2.refs;
              b4 === jh && (b4 = e2.refs = {});
              null === a4 ? delete b4[f3] : b4[f3] = a4;
            };
            b3._stringRef = f3;
            return b3;
          }
          if ("string" !== typeof a3)
            throw Error(p3(284));
          if (!c3._owner)
            throw Error(p3(290, a3));
        }
        return a3;
      }
      function th(a3, b3) {
        a3 = Object.prototype.toString.call(b3);
        throw Error(p3(31, "[object Object]" === a3 ? "object with keys {" + Object.keys(b3).join(", ") + "}" : a3));
      }
      function uh(a3) {
        var b3 = a3._init;
        return b3(a3._payload);
      }
      function vh(a3) {
        function b3(b4, c4) {
          if (a3) {
            var d4 = b4.deletions;
            null === d4 ? (b4.deletions = [c4], b4.flags |= 16) : d4.push(c4);
          }
        }
        function c3(c4, d4) {
          if (!a3)
            return null;
          for (; null !== d4; )
            b3(c4, d4), d4 = d4.sibling;
          return null;
        }
        function d3(a4, b4) {
          for (a4 = /* @__PURE__ */ new Map(); null !== b4; )
            null !== b4.key ? a4.set(b4.key, b4) : a4.set(b4.index, b4), b4 = b4.sibling;
          return a4;
        }
        function e2(a4, b4) {
          a4 = wh(a4, b4);
          a4.index = 0;
          a4.sibling = null;
          return a4;
        }
        function f3(b4, c4, d4) {
          b4.index = d4;
          if (!a3)
            return b4.flags |= 1048576, c4;
          d4 = b4.alternate;
          if (null !== d4)
            return d4 = d4.index, d4 < c4 ? (b4.flags |= 2, c4) : d4;
          b4.flags |= 2;
          return c4;
        }
        function g3(b4) {
          a3 && null === b4.alternate && (b4.flags |= 2);
          return b4;
        }
        function h3(a4, b4, c4, d4) {
          if (null === b4 || 6 !== b4.tag)
            return b4 = xh(c4, a4.mode, d4), b4.return = a4, b4;
          b4 = e2(b4, c4);
          b4.return = a4;
          return b4;
        }
        function k2(a4, b4, c4, d4) {
          var f4 = c4.type;
          if (f4 === ya)
            return m3(a4, b4, c4.props.children, d4, c4.key);
          if (null !== b4 && (b4.elementType === f4 || "object" === typeof f4 && null !== f4 && f4.$$typeof === Ha && uh(f4) === b4.type))
            return d4 = e2(b4, c4.props), d4.ref = sh(a4, b4, c4), d4.return = a4, d4;
          d4 = yh(c4.type, c4.key, c4.props, null, a4.mode, d4);
          d4.ref = sh(a4, b4, c4);
          d4.return = a4;
          return d4;
        }
        function l3(a4, b4, c4, d4) {
          if (null === b4 || 4 !== b4.tag || b4.stateNode.containerInfo !== c4.containerInfo || b4.stateNode.implementation !== c4.implementation)
            return b4 = zh(c4, a4.mode, d4), b4.return = a4, b4;
          b4 = e2(b4, c4.children || []);
          b4.return = a4;
          return b4;
        }
        function m3(a4, b4, c4, d4, f4) {
          if (null === b4 || 7 !== b4.tag)
            return b4 = Ah(c4, a4.mode, d4, f4), b4.return = a4, b4;
          b4 = e2(b4, c4);
          b4.return = a4;
          return b4;
        }
        function q(a4, b4, c4) {
          if ("string" === typeof b4 && "" !== b4 || "number" === typeof b4)
            return b4 = xh("" + b4, a4.mode, c4), b4.return = a4, b4;
          if ("object" === typeof b4 && null !== b4) {
            switch (b4.$$typeof) {
              case va:
                return c4 = yh(b4.type, b4.key, b4.props, null, a4.mode, c4), c4.ref = sh(a4, null, b4), c4.return = a4, c4;
              case wa:
                return b4 = zh(b4, a4.mode, c4), b4.return = a4, b4;
              case Ha:
                var d4 = b4._init;
                return q(a4, d4(b4._payload), c4);
            }
            if (eb(b4) || Ka(b4))
              return b4 = Ah(b4, a4.mode, c4, null), b4.return = a4, b4;
            th(a4, b4);
          }
          return null;
        }
        function r3(a4, b4, c4, d4) {
          var e3 = null !== b4 ? b4.key : null;
          if ("string" === typeof c4 && "" !== c4 || "number" === typeof c4)
            return null !== e3 ? null : h3(a4, b4, "" + c4, d4);
          if ("object" === typeof c4 && null !== c4) {
            switch (c4.$$typeof) {
              case va:
                return c4.key === e3 ? k2(a4, b4, c4, d4) : null;
              case wa:
                return c4.key === e3 ? l3(a4, b4, c4, d4) : null;
              case Ha:
                return e3 = c4._init, r3(
                  a4,
                  b4,
                  e3(c4._payload),
                  d4
                );
            }
            if (eb(c4) || Ka(c4))
              return null !== e3 ? null : m3(a4, b4, c4, d4, null);
            th(a4, c4);
          }
          return null;
        }
        function y3(a4, b4, c4, d4, e3) {
          if ("string" === typeof d4 && "" !== d4 || "number" === typeof d4)
            return a4 = a4.get(c4) || null, h3(b4, a4, "" + d4, e3);
          if ("object" === typeof d4 && null !== d4) {
            switch (d4.$$typeof) {
              case va:
                return a4 = a4.get(null === d4.key ? c4 : d4.key) || null, k2(b4, a4, d4, e3);
              case wa:
                return a4 = a4.get(null === d4.key ? c4 : d4.key) || null, l3(b4, a4, d4, e3);
              case Ha:
                var f4 = d4._init;
                return y3(a4, b4, c4, f4(d4._payload), e3);
            }
            if (eb(d4) || Ka(d4))
              return a4 = a4.get(c4) || null, m3(b4, a4, d4, e3, null);
            th(b4, d4);
          }
          return null;
        }
        function n3(e3, g4, h4, k3) {
          for (var l4 = null, m4 = null, u3 = g4, w3 = g4 = 0, x3 = null; null !== u3 && w3 < h4.length; w3++) {
            u3.index > w3 ? (x3 = u3, u3 = null) : x3 = u3.sibling;
            var n4 = r3(e3, u3, h4[w3], k3);
            if (null === n4) {
              null === u3 && (u3 = x3);
              break;
            }
            a3 && u3 && null === n4.alternate && b3(e3, u3);
            g4 = f3(n4, g4, w3);
            null === m4 ? l4 = n4 : m4.sibling = n4;
            m4 = n4;
            u3 = x3;
          }
          if (w3 === h4.length)
            return c3(e3, u3), I && tg(e3, w3), l4;
          if (null === u3) {
            for (; w3 < h4.length; w3++)
              u3 = q(e3, h4[w3], k3), null !== u3 && (g4 = f3(u3, g4, w3), null === m4 ? l4 = u3 : m4.sibling = u3, m4 = u3);
            I && tg(e3, w3);
            return l4;
          }
          for (u3 = d3(e3, u3); w3 < h4.length; w3++)
            x3 = y3(u3, e3, w3, h4[w3], k3), null !== x3 && (a3 && null !== x3.alternate && u3.delete(null === x3.key ? w3 : x3.key), g4 = f3(x3, g4, w3), null === m4 ? l4 = x3 : m4.sibling = x3, m4 = x3);
          a3 && u3.forEach(function(a4) {
            return b3(e3, a4);
          });
          I && tg(e3, w3);
          return l4;
        }
        function t4(e3, g4, h4, k3) {
          var l4 = Ka(h4);
          if ("function" !== typeof l4)
            throw Error(p3(150));
          h4 = l4.call(h4);
          if (null == h4)
            throw Error(p3(151));
          for (var u3 = l4 = null, m4 = g4, w3 = g4 = 0, x3 = null, n4 = h4.next(); null !== m4 && !n4.done; w3++, n4 = h4.next()) {
            m4.index > w3 ? (x3 = m4, m4 = null) : x3 = m4.sibling;
            var t5 = r3(e3, m4, n4.value, k3);
            if (null === t5) {
              null === m4 && (m4 = x3);
              break;
            }
            a3 && m4 && null === t5.alternate && b3(e3, m4);
            g4 = f3(t5, g4, w3);
            null === u3 ? l4 = t5 : u3.sibling = t5;
            u3 = t5;
            m4 = x3;
          }
          if (n4.done)
            return c3(
              e3,
              m4
            ), I && tg(e3, w3), l4;
          if (null === m4) {
            for (; !n4.done; w3++, n4 = h4.next())
              n4 = q(e3, n4.value, k3), null !== n4 && (g4 = f3(n4, g4, w3), null === u3 ? l4 = n4 : u3.sibling = n4, u3 = n4);
            I && tg(e3, w3);
            return l4;
          }
          for (m4 = d3(e3, m4); !n4.done; w3++, n4 = h4.next())
            n4 = y3(m4, e3, w3, n4.value, k3), null !== n4 && (a3 && null !== n4.alternate && m4.delete(null === n4.key ? w3 : n4.key), g4 = f3(n4, g4, w3), null === u3 ? l4 = n4 : u3.sibling = n4, u3 = n4);
          a3 && m4.forEach(function(a4) {
            return b3(e3, a4);
          });
          I && tg(e3, w3);
          return l4;
        }
        function J(a4, d4, f4, h4) {
          "object" === typeof f4 && null !== f4 && f4.type === ya && null === f4.key && (f4 = f4.props.children);
          if ("object" === typeof f4 && null !== f4) {
            switch (f4.$$typeof) {
              case va:
                a: {
                  for (var k3 = f4.key, l4 = d4; null !== l4; ) {
                    if (l4.key === k3) {
                      k3 = f4.type;
                      if (k3 === ya) {
                        if (7 === l4.tag) {
                          c3(a4, l4.sibling);
                          d4 = e2(l4, f4.props.children);
                          d4.return = a4;
                          a4 = d4;
                          break a;
                        }
                      } else if (l4.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l4.type) {
                        c3(a4, l4.sibling);
                        d4 = e2(l4, f4.props);
                        d4.ref = sh(a4, l4, f4);
                        d4.return = a4;
                        a4 = d4;
                        break a;
                      }
                      c3(a4, l4);
                      break;
                    } else
                      b3(a4, l4);
                    l4 = l4.sibling;
                  }
                  f4.type === ya ? (d4 = Ah(f4.props.children, a4.mode, h4, f4.key), d4.return = a4, a4 = d4) : (h4 = yh(f4.type, f4.key, f4.props, null, a4.mode, h4), h4.ref = sh(a4, d4, f4), h4.return = a4, a4 = h4);
                }
                return g3(a4);
              case wa:
                a: {
                  for (l4 = f4.key; null !== d4; ) {
                    if (d4.key === l4)
                      if (4 === d4.tag && d4.stateNode.containerInfo === f4.containerInfo && d4.stateNode.implementation === f4.implementation) {
                        c3(a4, d4.sibling);
                        d4 = e2(d4, f4.children || []);
                        d4.return = a4;
                        a4 = d4;
                        break a;
                      } else {
                        c3(a4, d4);
                        break;
                      }
                    else
                      b3(a4, d4);
                    d4 = d4.sibling;
                  }
                  d4 = zh(f4, a4.mode, h4);
                  d4.return = a4;
                  a4 = d4;
                }
                return g3(a4);
              case Ha:
                return l4 = f4._init, J(a4, d4, l4(f4._payload), h4);
            }
            if (eb(f4))
              return n3(a4, d4, f4, h4);
            if (Ka(f4))
              return t4(a4, d4, f4, h4);
            th(a4, f4);
          }
          return "string" === typeof f4 && "" !== f4 || "number" === typeof f4 ? (f4 = "" + f4, null !== d4 && 6 === d4.tag ? (c3(a4, d4.sibling), d4 = e2(d4, f4), d4.return = a4, a4 = d4) : (c3(a4, d4), d4 = xh(f4, a4.mode, h4), d4.return = a4, a4 = d4), g3(a4)) : c3(a4, d4);
        }
        return J;
      }
      var Bh = vh(true);
      var Ch = vh(false);
      var Dh = {};
      var Eh = Uf(Dh);
      var Fh = Uf(Dh);
      var Gh = Uf(Dh);
      function Hh(a3) {
        if (a3 === Dh)
          throw Error(p3(174));
        return a3;
      }
      function Ih(a3, b3) {
        G(Gh, b3);
        G(Fh, a3);
        G(Eh, Dh);
        a3 = b3.nodeType;
        switch (a3) {
          case 9:
          case 11:
            b3 = (b3 = b3.documentElement) ? b3.namespaceURI : lb(null, "");
            break;
          default:
            a3 = 8 === a3 ? b3.parentNode : b3, b3 = a3.namespaceURI || null, a3 = a3.tagName, b3 = lb(b3, a3);
        }
        E3(Eh);
        G(Eh, b3);
      }
      function Jh() {
        E3(Eh);
        E3(Fh);
        E3(Gh);
      }
      function Kh(a3) {
        Hh(Gh.current);
        var b3 = Hh(Eh.current);
        var c3 = lb(b3, a3.type);
        b3 !== c3 && (G(Fh, a3), G(Eh, c3));
      }
      function Lh(a3) {
        Fh.current === a3 && (E3(Eh), E3(Fh));
      }
      var M = Uf(0);
      function Mh(a3) {
        for (var b3 = a3; null !== b3; ) {
          if (13 === b3.tag) {
            var c3 = b3.memoizedState;
            if (null !== c3 && (c3 = c3.dehydrated, null === c3 || "$?" === c3.data || "$!" === c3.data))
              return b3;
          } else if (19 === b3.tag && void 0 !== b3.memoizedProps.revealOrder) {
            if (0 !== (b3.flags & 128))
              return b3;
          } else if (null !== b3.child) {
            b3.child.return = b3;
            b3 = b3.child;
            continue;
          }
          if (b3 === a3)
            break;
          for (; null === b3.sibling; ) {
            if (null === b3.return || b3.return === a3)
              return null;
            b3 = b3.return;
          }
          b3.sibling.return = b3.return;
          b3 = b3.sibling;
        }
        return null;
      }
      var Nh = [];
      function Oh() {
        for (var a3 = 0; a3 < Nh.length; a3++)
          Nh[a3]._workInProgressVersionPrimary = null;
        Nh.length = 0;
      }
      var Ph = ua.ReactCurrentDispatcher;
      var Qh = ua.ReactCurrentBatchConfig;
      var Rh = 0;
      var N2 = null;
      var O2 = null;
      var P2 = null;
      var Sh = false;
      var Th = false;
      var Uh = 0;
      var Vh = 0;
      function Q() {
        throw Error(p3(321));
      }
      function Wh(a3, b3) {
        if (null === b3)
          return false;
        for (var c3 = 0; c3 < b3.length && c3 < a3.length; c3++)
          if (!He(a3[c3], b3[c3]))
            return false;
        return true;
      }
      function Xh(a3, b3, c3, d3, e2, f3) {
        Rh = f3;
        N2 = b3;
        b3.memoizedState = null;
        b3.updateQueue = null;
        b3.lanes = 0;
        Ph.current = null === a3 || null === a3.memoizedState ? Yh : Zh;
        a3 = c3(d3, e2);
        if (Th) {
          f3 = 0;
          do {
            Th = false;
            Uh = 0;
            if (25 <= f3)
              throw Error(p3(301));
            f3 += 1;
            P2 = O2 = null;
            b3.updateQueue = null;
            Ph.current = $h;
            a3 = c3(d3, e2);
          } while (Th);
        }
        Ph.current = ai;
        b3 = null !== O2 && null !== O2.next;
        Rh = 0;
        P2 = O2 = N2 = null;
        Sh = false;
        if (b3)
          throw Error(p3(300));
        return a3;
      }
      function bi() {
        var a3 = 0 !== Uh;
        Uh = 0;
        return a3;
      }
      function ci() {
        var a3 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
        null === P2 ? N2.memoizedState = P2 = a3 : P2 = P2.next = a3;
        return P2;
      }
      function di() {
        if (null === O2) {
          var a3 = N2.alternate;
          a3 = null !== a3 ? a3.memoizedState : null;
        } else
          a3 = O2.next;
        var b3 = null === P2 ? N2.memoizedState : P2.next;
        if (null !== b3)
          P2 = b3, O2 = a3;
        else {
          if (null === a3)
            throw Error(p3(310));
          O2 = a3;
          a3 = { memoizedState: O2.memoizedState, baseState: O2.baseState, baseQueue: O2.baseQueue, queue: O2.queue, next: null };
          null === P2 ? N2.memoizedState = P2 = a3 : P2 = P2.next = a3;
        }
        return P2;
      }
      function ei(a3, b3) {
        return "function" === typeof b3 ? b3(a3) : b3;
      }
      function fi(a3) {
        var b3 = di(), c3 = b3.queue;
        if (null === c3)
          throw Error(p3(311));
        c3.lastRenderedReducer = a3;
        var d3 = O2, e2 = d3.baseQueue, f3 = c3.pending;
        if (null !== f3) {
          if (null !== e2) {
            var g3 = e2.next;
            e2.next = f3.next;
            f3.next = g3;
          }
          d3.baseQueue = e2 = f3;
          c3.pending = null;
        }
        if (null !== e2) {
          f3 = e2.next;
          d3 = d3.baseState;
          var h3 = g3 = null, k2 = null, l3 = f3;
          do {
            var m3 = l3.lane;
            if ((Rh & m3) === m3)
              null !== k2 && (k2 = k2.next = { lane: 0, action: l3.action, hasEagerState: l3.hasEagerState, eagerState: l3.eagerState, next: null }), d3 = l3.hasEagerState ? l3.eagerState : a3(d3, l3.action);
            else {
              var q = {
                lane: m3,
                action: l3.action,
                hasEagerState: l3.hasEagerState,
                eagerState: l3.eagerState,
                next: null
              };
              null === k2 ? (h3 = k2 = q, g3 = d3) : k2 = k2.next = q;
              N2.lanes |= m3;
              hh |= m3;
            }
            l3 = l3.next;
          } while (null !== l3 && l3 !== f3);
          null === k2 ? g3 = d3 : k2.next = h3;
          He(d3, b3.memoizedState) || (Ug = true);
          b3.memoizedState = d3;
          b3.baseState = g3;
          b3.baseQueue = k2;
          c3.lastRenderedState = d3;
        }
        a3 = c3.interleaved;
        if (null !== a3) {
          e2 = a3;
          do
            f3 = e2.lane, N2.lanes |= f3, hh |= f3, e2 = e2.next;
          while (e2 !== a3);
        } else
          null === e2 && (c3.lanes = 0);
        return [b3.memoizedState, c3.dispatch];
      }
      function gi(a3) {
        var b3 = di(), c3 = b3.queue;
        if (null === c3)
          throw Error(p3(311));
        c3.lastRenderedReducer = a3;
        var d3 = c3.dispatch, e2 = c3.pending, f3 = b3.memoizedState;
        if (null !== e2) {
          c3.pending = null;
          var g3 = e2 = e2.next;
          do
            f3 = a3(f3, g3.action), g3 = g3.next;
          while (g3 !== e2);
          He(f3, b3.memoizedState) || (Ug = true);
          b3.memoizedState = f3;
          null === b3.baseQueue && (b3.baseState = f3);
          c3.lastRenderedState = f3;
        }
        return [f3, d3];
      }
      function hi() {
      }
      function ii(a3, b3) {
        var c3 = N2, d3 = di(), e2 = b3(), f3 = !He(d3.memoizedState, e2);
        f3 && (d3.memoizedState = e2, Ug = true);
        d3 = d3.queue;
        ji(ki.bind(null, c3, d3, a3), [a3]);
        if (d3.getSnapshot !== b3 || f3 || null !== P2 && P2.memoizedState.tag & 1) {
          c3.flags |= 2048;
          li(9, mi.bind(null, c3, d3, e2, b3), void 0, null);
          if (null === R3)
            throw Error(p3(349));
          0 !== (Rh & 30) || ni(c3, b3, e2);
        }
        return e2;
      }
      function ni(a3, b3, c3) {
        a3.flags |= 16384;
        a3 = { getSnapshot: b3, value: c3 };
        b3 = N2.updateQueue;
        null === b3 ? (b3 = { lastEffect: null, stores: null }, N2.updateQueue = b3, b3.stores = [a3]) : (c3 = b3.stores, null === c3 ? b3.stores = [a3] : c3.push(a3));
      }
      function mi(a3, b3, c3, d3) {
        b3.value = c3;
        b3.getSnapshot = d3;
        oi(b3) && pi(a3);
      }
      function ki(a3, b3, c3) {
        return c3(function() {
          oi(b3) && pi(a3);
        });
      }
      function oi(a3) {
        var b3 = a3.getSnapshot;
        a3 = a3.value;
        try {
          var c3 = b3();
          return !He(a3, c3);
        } catch (d3) {
          return true;
        }
      }
      function pi(a3) {
        var b3 = Zg(a3, 1);
        null !== b3 && mh(b3, a3, 1, -1);
      }
      function qi(a3) {
        var b3 = ci();
        "function" === typeof a3 && (a3 = a3());
        b3.memoizedState = b3.baseState = a3;
        a3 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei, lastRenderedState: a3 };
        b3.queue = a3;
        a3 = a3.dispatch = ri.bind(null, N2, a3);
        return [b3.memoizedState, a3];
      }
      function li(a3, b3, c3, d3) {
        a3 = { tag: a3, create: b3, destroy: c3, deps: d3, next: null };
        b3 = N2.updateQueue;
        null === b3 ? (b3 = { lastEffect: null, stores: null }, N2.updateQueue = b3, b3.lastEffect = a3.next = a3) : (c3 = b3.lastEffect, null === c3 ? b3.lastEffect = a3.next = a3 : (d3 = c3.next, c3.next = a3, a3.next = d3, b3.lastEffect = a3));
        return a3;
      }
      function si() {
        return di().memoizedState;
      }
      function ti(a3, b3, c3, d3) {
        var e2 = ci();
        N2.flags |= a3;
        e2.memoizedState = li(1 | b3, c3, void 0, void 0 === d3 ? null : d3);
      }
      function ui(a3, b3, c3, d3) {
        var e2 = di();
        d3 = void 0 === d3 ? null : d3;
        var f3 = void 0;
        if (null !== O2) {
          var g3 = O2.memoizedState;
          f3 = g3.destroy;
          if (null !== d3 && Wh(d3, g3.deps)) {
            e2.memoizedState = li(b3, c3, f3, d3);
            return;
          }
        }
        N2.flags |= a3;
        e2.memoizedState = li(1 | b3, c3, f3, d3);
      }
      function vi(a3, b3) {
        return ti(8390656, 8, a3, b3);
      }
      function ji(a3, b3) {
        return ui(2048, 8, a3, b3);
      }
      function wi(a3, b3) {
        return ui(4, 2, a3, b3);
      }
      function xi(a3, b3) {
        return ui(4, 4, a3, b3);
      }
      function yi(a3, b3) {
        if ("function" === typeof b3)
          return a3 = a3(), b3(a3), function() {
            b3(null);
          };
        if (null !== b3 && void 0 !== b3)
          return a3 = a3(), b3.current = a3, function() {
            b3.current = null;
          };
      }
      function zi(a3, b3, c3) {
        c3 = null !== c3 && void 0 !== c3 ? c3.concat([a3]) : null;
        return ui(4, 4, yi.bind(null, b3, a3), c3);
      }
      function Ai() {
      }
      function Bi(a3, b3) {
        var c3 = di();
        b3 = void 0 === b3 ? null : b3;
        var d3 = c3.memoizedState;
        if (null !== d3 && null !== b3 && Wh(b3, d3[1]))
          return d3[0];
        c3.memoizedState = [a3, b3];
        return a3;
      }
      function Ci(a3, b3) {
        var c3 = di();
        b3 = void 0 === b3 ? null : b3;
        var d3 = c3.memoizedState;
        if (null !== d3 && null !== b3 && Wh(b3, d3[1]))
          return d3[0];
        a3 = a3();
        c3.memoizedState = [a3, b3];
        return a3;
      }
      function Di(a3, b3, c3) {
        if (0 === (Rh & 21))
          return a3.baseState && (a3.baseState = false, Ug = true), a3.memoizedState = c3;
        He(c3, b3) || (c3 = yc(), N2.lanes |= c3, hh |= c3, a3.baseState = true);
        return b3;
      }
      function Ei(a3, b3) {
        var c3 = C2;
        C2 = 0 !== c3 && 4 > c3 ? c3 : 4;
        a3(true);
        var d3 = Qh.transition;
        Qh.transition = {};
        try {
          a3(false), b3();
        } finally {
          C2 = c3, Qh.transition = d3;
        }
      }
      function Fi() {
        return di().memoizedState;
      }
      function Gi(a3, b3, c3) {
        var d3 = lh(a3);
        c3 = { lane: d3, action: c3, hasEagerState: false, eagerState: null, next: null };
        if (Hi(a3))
          Ii(b3, c3);
        else if (c3 = Yg(a3, b3, c3, d3), null !== c3) {
          var e2 = L3();
          mh(c3, a3, d3, e2);
          Ji(c3, b3, d3);
        }
      }
      function ri(a3, b3, c3) {
        var d3 = lh(a3), e2 = { lane: d3, action: c3, hasEagerState: false, eagerState: null, next: null };
        if (Hi(a3))
          Ii(b3, e2);
        else {
          var f3 = a3.alternate;
          if (0 === a3.lanes && (null === f3 || 0 === f3.lanes) && (f3 = b3.lastRenderedReducer, null !== f3))
            try {
              var g3 = b3.lastRenderedState, h3 = f3(g3, c3);
              e2.hasEagerState = true;
              e2.eagerState = h3;
              if (He(h3, g3)) {
                var k2 = b3.interleaved;
                null === k2 ? (e2.next = e2, Xg(b3)) : (e2.next = k2.next, k2.next = e2);
                b3.interleaved = e2;
                return;
              }
            } catch (l3) {
            } finally {
            }
          c3 = Yg(a3, b3, e2, d3);
          null !== c3 && (e2 = L3(), mh(c3, a3, d3, e2), Ji(c3, b3, d3));
        }
      }
      function Hi(a3) {
        var b3 = a3.alternate;
        return a3 === N2 || null !== b3 && b3 === N2;
      }
      function Ii(a3, b3) {
        Th = Sh = true;
        var c3 = a3.pending;
        null === c3 ? b3.next = b3 : (b3.next = c3.next, c3.next = b3);
        a3.pending = b3;
      }
      function Ji(a3, b3, c3) {
        if (0 !== (c3 & 4194240)) {
          var d3 = b3.lanes;
          d3 &= a3.pendingLanes;
          c3 |= d3;
          b3.lanes = c3;
          Cc(a3, c3);
        }
      }
      var ai = { readContext: Vg, useCallback: Q, useContext: Q, useEffect: Q, useImperativeHandle: Q, useInsertionEffect: Q, useLayoutEffect: Q, useMemo: Q, useReducer: Q, useRef: Q, useState: Q, useDebugValue: Q, useDeferredValue: Q, useTransition: Q, useMutableSource: Q, useSyncExternalStore: Q, useId: Q, unstable_isNewReconciler: false };
      var Yh = { readContext: Vg, useCallback: function(a3, b3) {
        ci().memoizedState = [a3, void 0 === b3 ? null : b3];
        return a3;
      }, useContext: Vg, useEffect: vi, useImperativeHandle: function(a3, b3, c3) {
        c3 = null !== c3 && void 0 !== c3 ? c3.concat([a3]) : null;
        return ti(
          4194308,
          4,
          yi.bind(null, b3, a3),
          c3
        );
      }, useLayoutEffect: function(a3, b3) {
        return ti(4194308, 4, a3, b3);
      }, useInsertionEffect: function(a3, b3) {
        return ti(4, 2, a3, b3);
      }, useMemo: function(a3, b3) {
        var c3 = ci();
        b3 = void 0 === b3 ? null : b3;
        a3 = a3();
        c3.memoizedState = [a3, b3];
        return a3;
      }, useReducer: function(a3, b3, c3) {
        var d3 = ci();
        b3 = void 0 !== c3 ? c3(b3) : b3;
        d3.memoizedState = d3.baseState = b3;
        a3 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a3, lastRenderedState: b3 };
        d3.queue = a3;
        a3 = a3.dispatch = Gi.bind(null, N2, a3);
        return [d3.memoizedState, a3];
      }, useRef: function(a3) {
        var b3 = ci();
        a3 = { current: a3 };
        return b3.memoizedState = a3;
      }, useState: qi, useDebugValue: Ai, useDeferredValue: function(a3) {
        return ci().memoizedState = a3;
      }, useTransition: function() {
        var a3 = qi(false), b3 = a3[0];
        a3 = Ei.bind(null, a3[1]);
        ci().memoizedState = a3;
        return [b3, a3];
      }, useMutableSource: function() {
      }, useSyncExternalStore: function(a3, b3, c3) {
        var d3 = N2, e2 = ci();
        if (I) {
          if (void 0 === c3)
            throw Error(p3(407));
          c3 = c3();
        } else {
          c3 = b3();
          if (null === R3)
            throw Error(p3(349));
          0 !== (Rh & 30) || ni(d3, b3, c3);
        }
        e2.memoizedState = c3;
        var f3 = { value: c3, getSnapshot: b3 };
        e2.queue = f3;
        vi(ki.bind(
          null,
          d3,
          f3,
          a3
        ), [a3]);
        d3.flags |= 2048;
        li(9, mi.bind(null, d3, f3, c3, b3), void 0, null);
        return c3;
      }, useId: function() {
        var a3 = ci(), b3 = R3.identifierPrefix;
        if (I) {
          var c3 = sg;
          var d3 = rg;
          c3 = (d3 & ~(1 << 32 - oc(d3) - 1)).toString(32) + c3;
          b3 = ":" + b3 + "R" + c3;
          c3 = Uh++;
          0 < c3 && (b3 += "H" + c3.toString(32));
          b3 += ":";
        } else
          c3 = Vh++, b3 = ":" + b3 + "r" + c3.toString(32) + ":";
        return a3.memoizedState = b3;
      }, unstable_isNewReconciler: false };
      var Zh = {
        readContext: Vg,
        useCallback: Bi,
        useContext: Vg,
        useEffect: ji,
        useImperativeHandle: zi,
        useInsertionEffect: wi,
        useLayoutEffect: xi,
        useMemo: Ci,
        useReducer: fi,
        useRef: si,
        useState: function() {
          return fi(ei);
        },
        useDebugValue: Ai,
        useDeferredValue: function(a3) {
          var b3 = di();
          return Di(b3, O2.memoizedState, a3);
        },
        useTransition: function() {
          var a3 = fi(ei)[0], b3 = di().memoizedState;
          return [a3, b3];
        },
        useMutableSource: hi,
        useSyncExternalStore: ii,
        useId: Fi,
        unstable_isNewReconciler: false
      };
      var $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi, useRef: si, useState: function() {
        return gi(ei);
      }, useDebugValue: Ai, useDeferredValue: function(a3) {
        var b3 = di();
        return null === O2 ? b3.memoizedState = a3 : Di(b3, O2.memoizedState, a3);
      }, useTransition: function() {
        var a3 = gi(ei)[0], b3 = di().memoizedState;
        return [a3, b3];
      }, useMutableSource: hi, useSyncExternalStore: ii, useId: Fi, unstable_isNewReconciler: false };
      function Ki(a3, b3) {
        try {
          var c3 = "", d3 = b3;
          do
            c3 += Pa(d3), d3 = d3.return;
          while (d3);
          var e2 = c3;
        } catch (f3) {
          e2 = "\nError generating stack: " + f3.message + "\n" + f3.stack;
        }
        return { value: a3, source: b3, stack: e2, digest: null };
      }
      function Li(a3, b3, c3) {
        return { value: a3, source: null, stack: null != c3 ? c3 : null, digest: null != b3 ? b3 : null };
      }
      function Mi(a3, b3) {
        try {
          console.error(b3.value);
        } catch (c3) {
          setTimeout(function() {
            throw c3;
          });
        }
      }
      var Ni = "function" === typeof WeakMap ? WeakMap : Map;
      function Oi(a3, b3, c3) {
        c3 = ch(-1, c3);
        c3.tag = 3;
        c3.payload = { element: null };
        var d3 = b3.value;
        c3.callback = function() {
          Pi || (Pi = true, Qi = d3);
          Mi(a3, b3);
        };
        return c3;
      }
      function Ri(a3, b3, c3) {
        c3 = ch(-1, c3);
        c3.tag = 3;
        var d3 = a3.type.getDerivedStateFromError;
        if ("function" === typeof d3) {
          var e2 = b3.value;
          c3.payload = function() {
            return d3(e2);
          };
          c3.callback = function() {
            Mi(a3, b3);
          };
        }
        var f3 = a3.stateNode;
        null !== f3 && "function" === typeof f3.componentDidCatch && (c3.callback = function() {
          Mi(a3, b3);
          "function" !== typeof d3 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
          var c4 = b3.stack;
          this.componentDidCatch(b3.value, { componentStack: null !== c4 ? c4 : "" });
        });
        return c3;
      }
      function Ti(a3, b3, c3) {
        var d3 = a3.pingCache;
        if (null === d3) {
          d3 = a3.pingCache = new Ni();
          var e2 = /* @__PURE__ */ new Set();
          d3.set(b3, e2);
        } else
          e2 = d3.get(b3), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d3.set(b3, e2));
        e2.has(c3) || (e2.add(c3), a3 = Ui.bind(null, a3, b3, c3), b3.then(a3, a3));
      }
      function Vi(a3) {
        do {
          var b3;
          if (b3 = 13 === a3.tag)
            b3 = a3.memoizedState, b3 = null !== b3 ? null !== b3.dehydrated ? true : false : true;
          if (b3)
            return a3;
          a3 = a3.return;
        } while (null !== a3);
        return null;
      }
      function Wi(a3, b3, c3, d3, e2) {
        if (0 === (a3.mode & 1))
          return a3 === b3 ? a3.flags |= 65536 : (a3.flags |= 128, c3.flags |= 131072, c3.flags &= -52805, 1 === c3.tag && (null === c3.alternate ? c3.tag = 17 : (b3 = ch(-1, 1), b3.tag = 2, dh(c3, b3, 1))), c3.lanes |= 1), a3;
        a3.flags |= 65536;
        a3.lanes = e2;
        return a3;
      }
      var Xi = ua.ReactCurrentOwner;
      var Ug = false;
      function Yi(a3, b3, c3, d3) {
        b3.child = null === a3 ? Ch(b3, null, c3, d3) : Bh(b3, a3.child, c3, d3);
      }
      function Zi(a3, b3, c3, d3, e2) {
        c3 = c3.render;
        var f3 = b3.ref;
        Tg(b3, e2);
        d3 = Xh(a3, b3, c3, d3, f3, e2);
        c3 = bi();
        if (null !== a3 && !Ug)
          return b3.updateQueue = a3.updateQueue, b3.flags &= -2053, a3.lanes &= ~e2, $i(a3, b3, e2);
        I && c3 && vg(b3);
        b3.flags |= 1;
        Yi(a3, b3, d3, e2);
        return b3.child;
      }
      function aj(a3, b3, c3, d3, e2) {
        if (null === a3) {
          var f3 = c3.type;
          if ("function" === typeof f3 && !bj(f3) && void 0 === f3.defaultProps && null === c3.compare && void 0 === c3.defaultProps)
            return b3.tag = 15, b3.type = f3, cj(a3, b3, f3, d3, e2);
          a3 = yh(c3.type, null, d3, b3, b3.mode, e2);
          a3.ref = b3.ref;
          a3.return = b3;
          return b3.child = a3;
        }
        f3 = a3.child;
        if (0 === (a3.lanes & e2)) {
          var g3 = f3.memoizedProps;
          c3 = c3.compare;
          c3 = null !== c3 ? c3 : Ie;
          if (c3(g3, d3) && a3.ref === b3.ref)
            return $i(a3, b3, e2);
        }
        b3.flags |= 1;
        a3 = wh(f3, d3);
        a3.ref = b3.ref;
        a3.return = b3;
        return b3.child = a3;
      }
      function cj(a3, b3, c3, d3, e2) {
        if (null !== a3) {
          var f3 = a3.memoizedProps;
          if (Ie(f3, d3) && a3.ref === b3.ref)
            if (Ug = false, b3.pendingProps = d3 = f3, 0 !== (a3.lanes & e2))
              0 !== (a3.flags & 131072) && (Ug = true);
            else
              return b3.lanes = a3.lanes, $i(a3, b3, e2);
        }
        return dj(a3, b3, c3, d3, e2);
      }
      function ej(a3, b3, c3) {
        var d3 = b3.pendingProps, e2 = d3.children, f3 = null !== a3 ? a3.memoizedState : null;
        if ("hidden" === d3.mode)
          if (0 === (b3.mode & 1))
            b3.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(fj, gj), gj |= c3;
          else {
            if (0 === (c3 & 1073741824))
              return a3 = null !== f3 ? f3.baseLanes | c3 : c3, b3.lanes = b3.childLanes = 1073741824, b3.memoizedState = { baseLanes: a3, cachePool: null, transitions: null }, b3.updateQueue = null, G(fj, gj), gj |= a3, null;
            b3.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
            d3 = null !== f3 ? f3.baseLanes : c3;
            G(fj, gj);
            gj |= d3;
          }
        else
          null !== f3 ? (d3 = f3.baseLanes | c3, b3.memoizedState = null) : d3 = c3, G(fj, gj), gj |= d3;
        Yi(a3, b3, e2, c3);
        return b3.child;
      }
      function hj(a3, b3) {
        var c3 = b3.ref;
        if (null === a3 && null !== c3 || null !== a3 && a3.ref !== c3)
          b3.flags |= 512, b3.flags |= 2097152;
      }
      function dj(a3, b3, c3, d3, e2) {
        var f3 = Zf(c3) ? Xf : H2.current;
        f3 = Yf(b3, f3);
        Tg(b3, e2);
        c3 = Xh(a3, b3, c3, d3, f3, e2);
        d3 = bi();
        if (null !== a3 && !Ug)
          return b3.updateQueue = a3.updateQueue, b3.flags &= -2053, a3.lanes &= ~e2, $i(a3, b3, e2);
        I && d3 && vg(b3);
        b3.flags |= 1;
        Yi(a3, b3, c3, e2);
        return b3.child;
      }
      function ij(a3, b3, c3, d3, e2) {
        if (Zf(c3)) {
          var f3 = true;
          cg(b3);
        } else
          f3 = false;
        Tg(b3, e2);
        if (null === b3.stateNode)
          jj(a3, b3), ph(b3, c3, d3), rh(b3, c3, d3, e2), d3 = true;
        else if (null === a3) {
          var g3 = b3.stateNode, h3 = b3.memoizedProps;
          g3.props = h3;
          var k2 = g3.context, l3 = c3.contextType;
          "object" === typeof l3 && null !== l3 ? l3 = Vg(l3) : (l3 = Zf(c3) ? Xf : H2.current, l3 = Yf(b3, l3));
          var m3 = c3.getDerivedStateFromProps, q = "function" === typeof m3 || "function" === typeof g3.getSnapshotBeforeUpdate;
          q || "function" !== typeof g3.UNSAFE_componentWillReceiveProps && "function" !== typeof g3.componentWillReceiveProps || (h3 !== d3 || k2 !== l3) && qh(b3, g3, d3, l3);
          $g = false;
          var r3 = b3.memoizedState;
          g3.state = r3;
          gh(b3, d3, g3, e2);
          k2 = b3.memoizedState;
          h3 !== d3 || r3 !== k2 || Wf.current || $g ? ("function" === typeof m3 && (kh(b3, c3, m3, d3), k2 = b3.memoizedState), (h3 = $g || oh(b3, c3, h3, d3, r3, k2, l3)) ? (q || "function" !== typeof g3.UNSAFE_componentWillMount && "function" !== typeof g3.componentWillMount || ("function" === typeof g3.componentWillMount && g3.componentWillMount(), "function" === typeof g3.UNSAFE_componentWillMount && g3.UNSAFE_componentWillMount()), "function" === typeof g3.componentDidMount && (b3.flags |= 4194308)) : ("function" === typeof g3.componentDidMount && (b3.flags |= 4194308), b3.memoizedProps = d3, b3.memoizedState = k2), g3.props = d3, g3.state = k2, g3.context = l3, d3 = h3) : ("function" === typeof g3.componentDidMount && (b3.flags |= 4194308), d3 = false);
        } else {
          g3 = b3.stateNode;
          bh(a3, b3);
          h3 = b3.memoizedProps;
          l3 = b3.type === b3.elementType ? h3 : Lg(b3.type, h3);
          g3.props = l3;
          q = b3.pendingProps;
          r3 = g3.context;
          k2 = c3.contextType;
          "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c3) ? Xf : H2.current, k2 = Yf(b3, k2));
          var y3 = c3.getDerivedStateFromProps;
          (m3 = "function" === typeof y3 || "function" === typeof g3.getSnapshotBeforeUpdate) || "function" !== typeof g3.UNSAFE_componentWillReceiveProps && "function" !== typeof g3.componentWillReceiveProps || (h3 !== q || r3 !== k2) && qh(b3, g3, d3, k2);
          $g = false;
          r3 = b3.memoizedState;
          g3.state = r3;
          gh(b3, d3, g3, e2);
          var n3 = b3.memoizedState;
          h3 !== q || r3 !== n3 || Wf.current || $g ? ("function" === typeof y3 && (kh(b3, c3, y3, d3), n3 = b3.memoizedState), (l3 = $g || oh(b3, c3, l3, d3, r3, n3, k2) || false) ? (m3 || "function" !== typeof g3.UNSAFE_componentWillUpdate && "function" !== typeof g3.componentWillUpdate || ("function" === typeof g3.componentWillUpdate && g3.componentWillUpdate(d3, n3, k2), "function" === typeof g3.UNSAFE_componentWillUpdate && g3.UNSAFE_componentWillUpdate(d3, n3, k2)), "function" === typeof g3.componentDidUpdate && (b3.flags |= 4), "function" === typeof g3.getSnapshotBeforeUpdate && (b3.flags |= 1024)) : ("function" !== typeof g3.componentDidUpdate || h3 === a3.memoizedProps && r3 === a3.memoizedState || (b3.flags |= 4), "function" !== typeof g3.getSnapshotBeforeUpdate || h3 === a3.memoizedProps && r3 === a3.memoizedState || (b3.flags |= 1024), b3.memoizedProps = d3, b3.memoizedState = n3), g3.props = d3, g3.state = n3, g3.context = k2, d3 = l3) : ("function" !== typeof g3.componentDidUpdate || h3 === a3.memoizedProps && r3 === a3.memoizedState || (b3.flags |= 4), "function" !== typeof g3.getSnapshotBeforeUpdate || h3 === a3.memoizedProps && r3 === a3.memoizedState || (b3.flags |= 1024), d3 = false);
        }
        return kj(a3, b3, c3, d3, f3, e2);
      }
      function kj(a3, b3, c3, d3, e2, f3) {
        hj(a3, b3);
        var g3 = 0 !== (b3.flags & 128);
        if (!d3 && !g3)
          return e2 && dg(b3, c3, false), $i(a3, b3, f3);
        d3 = b3.stateNode;
        Xi.current = b3;
        var h3 = g3 && "function" !== typeof c3.getDerivedStateFromError ? null : d3.render();
        b3.flags |= 1;
        null !== a3 && g3 ? (b3.child = Bh(b3, a3.child, null, f3), b3.child = Bh(b3, null, h3, f3)) : Yi(a3, b3, h3, f3);
        b3.memoizedState = d3.state;
        e2 && dg(b3, c3, true);
        return b3.child;
      }
      function lj(a3) {
        var b3 = a3.stateNode;
        b3.pendingContext ? ag(a3, b3.pendingContext, b3.pendingContext !== b3.context) : b3.context && ag(a3, b3.context, false);
        Ih(a3, b3.containerInfo);
      }
      function mj(a3, b3, c3, d3, e2) {
        Ig();
        Jg(e2);
        b3.flags |= 256;
        Yi(a3, b3, c3, d3);
        return b3.child;
      }
      var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
      function oj(a3) {
        return { baseLanes: a3, cachePool: null, transitions: null };
      }
      function pj(a3, b3, c3) {
        var d3 = b3.pendingProps, e2 = M.current, f3 = false, g3 = 0 !== (b3.flags & 128), h3;
        (h3 = g3) || (h3 = null !== a3 && null === a3.memoizedState ? false : 0 !== (e2 & 2));
        if (h3)
          f3 = true, b3.flags &= -129;
        else if (null === a3 || null !== a3.memoizedState)
          e2 |= 1;
        G(M, e2 & 1);
        if (null === a3) {
          Eg(b3);
          a3 = b3.memoizedState;
          if (null !== a3 && (a3 = a3.dehydrated, null !== a3))
            return 0 === (b3.mode & 1) ? b3.lanes = 1 : "$!" === a3.data ? b3.lanes = 8 : b3.lanes = 1073741824, null;
          g3 = d3.children;
          a3 = d3.fallback;
          return f3 ? (d3 = b3.mode, f3 = b3.child, g3 = { mode: "hidden", children: g3 }, 0 === (d3 & 1) && null !== f3 ? (f3.childLanes = 0, f3.pendingProps = g3) : f3 = qj(g3, d3, 0, null), a3 = Ah(a3, d3, c3, null), f3.return = b3, a3.return = b3, f3.sibling = a3, b3.child = f3, b3.child.memoizedState = oj(c3), b3.memoizedState = nj, a3) : rj(b3, g3);
        }
        e2 = a3.memoizedState;
        if (null !== e2 && (h3 = e2.dehydrated, null !== h3))
          return sj(a3, b3, g3, d3, h3, e2, c3);
        if (f3) {
          f3 = d3.fallback;
          g3 = b3.mode;
          e2 = a3.child;
          h3 = e2.sibling;
          var k2 = { mode: "hidden", children: d3.children };
          0 === (g3 & 1) && b3.child !== e2 ? (d3 = b3.child, d3.childLanes = 0, d3.pendingProps = k2, b3.deletions = null) : (d3 = wh(e2, k2), d3.subtreeFlags = e2.subtreeFlags & 14680064);
          null !== h3 ? f3 = wh(h3, f3) : (f3 = Ah(f3, g3, c3, null), f3.flags |= 2);
          f3.return = b3;
          d3.return = b3;
          d3.sibling = f3;
          b3.child = d3;
          d3 = f3;
          f3 = b3.child;
          g3 = a3.child.memoizedState;
          g3 = null === g3 ? oj(c3) : { baseLanes: g3.baseLanes | c3, cachePool: null, transitions: g3.transitions };
          f3.memoizedState = g3;
          f3.childLanes = a3.childLanes & ~c3;
          b3.memoizedState = nj;
          return d3;
        }
        f3 = a3.child;
        a3 = f3.sibling;
        d3 = wh(f3, { mode: "visible", children: d3.children });
        0 === (b3.mode & 1) && (d3.lanes = c3);
        d3.return = b3;
        d3.sibling = null;
        null !== a3 && (c3 = b3.deletions, null === c3 ? (b3.deletions = [a3], b3.flags |= 16) : c3.push(a3));
        b3.child = d3;
        b3.memoizedState = null;
        return d3;
      }
      function rj(a3, b3) {
        b3 = qj({ mode: "visible", children: b3 }, a3.mode, 0, null);
        b3.return = a3;
        return a3.child = b3;
      }
      function tj(a3, b3, c3, d3) {
        null !== d3 && Jg(d3);
        Bh(b3, a3.child, null, c3);
        a3 = rj(b3, b3.pendingProps.children);
        a3.flags |= 2;
        b3.memoizedState = null;
        return a3;
      }
      function sj(a3, b3, c3, d3, e2, f3, g3) {
        if (c3) {
          if (b3.flags & 256)
            return b3.flags &= -257, d3 = Li(Error(p3(422))), tj(a3, b3, g3, d3);
          if (null !== b3.memoizedState)
            return b3.child = a3.child, b3.flags |= 128, null;
          f3 = d3.fallback;
          e2 = b3.mode;
          d3 = qj({ mode: "visible", children: d3.children }, e2, 0, null);
          f3 = Ah(f3, e2, g3, null);
          f3.flags |= 2;
          d3.return = b3;
          f3.return = b3;
          d3.sibling = f3;
          b3.child = d3;
          0 !== (b3.mode & 1) && Bh(b3, a3.child, null, g3);
          b3.child.memoizedState = oj(g3);
          b3.memoizedState = nj;
          return f3;
        }
        if (0 === (b3.mode & 1))
          return tj(a3, b3, g3, null);
        if ("$!" === e2.data) {
          d3 = e2.nextSibling && e2.nextSibling.dataset;
          if (d3)
            var h3 = d3.dgst;
          d3 = h3;
          f3 = Error(p3(419));
          d3 = Li(f3, d3, void 0);
          return tj(a3, b3, g3, d3);
        }
        h3 = 0 !== (g3 & a3.childLanes);
        if (Ug || h3) {
          d3 = R3;
          if (null !== d3) {
            switch (g3 & -g3) {
              case 4:
                e2 = 2;
                break;
              case 16:
                e2 = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                e2 = 32;
                break;
              case 536870912:
                e2 = 268435456;
                break;
              default:
                e2 = 0;
            }
            e2 = 0 !== (e2 & (d3.suspendedLanes | g3)) ? 0 : e2;
            0 !== e2 && e2 !== f3.retryLane && (f3.retryLane = e2, Zg(a3, e2), mh(d3, a3, e2, -1));
          }
          uj();
          d3 = Li(Error(p3(421)));
          return tj(a3, b3, g3, d3);
        }
        if ("$?" === e2.data)
          return b3.flags |= 128, b3.child = a3.child, b3 = vj.bind(null, a3), e2._reactRetry = b3, null;
        a3 = f3.treeContext;
        yg = Lf(e2.nextSibling);
        xg = b3;
        I = true;
        zg = null;
        null !== a3 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a3.id, sg = a3.overflow, qg = b3);
        b3 = rj(b3, d3.children);
        b3.flags |= 4096;
        return b3;
      }
      function wj(a3, b3, c3) {
        a3.lanes |= b3;
        var d3 = a3.alternate;
        null !== d3 && (d3.lanes |= b3);
        Sg(a3.return, b3, c3);
      }
      function xj(a3, b3, c3, d3, e2) {
        var f3 = a3.memoizedState;
        null === f3 ? a3.memoizedState = { isBackwards: b3, rendering: null, renderingStartTime: 0, last: d3, tail: c3, tailMode: e2 } : (f3.isBackwards = b3, f3.rendering = null, f3.renderingStartTime = 0, f3.last = d3, f3.tail = c3, f3.tailMode = e2);
      }
      function yj(a3, b3, c3) {
        var d3 = b3.pendingProps, e2 = d3.revealOrder, f3 = d3.tail;
        Yi(a3, b3, d3.children, c3);
        d3 = M.current;
        if (0 !== (d3 & 2))
          d3 = d3 & 1 | 2, b3.flags |= 128;
        else {
          if (null !== a3 && 0 !== (a3.flags & 128))
            a:
              for (a3 = b3.child; null !== a3; ) {
                if (13 === a3.tag)
                  null !== a3.memoizedState && wj(a3, c3, b3);
                else if (19 === a3.tag)
                  wj(a3, c3, b3);
                else if (null !== a3.child) {
                  a3.child.return = a3;
                  a3 = a3.child;
                  continue;
                }
                if (a3 === b3)
                  break a;
                for (; null === a3.sibling; ) {
                  if (null === a3.return || a3.return === b3)
                    break a;
                  a3 = a3.return;
                }
                a3.sibling.return = a3.return;
                a3 = a3.sibling;
              }
          d3 &= 1;
        }
        G(M, d3);
        if (0 === (b3.mode & 1))
          b3.memoizedState = null;
        else
          switch (e2) {
            case "forwards":
              c3 = b3.child;
              for (e2 = null; null !== c3; )
                a3 = c3.alternate, null !== a3 && null === Mh(a3) && (e2 = c3), c3 = c3.sibling;
              c3 = e2;
              null === c3 ? (e2 = b3.child, b3.child = null) : (e2 = c3.sibling, c3.sibling = null);
              xj(b3, false, e2, c3, f3);
              break;
            case "backwards":
              c3 = null;
              e2 = b3.child;
              for (b3.child = null; null !== e2; ) {
                a3 = e2.alternate;
                if (null !== a3 && null === Mh(a3)) {
                  b3.child = e2;
                  break;
                }
                a3 = e2.sibling;
                e2.sibling = c3;
                c3 = e2;
                e2 = a3;
              }
              xj(b3, true, c3, null, f3);
              break;
            case "together":
              xj(b3, false, null, null, void 0);
              break;
            default:
              b3.memoizedState = null;
          }
        return b3.child;
      }
      function jj(a3, b3) {
        0 === (b3.mode & 1) && null !== a3 && (a3.alternate = null, b3.alternate = null, b3.flags |= 2);
      }
      function $i(a3, b3, c3) {
        null !== a3 && (b3.dependencies = a3.dependencies);
        hh |= b3.lanes;
        if (0 === (c3 & b3.childLanes))
          return null;
        if (null !== a3 && b3.child !== a3.child)
          throw Error(p3(153));
        if (null !== b3.child) {
          a3 = b3.child;
          c3 = wh(a3, a3.pendingProps);
          b3.child = c3;
          for (c3.return = b3; null !== a3.sibling; )
            a3 = a3.sibling, c3 = c3.sibling = wh(a3, a3.pendingProps), c3.return = b3;
          c3.sibling = null;
        }
        return b3.child;
      }
      function zj(a3, b3, c3) {
        switch (b3.tag) {
          case 3:
            lj(b3);
            Ig();
            break;
          case 5:
            Kh(b3);
            break;
          case 1:
            Zf(b3.type) && cg(b3);
            break;
          case 4:
            Ih(b3, b3.stateNode.containerInfo);
            break;
          case 10:
            var d3 = b3.type._context, e2 = b3.memoizedProps.value;
            G(Mg, d3._currentValue);
            d3._currentValue = e2;
            break;
          case 13:
            d3 = b3.memoizedState;
            if (null !== d3) {
              if (null !== d3.dehydrated)
                return G(M, M.current & 1), b3.flags |= 128, null;
              if (0 !== (c3 & b3.child.childLanes))
                return pj(a3, b3, c3);
              G(M, M.current & 1);
              a3 = $i(a3, b3, c3);
              return null !== a3 ? a3.sibling : null;
            }
            G(M, M.current & 1);
            break;
          case 19:
            d3 = 0 !== (c3 & b3.childLanes);
            if (0 !== (a3.flags & 128)) {
              if (d3)
                return yj(a3, b3, c3);
              b3.flags |= 128;
            }
            e2 = b3.memoizedState;
            null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
            G(M, M.current);
            if (d3)
              break;
            else
              return null;
          case 22:
          case 23:
            return b3.lanes = 0, ej(a3, b3, c3);
        }
        return $i(a3, b3, c3);
      }
      var Aj;
      var Bj;
      var Cj;
      var Dj;
      Aj = function(a3, b3) {
        for (var c3 = b3.child; null !== c3; ) {
          if (5 === c3.tag || 6 === c3.tag)
            a3.appendChild(c3.stateNode);
          else if (4 !== c3.tag && null !== c3.child) {
            c3.child.return = c3;
            c3 = c3.child;
            continue;
          }
          if (c3 === b3)
            break;
          for (; null === c3.sibling; ) {
            if (null === c3.return || c3.return === b3)
              return;
            c3 = c3.return;
          }
          c3.sibling.return = c3.return;
          c3 = c3.sibling;
        }
      };
      Bj = function() {
      };
      Cj = function(a3, b3, c3, d3) {
        var e2 = a3.memoizedProps;
        if (e2 !== d3) {
          a3 = b3.stateNode;
          Hh(Eh.current);
          var f3 = null;
          switch (c3) {
            case "input":
              e2 = Ya(a3, e2);
              d3 = Ya(a3, d3);
              f3 = [];
              break;
            case "select":
              e2 = A2({}, e2, { value: void 0 });
              d3 = A2({}, d3, { value: void 0 });
              f3 = [];
              break;
            case "textarea":
              e2 = gb(a3, e2);
              d3 = gb(a3, d3);
              f3 = [];
              break;
            default:
              "function" !== typeof e2.onClick && "function" === typeof d3.onClick && (a3.onclick = Bf);
          }
          ub(c3, d3);
          var g3;
          c3 = null;
          for (l3 in e2)
            if (!d3.hasOwnProperty(l3) && e2.hasOwnProperty(l3) && null != e2[l3])
              if ("style" === l3) {
                var h3 = e2[l3];
                for (g3 in h3)
                  h3.hasOwnProperty(g3) && (c3 || (c3 = {}), c3[g3] = "");
              } else
                "dangerouslySetInnerHTML" !== l3 && "children" !== l3 && "suppressContentEditableWarning" !== l3 && "suppressHydrationWarning" !== l3 && "autoFocus" !== l3 && (ea.hasOwnProperty(l3) ? f3 || (f3 = []) : (f3 = f3 || []).push(l3, null));
          for (l3 in d3) {
            var k2 = d3[l3];
            h3 = null != e2 ? e2[l3] : void 0;
            if (d3.hasOwnProperty(l3) && k2 !== h3 && (null != k2 || null != h3))
              if ("style" === l3)
                if (h3) {
                  for (g3 in h3)
                    !h3.hasOwnProperty(g3) || k2 && k2.hasOwnProperty(g3) || (c3 || (c3 = {}), c3[g3] = "");
                  for (g3 in k2)
                    k2.hasOwnProperty(g3) && h3[g3] !== k2[g3] && (c3 || (c3 = {}), c3[g3] = k2[g3]);
                } else
                  c3 || (f3 || (f3 = []), f3.push(
                    l3,
                    c3
                  )), c3 = k2;
              else
                "dangerouslySetInnerHTML" === l3 ? (k2 = k2 ? k2.__html : void 0, h3 = h3 ? h3.__html : void 0, null != k2 && h3 !== k2 && (f3 = f3 || []).push(l3, k2)) : "children" === l3 ? "string" !== typeof k2 && "number" !== typeof k2 || (f3 = f3 || []).push(l3, "" + k2) : "suppressContentEditableWarning" !== l3 && "suppressHydrationWarning" !== l3 && (ea.hasOwnProperty(l3) ? (null != k2 && "onScroll" === l3 && D3("scroll", a3), f3 || h3 === k2 || (f3 = [])) : (f3 = f3 || []).push(l3, k2));
          }
          c3 && (f3 = f3 || []).push("style", c3);
          var l3 = f3;
          if (b3.updateQueue = l3)
            b3.flags |= 4;
        }
      };
      Dj = function(a3, b3, c3, d3) {
        c3 !== d3 && (b3.flags |= 4);
      };
      function Ej(a3, b3) {
        if (!I)
          switch (a3.tailMode) {
            case "hidden":
              b3 = a3.tail;
              for (var c3 = null; null !== b3; )
                null !== b3.alternate && (c3 = b3), b3 = b3.sibling;
              null === c3 ? a3.tail = null : c3.sibling = null;
              break;
            case "collapsed":
              c3 = a3.tail;
              for (var d3 = null; null !== c3; )
                null !== c3.alternate && (d3 = c3), c3 = c3.sibling;
              null === d3 ? b3 || null === a3.tail ? a3.tail = null : a3.tail.sibling = null : d3.sibling = null;
          }
      }
      function S2(a3) {
        var b3 = null !== a3.alternate && a3.alternate.child === a3.child, c3 = 0, d3 = 0;
        if (b3)
          for (var e2 = a3.child; null !== e2; )
            c3 |= e2.lanes | e2.childLanes, d3 |= e2.subtreeFlags & 14680064, d3 |= e2.flags & 14680064, e2.return = a3, e2 = e2.sibling;
        else
          for (e2 = a3.child; null !== e2; )
            c3 |= e2.lanes | e2.childLanes, d3 |= e2.subtreeFlags, d3 |= e2.flags, e2.return = a3, e2 = e2.sibling;
        a3.subtreeFlags |= d3;
        a3.childLanes = c3;
        return b3;
      }
      function Fj(a3, b3, c3) {
        var d3 = b3.pendingProps;
        wg(b3);
        switch (b3.tag) {
          case 2:
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return S2(b3), null;
          case 1:
            return Zf(b3.type) && $f(), S2(b3), null;
          case 3:
            d3 = b3.stateNode;
            Jh();
            E3(Wf);
            E3(H2);
            Oh();
            d3.pendingContext && (d3.context = d3.pendingContext, d3.pendingContext = null);
            if (null === a3 || null === a3.child)
              Gg(b3) ? b3.flags |= 4 : null === a3 || a3.memoizedState.isDehydrated && 0 === (b3.flags & 256) || (b3.flags |= 1024, null !== zg && (Gj(zg), zg = null));
            Bj(a3, b3);
            S2(b3);
            return null;
          case 5:
            Lh(b3);
            var e2 = Hh(Gh.current);
            c3 = b3.type;
            if (null !== a3 && null != b3.stateNode)
              Cj(a3, b3, c3, d3, e2), a3.ref !== b3.ref && (b3.flags |= 512, b3.flags |= 2097152);
            else {
              if (!d3) {
                if (null === b3.stateNode)
                  throw Error(p3(166));
                S2(b3);
                return null;
              }
              a3 = Hh(Eh.current);
              if (Gg(b3)) {
                d3 = b3.stateNode;
                c3 = b3.type;
                var f3 = b3.memoizedProps;
                d3[Of] = b3;
                d3[Pf] = f3;
                a3 = 0 !== (b3.mode & 1);
                switch (c3) {
                  case "dialog":
                    D3("cancel", d3);
                    D3("close", d3);
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D3("load", d3);
                    break;
                  case "video":
                  case "audio":
                    for (e2 = 0; e2 < lf.length; e2++)
                      D3(lf[e2], d3);
                    break;
                  case "source":
                    D3("error", d3);
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D3(
                      "error",
                      d3
                    );
                    D3("load", d3);
                    break;
                  case "details":
                    D3("toggle", d3);
                    break;
                  case "input":
                    Za(d3, f3);
                    D3("invalid", d3);
                    break;
                  case "select":
                    d3._wrapperState = { wasMultiple: !!f3.multiple };
                    D3("invalid", d3);
                    break;
                  case "textarea":
                    hb(d3, f3), D3("invalid", d3);
                }
                ub(c3, f3);
                e2 = null;
                for (var g3 in f3)
                  if (f3.hasOwnProperty(g3)) {
                    var h3 = f3[g3];
                    "children" === g3 ? "string" === typeof h3 ? d3.textContent !== h3 && (true !== f3.suppressHydrationWarning && Af(d3.textContent, h3, a3), e2 = ["children", h3]) : "number" === typeof h3 && d3.textContent !== "" + h3 && (true !== f3.suppressHydrationWarning && Af(
                      d3.textContent,
                      h3,
                      a3
                    ), e2 = ["children", "" + h3]) : ea.hasOwnProperty(g3) && null != h3 && "onScroll" === g3 && D3("scroll", d3);
                  }
                switch (c3) {
                  case "input":
                    Va(d3);
                    db(d3, f3, true);
                    break;
                  case "textarea":
                    Va(d3);
                    jb(d3);
                    break;
                  case "select":
                  case "option":
                    break;
                  default:
                    "function" === typeof f3.onClick && (d3.onclick = Bf);
                }
                d3 = e2;
                b3.updateQueue = d3;
                null !== d3 && (b3.flags |= 4);
              } else {
                g3 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
                "http://www.w3.org/1999/xhtml" === a3 && (a3 = kb(c3));
                "http://www.w3.org/1999/xhtml" === a3 ? "script" === c3 ? (a3 = g3.createElement("div"), a3.innerHTML = "<script><\/script>", a3 = a3.removeChild(a3.firstChild)) : "string" === typeof d3.is ? a3 = g3.createElement(c3, { is: d3.is }) : (a3 = g3.createElement(c3), "select" === c3 && (g3 = a3, d3.multiple ? g3.multiple = true : d3.size && (g3.size = d3.size))) : a3 = g3.createElementNS(a3, c3);
                a3[Of] = b3;
                a3[Pf] = d3;
                Aj(a3, b3, false, false);
                b3.stateNode = a3;
                a: {
                  g3 = vb(c3, d3);
                  switch (c3) {
                    case "dialog":
                      D3("cancel", a3);
                      D3("close", a3);
                      e2 = d3;
                      break;
                    case "iframe":
                    case "object":
                    case "embed":
                      D3("load", a3);
                      e2 = d3;
                      break;
                    case "video":
                    case "audio":
                      for (e2 = 0; e2 < lf.length; e2++)
                        D3(lf[e2], a3);
                      e2 = d3;
                      break;
                    case "source":
                      D3("error", a3);
                      e2 = d3;
                      break;
                    case "img":
                    case "image":
                    case "link":
                      D3(
                        "error",
                        a3
                      );
                      D3("load", a3);
                      e2 = d3;
                      break;
                    case "details":
                      D3("toggle", a3);
                      e2 = d3;
                      break;
                    case "input":
                      Za(a3, d3);
                      e2 = Ya(a3, d3);
                      D3("invalid", a3);
                      break;
                    case "option":
                      e2 = d3;
                      break;
                    case "select":
                      a3._wrapperState = { wasMultiple: !!d3.multiple };
                      e2 = A2({}, d3, { value: void 0 });
                      D3("invalid", a3);
                      break;
                    case "textarea":
                      hb(a3, d3);
                      e2 = gb(a3, d3);
                      D3("invalid", a3);
                      break;
                    default:
                      e2 = d3;
                  }
                  ub(c3, e2);
                  h3 = e2;
                  for (f3 in h3)
                    if (h3.hasOwnProperty(f3)) {
                      var k2 = h3[f3];
                      "style" === f3 ? sb(a3, k2) : "dangerouslySetInnerHTML" === f3 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a3, k2)) : "children" === f3 ? "string" === typeof k2 ? ("textarea" !== c3 || "" !== k2) && ob(a3, k2) : "number" === typeof k2 && ob(a3, "" + k2) : "suppressContentEditableWarning" !== f3 && "suppressHydrationWarning" !== f3 && "autoFocus" !== f3 && (ea.hasOwnProperty(f3) ? null != k2 && "onScroll" === f3 && D3("scroll", a3) : null != k2 && ta(a3, f3, k2, g3));
                    }
                  switch (c3) {
                    case "input":
                      Va(a3);
                      db(a3, d3, false);
                      break;
                    case "textarea":
                      Va(a3);
                      jb(a3);
                      break;
                    case "option":
                      null != d3.value && a3.setAttribute("value", "" + Sa(d3.value));
                      break;
                    case "select":
                      a3.multiple = !!d3.multiple;
                      f3 = d3.value;
                      null != f3 ? fb(a3, !!d3.multiple, f3, false) : null != d3.defaultValue && fb(
                        a3,
                        !!d3.multiple,
                        d3.defaultValue,
                        true
                      );
                      break;
                    default:
                      "function" === typeof e2.onClick && (a3.onclick = Bf);
                  }
                  switch (c3) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      d3 = !!d3.autoFocus;
                      break a;
                    case "img":
                      d3 = true;
                      break a;
                    default:
                      d3 = false;
                  }
                }
                d3 && (b3.flags |= 4);
              }
              null !== b3.ref && (b3.flags |= 512, b3.flags |= 2097152);
            }
            S2(b3);
            return null;
          case 6:
            if (a3 && null != b3.stateNode)
              Dj(a3, b3, a3.memoizedProps, d3);
            else {
              if ("string" !== typeof d3 && null === b3.stateNode)
                throw Error(p3(166));
              c3 = Hh(Gh.current);
              Hh(Eh.current);
              if (Gg(b3)) {
                d3 = b3.stateNode;
                c3 = b3.memoizedProps;
                d3[Of] = b3;
                if (f3 = d3.nodeValue !== c3) {
                  if (a3 = xg, null !== a3)
                    switch (a3.tag) {
                      case 3:
                        Af(d3.nodeValue, c3, 0 !== (a3.mode & 1));
                        break;
                      case 5:
                        true !== a3.memoizedProps.suppressHydrationWarning && Af(d3.nodeValue, c3, 0 !== (a3.mode & 1));
                    }
                }
                f3 && (b3.flags |= 4);
              } else
                d3 = (9 === c3.nodeType ? c3 : c3.ownerDocument).createTextNode(d3), d3[Of] = b3, b3.stateNode = d3;
            }
            S2(b3);
            return null;
          case 13:
            E3(M);
            d3 = b3.memoizedState;
            if (null === a3 || null !== a3.memoizedState && null !== a3.memoizedState.dehydrated) {
              if (I && null !== yg && 0 !== (b3.mode & 1) && 0 === (b3.flags & 128))
                Hg(), Ig(), b3.flags |= 98560, f3 = false;
              else if (f3 = Gg(b3), null !== d3 && null !== d3.dehydrated) {
                if (null === a3) {
                  if (!f3)
                    throw Error(p3(318));
                  f3 = b3.memoizedState;
                  f3 = null !== f3 ? f3.dehydrated : null;
                  if (!f3)
                    throw Error(p3(317));
                  f3[Of] = b3;
                } else
                  Ig(), 0 === (b3.flags & 128) && (b3.memoizedState = null), b3.flags |= 4;
                S2(b3);
                f3 = false;
              } else
                null !== zg && (Gj(zg), zg = null), f3 = true;
              if (!f3)
                return b3.flags & 65536 ? b3 : null;
            }
            if (0 !== (b3.flags & 128))
              return b3.lanes = c3, b3;
            d3 = null !== d3;
            d3 !== (null !== a3 && null !== a3.memoizedState) && d3 && (b3.child.flags |= 8192, 0 !== (b3.mode & 1) && (null === a3 || 0 !== (M.current & 1) ? 0 === T3 && (T3 = 3) : uj()));
            null !== b3.updateQueue && (b3.flags |= 4);
            S2(b3);
            return null;
          case 4:
            return Jh(), Bj(a3, b3), null === a3 && sf(b3.stateNode.containerInfo), S2(b3), null;
          case 10:
            return Rg(b3.type._context), S2(b3), null;
          case 17:
            return Zf(b3.type) && $f(), S2(b3), null;
          case 19:
            E3(M);
            f3 = b3.memoizedState;
            if (null === f3)
              return S2(b3), null;
            d3 = 0 !== (b3.flags & 128);
            g3 = f3.rendering;
            if (null === g3)
              if (d3)
                Ej(f3, false);
              else {
                if (0 !== T3 || null !== a3 && 0 !== (a3.flags & 128))
                  for (a3 = b3.child; null !== a3; ) {
                    g3 = Mh(a3);
                    if (null !== g3) {
                      b3.flags |= 128;
                      Ej(f3, false);
                      d3 = g3.updateQueue;
                      null !== d3 && (b3.updateQueue = d3, b3.flags |= 4);
                      b3.subtreeFlags = 0;
                      d3 = c3;
                      for (c3 = b3.child; null !== c3; )
                        f3 = c3, a3 = d3, f3.flags &= 14680066, g3 = f3.alternate, null === g3 ? (f3.childLanes = 0, f3.lanes = a3, f3.child = null, f3.subtreeFlags = 0, f3.memoizedProps = null, f3.memoizedState = null, f3.updateQueue = null, f3.dependencies = null, f3.stateNode = null) : (f3.childLanes = g3.childLanes, f3.lanes = g3.lanes, f3.child = g3.child, f3.subtreeFlags = 0, f3.deletions = null, f3.memoizedProps = g3.memoizedProps, f3.memoizedState = g3.memoizedState, f3.updateQueue = g3.updateQueue, f3.type = g3.type, a3 = g3.dependencies, f3.dependencies = null === a3 ? null : { lanes: a3.lanes, firstContext: a3.firstContext }), c3 = c3.sibling;
                      G(M, M.current & 1 | 2);
                      return b3.child;
                    }
                    a3 = a3.sibling;
                  }
                null !== f3.tail && B() > Hj && (b3.flags |= 128, d3 = true, Ej(f3, false), b3.lanes = 4194304);
              }
            else {
              if (!d3)
                if (a3 = Mh(g3), null !== a3) {
                  if (b3.flags |= 128, d3 = true, c3 = a3.updateQueue, null !== c3 && (b3.updateQueue = c3, b3.flags |= 4), Ej(f3, true), null === f3.tail && "hidden" === f3.tailMode && !g3.alternate && !I)
                    return S2(b3), null;
                } else
                  2 * B() - f3.renderingStartTime > Hj && 1073741824 !== c3 && (b3.flags |= 128, d3 = true, Ej(f3, false), b3.lanes = 4194304);
              f3.isBackwards ? (g3.sibling = b3.child, b3.child = g3) : (c3 = f3.last, null !== c3 ? c3.sibling = g3 : b3.child = g3, f3.last = g3);
            }
            if (null !== f3.tail)
              return b3 = f3.tail, f3.rendering = b3, f3.tail = b3.sibling, f3.renderingStartTime = B(), b3.sibling = null, c3 = M.current, G(M, d3 ? c3 & 1 | 2 : c3 & 1), b3;
            S2(b3);
            return null;
          case 22:
          case 23:
            return Ij(), d3 = null !== b3.memoizedState, null !== a3 && null !== a3.memoizedState !== d3 && (b3.flags |= 8192), d3 && 0 !== (b3.mode & 1) ? 0 !== (gj & 1073741824) && (S2(b3), b3.subtreeFlags & 6 && (b3.flags |= 8192)) : S2(b3), null;
          case 24:
            return null;
          case 25:
            return null;
        }
        throw Error(p3(156, b3.tag));
      }
      function Jj(a3, b3) {
        wg(b3);
        switch (b3.tag) {
          case 1:
            return Zf(b3.type) && $f(), a3 = b3.flags, a3 & 65536 ? (b3.flags = a3 & -65537 | 128, b3) : null;
          case 3:
            return Jh(), E3(Wf), E3(H2), Oh(), a3 = b3.flags, 0 !== (a3 & 65536) && 0 === (a3 & 128) ? (b3.flags = a3 & -65537 | 128, b3) : null;
          case 5:
            return Lh(b3), null;
          case 13:
            E3(M);
            a3 = b3.memoizedState;
            if (null !== a3 && null !== a3.dehydrated) {
              if (null === b3.alternate)
                throw Error(p3(340));
              Ig();
            }
            a3 = b3.flags;
            return a3 & 65536 ? (b3.flags = a3 & -65537 | 128, b3) : null;
          case 19:
            return E3(M), null;
          case 4:
            return Jh(), null;
          case 10:
            return Rg(b3.type._context), null;
          case 22:
          case 23:
            return Ij(), null;
          case 24:
            return null;
          default:
            return null;
        }
      }
      var Kj = false;
      var U = false;
      var Lj = "function" === typeof WeakSet ? WeakSet : Set;
      var V2 = null;
      function Mj(a3, b3) {
        var c3 = a3.ref;
        if (null !== c3)
          if ("function" === typeof c3)
            try {
              c3(null);
            } catch (d3) {
              W2(a3, b3, d3);
            }
          else
            c3.current = null;
      }
      function Nj(a3, b3, c3) {
        try {
          c3();
        } catch (d3) {
          W2(a3, b3, d3);
        }
      }
      var Oj = false;
      function Pj(a3, b3) {
        Cf = dd;
        a3 = Me();
        if (Ne(a3)) {
          if ("selectionStart" in a3)
            var c3 = { start: a3.selectionStart, end: a3.selectionEnd };
          else
            a: {
              c3 = (c3 = a3.ownerDocument) && c3.defaultView || window;
              var d3 = c3.getSelection && c3.getSelection();
              if (d3 && 0 !== d3.rangeCount) {
                c3 = d3.anchorNode;
                var e2 = d3.anchorOffset, f3 = d3.focusNode;
                d3 = d3.focusOffset;
                try {
                  c3.nodeType, f3.nodeType;
                } catch (F) {
                  c3 = null;
                  break a;
                }
                var g3 = 0, h3 = -1, k2 = -1, l3 = 0, m3 = 0, q = a3, r3 = null;
                b:
                  for (; ; ) {
                    for (var y3; ; ) {
                      q !== c3 || 0 !== e2 && 3 !== q.nodeType || (h3 = g3 + e2);
                      q !== f3 || 0 !== d3 && 3 !== q.nodeType || (k2 = g3 + d3);
                      3 === q.nodeType && (g3 += q.nodeValue.length);
                      if (null === (y3 = q.firstChild))
                        break;
                      r3 = q;
                      q = y3;
                    }
                    for (; ; ) {
                      if (q === a3)
                        break b;
                      r3 === c3 && ++l3 === e2 && (h3 = g3);
                      r3 === f3 && ++m3 === d3 && (k2 = g3);
                      if (null !== (y3 = q.nextSibling))
                        break;
                      q = r3;
                      r3 = q.parentNode;
                    }
                    q = y3;
                  }
                c3 = -1 === h3 || -1 === k2 ? null : { start: h3, end: k2 };
              } else
                c3 = null;
            }
          c3 = c3 || { start: 0, end: 0 };
        } else
          c3 = null;
        Df = { focusedElem: a3, selectionRange: c3 };
        dd = false;
        for (V2 = b3; null !== V2; )
          if (b3 = V2, a3 = b3.child, 0 !== (b3.subtreeFlags & 1028) && null !== a3)
            a3.return = b3, V2 = a3;
          else
            for (; null !== V2; ) {
              b3 = V2;
              try {
                var n3 = b3.alternate;
                if (0 !== (b3.flags & 1024))
                  switch (b3.tag) {
                    case 0:
                    case 11:
                    case 15:
                      break;
                    case 1:
                      if (null !== n3) {
                        var t4 = n3.memoizedProps, J = n3.memoizedState, x3 = b3.stateNode, w3 = x3.getSnapshotBeforeUpdate(b3.elementType === b3.type ? t4 : Lg(b3.type, t4), J);
                        x3.__reactInternalSnapshotBeforeUpdate = w3;
                      }
                      break;
                    case 3:
                      var u3 = b3.stateNode.containerInfo;
                      1 === u3.nodeType ? u3.textContent = "" : 9 === u3.nodeType && u3.documentElement && u3.removeChild(u3.documentElement);
                      break;
                    case 5:
                    case 6:
                    case 4:
                    case 17:
                      break;
                    default:
                      throw Error(p3(163));
                  }
              } catch (F) {
                W2(b3, b3.return, F);
              }
              a3 = b3.sibling;
              if (null !== a3) {
                a3.return = b3.return;
                V2 = a3;
                break;
              }
              V2 = b3.return;
            }
        n3 = Oj;
        Oj = false;
        return n3;
      }
      function Qj(a3, b3, c3) {
        var d3 = b3.updateQueue;
        d3 = null !== d3 ? d3.lastEffect : null;
        if (null !== d3) {
          var e2 = d3 = d3.next;
          do {
            if ((e2.tag & a3) === a3) {
              var f3 = e2.destroy;
              e2.destroy = void 0;
              void 0 !== f3 && Nj(b3, c3, f3);
            }
            e2 = e2.next;
          } while (e2 !== d3);
        }
      }
      function Rj(a3, b3) {
        b3 = b3.updateQueue;
        b3 = null !== b3 ? b3.lastEffect : null;
        if (null !== b3) {
          var c3 = b3 = b3.next;
          do {
            if ((c3.tag & a3) === a3) {
              var d3 = c3.create;
              c3.destroy = d3();
            }
            c3 = c3.next;
          } while (c3 !== b3);
        }
      }
      function Sj(a3) {
        var b3 = a3.ref;
        if (null !== b3) {
          var c3 = a3.stateNode;
          switch (a3.tag) {
            case 5:
              a3 = c3;
              break;
            default:
              a3 = c3;
          }
          "function" === typeof b3 ? b3(a3) : b3.current = a3;
        }
      }
      function Tj(a3) {
        var b3 = a3.alternate;
        null !== b3 && (a3.alternate = null, Tj(b3));
        a3.child = null;
        a3.deletions = null;
        a3.sibling = null;
        5 === a3.tag && (b3 = a3.stateNode, null !== b3 && (delete b3[Of], delete b3[Pf], delete b3[of], delete b3[Qf], delete b3[Rf]));
        a3.stateNode = null;
        a3.return = null;
        a3.dependencies = null;
        a3.memoizedProps = null;
        a3.memoizedState = null;
        a3.pendingProps = null;
        a3.stateNode = null;
        a3.updateQueue = null;
      }
      function Uj(a3) {
        return 5 === a3.tag || 3 === a3.tag || 4 === a3.tag;
      }
      function Vj(a3) {
        a:
          for (; ; ) {
            for (; null === a3.sibling; ) {
              if (null === a3.return || Uj(a3.return))
                return null;
              a3 = a3.return;
            }
            a3.sibling.return = a3.return;
            for (a3 = a3.sibling; 5 !== a3.tag && 6 !== a3.tag && 18 !== a3.tag; ) {
              if (a3.flags & 2)
                continue a;
              if (null === a3.child || 4 === a3.tag)
                continue a;
              else
                a3.child.return = a3, a3 = a3.child;
            }
            if (!(a3.flags & 2))
              return a3.stateNode;
          }
      }
      function Wj(a3, b3, c3) {
        var d3 = a3.tag;
        if (5 === d3 || 6 === d3)
          a3 = a3.stateNode, b3 ? 8 === c3.nodeType ? c3.parentNode.insertBefore(a3, b3) : c3.insertBefore(a3, b3) : (8 === c3.nodeType ? (b3 = c3.parentNode, b3.insertBefore(a3, c3)) : (b3 = c3, b3.appendChild(a3)), c3 = c3._reactRootContainer, null !== c3 && void 0 !== c3 || null !== b3.onclick || (b3.onclick = Bf));
        else if (4 !== d3 && (a3 = a3.child, null !== a3))
          for (Wj(a3, b3, c3), a3 = a3.sibling; null !== a3; )
            Wj(a3, b3, c3), a3 = a3.sibling;
      }
      function Xj(a3, b3, c3) {
        var d3 = a3.tag;
        if (5 === d3 || 6 === d3)
          a3 = a3.stateNode, b3 ? c3.insertBefore(a3, b3) : c3.appendChild(a3);
        else if (4 !== d3 && (a3 = a3.child, null !== a3))
          for (Xj(a3, b3, c3), a3 = a3.sibling; null !== a3; )
            Xj(a3, b3, c3), a3 = a3.sibling;
      }
      var X = null;
      var Yj = false;
      function Zj(a3, b3, c3) {
        for (c3 = c3.child; null !== c3; )
          ak(a3, b3, c3), c3 = c3.sibling;
      }
      function ak(a3, b3, c3) {
        if (lc && "function" === typeof lc.onCommitFiberUnmount)
          try {
            lc.onCommitFiberUnmount(kc, c3);
          } catch (h3) {
          }
        switch (c3.tag) {
          case 5:
            U || Mj(c3, b3);
          case 6:
            var d3 = X, e2 = Yj;
            X = null;
            Zj(a3, b3, c3);
            X = d3;
            Yj = e2;
            null !== X && (Yj ? (a3 = X, c3 = c3.stateNode, 8 === a3.nodeType ? a3.parentNode.removeChild(c3) : a3.removeChild(c3)) : X.removeChild(c3.stateNode));
            break;
          case 18:
            null !== X && (Yj ? (a3 = X, c3 = c3.stateNode, 8 === a3.nodeType ? Kf(a3.parentNode, c3) : 1 === a3.nodeType && Kf(a3, c3), bd(a3)) : Kf(X, c3.stateNode));
            break;
          case 4:
            d3 = X;
            e2 = Yj;
            X = c3.stateNode.containerInfo;
            Yj = true;
            Zj(a3, b3, c3);
            X = d3;
            Yj = e2;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            if (!U && (d3 = c3.updateQueue, null !== d3 && (d3 = d3.lastEffect, null !== d3))) {
              e2 = d3 = d3.next;
              do {
                var f3 = e2, g3 = f3.destroy;
                f3 = f3.tag;
                void 0 !== g3 && (0 !== (f3 & 2) ? Nj(c3, b3, g3) : 0 !== (f3 & 4) && Nj(c3, b3, g3));
                e2 = e2.next;
              } while (e2 !== d3);
            }
            Zj(a3, b3, c3);
            break;
          case 1:
            if (!U && (Mj(c3, b3), d3 = c3.stateNode, "function" === typeof d3.componentWillUnmount))
              try {
                d3.props = c3.memoizedProps, d3.state = c3.memoizedState, d3.componentWillUnmount();
              } catch (h3) {
                W2(c3, b3, h3);
              }
            Zj(a3, b3, c3);
            break;
          case 21:
            Zj(a3, b3, c3);
            break;
          case 22:
            c3.mode & 1 ? (U = (d3 = U) || null !== c3.memoizedState, Zj(a3, b3, c3), U = d3) : Zj(a3, b3, c3);
            break;
          default:
            Zj(a3, b3, c3);
        }
      }
      function bk(a3) {
        var b3 = a3.updateQueue;
        if (null !== b3) {
          a3.updateQueue = null;
          var c3 = a3.stateNode;
          null === c3 && (c3 = a3.stateNode = new Lj());
          b3.forEach(function(b4) {
            var d3 = ck.bind(null, a3, b4);
            c3.has(b4) || (c3.add(b4), b4.then(d3, d3));
          });
        }
      }
      function dk(a3, b3) {
        var c3 = b3.deletions;
        if (null !== c3)
          for (var d3 = 0; d3 < c3.length; d3++) {
            var e2 = c3[d3];
            try {
              var f3 = a3, g3 = b3, h3 = g3;
              a:
                for (; null !== h3; ) {
                  switch (h3.tag) {
                    case 5:
                      X = h3.stateNode;
                      Yj = false;
                      break a;
                    case 3:
                      X = h3.stateNode.containerInfo;
                      Yj = true;
                      break a;
                    case 4:
                      X = h3.stateNode.containerInfo;
                      Yj = true;
                      break a;
                  }
                  h3 = h3.return;
                }
              if (null === X)
                throw Error(p3(160));
              ak(f3, g3, e2);
              X = null;
              Yj = false;
              var k2 = e2.alternate;
              null !== k2 && (k2.return = null);
              e2.return = null;
            } catch (l3) {
              W2(e2, b3, l3);
            }
          }
        if (b3.subtreeFlags & 12854)
          for (b3 = b3.child; null !== b3; )
            ek(b3, a3), b3 = b3.sibling;
      }
      function ek(a3, b3) {
        var c3 = a3.alternate, d3 = a3.flags;
        switch (a3.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            dk(b3, a3);
            fk(a3);
            if (d3 & 4) {
              try {
                Qj(3, a3, a3.return), Rj(3, a3);
              } catch (t4) {
                W2(a3, a3.return, t4);
              }
              try {
                Qj(5, a3, a3.return);
              } catch (t4) {
                W2(a3, a3.return, t4);
              }
            }
            break;
          case 1:
            dk(b3, a3);
            fk(a3);
            d3 & 512 && null !== c3 && Mj(c3, c3.return);
            break;
          case 5:
            dk(b3, a3);
            fk(a3);
            d3 & 512 && null !== c3 && Mj(c3, c3.return);
            if (a3.flags & 32) {
              var e2 = a3.stateNode;
              try {
                ob(e2, "");
              } catch (t4) {
                W2(a3, a3.return, t4);
              }
            }
            if (d3 & 4 && (e2 = a3.stateNode, null != e2)) {
              var f3 = a3.memoizedProps, g3 = null !== c3 ? c3.memoizedProps : f3, h3 = a3.type, k2 = a3.updateQueue;
              a3.updateQueue = null;
              if (null !== k2)
                try {
                  "input" === h3 && "radio" === f3.type && null != f3.name && ab(e2, f3);
                  vb(h3, g3);
                  var l3 = vb(h3, f3);
                  for (g3 = 0; g3 < k2.length; g3 += 2) {
                    var m3 = k2[g3], q = k2[g3 + 1];
                    "style" === m3 ? sb(e2, q) : "dangerouslySetInnerHTML" === m3 ? nb(e2, q) : "children" === m3 ? ob(e2, q) : ta(e2, m3, q, l3);
                  }
                  switch (h3) {
                    case "input":
                      bb(e2, f3);
                      break;
                    case "textarea":
                      ib(e2, f3);
                      break;
                    case "select":
                      var r3 = e2._wrapperState.wasMultiple;
                      e2._wrapperState.wasMultiple = !!f3.multiple;
                      var y3 = f3.value;
                      null != y3 ? fb(e2, !!f3.multiple, y3, false) : r3 !== !!f3.multiple && (null != f3.defaultValue ? fb(
                        e2,
                        !!f3.multiple,
                        f3.defaultValue,
                        true
                      ) : fb(e2, !!f3.multiple, f3.multiple ? [] : "", false));
                  }
                  e2[Pf] = f3;
                } catch (t4) {
                  W2(a3, a3.return, t4);
                }
            }
            break;
          case 6:
            dk(b3, a3);
            fk(a3);
            if (d3 & 4) {
              if (null === a3.stateNode)
                throw Error(p3(162));
              e2 = a3.stateNode;
              f3 = a3.memoizedProps;
              try {
                e2.nodeValue = f3;
              } catch (t4) {
                W2(a3, a3.return, t4);
              }
            }
            break;
          case 3:
            dk(b3, a3);
            fk(a3);
            if (d3 & 4 && null !== c3 && c3.memoizedState.isDehydrated)
              try {
                bd(b3.containerInfo);
              } catch (t4) {
                W2(a3, a3.return, t4);
              }
            break;
          case 4:
            dk(b3, a3);
            fk(a3);
            break;
          case 13:
            dk(b3, a3);
            fk(a3);
            e2 = a3.child;
            e2.flags & 8192 && (f3 = null !== e2.memoizedState, e2.stateNode.isHidden = f3, !f3 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B()));
            d3 & 4 && bk(a3);
            break;
          case 22:
            m3 = null !== c3 && null !== c3.memoizedState;
            a3.mode & 1 ? (U = (l3 = U) || m3, dk(b3, a3), U = l3) : dk(b3, a3);
            fk(a3);
            if (d3 & 8192) {
              l3 = null !== a3.memoizedState;
              if ((a3.stateNode.isHidden = l3) && !m3 && 0 !== (a3.mode & 1))
                for (V2 = a3, m3 = a3.child; null !== m3; ) {
                  for (q = V2 = m3; null !== V2; ) {
                    r3 = V2;
                    y3 = r3.child;
                    switch (r3.tag) {
                      case 0:
                      case 11:
                      case 14:
                      case 15:
                        Qj(4, r3, r3.return);
                        break;
                      case 1:
                        Mj(r3, r3.return);
                        var n3 = r3.stateNode;
                        if ("function" === typeof n3.componentWillUnmount) {
                          d3 = r3;
                          c3 = r3.return;
                          try {
                            b3 = d3, n3.props = b3.memoizedProps, n3.state = b3.memoizedState, n3.componentWillUnmount();
                          } catch (t4) {
                            W2(d3, c3, t4);
                          }
                        }
                        break;
                      case 5:
                        Mj(r3, r3.return);
                        break;
                      case 22:
                        if (null !== r3.memoizedState) {
                          hk(q);
                          continue;
                        }
                    }
                    null !== y3 ? (y3.return = r3, V2 = y3) : hk(q);
                  }
                  m3 = m3.sibling;
                }
              a:
                for (m3 = null, q = a3; ; ) {
                  if (5 === q.tag) {
                    if (null === m3) {
                      m3 = q;
                      try {
                        e2 = q.stateNode, l3 ? (f3 = e2.style, "function" === typeof f3.setProperty ? f3.setProperty("display", "none", "important") : f3.display = "none") : (h3 = q.stateNode, k2 = q.memoizedProps.style, g3 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h3.style.display = rb("display", g3));
                      } catch (t4) {
                        W2(a3, a3.return, t4);
                      }
                    }
                  } else if (6 === q.tag) {
                    if (null === m3)
                      try {
                        q.stateNode.nodeValue = l3 ? "" : q.memoizedProps;
                      } catch (t4) {
                        W2(a3, a3.return, t4);
                      }
                  } else if ((22 !== q.tag && 23 !== q.tag || null === q.memoizedState || q === a3) && null !== q.child) {
                    q.child.return = q;
                    q = q.child;
                    continue;
                  }
                  if (q === a3)
                    break a;
                  for (; null === q.sibling; ) {
                    if (null === q.return || q.return === a3)
                      break a;
                    m3 === q && (m3 = null);
                    q = q.return;
                  }
                  m3 === q && (m3 = null);
                  q.sibling.return = q.return;
                  q = q.sibling;
                }
            }
            break;
          case 19:
            dk(b3, a3);
            fk(a3);
            d3 & 4 && bk(a3);
            break;
          case 21:
            break;
          default:
            dk(
              b3,
              a3
            ), fk(a3);
        }
      }
      function fk(a3) {
        var b3 = a3.flags;
        if (b3 & 2) {
          try {
            a: {
              for (var c3 = a3.return; null !== c3; ) {
                if (Uj(c3)) {
                  var d3 = c3;
                  break a;
                }
                c3 = c3.return;
              }
              throw Error(p3(160));
            }
            switch (d3.tag) {
              case 5:
                var e2 = d3.stateNode;
                d3.flags & 32 && (ob(e2, ""), d3.flags &= -33);
                var f3 = Vj(a3);
                Xj(a3, f3, e2);
                break;
              case 3:
              case 4:
                var g3 = d3.stateNode.containerInfo, h3 = Vj(a3);
                Wj(a3, h3, g3);
                break;
              default:
                throw Error(p3(161));
            }
          } catch (k2) {
            W2(a3, a3.return, k2);
          }
          a3.flags &= -3;
        }
        b3 & 4096 && (a3.flags &= -4097);
      }
      function ik(a3, b3, c3) {
        V2 = a3;
        jk(a3, b3, c3);
      }
      function jk(a3, b3, c3) {
        for (var d3 = 0 !== (a3.mode & 1); null !== V2; ) {
          var e2 = V2, f3 = e2.child;
          if (22 === e2.tag && d3) {
            var g3 = null !== e2.memoizedState || Kj;
            if (!g3) {
              var h3 = e2.alternate, k2 = null !== h3 && null !== h3.memoizedState || U;
              h3 = Kj;
              var l3 = U;
              Kj = g3;
              if ((U = k2) && !l3)
                for (V2 = e2; null !== V2; )
                  g3 = V2, k2 = g3.child, 22 === g3.tag && null !== g3.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g3, V2 = k2) : kk(e2);
              for (; null !== f3; )
                V2 = f3, jk(f3, b3, c3), f3 = f3.sibling;
              V2 = e2;
              Kj = h3;
              U = l3;
            }
            lk(a3, b3, c3);
          } else
            0 !== (e2.subtreeFlags & 8772) && null !== f3 ? (f3.return = e2, V2 = f3) : lk(a3, b3, c3);
        }
      }
      function lk(a3) {
        for (; null !== V2; ) {
          var b3 = V2;
          if (0 !== (b3.flags & 8772)) {
            var c3 = b3.alternate;
            try {
              if (0 !== (b3.flags & 8772))
                switch (b3.tag) {
                  case 0:
                  case 11:
                  case 15:
                    U || Rj(5, b3);
                    break;
                  case 1:
                    var d3 = b3.stateNode;
                    if (b3.flags & 4 && !U)
                      if (null === c3)
                        d3.componentDidMount();
                      else {
                        var e2 = b3.elementType === b3.type ? c3.memoizedProps : Lg(b3.type, c3.memoizedProps);
                        d3.componentDidUpdate(e2, c3.memoizedState, d3.__reactInternalSnapshotBeforeUpdate);
                      }
                    var f3 = b3.updateQueue;
                    null !== f3 && ih(b3, f3, d3);
                    break;
                  case 3:
                    var g3 = b3.updateQueue;
                    if (null !== g3) {
                      c3 = null;
                      if (null !== b3.child)
                        switch (b3.child.tag) {
                          case 5:
                            c3 = b3.child.stateNode;
                            break;
                          case 1:
                            c3 = b3.child.stateNode;
                        }
                      ih(b3, g3, c3);
                    }
                    break;
                  case 5:
                    var h3 = b3.stateNode;
                    if (null === c3 && b3.flags & 4) {
                      c3 = h3;
                      var k2 = b3.memoizedProps;
                      switch (b3.type) {
                        case "button":
                        case "input":
                        case "select":
                        case "textarea":
                          k2.autoFocus && c3.focus();
                          break;
                        case "img":
                          k2.src && (c3.src = k2.src);
                      }
                    }
                    break;
                  case 6:
                    break;
                  case 4:
                    break;
                  case 12:
                    break;
                  case 13:
                    if (null === b3.memoizedState) {
                      var l3 = b3.alternate;
                      if (null !== l3) {
                        var m3 = l3.memoizedState;
                        if (null !== m3) {
                          var q = m3.dehydrated;
                          null !== q && bd(q);
                        }
                      }
                    }
                    break;
                  case 19:
                  case 17:
                  case 21:
                  case 22:
                  case 23:
                  case 25:
                    break;
                  default:
                    throw Error(p3(163));
                }
              U || b3.flags & 512 && Sj(b3);
            } catch (r3) {
              W2(b3, b3.return, r3);
            }
          }
          if (b3 === a3) {
            V2 = null;
            break;
          }
          c3 = b3.sibling;
          if (null !== c3) {
            c3.return = b3.return;
            V2 = c3;
            break;
          }
          V2 = b3.return;
        }
      }
      function hk(a3) {
        for (; null !== V2; ) {
          var b3 = V2;
          if (b3 === a3) {
            V2 = null;
            break;
          }
          var c3 = b3.sibling;
          if (null !== c3) {
            c3.return = b3.return;
            V2 = c3;
            break;
          }
          V2 = b3.return;
        }
      }
      function kk(a3) {
        for (; null !== V2; ) {
          var b3 = V2;
          try {
            switch (b3.tag) {
              case 0:
              case 11:
              case 15:
                var c3 = b3.return;
                try {
                  Rj(4, b3);
                } catch (k2) {
                  W2(b3, c3, k2);
                }
                break;
              case 1:
                var d3 = b3.stateNode;
                if ("function" === typeof d3.componentDidMount) {
                  var e2 = b3.return;
                  try {
                    d3.componentDidMount();
                  } catch (k2) {
                    W2(b3, e2, k2);
                  }
                }
                var f3 = b3.return;
                try {
                  Sj(b3);
                } catch (k2) {
                  W2(b3, f3, k2);
                }
                break;
              case 5:
                var g3 = b3.return;
                try {
                  Sj(b3);
                } catch (k2) {
                  W2(b3, g3, k2);
                }
            }
          } catch (k2) {
            W2(b3, b3.return, k2);
          }
          if (b3 === a3) {
            V2 = null;
            break;
          }
          var h3 = b3.sibling;
          if (null !== h3) {
            h3.return = b3.return;
            V2 = h3;
            break;
          }
          V2 = b3.return;
        }
      }
      var mk = Math.ceil;
      var nk = ua.ReactCurrentDispatcher;
      var ok = ua.ReactCurrentOwner;
      var pk = ua.ReactCurrentBatchConfig;
      var K = 0;
      var R3 = null;
      var Y = null;
      var Z = 0;
      var gj = 0;
      var fj = Uf(0);
      var T3 = 0;
      var qk = null;
      var hh = 0;
      var rk = 0;
      var sk = 0;
      var tk = null;
      var uk = null;
      var gk = 0;
      var Hj = Infinity;
      var vk = null;
      var Pi = false;
      var Qi = null;
      var Si = null;
      var wk = false;
      var xk = null;
      var yk = 0;
      var zk = 0;
      var Ak = null;
      var Bk = -1;
      var Ck = 0;
      function L3() {
        return 0 !== (K & 6) ? B() : -1 !== Bk ? Bk : Bk = B();
      }
      function lh(a3) {
        if (0 === (a3.mode & 1))
          return 1;
        if (0 !== (K & 2) && 0 !== Z)
          return Z & -Z;
        if (null !== Kg.transition)
          return 0 === Ck && (Ck = yc()), Ck;
        a3 = C2;
        if (0 !== a3)
          return a3;
        a3 = window.event;
        a3 = void 0 === a3 ? 16 : jd(a3.type);
        return a3;
      }
      function mh(a3, b3, c3, d3) {
        if (50 < zk)
          throw zk = 0, Ak = null, Error(p3(185));
        Ac(a3, c3, d3);
        if (0 === (K & 2) || a3 !== R3)
          a3 === R3 && (0 === (K & 2) && (rk |= c3), 4 === T3 && Dk(a3, Z)), Ek(a3, d3), 1 === c3 && 0 === K && 0 === (b3.mode & 1) && (Hj = B() + 500, fg && jg());
      }
      function Ek(a3, b3) {
        var c3 = a3.callbackNode;
        wc(a3, b3);
        var d3 = uc(a3, a3 === R3 ? Z : 0);
        if (0 === d3)
          null !== c3 && bc(c3), a3.callbackNode = null, a3.callbackPriority = 0;
        else if (b3 = d3 & -d3, a3.callbackPriority !== b3) {
          null != c3 && bc(c3);
          if (1 === b3)
            0 === a3.tag ? ig(Fk.bind(null, a3)) : hg(Fk.bind(null, a3)), Jf(function() {
              0 === (K & 6) && jg();
            }), c3 = null;
          else {
            switch (Dc(d3)) {
              case 1:
                c3 = fc;
                break;
              case 4:
                c3 = gc;
                break;
              case 16:
                c3 = hc;
                break;
              case 536870912:
                c3 = jc;
                break;
              default:
                c3 = hc;
            }
            c3 = Gk(c3, Hk.bind(null, a3));
          }
          a3.callbackPriority = b3;
          a3.callbackNode = c3;
        }
      }
      function Hk(a3, b3) {
        Bk = -1;
        Ck = 0;
        if (0 !== (K & 6))
          throw Error(p3(327));
        var c3 = a3.callbackNode;
        if (Ik() && a3.callbackNode !== c3)
          return null;
        var d3 = uc(a3, a3 === R3 ? Z : 0);
        if (0 === d3)
          return null;
        if (0 !== (d3 & 30) || 0 !== (d3 & a3.expiredLanes) || b3)
          b3 = Jk(a3, d3);
        else {
          b3 = d3;
          var e2 = K;
          K |= 2;
          var f3 = Kk();
          if (R3 !== a3 || Z !== b3)
            vk = null, Hj = B() + 500, Lk(a3, b3);
          do
            try {
              Mk();
              break;
            } catch (h3) {
              Nk(a3, h3);
            }
          while (1);
          Qg();
          nk.current = f3;
          K = e2;
          null !== Y ? b3 = 0 : (R3 = null, Z = 0, b3 = T3);
        }
        if (0 !== b3) {
          2 === b3 && (e2 = xc(a3), 0 !== e2 && (d3 = e2, b3 = Ok(a3, e2)));
          if (1 === b3)
            throw c3 = qk, Lk(a3, 0), Dk(a3, d3), Ek(a3, B()), c3;
          if (6 === b3)
            Dk(a3, d3);
          else {
            e2 = a3.current.alternate;
            if (0 === (d3 & 30) && !Pk(e2) && (b3 = Jk(a3, d3), 2 === b3 && (f3 = xc(a3), 0 !== f3 && (d3 = f3, b3 = Ok(a3, f3))), 1 === b3))
              throw c3 = qk, Lk(a3, 0), Dk(a3, d3), Ek(a3, B()), c3;
            a3.finishedWork = e2;
            a3.finishedLanes = d3;
            switch (b3) {
              case 0:
              case 1:
                throw Error(p3(345));
              case 2:
                Qk(a3, uk, vk);
                break;
              case 3:
                Dk(a3, d3);
                if ((d3 & 130023424) === d3 && (b3 = gk + 500 - B(), 10 < b3)) {
                  if (0 !== uc(a3, 0))
                    break;
                  e2 = a3.suspendedLanes;
                  if ((e2 & d3) !== d3) {
                    L3();
                    a3.pingedLanes |= a3.suspendedLanes & e2;
                    break;
                  }
                  a3.timeoutHandle = Ff(Qk.bind(null, a3, uk, vk), b3);
                  break;
                }
                Qk(a3, uk, vk);
                break;
              case 4:
                Dk(a3, d3);
                if ((d3 & 4194240) === d3)
                  break;
                b3 = a3.eventTimes;
                for (e2 = -1; 0 < d3; ) {
                  var g3 = 31 - oc(d3);
                  f3 = 1 << g3;
                  g3 = b3[g3];
                  g3 > e2 && (e2 = g3);
                  d3 &= ~f3;
                }
                d3 = e2;
                d3 = B() - d3;
                d3 = (120 > d3 ? 120 : 480 > d3 ? 480 : 1080 > d3 ? 1080 : 1920 > d3 ? 1920 : 3e3 > d3 ? 3e3 : 4320 > d3 ? 4320 : 1960 * mk(d3 / 1960)) - d3;
                if (10 < d3) {
                  a3.timeoutHandle = Ff(Qk.bind(null, a3, uk, vk), d3);
                  break;
                }
                Qk(a3, uk, vk);
                break;
              case 5:
                Qk(a3, uk, vk);
                break;
              default:
                throw Error(p3(329));
            }
          }
        }
        Ek(a3, B());
        return a3.callbackNode === c3 ? Hk.bind(null, a3) : null;
      }
      function Ok(a3, b3) {
        var c3 = tk;
        a3.current.memoizedState.isDehydrated && (Lk(a3, b3).flags |= 256);
        a3 = Jk(a3, b3);
        2 !== a3 && (b3 = uk, uk = c3, null !== b3 && Gj(b3));
        return a3;
      }
      function Gj(a3) {
        null === uk ? uk = a3 : uk.push.apply(uk, a3);
      }
      function Pk(a3) {
        for (var b3 = a3; ; ) {
          if (b3.flags & 16384) {
            var c3 = b3.updateQueue;
            if (null !== c3 && (c3 = c3.stores, null !== c3))
              for (var d3 = 0; d3 < c3.length; d3++) {
                var e2 = c3[d3], f3 = e2.getSnapshot;
                e2 = e2.value;
                try {
                  if (!He(f3(), e2))
                    return false;
                } catch (g3) {
                  return false;
                }
              }
          }
          c3 = b3.child;
          if (b3.subtreeFlags & 16384 && null !== c3)
            c3.return = b3, b3 = c3;
          else {
            if (b3 === a3)
              break;
            for (; null === b3.sibling; ) {
              if (null === b3.return || b3.return === a3)
                return true;
              b3 = b3.return;
            }
            b3.sibling.return = b3.return;
            b3 = b3.sibling;
          }
        }
        return true;
      }
      function Dk(a3, b3) {
        b3 &= ~sk;
        b3 &= ~rk;
        a3.suspendedLanes |= b3;
        a3.pingedLanes &= ~b3;
        for (a3 = a3.expirationTimes; 0 < b3; ) {
          var c3 = 31 - oc(b3), d3 = 1 << c3;
          a3[c3] = -1;
          b3 &= ~d3;
        }
      }
      function Fk(a3) {
        if (0 !== (K & 6))
          throw Error(p3(327));
        Ik();
        var b3 = uc(a3, 0);
        if (0 === (b3 & 1))
          return Ek(a3, B()), null;
        var c3 = Jk(a3, b3);
        if (0 !== a3.tag && 2 === c3) {
          var d3 = xc(a3);
          0 !== d3 && (b3 = d3, c3 = Ok(a3, d3));
        }
        if (1 === c3)
          throw c3 = qk, Lk(a3, 0), Dk(a3, b3), Ek(a3, B()), c3;
        if (6 === c3)
          throw Error(p3(345));
        a3.finishedWork = a3.current.alternate;
        a3.finishedLanes = b3;
        Qk(a3, uk, vk);
        Ek(a3, B());
        return null;
      }
      function Rk(a3, b3) {
        var c3 = K;
        K |= 1;
        try {
          return a3(b3);
        } finally {
          K = c3, 0 === K && (Hj = B() + 500, fg && jg());
        }
      }
      function Sk(a3) {
        null !== xk && 0 === xk.tag && 0 === (K & 6) && Ik();
        var b3 = K;
        K |= 1;
        var c3 = pk.transition, d3 = C2;
        try {
          if (pk.transition = null, C2 = 1, a3)
            return a3();
        } finally {
          C2 = d3, pk.transition = c3, K = b3, 0 === (K & 6) && jg();
        }
      }
      function Ij() {
        gj = fj.current;
        E3(fj);
      }
      function Lk(a3, b3) {
        a3.finishedWork = null;
        a3.finishedLanes = 0;
        var c3 = a3.timeoutHandle;
        -1 !== c3 && (a3.timeoutHandle = -1, Gf(c3));
        if (null !== Y)
          for (c3 = Y.return; null !== c3; ) {
            var d3 = c3;
            wg(d3);
            switch (d3.tag) {
              case 1:
                d3 = d3.type.childContextTypes;
                null !== d3 && void 0 !== d3 && $f();
                break;
              case 3:
                Jh();
                E3(Wf);
                E3(H2);
                Oh();
                break;
              case 5:
                Lh(d3);
                break;
              case 4:
                Jh();
                break;
              case 13:
                E3(M);
                break;
              case 19:
                E3(M);
                break;
              case 10:
                Rg(d3.type._context);
                break;
              case 22:
              case 23:
                Ij();
            }
            c3 = c3.return;
          }
        R3 = a3;
        Y = a3 = wh(a3.current, null);
        Z = gj = b3;
        T3 = 0;
        qk = null;
        sk = rk = hh = 0;
        uk = tk = null;
        if (null !== Wg) {
          for (b3 = 0; b3 < Wg.length; b3++)
            if (c3 = Wg[b3], d3 = c3.interleaved, null !== d3) {
              c3.interleaved = null;
              var e2 = d3.next, f3 = c3.pending;
              if (null !== f3) {
                var g3 = f3.next;
                f3.next = e2;
                d3.next = g3;
              }
              c3.pending = d3;
            }
          Wg = null;
        }
        return a3;
      }
      function Nk(a3, b3) {
        do {
          var c3 = Y;
          try {
            Qg();
            Ph.current = ai;
            if (Sh) {
              for (var d3 = N2.memoizedState; null !== d3; ) {
                var e2 = d3.queue;
                null !== e2 && (e2.pending = null);
                d3 = d3.next;
              }
              Sh = false;
            }
            Rh = 0;
            P2 = O2 = N2 = null;
            Th = false;
            Uh = 0;
            ok.current = null;
            if (null === c3 || null === c3.return) {
              T3 = 1;
              qk = b3;
              Y = null;
              break;
            }
            a: {
              var f3 = a3, g3 = c3.return, h3 = c3, k2 = b3;
              b3 = Z;
              h3.flags |= 32768;
              if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
                var l3 = k2, m3 = h3, q = m3.tag;
                if (0 === (m3.mode & 1) && (0 === q || 11 === q || 15 === q)) {
                  var r3 = m3.alternate;
                  r3 ? (m3.updateQueue = r3.updateQueue, m3.memoizedState = r3.memoizedState, m3.lanes = r3.lanes) : (m3.updateQueue = null, m3.memoizedState = null);
                }
                var y3 = Vi(g3);
                if (null !== y3) {
                  y3.flags &= -257;
                  Wi(y3, g3, h3, f3, b3);
                  y3.mode & 1 && Ti(f3, l3, b3);
                  b3 = y3;
                  k2 = l3;
                  var n3 = b3.updateQueue;
                  if (null === n3) {
                    var t4 = /* @__PURE__ */ new Set();
                    t4.add(k2);
                    b3.updateQueue = t4;
                  } else
                    n3.add(k2);
                  break a;
                } else {
                  if (0 === (b3 & 1)) {
                    Ti(f3, l3, b3);
                    uj();
                    break a;
                  }
                  k2 = Error(p3(426));
                }
              } else if (I && h3.mode & 1) {
                var J = Vi(g3);
                if (null !== J) {
                  0 === (J.flags & 65536) && (J.flags |= 256);
                  Wi(J, g3, h3, f3, b3);
                  Jg(Ki(k2, h3));
                  break a;
                }
              }
              f3 = k2 = Ki(k2, h3);
              4 !== T3 && (T3 = 2);
              null === tk ? tk = [f3] : tk.push(f3);
              f3 = g3;
              do {
                switch (f3.tag) {
                  case 3:
                    f3.flags |= 65536;
                    b3 &= -b3;
                    f3.lanes |= b3;
                    var x3 = Oi(f3, k2, b3);
                    fh(f3, x3);
                    break a;
                  case 1:
                    h3 = k2;
                    var w3 = f3.type, u3 = f3.stateNode;
                    if (0 === (f3.flags & 128) && ("function" === typeof w3.getDerivedStateFromError || null !== u3 && "function" === typeof u3.componentDidCatch && (null === Si || !Si.has(u3)))) {
                      f3.flags |= 65536;
                      b3 &= -b3;
                      f3.lanes |= b3;
                      var F = Ri(f3, h3, b3);
                      fh(f3, F);
                      break a;
                    }
                }
                f3 = f3.return;
              } while (null !== f3);
            }
            Tk(c3);
          } catch (na) {
            b3 = na;
            Y === c3 && null !== c3 && (Y = c3 = c3.return);
            continue;
          }
          break;
        } while (1);
      }
      function Kk() {
        var a3 = nk.current;
        nk.current = ai;
        return null === a3 ? ai : a3;
      }
      function uj() {
        if (0 === T3 || 3 === T3 || 2 === T3)
          T3 = 4;
        null === R3 || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R3, Z);
      }
      function Jk(a3, b3) {
        var c3 = K;
        K |= 2;
        var d3 = Kk();
        if (R3 !== a3 || Z !== b3)
          vk = null, Lk(a3, b3);
        do
          try {
            Uk();
            break;
          } catch (e2) {
            Nk(a3, e2);
          }
        while (1);
        Qg();
        K = c3;
        nk.current = d3;
        if (null !== Y)
          throw Error(p3(261));
        R3 = null;
        Z = 0;
        return T3;
      }
      function Uk() {
        for (; null !== Y; )
          Vk(Y);
      }
      function Mk() {
        for (; null !== Y && !cc(); )
          Vk(Y);
      }
      function Vk(a3) {
        var b3 = Wk(a3.alternate, a3, gj);
        a3.memoizedProps = a3.pendingProps;
        null === b3 ? Tk(a3) : Y = b3;
        ok.current = null;
      }
      function Tk(a3) {
        var b3 = a3;
        do {
          var c3 = b3.alternate;
          a3 = b3.return;
          if (0 === (b3.flags & 32768)) {
            if (c3 = Fj(c3, b3, gj), null !== c3) {
              Y = c3;
              return;
            }
          } else {
            c3 = Jj(c3, b3);
            if (null !== c3) {
              c3.flags &= 32767;
              Y = c3;
              return;
            }
            if (null !== a3)
              a3.flags |= 32768, a3.subtreeFlags = 0, a3.deletions = null;
            else {
              T3 = 6;
              Y = null;
              return;
            }
          }
          b3 = b3.sibling;
          if (null !== b3) {
            Y = b3;
            return;
          }
          Y = b3 = a3;
        } while (null !== b3);
        0 === T3 && (T3 = 5);
      }
      function Qk(a3, b3, c3) {
        var d3 = C2, e2 = pk.transition;
        try {
          pk.transition = null, C2 = 1, Xk(a3, b3, c3, d3);
        } finally {
          pk.transition = e2, C2 = d3;
        }
        return null;
      }
      function Xk(a3, b3, c3, d3) {
        do
          Ik();
        while (null !== xk);
        if (0 !== (K & 6))
          throw Error(p3(327));
        c3 = a3.finishedWork;
        var e2 = a3.finishedLanes;
        if (null === c3)
          return null;
        a3.finishedWork = null;
        a3.finishedLanes = 0;
        if (c3 === a3.current)
          throw Error(p3(177));
        a3.callbackNode = null;
        a3.callbackPriority = 0;
        var f3 = c3.lanes | c3.childLanes;
        Bc(a3, f3);
        a3 === R3 && (Y = R3 = null, Z = 0);
        0 === (c3.subtreeFlags & 2064) && 0 === (c3.flags & 2064) || wk || (wk = true, Gk(hc, function() {
          Ik();
          return null;
        }));
        f3 = 0 !== (c3.flags & 15990);
        if (0 !== (c3.subtreeFlags & 15990) || f3) {
          f3 = pk.transition;
          pk.transition = null;
          var g3 = C2;
          C2 = 1;
          var h3 = K;
          K |= 4;
          ok.current = null;
          Pj(a3, c3);
          ek(c3, a3);
          Oe(Df);
          dd = !!Cf;
          Df = Cf = null;
          a3.current = c3;
          ik(c3, a3, e2);
          dc();
          K = h3;
          C2 = g3;
          pk.transition = f3;
        } else
          a3.current = c3;
        wk && (wk = false, xk = a3, yk = e2);
        f3 = a3.pendingLanes;
        0 === f3 && (Si = null);
        mc(c3.stateNode, d3);
        Ek(a3, B());
        if (null !== b3)
          for (d3 = a3.onRecoverableError, c3 = 0; c3 < b3.length; c3++)
            e2 = b3[c3], d3(e2.value, { componentStack: e2.stack, digest: e2.digest });
        if (Pi)
          throw Pi = false, a3 = Qi, Qi = null, a3;
        0 !== (yk & 1) && 0 !== a3.tag && Ik();
        f3 = a3.pendingLanes;
        0 !== (f3 & 1) ? a3 === Ak ? zk++ : (zk = 0, Ak = a3) : zk = 0;
        jg();
        return null;
      }
      function Ik() {
        if (null !== xk) {
          var a3 = Dc(yk), b3 = pk.transition, c3 = C2;
          try {
            pk.transition = null;
            C2 = 16 > a3 ? 16 : a3;
            if (null === xk)
              var d3 = false;
            else {
              a3 = xk;
              xk = null;
              yk = 0;
              if (0 !== (K & 6))
                throw Error(p3(331));
              var e2 = K;
              K |= 4;
              for (V2 = a3.current; null !== V2; ) {
                var f3 = V2, g3 = f3.child;
                if (0 !== (V2.flags & 16)) {
                  var h3 = f3.deletions;
                  if (null !== h3) {
                    for (var k2 = 0; k2 < h3.length; k2++) {
                      var l3 = h3[k2];
                      for (V2 = l3; null !== V2; ) {
                        var m3 = V2;
                        switch (m3.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Qj(8, m3, f3);
                        }
                        var q = m3.child;
                        if (null !== q)
                          q.return = m3, V2 = q;
                        else
                          for (; null !== V2; ) {
                            m3 = V2;
                            var r3 = m3.sibling, y3 = m3.return;
                            Tj(m3);
                            if (m3 === l3) {
                              V2 = null;
                              break;
                            }
                            if (null !== r3) {
                              r3.return = y3;
                              V2 = r3;
                              break;
                            }
                            V2 = y3;
                          }
                      }
                    }
                    var n3 = f3.alternate;
                    if (null !== n3) {
                      var t4 = n3.child;
                      if (null !== t4) {
                        n3.child = null;
                        do {
                          var J = t4.sibling;
                          t4.sibling = null;
                          t4 = J;
                        } while (null !== t4);
                      }
                    }
                    V2 = f3;
                  }
                }
                if (0 !== (f3.subtreeFlags & 2064) && null !== g3)
                  g3.return = f3, V2 = g3;
                else
                  b:
                    for (; null !== V2; ) {
                      f3 = V2;
                      if (0 !== (f3.flags & 2048))
                        switch (f3.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Qj(9, f3, f3.return);
                        }
                      var x3 = f3.sibling;
                      if (null !== x3) {
                        x3.return = f3.return;
                        V2 = x3;
                        break b;
                      }
                      V2 = f3.return;
                    }
              }
              var w3 = a3.current;
              for (V2 = w3; null !== V2; ) {
                g3 = V2;
                var u3 = g3.child;
                if (0 !== (g3.subtreeFlags & 2064) && null !== u3)
                  u3.return = g3, V2 = u3;
                else
                  b:
                    for (g3 = w3; null !== V2; ) {
                      h3 = V2;
                      if (0 !== (h3.flags & 2048))
                        try {
                          switch (h3.tag) {
                            case 0:
                            case 11:
                            case 15:
                              Rj(9, h3);
                          }
                        } catch (na) {
                          W2(h3, h3.return, na);
                        }
                      if (h3 === g3) {
                        V2 = null;
                        break b;
                      }
                      var F = h3.sibling;
                      if (null !== F) {
                        F.return = h3.return;
                        V2 = F;
                        break b;
                      }
                      V2 = h3.return;
                    }
              }
              K = e2;
              jg();
              if (lc && "function" === typeof lc.onPostCommitFiberRoot)
                try {
                  lc.onPostCommitFiberRoot(kc, a3);
                } catch (na) {
                }
              d3 = true;
            }
            return d3;
          } finally {
            C2 = c3, pk.transition = b3;
          }
        }
        return false;
      }
      function Yk(a3, b3, c3) {
        b3 = Ki(c3, b3);
        b3 = Oi(a3, b3, 1);
        a3 = dh(a3, b3, 1);
        b3 = L3();
        null !== a3 && (Ac(a3, 1, b3), Ek(a3, b3));
      }
      function W2(a3, b3, c3) {
        if (3 === a3.tag)
          Yk(a3, a3, c3);
        else
          for (; null !== b3; ) {
            if (3 === b3.tag) {
              Yk(b3, a3, c3);
              break;
            } else if (1 === b3.tag) {
              var d3 = b3.stateNode;
              if ("function" === typeof b3.type.getDerivedStateFromError || "function" === typeof d3.componentDidCatch && (null === Si || !Si.has(d3))) {
                a3 = Ki(c3, a3);
                a3 = Ri(b3, a3, 1);
                b3 = dh(b3, a3, 1);
                a3 = L3();
                null !== b3 && (Ac(b3, 1, a3), Ek(b3, a3));
                break;
              }
            }
            b3 = b3.return;
          }
      }
      function Ui(a3, b3, c3) {
        var d3 = a3.pingCache;
        null !== d3 && d3.delete(b3);
        b3 = L3();
        a3.pingedLanes |= a3.suspendedLanes & c3;
        R3 === a3 && (Z & c3) === c3 && (4 === T3 || 3 === T3 && (Z & 130023424) === Z && 500 > B() - gk ? Lk(a3, 0) : sk |= c3);
        Ek(a3, b3);
      }
      function Zk(a3, b3) {
        0 === b3 && (0 === (a3.mode & 1) ? b3 = 1 : (b3 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
        var c3 = L3();
        a3 = Zg(a3, b3);
        null !== a3 && (Ac(a3, b3, c3), Ek(a3, c3));
      }
      function vj(a3) {
        var b3 = a3.memoizedState, c3 = 0;
        null !== b3 && (c3 = b3.retryLane);
        Zk(a3, c3);
      }
      function ck(a3, b3) {
        var c3 = 0;
        switch (a3.tag) {
          case 13:
            var d3 = a3.stateNode;
            var e2 = a3.memoizedState;
            null !== e2 && (c3 = e2.retryLane);
            break;
          case 19:
            d3 = a3.stateNode;
            break;
          default:
            throw Error(p3(314));
        }
        null !== d3 && d3.delete(b3);
        Zk(a3, c3);
      }
      var Wk;
      Wk = function(a3, b3, c3) {
        if (null !== a3)
          if (a3.memoizedProps !== b3.pendingProps || Wf.current)
            Ug = true;
          else {
            if (0 === (a3.lanes & c3) && 0 === (b3.flags & 128))
              return Ug = false, zj(a3, b3, c3);
            Ug = 0 !== (a3.flags & 131072) ? true : false;
          }
        else
          Ug = false, I && 0 !== (b3.flags & 1048576) && ug(b3, ng, b3.index);
        b3.lanes = 0;
        switch (b3.tag) {
          case 2:
            var d3 = b3.type;
            jj(a3, b3);
            a3 = b3.pendingProps;
            var e2 = Yf(b3, H2.current);
            Tg(b3, c3);
            e2 = Xh(null, b3, d3, a3, e2, c3);
            var f3 = bi();
            b3.flags |= 1;
            "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b3.tag = 1, b3.memoizedState = null, b3.updateQueue = null, Zf(d3) ? (f3 = true, cg(b3)) : f3 = false, b3.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b3), e2.updater = nh, b3.stateNode = e2, e2._reactInternals = b3, rh(b3, d3, a3, c3), b3 = kj(null, b3, d3, true, f3, c3)) : (b3.tag = 0, I && f3 && vg(b3), Yi(null, b3, e2, c3), b3 = b3.child);
            return b3;
          case 16:
            d3 = b3.elementType;
            a: {
              jj(a3, b3);
              a3 = b3.pendingProps;
              e2 = d3._init;
              d3 = e2(d3._payload);
              b3.type = d3;
              e2 = b3.tag = $k(d3);
              a3 = Lg(d3, a3);
              switch (e2) {
                case 0:
                  b3 = dj(null, b3, d3, a3, c3);
                  break a;
                case 1:
                  b3 = ij(null, b3, d3, a3, c3);
                  break a;
                case 11:
                  b3 = Zi(null, b3, d3, a3, c3);
                  break a;
                case 14:
                  b3 = aj(null, b3, d3, Lg(d3.type, a3), c3);
                  break a;
              }
              throw Error(p3(
                306,
                d3,
                ""
              ));
            }
            return b3;
          case 0:
            return d3 = b3.type, e2 = b3.pendingProps, e2 = b3.elementType === d3 ? e2 : Lg(d3, e2), dj(a3, b3, d3, e2, c3);
          case 1:
            return d3 = b3.type, e2 = b3.pendingProps, e2 = b3.elementType === d3 ? e2 : Lg(d3, e2), ij(a3, b3, d3, e2, c3);
          case 3:
            a: {
              lj(b3);
              if (null === a3)
                throw Error(p3(387));
              d3 = b3.pendingProps;
              f3 = b3.memoizedState;
              e2 = f3.element;
              bh(a3, b3);
              gh(b3, d3, null, c3);
              var g3 = b3.memoizedState;
              d3 = g3.element;
              if (f3.isDehydrated)
                if (f3 = { element: d3, isDehydrated: false, cache: g3.cache, pendingSuspenseBoundaries: g3.pendingSuspenseBoundaries, transitions: g3.transitions }, b3.updateQueue.baseState = f3, b3.memoizedState = f3, b3.flags & 256) {
                  e2 = Ki(Error(p3(423)), b3);
                  b3 = mj(a3, b3, d3, c3, e2);
                  break a;
                } else if (d3 !== e2) {
                  e2 = Ki(Error(p3(424)), b3);
                  b3 = mj(a3, b3, d3, c3, e2);
                  break a;
                } else
                  for (yg = Lf(b3.stateNode.containerInfo.firstChild), xg = b3, I = true, zg = null, c3 = Ch(b3, null, d3, c3), b3.child = c3; c3; )
                    c3.flags = c3.flags & -3 | 4096, c3 = c3.sibling;
              else {
                Ig();
                if (d3 === e2) {
                  b3 = $i(a3, b3, c3);
                  break a;
                }
                Yi(a3, b3, d3, c3);
              }
              b3 = b3.child;
            }
            return b3;
          case 5:
            return Kh(b3), null === a3 && Eg(b3), d3 = b3.type, e2 = b3.pendingProps, f3 = null !== a3 ? a3.memoizedProps : null, g3 = e2.children, Ef(d3, e2) ? g3 = null : null !== f3 && Ef(d3, f3) && (b3.flags |= 32), hj(a3, b3), Yi(a3, b3, g3, c3), b3.child;
          case 6:
            return null === a3 && Eg(b3), null;
          case 13:
            return pj(a3, b3, c3);
          case 4:
            return Ih(b3, b3.stateNode.containerInfo), d3 = b3.pendingProps, null === a3 ? b3.child = Bh(b3, null, d3, c3) : Yi(a3, b3, d3, c3), b3.child;
          case 11:
            return d3 = b3.type, e2 = b3.pendingProps, e2 = b3.elementType === d3 ? e2 : Lg(d3, e2), Zi(a3, b3, d3, e2, c3);
          case 7:
            return Yi(a3, b3, b3.pendingProps, c3), b3.child;
          case 8:
            return Yi(a3, b3, b3.pendingProps.children, c3), b3.child;
          case 12:
            return Yi(a3, b3, b3.pendingProps.children, c3), b3.child;
          case 10:
            a: {
              d3 = b3.type._context;
              e2 = b3.pendingProps;
              f3 = b3.memoizedProps;
              g3 = e2.value;
              G(Mg, d3._currentValue);
              d3._currentValue = g3;
              if (null !== f3)
                if (He(f3.value, g3)) {
                  if (f3.children === e2.children && !Wf.current) {
                    b3 = $i(a3, b3, c3);
                    break a;
                  }
                } else
                  for (f3 = b3.child, null !== f3 && (f3.return = b3); null !== f3; ) {
                    var h3 = f3.dependencies;
                    if (null !== h3) {
                      g3 = f3.child;
                      for (var k2 = h3.firstContext; null !== k2; ) {
                        if (k2.context === d3) {
                          if (1 === f3.tag) {
                            k2 = ch(-1, c3 & -c3);
                            k2.tag = 2;
                            var l3 = f3.updateQueue;
                            if (null !== l3) {
                              l3 = l3.shared;
                              var m3 = l3.pending;
                              null === m3 ? k2.next = k2 : (k2.next = m3.next, m3.next = k2);
                              l3.pending = k2;
                            }
                          }
                          f3.lanes |= c3;
                          k2 = f3.alternate;
                          null !== k2 && (k2.lanes |= c3);
                          Sg(
                            f3.return,
                            c3,
                            b3
                          );
                          h3.lanes |= c3;
                          break;
                        }
                        k2 = k2.next;
                      }
                    } else if (10 === f3.tag)
                      g3 = f3.type === b3.type ? null : f3.child;
                    else if (18 === f3.tag) {
                      g3 = f3.return;
                      if (null === g3)
                        throw Error(p3(341));
                      g3.lanes |= c3;
                      h3 = g3.alternate;
                      null !== h3 && (h3.lanes |= c3);
                      Sg(g3, c3, b3);
                      g3 = f3.sibling;
                    } else
                      g3 = f3.child;
                    if (null !== g3)
                      g3.return = f3;
                    else
                      for (g3 = f3; null !== g3; ) {
                        if (g3 === b3) {
                          g3 = null;
                          break;
                        }
                        f3 = g3.sibling;
                        if (null !== f3) {
                          f3.return = g3.return;
                          g3 = f3;
                          break;
                        }
                        g3 = g3.return;
                      }
                    f3 = g3;
                  }
              Yi(a3, b3, e2.children, c3);
              b3 = b3.child;
            }
            return b3;
          case 9:
            return e2 = b3.type, d3 = b3.pendingProps.children, Tg(b3, c3), e2 = Vg(e2), d3 = d3(e2), b3.flags |= 1, Yi(a3, b3, d3, c3), b3.child;
          case 14:
            return d3 = b3.type, e2 = Lg(d3, b3.pendingProps), e2 = Lg(d3.type, e2), aj(a3, b3, d3, e2, c3);
          case 15:
            return cj(a3, b3, b3.type, b3.pendingProps, c3);
          case 17:
            return d3 = b3.type, e2 = b3.pendingProps, e2 = b3.elementType === d3 ? e2 : Lg(d3, e2), jj(a3, b3), b3.tag = 1, Zf(d3) ? (a3 = true, cg(b3)) : a3 = false, Tg(b3, c3), ph(b3, d3, e2), rh(b3, d3, e2, c3), kj(null, b3, d3, true, a3, c3);
          case 19:
            return yj(a3, b3, c3);
          case 22:
            return ej(a3, b3, c3);
        }
        throw Error(p3(156, b3.tag));
      };
      function Gk(a3, b3) {
        return ac(a3, b3);
      }
      function al(a3, b3, c3, d3) {
        this.tag = a3;
        this.key = c3;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.ref = null;
        this.pendingProps = b3;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = d3;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
      }
      function Bg(a3, b3, c3, d3) {
        return new al(a3, b3, c3, d3);
      }
      function bj(a3) {
        a3 = a3.prototype;
        return !(!a3 || !a3.isReactComponent);
      }
      function $k(a3) {
        if ("function" === typeof a3)
          return bj(a3) ? 1 : 0;
        if (void 0 !== a3 && null !== a3) {
          a3 = a3.$$typeof;
          if (a3 === Da)
            return 11;
          if (a3 === Ga)
            return 14;
        }
        return 2;
      }
      function wh(a3, b3) {
        var c3 = a3.alternate;
        null === c3 ? (c3 = Bg(a3.tag, b3, a3.key, a3.mode), c3.elementType = a3.elementType, c3.type = a3.type, c3.stateNode = a3.stateNode, c3.alternate = a3, a3.alternate = c3) : (c3.pendingProps = b3, c3.type = a3.type, c3.flags = 0, c3.subtreeFlags = 0, c3.deletions = null);
        c3.flags = a3.flags & 14680064;
        c3.childLanes = a3.childLanes;
        c3.lanes = a3.lanes;
        c3.child = a3.child;
        c3.memoizedProps = a3.memoizedProps;
        c3.memoizedState = a3.memoizedState;
        c3.updateQueue = a3.updateQueue;
        b3 = a3.dependencies;
        c3.dependencies = null === b3 ? null : { lanes: b3.lanes, firstContext: b3.firstContext };
        c3.sibling = a3.sibling;
        c3.index = a3.index;
        c3.ref = a3.ref;
        return c3;
      }
      function yh(a3, b3, c3, d3, e2, f3) {
        var g3 = 2;
        d3 = a3;
        if ("function" === typeof a3)
          bj(a3) && (g3 = 1);
        else if ("string" === typeof a3)
          g3 = 5;
        else
          a:
            switch (a3) {
              case ya:
                return Ah(c3.children, e2, f3, b3);
              case za:
                g3 = 8;
                e2 |= 8;
                break;
              case Aa:
                return a3 = Bg(12, c3, b3, e2 | 2), a3.elementType = Aa, a3.lanes = f3, a3;
              case Ea:
                return a3 = Bg(13, c3, b3, e2), a3.elementType = Ea, a3.lanes = f3, a3;
              case Fa:
                return a3 = Bg(19, c3, b3, e2), a3.elementType = Fa, a3.lanes = f3, a3;
              case Ia:
                return qj(c3, e2, f3, b3);
              default:
                if ("object" === typeof a3 && null !== a3)
                  switch (a3.$$typeof) {
                    case Ba:
                      g3 = 10;
                      break a;
                    case Ca:
                      g3 = 9;
                      break a;
                    case Da:
                      g3 = 11;
                      break a;
                    case Ga:
                      g3 = 14;
                      break a;
                    case Ha:
                      g3 = 16;
                      d3 = null;
                      break a;
                  }
                throw Error(p3(130, null == a3 ? a3 : typeof a3, ""));
            }
        b3 = Bg(g3, c3, b3, e2);
        b3.elementType = a3;
        b3.type = d3;
        b3.lanes = f3;
        return b3;
      }
      function Ah(a3, b3, c3, d3) {
        a3 = Bg(7, a3, d3, b3);
        a3.lanes = c3;
        return a3;
      }
      function qj(a3, b3, c3, d3) {
        a3 = Bg(22, a3, d3, b3);
        a3.elementType = Ia;
        a3.lanes = c3;
        a3.stateNode = { isHidden: false };
        return a3;
      }
      function xh(a3, b3, c3) {
        a3 = Bg(6, a3, null, b3);
        a3.lanes = c3;
        return a3;
      }
      function zh(a3, b3, c3) {
        b3 = Bg(4, null !== a3.children ? a3.children : [], a3.key, b3);
        b3.lanes = c3;
        b3.stateNode = { containerInfo: a3.containerInfo, pendingChildren: null, implementation: a3.implementation };
        return b3;
      }
      function bl(a3, b3, c3, d3, e2) {
        this.tag = b3;
        this.containerInfo = a3;
        this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = -1;
        this.callbackNode = this.pendingContext = this.context = null;
        this.callbackPriority = 0;
        this.eventTimes = zc(0);
        this.expirationTimes = zc(-1);
        this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = zc(0);
        this.identifierPrefix = d3;
        this.onRecoverableError = e2;
        this.mutableSourceEagerHydrationData = null;
      }
      function cl(a3, b3, c3, d3, e2, f3, g3, h3, k2) {
        a3 = new bl(a3, b3, c3, h3, k2);
        1 === b3 ? (b3 = 1, true === f3 && (b3 |= 8)) : b3 = 0;
        f3 = Bg(3, null, null, b3);
        a3.current = f3;
        f3.stateNode = a3;
        f3.memoizedState = { element: d3, isDehydrated: c3, cache: null, transitions: null, pendingSuspenseBoundaries: null };
        ah(f3);
        return a3;
      }
      function dl(a3, b3, c3) {
        var d3 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return { $$typeof: wa, key: null == d3 ? null : "" + d3, children: a3, containerInfo: b3, implementation: c3 };
      }
      function el(a3) {
        if (!a3)
          return Vf;
        a3 = a3._reactInternals;
        a: {
          if (Vb(a3) !== a3 || 1 !== a3.tag)
            throw Error(p3(170));
          var b3 = a3;
          do {
            switch (b3.tag) {
              case 3:
                b3 = b3.stateNode.context;
                break a;
              case 1:
                if (Zf(b3.type)) {
                  b3 = b3.stateNode.__reactInternalMemoizedMergedChildContext;
                  break a;
                }
            }
            b3 = b3.return;
          } while (null !== b3);
          throw Error(p3(171));
        }
        if (1 === a3.tag) {
          var c3 = a3.type;
          if (Zf(c3))
            return bg(a3, c3, b3);
        }
        return b3;
      }
      function fl(a3, b3, c3, d3, e2, f3, g3, h3, k2) {
        a3 = cl(c3, d3, true, a3, e2, f3, g3, h3, k2);
        a3.context = el(null);
        c3 = a3.current;
        d3 = L3();
        e2 = lh(c3);
        f3 = ch(d3, e2);
        f3.callback = void 0 !== b3 && null !== b3 ? b3 : null;
        dh(c3, f3, e2);
        a3.current.lanes = e2;
        Ac(a3, e2, d3);
        Ek(a3, d3);
        return a3;
      }
      function gl(a3, b3, c3, d3) {
        var e2 = b3.current, f3 = L3(), g3 = lh(e2);
        c3 = el(c3);
        null === b3.context ? b3.context = c3 : b3.pendingContext = c3;
        b3 = ch(f3, g3);
        b3.payload = { element: a3 };
        d3 = void 0 === d3 ? null : d3;
        null !== d3 && (b3.callback = d3);
        a3 = dh(e2, b3, g3);
        null !== a3 && (mh(a3, e2, g3, f3), eh(a3, e2, g3));
        return g3;
      }
      function hl(a3) {
        a3 = a3.current;
        if (!a3.child)
          return null;
        switch (a3.child.tag) {
          case 5:
            return a3.child.stateNode;
          default:
            return a3.child.stateNode;
        }
      }
      function il(a3, b3) {
        a3 = a3.memoizedState;
        if (null !== a3 && null !== a3.dehydrated) {
          var c3 = a3.retryLane;
          a3.retryLane = 0 !== c3 && c3 < b3 ? c3 : b3;
        }
      }
      function jl(a3, b3) {
        il(a3, b3);
        (a3 = a3.alternate) && il(a3, b3);
      }
      function kl() {
        return null;
      }
      var ll = "function" === typeof reportError ? reportError : function(a3) {
        console.error(a3);
      };
      function ml(a3) {
        this._internalRoot = a3;
      }
      nl.prototype.render = ml.prototype.render = function(a3) {
        var b3 = this._internalRoot;
        if (null === b3)
          throw Error(p3(409));
        gl(a3, b3, null, null);
      };
      nl.prototype.unmount = ml.prototype.unmount = function() {
        var a3 = this._internalRoot;
        if (null !== a3) {
          this._internalRoot = null;
          var b3 = a3.containerInfo;
          Sk(function() {
            gl(null, a3, null, null);
          });
          b3[uf] = null;
        }
      };
      function nl(a3) {
        this._internalRoot = a3;
      }
      nl.prototype.unstable_scheduleHydration = function(a3) {
        if (a3) {
          var b3 = Hc();
          a3 = { blockedOn: null, target: a3, priority: b3 };
          for (var c3 = 0; c3 < Qc.length && 0 !== b3 && b3 < Qc[c3].priority; c3++)
            ;
          Qc.splice(c3, 0, a3);
          0 === c3 && Vc(a3);
        }
      };
      function ol(a3) {
        return !(!a3 || 1 !== a3.nodeType && 9 !== a3.nodeType && 11 !== a3.nodeType);
      }
      function pl(a3) {
        return !(!a3 || 1 !== a3.nodeType && 9 !== a3.nodeType && 11 !== a3.nodeType && (8 !== a3.nodeType || " react-mount-point-unstable " !== a3.nodeValue));
      }
      function ql() {
      }
      function rl(a3, b3, c3, d3, e2) {
        if (e2) {
          if ("function" === typeof d3) {
            var f3 = d3;
            d3 = function() {
              var a4 = hl(g3);
              f3.call(a4);
            };
          }
          var g3 = fl(b3, d3, a3, 0, null, false, false, "", ql);
          a3._reactRootContainer = g3;
          a3[uf] = g3.current;
          sf(8 === a3.nodeType ? a3.parentNode : a3);
          Sk();
          return g3;
        }
        for (; e2 = a3.lastChild; )
          a3.removeChild(e2);
        if ("function" === typeof d3) {
          var h3 = d3;
          d3 = function() {
            var a4 = hl(k2);
            h3.call(a4);
          };
        }
        var k2 = cl(a3, 0, false, null, null, false, false, "", ql);
        a3._reactRootContainer = k2;
        a3[uf] = k2.current;
        sf(8 === a3.nodeType ? a3.parentNode : a3);
        Sk(function() {
          gl(b3, k2, c3, d3);
        });
        return k2;
      }
      function sl(a3, b3, c3, d3, e2) {
        var f3 = c3._reactRootContainer;
        if (f3) {
          var g3 = f3;
          if ("function" === typeof e2) {
            var h3 = e2;
            e2 = function() {
              var a4 = hl(g3);
              h3.call(a4);
            };
          }
          gl(b3, g3, a3, e2);
        } else
          g3 = rl(c3, b3, a3, e2, d3);
        return hl(g3);
      }
      Ec = function(a3) {
        switch (a3.tag) {
          case 3:
            var b3 = a3.stateNode;
            if (b3.current.memoizedState.isDehydrated) {
              var c3 = tc(b3.pendingLanes);
              0 !== c3 && (Cc(b3, c3 | 1), Ek(b3, B()), 0 === (K & 6) && (Hj = B() + 500, jg()));
            }
            break;
          case 13:
            Sk(function() {
              var b4 = Zg(a3, 1);
              if (null !== b4) {
                var c4 = L3();
                mh(b4, a3, 1, c4);
              }
            }), jl(a3, 1);
        }
      };
      Fc = function(a3) {
        if (13 === a3.tag) {
          var b3 = Zg(a3, 134217728);
          if (null !== b3) {
            var c3 = L3();
            mh(b3, a3, 134217728, c3);
          }
          jl(a3, 134217728);
        }
      };
      Gc = function(a3) {
        if (13 === a3.tag) {
          var b3 = lh(a3), c3 = Zg(a3, b3);
          if (null !== c3) {
            var d3 = L3();
            mh(c3, a3, b3, d3);
          }
          jl(a3, b3);
        }
      };
      Hc = function() {
        return C2;
      };
      Ic = function(a3, b3) {
        var c3 = C2;
        try {
          return C2 = a3, b3();
        } finally {
          C2 = c3;
        }
      };
      yb = function(a3, b3, c3) {
        switch (b3) {
          case "input":
            bb(a3, c3);
            b3 = c3.name;
            if ("radio" === c3.type && null != b3) {
              for (c3 = a3; c3.parentNode; )
                c3 = c3.parentNode;
              c3 = c3.querySelectorAll("input[name=" + JSON.stringify("" + b3) + '][type="radio"]');
              for (b3 = 0; b3 < c3.length; b3++) {
                var d3 = c3[b3];
                if (d3 !== a3 && d3.form === a3.form) {
                  var e2 = Db(d3);
                  if (!e2)
                    throw Error(p3(90));
                  Wa(d3);
                  bb(d3, e2);
                }
              }
            }
            break;
          case "textarea":
            ib(a3, c3);
            break;
          case "select":
            b3 = c3.value, null != b3 && fb(a3, !!c3.multiple, b3, false);
        }
      };
      Gb = Rk;
      Hb = Sk;
      var tl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Rk] };
      var ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
      var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a3) {
        a3 = Zb(a3);
        return null === a3 ? null : a3.stateNode;
      }, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
      if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!wl.isDisabled && wl.supportsFiber)
          try {
            kc = wl.inject(vl), lc = wl;
          } catch (a3) {
          }
      }
      var wl;
      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
      exports.createPortal = function(a3, b3) {
        var c3 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!ol(b3))
          throw Error(p3(200));
        return dl(a3, b3, null, c3);
      };
      exports.createRoot = function(a3, b3) {
        if (!ol(a3))
          throw Error(p3(299));
        var c3 = false, d3 = "", e2 = ll;
        null !== b3 && void 0 !== b3 && (true === b3.unstable_strictMode && (c3 = true), void 0 !== b3.identifierPrefix && (d3 = b3.identifierPrefix), void 0 !== b3.onRecoverableError && (e2 = b3.onRecoverableError));
        b3 = cl(a3, 1, false, null, null, c3, false, d3, e2);
        a3[uf] = b3.current;
        sf(8 === a3.nodeType ? a3.parentNode : a3);
        return new ml(b3);
      };
      exports.findDOMNode = function(a3) {
        if (null == a3)
          return null;
        if (1 === a3.nodeType)
          return a3;
        var b3 = a3._reactInternals;
        if (void 0 === b3) {
          if ("function" === typeof a3.render)
            throw Error(p3(188));
          a3 = Object.keys(a3).join(",");
          throw Error(p3(268, a3));
        }
        a3 = Zb(b3);
        a3 = null === a3 ? null : a3.stateNode;
        return a3;
      };
      exports.flushSync = function(a3) {
        return Sk(a3);
      };
      exports.hydrate = function(a3, b3, c3) {
        if (!pl(b3))
          throw Error(p3(200));
        return sl(null, a3, b3, true, c3);
      };
      exports.hydrateRoot = function(a3, b3, c3) {
        if (!ol(a3))
          throw Error(p3(405));
        var d3 = null != c3 && c3.hydratedSources || null, e2 = false, f3 = "", g3 = ll;
        null !== c3 && void 0 !== c3 && (true === c3.unstable_strictMode && (e2 = true), void 0 !== c3.identifierPrefix && (f3 = c3.identifierPrefix), void 0 !== c3.onRecoverableError && (g3 = c3.onRecoverableError));
        b3 = fl(b3, null, a3, 1, null != c3 ? c3 : null, e2, false, f3, g3);
        a3[uf] = b3.current;
        sf(a3);
        if (d3)
          for (a3 = 0; a3 < d3.length; a3++)
            c3 = d3[a3], e2 = c3._getVersion, e2 = e2(c3._source), null == b3.mutableSourceEagerHydrationData ? b3.mutableSourceEagerHydrationData = [c3, e2] : b3.mutableSourceEagerHydrationData.push(
              c3,
              e2
            );
        return new nl(b3);
      };
      exports.render = function(a3, b3, c3) {
        if (!pl(b3))
          throw Error(p3(200));
        return sl(null, a3, b3, false, c3);
      };
      exports.unmountComponentAtNode = function(a3) {
        if (!pl(a3))
          throw Error(p3(40));
        return a3._reactRootContainer ? (Sk(function() {
          sl(null, null, a3, false, function() {
            a3._reactRootContainer = null;
            a3[uf] = null;
          });
        }), true) : false;
      };
      exports.unstable_batchedUpdates = Rk;
      exports.unstable_renderSubtreeIntoContainer = function(a3, b3, c3, d3) {
        if (!pl(c3))
          throw Error(p3(200));
        if (null == a3 || void 0 === a3._reactInternals)
          throw Error(p3(38));
        return sl(a3, b3, c3, false, d3);
      };
      exports.version = "18.2.0-next-9e3b772b8-20220608";
    }
  });

  // ../../../node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "../../../node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        if (false) {
          throw new Error("^_^");
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      if (true) {
        checkDCE();
        module.exports = require_react_dom_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // ../../../node_modules/react-dom/client.js
  var require_client = __commonJS({
    "../../../node_modules/react-dom/client.js"(exports) {
      "use strict";
      var m3 = require_react_dom();
      if (true) {
        exports.createRoot = m3.createRoot;
        exports.hydrateRoot = m3.hydrateRoot;
      } else {
        i3 = m3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        exports.createRoot = function(c3, o3) {
          i3.usingClientEntryPoint = true;
          try {
            return m3.createRoot(c3, o3);
          } finally {
            i3.usingClientEntryPoint = false;
          }
        };
        exports.hydrateRoot = function(c3, h3, o3) {
          i3.usingClientEntryPoint = true;
          try {
            return m3.hydrateRoot(c3, h3, o3);
          } finally {
            i3.usingClientEntryPoint = false;
          }
        };
      }
      var i3;
    }
  });

  // ../../../node_modules/lodash.isequal/index.js
  var require_lodash = __commonJS({
    "../../../node_modules/lodash.isequal/index.js"(exports, module) {
      var LARGE_ARRAY_SIZE = 200;
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      var MAX_SAFE_INTEGER = 9007199254740991;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var asyncTag = "[object AsyncFunction]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var nullTag = "[object Null]";
      var objectTag = "[object Object]";
      var promiseTag = "[object Promise]";
      var proxyTag = "[object Proxy]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var undefinedTag = "[object Undefined]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e2) {
        }
      }();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function arrayFilter(array2, predicate) {
        var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
        while (++index2 < length) {
          var value = array2[index2];
          if (predicate(value, index2, array2)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayPush(array2, values) {
        var index2 = -1, length = values.length, offset = array2.length;
        while (++index2 < length) {
          array2[offset + index2] = values[index2];
        }
        return array2;
      }
      function arraySome(array2, predicate) {
        var index2 = -1, length = array2 == null ? 0 : array2.length;
        while (++index2 < length) {
          if (predicate(array2[index2], index2, array2)) {
            return true;
          }
        }
        return false;
      }
      function baseTimes(n3, iteratee) {
        var index2 = -1, result = Array(n3);
        while (++index2 < n3) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function getValue(object2, key) {
        return object2 == null ? void 0 : object2[key];
      }
      function mapToArray(map) {
        var index2 = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index2] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function setToArray(set) {
        var index2 = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index2] = value;
        });
        return result;
      }
      var arrayProto = Array.prototype;
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var coreJsData = root["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer3 = moduleExports ? root.Buffer : void 0;
      var Symbol2 = root.Symbol;
      var Uint8Array2 = root.Uint8Array;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var splice = arrayProto.splice;
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var nativeIsBuffer = Buffer3 ? Buffer3.isBuffer : void 0;
      var nativeKeys = overArg(Object.keys, Object);
      var DataView2 = getNative(root, "DataView");
      var Map2 = getNative(root, "Map");
      var Promise2 = getNative(root, "Promise");
      var Set2 = getNative(root, "Set");
      var WeakMap2 = getNative(root, "WeakMap");
      var nativeCreate = getNative(Object, "create");
      var dataViewCtorString = toSource(DataView2);
      var mapCtorString = toSource(Map2);
      var promiseCtorString = toSource(Promise2);
      var setCtorString = toSource(Set2);
      var weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function Hash(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty2.call(data, key) ? data[key] : void 0;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index2 == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index2, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        return index2 < 0 ? void 0 : data[index2][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index2][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values) {
        var index2 = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache();
        while (++index2 < length) {
          this.add(values[index2]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack2(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack2.prototype.clear = stackClear;
      Stack2.prototype["delete"] = stackDelete;
      Stack2.prototype.get = stackGet;
      Stack2.prototype.has = stackHas;
      Stack2.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      function assocIndexOf(array2, key) {
        var length = array2.length;
        while (length--) {
          if (eq(array2[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
        var result = keysFunc(object2);
        return isArray(object2) ? result : arrayPush(result, symbolsFunc(object2));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack3) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack3);
      }
      function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack3) {
        var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object2)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack3 || (stack3 = new Stack2());
          return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack3) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack3);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
            stack3 || (stack3 = new Stack2());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack3);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack3 || (stack3 = new Stack2());
        return equalObjects(object2, other, bitmask, customizer, equalFunc, stack3);
      }
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseKeys(object2) {
        if (!isPrototype(object2)) {
          return nativeKeys(object2);
        }
        var result = [];
        for (var key in Object(object2)) {
          if (hasOwnProperty2.call(object2, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      function equalArrays(array2, other, bitmask, customizer, equalFunc, stack3) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var stacked = stack3.get(array2);
        if (stacked && stack3.get(other)) {
          return stacked == other;
        }
        var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
        stack3.set(array2, other);
        stack3.set(other, array2);
        while (++index2 < arrLength) {
          var arrValue = array2[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack3) : customizer(arrValue, othValue, index2, array2, other, stack3);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack3))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack3))) {
            result = false;
            break;
          }
        }
        stack3["delete"](array2);
        stack3["delete"](other);
        return result;
      }
      function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack3) {
        switch (tag) {
          case dataViewTag:
            if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
              return false;
            }
            object2 = object2.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object2, +other);
          case errorTag:
            return object2.name == other.name && object2.message == other.message;
          case regexpTag:
          case stringTag:
            return object2 == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object2.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack3.get(object2);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack3.set(object2, other);
            var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack3);
            stack3["delete"](object2);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object2) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object2, other, bitmask, customizer, equalFunc, stack3) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key = objProps[index2];
          if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
            return false;
          }
        }
        var stacked = stack3.get(object2);
        if (stacked && stack3.get(other)) {
          return stacked == other;
        }
        var result = true;
        stack3.set(object2, other);
        stack3.set(other, object2);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key = objProps[index2];
          var objValue = object2[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack3) : customizer(objValue, othValue, key, object2, other, stack3);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack3) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object2.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack3["delete"](object2);
        stack3["delete"](other);
        return result;
      }
      function getAllKeys(object2) {
        return baseGetAllKeys(object2, keys, getSymbols);
      }
      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getNative(object2, key) {
        var value = getValue(object2, key);
        return baseIsNative(value) ? value : void 0;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = void 0;
          var unmasked = true;
        } catch (e2) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
        if (object2 == null) {
          return [];
        }
        object2 = Object(object2);
        return arrayFilter(nativeGetSymbols(object2), function(symbol) {
          return propertyIsEnumerable.call(object2, symbol);
        });
      };
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result;
        };
      }
      function isIndex(value, length) {
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e2) {
          }
          try {
            return func + "";
          } catch (e2) {
          }
        }
        return "";
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray = Array.isArray;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      function isEqual2(value, other) {
        return baseIsEqual(value, other);
      }
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function keys(object2) {
        return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
      }
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      module.exports = isEqual2;
    }
  });

  // ../../../node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "../../../node_modules/eventemitter3/index.js"(exports, module) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__)
          prefix = false;
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt])
          emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn)
          emitter._events[evt].push(listener);
        else
          emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0)
          emitter._events = new Events();
        else
          delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events, name;
        if (this._eventsCount === 0)
          return names;
        for (name in events = this._events) {
          if (has.call(events, name))
            names.push(prefix ? name.slice(1) : name);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers)
          return [];
        if (handlers.fn)
          return [handlers.fn];
        for (var i3 = 0, l3 = handlers.length, ee = new Array(l3); i3 < l3; i3++) {
          ee[i3] = handlers[i3].fn;
        }
        return ee;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners)
          return 0;
        if (listeners.fn)
          return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a22, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return false;
        var listeners = this._events[evt], len = arguments.length, args, i3;
        if (listeners.fn) {
          if (listeners.once)
            this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a22), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a22, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a22, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a22, a3, a4, a5), true;
          }
          for (i3 = 1, args = new Array(len - 1); i3 < len; i3++) {
            args[i3 - 1] = arguments[i3];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j;
          for (i3 = 0; i3 < length; i3++) {
            if (listeners[i3].once)
              this.removeListener(event, listeners[i3].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i3].fn.call(listeners[i3].context);
                break;
              case 2:
                listeners[i3].fn.call(listeners[i3].context, a1);
                break;
              case 3:
                listeners[i3].fn.call(listeners[i3].context, a1, a22);
                break;
              case 4:
                listeners[i3].fn.call(listeners[i3].context, a1, a22, a3);
                break;
              default:
                if (!args)
                  for (j = 1, args = new Array(len - 1); j < len; j++) {
                    args[j - 1] = arguments[j];
                  }
                listeners[i3].fn.apply(listeners[i3].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context) {
        return addListener(this, event, fn, context, false);
      };
      EventEmitter2.prototype.once = function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt])
          return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i3 = 0, events = [], length = listeners.length; i3 < length; i3++) {
            if (listeners[i3].fn !== fn || once && !listeners[i3].once || context && listeners[i3].context !== context) {
              events.push(listeners[i3]);
            }
          }
          if (events.length)
            this._events[evt] = events.length === 1 ? events[0] : events;
          else
            clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt])
            clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      if ("undefined" !== typeof module) {
        module.exports = EventEmitter2;
      }
    }
  });

  // ../../../node_modules/react/cjs/react-jsx-runtime.production.min.js
  var require_react_jsx_runtime_production_min = __commonJS({
    "../../../node_modules/react/cjs/react-jsx-runtime.production.min.js"(exports) {
      "use strict";
      var f3 = require_react();
      var k2 = Symbol.for("react.element");
      var l3 = Symbol.for("react.fragment");
      var m3 = Object.prototype.hasOwnProperty;
      var n3 = f3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;
      var p3 = { key: true, ref: true, __self: true, __source: true };
      function q(c3, a3, g3) {
        var b3, d3 = {}, e2 = null, h3 = null;
        void 0 !== g3 && (e2 = "" + g3);
        void 0 !== a3.key && (e2 = "" + a3.key);
        void 0 !== a3.ref && (h3 = a3.ref);
        for (b3 in a3)
          m3.call(a3, b3) && !p3.hasOwnProperty(b3) && (d3[b3] = a3[b3]);
        if (c3 && c3.defaultProps)
          for (b3 in a3 = c3.defaultProps, a3)
            void 0 === d3[b3] && (d3[b3] = a3[b3]);
        return { $$typeof: k2, type: c3, key: e2, ref: h3, props: d3, _owner: n3.current };
      }
      exports.Fragment = l3;
      exports.jsx = q;
      exports.jsxs = q;
    }
  });

  // ../../../node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "../../../node_modules/react/jsx-runtime.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_react_jsx_runtime_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // ../../../node_modules/classnames/index.js
  var require_classnames = __commonJS({
    "../../../node_modules/classnames/index.js"(exports, module) {
      (function() {
        "use strict";
        var hasOwn = {}.hasOwnProperty;
        var nativeCodeString = "[native code]";
        function classNames21() {
          var classes = [];
          for (var i3 = 0; i3 < arguments.length; i3++) {
            var arg = arguments[i3];
            if (!arg)
              continue;
            var argType = typeof arg;
            if (argType === "string" || argType === "number") {
              classes.push(arg);
            } else if (Array.isArray(arg)) {
              if (arg.length) {
                var inner = classNames21.apply(null, arg);
                if (inner) {
                  classes.push(inner);
                }
              }
            } else if (argType === "object") {
              if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
                classes.push(arg.toString());
                continue;
              }
              for (var key in arg) {
                if (hasOwn.call(arg, key) && arg[key]) {
                  classes.push(key);
                }
              }
            }
          }
          return classes.join(" ");
        }
        if (typeof module !== "undefined" && module.exports) {
          classNames21.default = classNames21;
          module.exports = classNames21;
        } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
          define("classnames", [], function() {
            return classNames21;
          });
        } else {
          window.classNames = classNames21;
        }
      })();
    }
  });

  // ../../../node_modules/lodash.uniq/index.js
  var require_lodash2 = __commonJS({
    "../../../node_modules/lodash.uniq/index.js"(exports, module) {
      var LARGE_ARRAY_SIZE = 200;
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var INFINITY = 1 / 0;
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      function arrayIncludes(array2, value) {
        var length = array2 ? array2.length : 0;
        return !!length && baseIndexOf(array2, value, 0) > -1;
      }
      function arrayIncludesWith(array2, value, comparator) {
        var index2 = -1, length = array2 ? array2.length : 0;
        while (++index2 < length) {
          if (comparator(value, array2[index2])) {
            return true;
          }
        }
        return false;
      }
      function baseFindIndex(array2, predicate, fromIndex, fromRight) {
        var length = array2.length, index2 = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index2-- : ++index2 < length) {
          if (predicate(array2[index2], index2, array2)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIndexOf(array2, value, fromIndex) {
        if (value !== value) {
          return baseFindIndex(array2, baseIsNaN, fromIndex);
        }
        var index2 = fromIndex - 1, length = array2.length;
        while (++index2 < length) {
          if (array2[index2] === value) {
            return index2;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function getValue(object2, key) {
        return object2 == null ? void 0 : object2[key];
      }
      function isHostObject(value) {
        var result = false;
        if (value != null && typeof value.toString != "function") {
          try {
            result = !!(value + "");
          } catch (e2) {
          }
        }
        return result;
      }
      function setToArray(set) {
        var index2 = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index2] = value;
        });
        return result;
      }
      var arrayProto = Array.prototype;
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var coreJsData = root["__core-js_shared__"];
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var objectToString = objectProto.toString;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var splice = arrayProto.splice;
      var Map2 = getNative(root, "Map");
      var Set2 = getNative(root, "Set");
      var nativeCreate = getNative(Object, "create");
      function Hash(entries) {
        var index2 = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
      }
      function hashDelete(key) {
        return this.has(key) && delete this.__data__[key];
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty2.call(data, key) ? data[key] : void 0;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index2 = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
      }
      function listCacheDelete(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index2 == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index2, 1);
        }
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        return index2 < 0 ? void 0 : data[index2][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          data.push([key, value]);
        } else {
          data[index2][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index2 = -1, length = entries ? entries.length : 0;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        return getMapData(this, key)["delete"](key);
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        getMapData(this, key).set(key, value);
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values) {
        var index2 = -1, length = values ? values.length : 0;
        this.__data__ = new MapCache();
        while (++index2 < length) {
          this.add(values[index2]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function assocIndexOf(array2, key) {
        var length = array2.length;
        while (length--) {
          if (eq(array2[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseUniq(array2, iteratee, comparator) {
        var index2 = -1, includes = arrayIncludes, length = array2.length, isCommon = true, result = [], seen = result;
        if (comparator) {
          isCommon = false;
          includes = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set = iteratee ? null : createSet(array2);
          if (set) {
            return setToArray(set);
          }
          isCommon = false;
          includes = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee ? [] : result;
        }
        outer:
          while (++index2 < length) {
            var value = array2[index2], computed2 = iteratee ? iteratee(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed2) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed2);
              }
              result.push(value);
            } else if (!includes(seen, computed2, comparator)) {
              if (seen !== result) {
                seen.push(computed2);
              }
              result.push(value);
            }
          }
        return result;
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop3 : function(values) {
        return new Set2(values);
      };
      function getMapData(map, key) {
        var data = map.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getNative(object2, key) {
        var value = getValue(object2, key);
        return baseIsNative(value) ? value : void 0;
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e2) {
          }
          try {
            return func + "";
          } catch (e2) {
          }
        }
        return "";
      }
      function uniq3(array2) {
        return array2 && array2.length ? baseUniq(array2) : [];
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      function isFunction(value) {
        var tag = isObject(value) ? objectToString.call(value) : "";
        return tag == funcTag || tag == genTag;
      }
      function isObject(value) {
        var type = typeof value;
        return !!value && (type == "object" || type == "function");
      }
      function noop3() {
      }
      module.exports = uniq3;
    }
  });

  // ../../../node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "../../../node_modules/base64-js/index.js"(exports) {
      "use strict";
      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i3 = 0, len = code3.length; i3 < len; ++i3) {
        lookup[i3] = code3[i3];
        revLookup[code3.charCodeAt(i3)] = i3;
      }
      var i3;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i4;
        for (i4 = 0; i4 < len2; i4 += 4) {
          tmp = revLookup[b64.charCodeAt(i4)] << 18 | revLookup[b64.charCodeAt(i4 + 1)] << 12 | revLookup[b64.charCodeAt(i4 + 2)] << 6 | revLookup[b64.charCodeAt(i4 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i4)] << 2 | revLookup[b64.charCodeAt(i4 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i4)] << 10 | revLookup[b64.charCodeAt(i4 + 1)] << 4 | revLookup[b64.charCodeAt(i4 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i4 = start; i4 < end; i4 += 3) {
          tmp = (uint8[i4] << 16 & 16711680) + (uint8[i4 + 1] << 8 & 65280) + (uint8[i4 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i4 = 0, len22 = len2 - extraBytes; i4 < len22; i4 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i4, i4 + maxChunkLength > len22 ? len22 : i4 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
          );
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(
            lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
          );
        }
        return parts.join("");
      }
    }
  });

  // ../../../node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "../../../node_modules/ieee754/index.js"(exports) {
      exports.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e2, m3;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i3 = isLE ? nBytes - 1 : 0;
        var d3 = isLE ? -1 : 1;
        var s3 = buffer[offset + i3];
        i3 += d3;
        e2 = s3 & (1 << -nBits) - 1;
        s3 >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i3], i3 += d3, nBits -= 8) {
        }
        m3 = e2 & (1 << -nBits) - 1;
        e2 >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m3 = m3 * 256 + buffer[offset + i3], i3 += d3, nBits -= 8) {
        }
        if (e2 === 0) {
          e2 = 1 - eBias;
        } else if (e2 === eMax) {
          return m3 ? NaN : (s3 ? -1 : 1) * Infinity;
        } else {
          m3 = m3 + Math.pow(2, mLen);
          e2 = e2 - eBias;
        }
        return (s3 ? -1 : 1) * m3 * Math.pow(2, e2 - mLen);
      };
      exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e2, m3, c3;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i3 = isLE ? 0 : nBytes - 1;
        var d3 = isLE ? 1 : -1;
        var s3 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m3 = isNaN(value) ? 1 : 0;
          e2 = eMax;
        } else {
          e2 = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c3 = Math.pow(2, -e2)) < 1) {
            e2--;
            c3 *= 2;
          }
          if (e2 + eBias >= 1) {
            value += rt / c3;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c3 >= 2) {
            e2++;
            c3 /= 2;
          }
          if (e2 + eBias >= eMax) {
            m3 = 0;
            e2 = eMax;
          } else if (e2 + eBias >= 1) {
            m3 = (value * c3 - 1) * Math.pow(2, mLen);
            e2 = e2 + eBias;
          } else {
            m3 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e2 = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i3] = m3 & 255, i3 += d3, m3 /= 256, mLen -= 8) {
        }
        e2 = e2 << mLen | m3;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i3] = e2 & 255, i3 += d3, e2 /= 256, eLen -= 8) {
        }
        buffer[offset + i3 - d3] |= s3 * 128;
      };
    }
  });

  // ../../../node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "../../../node_modules/buffer/index.js"(exports) {
      "use strict";
      var base64 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports.Buffer = Buffer3;
      exports.SlowBuffer = SlowBuffer;
      exports.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports.kMaxLength = K_MAX_LENGTH;
      Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new Uint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e2) {
          return false;
        }
      }
      Object.defineProperty(Buffer3.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer3.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer3.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer3.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer2(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new Uint8Array(length);
        Object.setPrototypeOf(buf, Buffer3.prototype);
        return buf;
      }
      function Buffer3(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer3.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer3.from(valueOf, encodingOrOffset, length);
        }
        const b3 = fromObject(value);
        if (b3)
          return b3;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer3.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer3, Uint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer2(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer2(size).fill(fill, encoding) : createBuffer2(size).fill(fill);
        }
        return createBuffer2(size);
      }
      Buffer3.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer2(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer3.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer3.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string2, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength(string2, encoding) | 0;
        let buf = createBuffer2(length);
        const actual = buf.write(string2, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array2) {
        const length = array2.length < 0 ? 0 : checked(array2.length) | 0;
        const buf = createBuffer2(length);
        for (let i3 = 0; i3 < length; i3 += 1) {
          buf[i3] = array2[i3] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          const copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array2, byteOffset, length) {
        if (byteOffset < 0 || array2.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array2.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new Uint8Array(array2);
        } else if (length === void 0) {
          buf = new Uint8Array(array2, byteOffset);
        } else {
          buf = new Uint8Array(array2, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer3.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer3.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer2(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer2(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer3.alloc(+length);
      }
      Buffer3.isBuffer = function isBuffer(b3) {
        return b3 != null && b3._isBuffer === true && b3 !== Buffer3.prototype;
      };
      Buffer3.compare = function compare(a3, b3) {
        if (isInstance(a3, Uint8Array))
          a3 = Buffer3.from(a3, a3.offset, a3.byteLength);
        if (isInstance(b3, Uint8Array))
          b3 = Buffer3.from(b3, b3.offset, b3.byteLength);
        if (!Buffer3.isBuffer(a3) || !Buffer3.isBuffer(b3)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a3 === b3)
          return 0;
        let x3 = a3.length;
        let y3 = b3.length;
        for (let i3 = 0, len = Math.min(x3, y3); i3 < len; ++i3) {
          if (a3[i3] !== b3[i3]) {
            x3 = a3[i3];
            y3 = b3[i3];
            break;
          }
        }
        if (x3 < y3)
          return -1;
        if (y3 < x3)
          return 1;
        return 0;
      };
      Buffer3.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer3.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer3.alloc(0);
        }
        let i3;
        if (length === void 0) {
          length = 0;
          for (i3 = 0; i3 < list.length; ++i3) {
            length += list[i3].length;
          }
        }
        const buffer = Buffer3.allocUnsafe(length);
        let pos = 0;
        for (i3 = 0; i3 < list.length; ++i3) {
          let buf = list[i3];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer3.isBuffer(buf))
                buf = Buffer3.from(buf);
              buf.copy(buffer, pos);
            } else {
              Uint8Array.prototype.set.call(
                buffer,
                buf,
                pos
              );
            }
          } else if (!Buffer3.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string2, encoding) {
        if (Buffer3.isBuffer(string2)) {
          return string2.length;
        }
        if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
          return string2.byteLength;
        }
        if (typeof string2 !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2
          );
        }
        const len = string2.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string2).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string2).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string2).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer3.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer3.prototype._isBuffer = true;
      function swap(b3, n3, m3) {
        const i3 = b3[n3];
        b3[n3] = b3[m3];
        b3[m3] = i3;
      }
      Buffer3.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i3 = 0; i3 < len; i3 += 2) {
          swap(this, i3, i3 + 1);
        }
        return this;
      };
      Buffer3.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i3 = 0; i3 < len; i3 += 4) {
          swap(this, i3, i3 + 3);
          swap(this, i3 + 1, i3 + 2);
        }
        return this;
      };
      Buffer3.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i3 = 0; i3 < len; i3 += 8) {
          swap(this, i3, i3 + 7);
          swap(this, i3 + 1, i3 + 6);
          swap(this, i3 + 2, i3 + 5);
          swap(this, i3 + 3, i3 + 4);
        }
        return this;
      };
      Buffer3.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
      Buffer3.prototype.equals = function equals2(b3) {
        if (!Buffer3.isBuffer(b3))
          throw new TypeError("Argument must be a Buffer");
        if (this === b3)
          return true;
        return Buffer3.compare(this, b3) === 0;
      };
      Buffer3.prototype.inspect = function inspect() {
        let str = "";
        const max = exports.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
      }
      Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer3.from(target, target.offset, target.byteLength);
        }
        if (!Buffer3.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x3 = thisEnd - thisStart;
        let y3 = end - start;
        const len = Math.min(x3, y3);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i3 = 0; i3 < len; ++i3) {
          if (thisCopy[i3] !== targetCopy[i3]) {
            x3 = thisCopy[i3];
            y3 = targetCopy[i3];
            break;
          }
        }
        if (x3 < y3)
          return -1;
        if (y3 < x3)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer3.from(val, encoding);
        }
        if (Buffer3.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i4) {
          if (indexSize === 1) {
            return buf[i4];
          } else {
            return buf.readUInt16BE(i4 * indexSize);
          }
        }
        let i3;
        if (dir) {
          let foundIndex = -1;
          for (i3 = byteOffset; i3 < arrLength; i3++) {
            if (read(arr, i3) === read(val, foundIndex === -1 ? 0 : i3 - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i3;
              if (i3 - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i3 -= i3 - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i3 = byteOffset; i3 >= 0; i3--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read(arr, i3 + j) !== read(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i3;
          }
        }
        return -1;
      }
      Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string2, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string2.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i3;
        for (i3 = 0; i3 < length; ++i3) {
          const parsed = parseInt(string2.substr(i3 * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i3;
          buf[offset + i3] = parsed;
        }
        return i3;
      }
      function utf8Write(buf, string2, offset, length) {
        return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string2, offset, length) {
        return blitBuffer(asciiToBytes(string2), buf, offset, length);
      }
      function base64Write(buf, string2, offset, length) {
        return blitBuffer(base64ToBytes(string2), buf, offset, length);
      }
      function ucs2Write(buf, string2, offset, length) {
        return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length);
      }
      Buffer3.prototype.write = function write(string2, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining)
          length = remaining;
        if (string2.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string2, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string2, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string2, offset, length);
            case "base64":
              return base64Write(this, string2, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string2, offset, length);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer3.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i3 = start;
        while (i3 < end) {
          const firstByte = buf[i3];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i3 + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i3 + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i3 + 1];
                thirdByte = buf[i3 + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i3 + 1];
                thirdByte = buf[i3 + 2];
                fourthByte = buf[i3 + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i3 += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i3 = 0;
        while (i3 < len) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i3, i3 += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i3 = start; i3 < end; ++i3) {
          ret += String.fromCharCode(buf[i3] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i3 = start; i3 < end; ++i3) {
          ret += String.fromCharCode(buf[i3]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        let out = "";
        for (let i3 = start; i3 < end; ++i3) {
          out += hexSliceLookupTable[buf[i3]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i3 = 0; i3 < bytes.length - 1; i3 += 2) {
          res += String.fromCharCode(bytes[i3] + bytes[i3 + 1] * 256);
        }
        return res;
      }
      Buffer3.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer3.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i3 = 0;
        while (++i3 < byteLength2 && (mul *= 256)) {
          val += this[offset + i3] * mul;
        }
        return val;
      };
      Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last2 = this[offset + 7];
        if (first === void 0 || last2 === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * __pow(2, 8) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 24);
        const hi = this[++offset] + this[++offset] * __pow(2, 8) + this[++offset] * __pow(2, 16) + last2 * __pow(2, 24);
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last2 = this[offset + 7];
        if (first === void 0 || last2 === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * __pow(2, 24) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + this[++offset];
        const lo = this[++offset] * __pow(2, 24) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + last2;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i3 = 0;
        while (++i3 < byteLength2 && (mul *= 256)) {
          val += this[offset + i3] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let i3 = byteLength2;
        let mul = 1;
        let val = this[offset + --i3];
        while (i3 > 0 && (mul *= 256)) {
          val += this[offset + --i3] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last2 = this[offset + 7];
        if (first === void 0 || last2 === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * __pow(2, 8) + this[offset + 6] * __pow(2, 16) + (last2 << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * __pow(2, 8) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 24));
      });
      Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last2 = this[offset + 7];
        if (first === void 0 || last2 === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * __pow(2, 24) + this[++offset] * __pow(2, 16) + this[++offset] * __pow(2, 8) + last2);
      });
      Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min2) {
        if (!Buffer3.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min2)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i3 = 0;
        this[offset] = value & 255;
        while (++i3 < byteLength2 && (mul *= 256)) {
          this[offset + i3] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i3 = byteLength2 - 1;
        let mul = 1;
        this[offset + i3] = value & 255;
        while (--i3 >= 0 && (mul *= 256)) {
          this[offset + i3] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min2, max) {
        checkIntBI(value, min2, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min2, max) {
        checkIntBI(value, min2, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i3 = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i3 < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i3 - 1] !== 0) {
            sub = 1;
          }
          this[offset + i3] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i3 = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i3] = value & 255;
        while (--i3 >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i3 + 1] !== 0) {
            sub = 1;
          }
          this[offset + i3] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min2) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer3.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len;
      };
      Buffer3.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code3 = val.charCodeAt(0);
            if (encoding === "utf8" && code3 < 128 || encoding === "latin1") {
              val = code3;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i3;
        if (typeof val === "number") {
          for (i3 = start; i3 < end; ++i3) {
            this[i3] = val;
          }
        } else {
          const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i3 = 0; i3 < end - start; ++i3) {
            this[i3 + start] = bytes[i3 % len];
          }
        }
        return this;
      };
      var errors = {};
      function E3(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E3(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E3(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E3(
        "ERR_OUT_OF_RANGE",
        function(str, range, input) {
          let msg2 = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > __pow(2, 32)) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > __pow(BigInt(2), BigInt(32)) || input < -__pow(BigInt(2), BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg2 += ` It must be ${range}. Received ${received}`;
          return msg2;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i3 = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i3 >= start + 4; i3 -= 3) {
          res = `_${val.slice(i3 - 3, i3)}${res}`;
        }
        return `${val.slice(0, i3)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min2, max, buf, offset, byteLength2) {
        if (value > max || value < min2) {
          const n3 = typeof min2 === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min2 === 0 || min2 === BigInt(0)) {
              range = `>= 0${n3} and < 2${n3} ** ${(byteLength2 + 1) * 8}${n3}`;
            } else {
              range = `>= -(2${n3} ** ${(byteLength2 + 1) * 8 - 1}${n3}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n3}`;
            }
          } else {
            range = `>= ${min2}${n3} and <= ${max}${n3}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          type || "offset",
          `>= ${type ? 1 : 0} and <= ${length}`,
          value
        );
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string2, units) {
        units = units || Infinity;
        let codePoint;
        const length = string2.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i3 = 0; i3 < length; ++i3) {
          codePoint = string2.charCodeAt(i3);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i3 + 1 === length) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i3 = 0; i3 < str.length; ++i3) {
          byteArray.push(str.charCodeAt(i3) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c3, hi, lo;
        const byteArray = [];
        for (let i3 = 0; i3 < str.length; ++i3) {
          if ((units -= 2) < 0)
            break;
          c3 = str.charCodeAt(i3);
          hi = c3 >> 8;
          lo = c3 % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i3;
        for (i3 = 0; i3 < length; ++i3) {
          if (i3 + offset >= dst.length || i3 >= src.length)
            break;
          dst[i3 + offset] = src[i3];
        }
        return i3;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i3 = 0; i3 < 16; ++i3) {
          const i16 = i3 * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i3] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // ../../../node_modules/lodash.throttle/index.js
  var require_lodash3 = __commonJS({
    "../../../node_modules/lodash.throttle/index.js"(exports, module) {
      var FUNC_ERROR_TEXT = "Expected a function";
      var NAN = 0 / 0;
      var symbolTag = "[object Symbol]";
      var reTrim = /^\s+|\s+$/g;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var objectProto = Object.prototype;
      var objectToString = objectProto.toString;
      var nativeMax = Math.max;
      var nativeMin = Math.min;
      var now = function() {
        return root.Date.now();
      };
      function debounce2(func, wait, options) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
          return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = void 0;
          return result;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
          return timerId === void 0 ? result : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      function throttle4(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce2(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function isObject(value) {
        var type = typeof value;
        return !!value && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, "");
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      module.exports = throttle4;
    }
  });

  // ../../../node_modules/lz-string/libs/lz-string.js
  var require_lz_string = __commonJS({
    "../../../node_modules/lz-string/libs/lz-string.js"(exports, module) {
      var LZString = function() {
        var f3 = String.fromCharCode;
        var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
        var baseReverseDic = {};
        function getBaseValue(alphabet, character) {
          if (!baseReverseDic[alphabet]) {
            baseReverseDic[alphabet] = {};
            for (var i3 = 0; i3 < alphabet.length; i3++) {
              baseReverseDic[alphabet][alphabet.charAt(i3)] = i3;
            }
          }
          return baseReverseDic[alphabet][character];
        }
        var LZString2 = {
          compressToBase64: function(input) {
            if (input == null)
              return "";
            var res = LZString2._compress(input, 6, function(a3) {
              return keyStrBase64.charAt(a3);
            });
            switch (res.length % 4) {
              default:
              case 0:
                return res;
              case 1:
                return res + "===";
              case 2:
                return res + "==";
              case 3:
                return res + "=";
            }
          },
          decompressFromBase64: function(input) {
            if (input == null)
              return "";
            if (input == "")
              return null;
            return LZString2._decompress(input.length, 32, function(index2) {
              return getBaseValue(keyStrBase64, input.charAt(index2));
            });
          },
          compressToUTF16: function(input) {
            if (input == null)
              return "";
            return LZString2._compress(input, 15, function(a3) {
              return f3(a3 + 32);
            }) + " ";
          },
          decompressFromUTF16: function(compressed) {
            if (compressed == null)
              return "";
            if (compressed == "")
              return null;
            return LZString2._decompress(compressed.length, 16384, function(index2) {
              return compressed.charCodeAt(index2) - 32;
            });
          },
          //compress into uint8array (UCS-2 big endian format)
          compressToUint8Array: function(uncompressed) {
            var compressed = LZString2.compress(uncompressed);
            var buf = new Uint8Array(compressed.length * 2);
            for (var i3 = 0, TotalLen = compressed.length; i3 < TotalLen; i3++) {
              var current_value = compressed.charCodeAt(i3);
              buf[i3 * 2] = current_value >>> 8;
              buf[i3 * 2 + 1] = current_value % 256;
            }
            return buf;
          },
          //decompress from uint8array (UCS-2 big endian format)
          decompressFromUint8Array: function(compressed) {
            if (compressed === null || compressed === void 0) {
              return LZString2.decompress(compressed);
            } else {
              var buf = new Array(compressed.length / 2);
              for (var i3 = 0, TotalLen = buf.length; i3 < TotalLen; i3++) {
                buf[i3] = compressed[i3 * 2] * 256 + compressed[i3 * 2 + 1];
              }
              var result = [];
              buf.forEach(function(c3) {
                result.push(f3(c3));
              });
              return LZString2.decompress(result.join(""));
            }
          },
          //compress into a string that is already URI encoded
          compressToEncodedURIComponent: function(input) {
            if (input == null)
              return "";
            return LZString2._compress(input, 6, function(a3) {
              return keyStrUriSafe.charAt(a3);
            });
          },
          //decompress from an output of compressToEncodedURIComponent
          decompressFromEncodedURIComponent: function(input) {
            if (input == null)
              return "";
            if (input == "")
              return null;
            input = input.replace(/ /g, "+");
            return LZString2._decompress(input.length, 32, function(index2) {
              return getBaseValue(keyStrUriSafe, input.charAt(index2));
            });
          },
          compress: function(uncompressed) {
            return LZString2._compress(uncompressed, 16, function(a3) {
              return f3(a3);
            });
          },
          _compress: function(uncompressed, bitsPerChar, getCharFromInt) {
            if (uncompressed == null)
              return "";
            var i3, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;
            for (ii = 0; ii < uncompressed.length; ii += 1) {
              context_c = uncompressed.charAt(ii);
              if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
                context_dictionary[context_c] = context_dictSize++;
                context_dictionaryToCreate[context_c] = true;
              }
              context_wc = context_w + context_c;
              if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
                context_w = context_wc;
              } else {
                if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                  if (context_w.charCodeAt(0) < 256) {
                    for (i3 = 0; i3 < context_numBits; i3++) {
                      context_data_val = context_data_val << 1;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                    }
                    value = context_w.charCodeAt(0);
                    for (i3 = 0; i3 < 8; i3++) {
                      context_data_val = context_data_val << 1 | value & 1;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                      value = value >> 1;
                    }
                  } else {
                    value = 1;
                    for (i3 = 0; i3 < context_numBits; i3++) {
                      context_data_val = context_data_val << 1 | value;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                      value = 0;
                    }
                    value = context_w.charCodeAt(0);
                    for (i3 = 0; i3 < 16; i3++) {
                      context_data_val = context_data_val << 1 | value & 1;
                      if (context_data_position == bitsPerChar - 1) {
                        context_data_position = 0;
                        context_data.push(getCharFromInt(context_data_val));
                        context_data_val = 0;
                      } else {
                        context_data_position++;
                      }
                      value = value >> 1;
                    }
                  }
                  context_enlargeIn--;
                  if (context_enlargeIn == 0) {
                    context_enlargeIn = Math.pow(2, context_numBits);
                    context_numBits++;
                  }
                  delete context_dictionaryToCreate[context_w];
                } else {
                  value = context_dictionary[context_w];
                  for (i3 = 0; i3 < context_numBits; i3++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                }
                context_enlargeIn--;
                if (context_enlargeIn == 0) {
                  context_enlargeIn = Math.pow(2, context_numBits);
                  context_numBits++;
                }
                context_dictionary[context_wc] = context_dictSize++;
                context_w = String(context_c);
              }
            }
            if (context_w !== "") {
              if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
                if (context_w.charCodeAt(0) < 256) {
                  for (i3 = 0; i3 < context_numBits; i3++) {
                    context_data_val = context_data_val << 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                  }
                  value = context_w.charCodeAt(0);
                  for (i3 = 0; i3 < 8; i3++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                } else {
                  value = 1;
                  for (i3 = 0; i3 < context_numBits; i3++) {
                    context_data_val = context_data_val << 1 | value;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = 0;
                  }
                  value = context_w.charCodeAt(0);
                  for (i3 = 0; i3 < 16; i3++) {
                    context_data_val = context_data_val << 1 | value & 1;
                    if (context_data_position == bitsPerChar - 1) {
                      context_data_position = 0;
                      context_data.push(getCharFromInt(context_data_val));
                      context_data_val = 0;
                    } else {
                      context_data_position++;
                    }
                    value = value >> 1;
                  }
                }
                context_enlargeIn--;
                if (context_enlargeIn == 0) {
                  context_enlargeIn = Math.pow(2, context_numBits);
                  context_numBits++;
                }
                delete context_dictionaryToCreate[context_w];
              } else {
                value = context_dictionary[context_w];
                for (i3 = 0; i3 < context_numBits; i3++) {
                  context_data_val = context_data_val << 1 | value & 1;
                  if (context_data_position == bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else {
                    context_data_position++;
                  }
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn == 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
            }
            value = 2;
            for (i3 = 0; i3 < context_numBits; i3++) {
              context_data_val = context_data_val << 1 | value & 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
            while (true) {
              context_data_val = context_data_val << 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data.push(getCharFromInt(context_data_val));
                break;
              } else
                context_data_position++;
            }
            return context_data.join("");
          },
          decompress: function(compressed) {
            if (compressed == null)
              return "";
            if (compressed == "")
              return null;
            return LZString2._decompress(compressed.length, 32768, function(index2) {
              return compressed.charCodeAt(index2);
            });
          },
          _decompress: function(length, resetValue, getNextValue) {
            var dictionary = [], next, enlargeIn = 4, dictSize = 4, numBits = 3, entry = "", result = [], i3, w3, bits, resb, maxpower, power, c3, data = { val: getNextValue(0), position: resetValue, index: 1 };
            for (i3 = 0; i3 < 3; i3 += 1) {
              dictionary[i3] = i3;
            }
            bits = 0;
            maxpower = Math.pow(2, 2);
            power = 1;
            while (power != maxpower) {
              resb = data.val & data.position;
              data.position >>= 1;
              if (data.position == 0) {
                data.position = resetValue;
                data.val = getNextValue(data.index++);
              }
              bits |= (resb > 0 ? 1 : 0) * power;
              power <<= 1;
            }
            switch (next = bits) {
              case 0:
                bits = 0;
                maxpower = Math.pow(2, 8);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                c3 = f3(bits);
                break;
              case 1:
                bits = 0;
                maxpower = Math.pow(2, 16);
                power = 1;
                while (power != maxpower) {
                  resb = data.val & data.position;
                  data.position >>= 1;
                  if (data.position == 0) {
                    data.position = resetValue;
                    data.val = getNextValue(data.index++);
                  }
                  bits |= (resb > 0 ? 1 : 0) * power;
                  power <<= 1;
                }
                c3 = f3(bits);
                break;
              case 2:
                return "";
            }
            dictionary[3] = c3;
            w3 = c3;
            result.push(c3);
            while (true) {
              if (data.index > length) {
                return "";
              }
              bits = 0;
              maxpower = Math.pow(2, numBits);
              power = 1;
              while (power != maxpower) {
                resb = data.val & data.position;
                data.position >>= 1;
                if (data.position == 0) {
                  data.position = resetValue;
                  data.val = getNextValue(data.index++);
                }
                bits |= (resb > 0 ? 1 : 0) * power;
                power <<= 1;
              }
              switch (c3 = bits) {
                case 0:
                  bits = 0;
                  maxpower = Math.pow(2, 8);
                  power = 1;
                  while (power != maxpower) {
                    resb = data.val & data.position;
                    data.position >>= 1;
                    if (data.position == 0) {
                      data.position = resetValue;
                      data.val = getNextValue(data.index++);
                    }
                    bits |= (resb > 0 ? 1 : 0) * power;
                    power <<= 1;
                  }
                  dictionary[dictSize++] = f3(bits);
                  c3 = dictSize - 1;
                  enlargeIn--;
                  break;
                case 1:
                  bits = 0;
                  maxpower = Math.pow(2, 16);
                  power = 1;
                  while (power != maxpower) {
                    resb = data.val & data.position;
                    data.position >>= 1;
                    if (data.position == 0) {
                      data.position = resetValue;
                      data.val = getNextValue(data.index++);
                    }
                    bits |= (resb > 0 ? 1 : 0) * power;
                    power <<= 1;
                  }
                  dictionary[dictSize++] = f3(bits);
                  c3 = dictSize - 1;
                  enlargeIn--;
                  break;
                case 2:
                  return result.join("");
              }
              if (enlargeIn == 0) {
                enlargeIn = Math.pow(2, numBits);
                numBits++;
              }
              if (dictionary[c3]) {
                entry = dictionary[c3];
              } else {
                if (c3 === dictSize) {
                  entry = w3 + w3.charAt(0);
                } else {
                  return null;
                }
              }
              result.push(entry);
              dictionary[dictSize++] = w3 + entry.charAt(0);
              enlargeIn--;
              w3 = entry;
              if (enlargeIn == 0) {
                enlargeIn = Math.pow(2, numBits);
                numBits++;
              }
            }
          }
        };
        return LZString2;
      }();
      if (typeof define === "function" && define.amd) {
        define(function() {
          return LZString;
        });
      } else if (typeof module !== "undefined" && module != null) {
        module.exports = LZString;
      } else if (typeof angular !== "undefined" && angular != null) {
        angular.module("LZString", []).factory("LZString", function() {
          return LZString;
        });
      }
    }
  });

  // src/index.tsx
  var React73 = __toESM(require_react());
  var import_client = __toESM(require_client());

  // ../../../packages/utils/src/lib/array.ts
  function dedupe(input, equals2) {
    const result = [];
    mainLoop:
      for (const item of input) {
        for (const existing of result) {
          if (equals2 ? equals2(item, existing) : item === existing) {
            continue mainLoop;
          }
        }
        result.push(item);
      }
    return result;
  }
  function compact(arr) {
    return arr.filter((i3) => i3 !== void 0 && i3 !== null);
  }
  function last(arr) {
    return arr[arr.length - 1];
  }
  function minBy(arr, fn) {
    let min2;
    let minVal = Infinity;
    for (const item of arr) {
      const val = fn(item);
      if (val < minVal) {
        min2 = item;
        minVal = val;
      }
    }
    return min2;
  }
  function partition(arr, predicate) {
    const satisfies = [];
    const doesNotSatisfy = [];
    for (const item of arr) {
      if (predicate(item)) {
        satisfies.push(item);
      } else {
        doesNotSatisfy.push(item);
      }
    }
    return [satisfies, doesNotSatisfy];
  }

  // ../../../packages/utils/src/lib/function.ts
  function omitFromStackTrace(fn) {
    const wrappedFn = (...args) => {
      try {
        return fn(...args);
      } catch (error) {
        if (error instanceof Error && Error.captureStackTrace) {
          Error.captureStackTrace(error, wrappedFn);
        }
        throw error;
      }
    };
    return wrappedFn;
  }

  // ../../../packages/utils/src/lib/control.ts
  var Result = {
    ok(value) {
      return { ok: true, value };
    },
    err(error) {
      return { ok: false, error };
    }
  };
  function exhaustiveSwitchError(value, property) {
    const debugValue = property && value && typeof value === "object" && property in value ? value[property] : value;
    throw new Error(`Unknown switch case ${debugValue}`);
  }
  var assert = omitFromStackTrace(
    (value, message) => {
      if (!value) {
        throw new Error(message || "Assertion Error");
      }
    }
  );
  var assertExists = omitFromStackTrace((value, message) => {
    if (value == null) {
      throw new Error(message != null ? message : "value must be defined");
    }
    return value;
  });

  // ../../../packages/utils/src/lib/debounce.ts
  function debounce(callback, wait) {
    let state = void 0;
    const fn = (...args) => {
      if (!state) {
        state = {};
        state.promise = new Promise((resolve, reject) => {
          state.resolve = resolve;
          state.reject = reject;
        });
      }
      clearTimeout(state.timeout);
      state.latestArgs = args;
      state.timeout = setTimeout(() => {
        const s3 = state;
        state = void 0;
        try {
          s3.resolve(callback(...s3.latestArgs));
        } catch (e2) {
          s3.reject(e2);
        }
      }, wait);
      return state.promise;
    };
    fn.cancel = () => {
      if (!state)
        return;
      clearTimeout(state.timeout);
    };
    return fn;
  }

  // ../../../packages/utils/src/lib/error.ts
  var annotationsByError = /* @__PURE__ */ new WeakMap();
  function annotateError(error, annotations) {
    if (typeof error !== "object" || error === null)
      return;
    let currentAnnotations = annotationsByError.get(error);
    if (!currentAnnotations) {
      currentAnnotations = { tags: {}, extras: {} };
      annotationsByError.set(error, currentAnnotations);
    }
    if (annotations.tags) {
      currentAnnotations.tags = __spreadValues(__spreadValues({}, currentAnnotations.tags), annotations.tags);
    }
    if (annotations.extras) {
      currentAnnotations.extras = __spreadValues(__spreadValues({}, currentAnnotations.extras), annotations.extras);
    }
  }

  // ../../../packages/utils/src/lib/hash.ts
  function getHashForString(string2) {
    let hash = 0;
    for (let i3 = 0; i3 < string2.length; i3++) {
      hash = (hash << 5) - hash + string2.charCodeAt(i3);
      hash |= 0;
    }
    return hash + "";
  }

  // ../../../packages/utils/src/lib/number.ts
  function rng(seed = "") {
    let x3 = 0;
    let y3 = 0;
    let z2 = 0;
    let w3 = 0;
    function next() {
      const t4 = x3 ^ x3 << 11;
      x3 = y3;
      y3 = z2;
      z2 = w3;
      w3 ^= (w3 >>> 19 ^ t4 ^ t4 >>> 8) >>> 0;
      return w3 / 4294967296 * 2;
    }
    for (let k2 = 0; k2 < seed.length + 64; k2++) {
      x3 ^= seed.charCodeAt(k2) | 0;
      next();
    }
    return next;
  }
  function modulate(value, rangeA, rangeB, clamp3 = false) {
    const [fromLow, fromHigh] = rangeA;
    const [v0, v1] = rangeB;
    const result = v0 + (value - fromLow) / (fromHigh - fromLow) * (v1 - v0);
    return clamp3 ? v0 < v1 ? Math.max(Math.min(result, v1), v0) : Math.max(Math.min(result, v0), v1) : result;
  }

  // ../../../packages/utils/src/lib/object.ts
  function hasOwnProperty(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
  }
  function getOwnProperty(obj, key) {
    if (!hasOwnProperty(obj, key)) {
      return void 0;
    }
    return obj[key];
  }
  function deepCopy(obj) {
    if (!obj)
      return obj;
    if (Array.isArray(obj)) {
      const arr = [];
      const length = obj.length;
      for (let i3 = 0; i3 < length; i3++)
        arr.push(deepCopy(obj[i3]));
      return arr;
    } else if (typeof obj === "object") {
      const keys = Object.keys(obj);
      const length = keys.length;
      const newObject = {};
      for (let i3 = 0; i3 < length; i3++) {
        const key = keys[i3];
        newObject[key] = deepCopy(obj[key]);
      }
      return newObject;
    }
    return obj;
  }
  function objectMapValues(object2) {
    return Object.values(object2);
  }
  function objectMapEntries(object2) {
    return Object.entries(object2);
  }

  // ../../../packages/utils/src/lib/raf.ts
  var isTest = () => typeof process !== "undefined" && false;
  var rafQueue = [];
  var tick = () => {
    const queue = rafQueue.splice(0, rafQueue.length);
    for (const fn of queue) {
      fn();
    }
  };
  var frame;
  function raf() {
    if (frame) {
      return;
    }
    frame = requestAnimationFrame(() => {
      frame = void 0;
      tick();
    });
  }
  function throttledRaf(fn) {
    if (isTest()) {
      return fn();
    }
    if (rafQueue.includes(fn)) {
      return;
    }
    rafQueue.push(fn);
    raf();
  }

  // ../../../packages/utils/src/lib/value.ts
  function isNonNull(value) {
    return value !== null;
  }
  function isNonNullish(value) {
    return value !== null && value !== void 0;
  }
  var structuredClone = typeof window !== "undefined" && window.structuredClone ? window.structuredClone : (i3) => i3 ? JSON.parse(JSON.stringify(i3)) : i3;

  // ../../../packages/tlstore/src/lib/IncrementalSetConstructor.ts
  var IncrementalSetConstructor = class {
    constructor(previousValue) {
      this.previousValue = previousValue;
      /**
       * The next value of the set.
       *
       * @internal
       */
      __publicField(this, "nextValue");
      /**
       * The diff of the set.
       *
       * @internal
       */
      __publicField(this, "diff");
    }
    /**
     * Get the next value of the set.
     *
     * @public
     */
    get() {
      var _a5, _b2, _c, _d, _e, _f;
      const numRemoved = (_c = (_b2 = (_a5 = this.diff) == null ? void 0 : _a5.removed) == null ? void 0 : _b2.size) != null ? _c : 0;
      const numAdded = (_f = (_e = (_d = this.diff) == null ? void 0 : _d.added) == null ? void 0 : _e.size) != null ? _f : 0;
      if (numRemoved === 0 && numAdded === 0) {
        return void 0;
      }
      return { value: this.nextValue, diff: this.diff };
    }
    /**
     * Add an item to the set.
     *
     * @param item - The item to add.
     * @param wasAlreadyPresent - Whether the item was already present in the set.
     * @internal
     */
    _add(item, wasAlreadyPresent) {
      var _a5, _b2, _c, _d, _e;
      (_a5 = this.nextValue) != null ? _a5 : this.nextValue = new Set(this.previousValue);
      this.nextValue.add(item);
      (_b2 = this.diff) != null ? _b2 : this.diff = {};
      if (wasAlreadyPresent) {
        (_c = this.diff.removed) == null ? void 0 : _c.delete(item);
      } else {
        (_e = (_d = this.diff).added) != null ? _e : _d.added = /* @__PURE__ */ new Set();
        this.diff.added.add(item);
      }
    }
    /**
     * Add an item to the set.
     *
     * @param item - The item to add.
     * @public
     */
    add(item) {
      var _a5, _b2, _c;
      const wasAlreadyPresent = this.previousValue.has(item);
      if (wasAlreadyPresent) {
        const wasRemoved = (_b2 = (_a5 = this.diff) == null ? void 0 : _a5.removed) == null ? void 0 : _b2.has(item);
        if (!wasRemoved)
          return;
        return this._add(item, wasAlreadyPresent);
      }
      const isCurrentlyPresent = (_c = this.nextValue) == null ? void 0 : _c.has(item);
      if (isCurrentlyPresent)
        return;
      this._add(item, wasAlreadyPresent);
    }
    /**
     * Remove an item from the set.
     *
     * @param item - The item to remove.
     * @param wasAlreadyPresent - Whether the item was already present in the set.
     * @internal
     */
    _remove(item, wasAlreadyPresent) {
      var _a5, _b2, _c, _d, _e;
      (_a5 = this.nextValue) != null ? _a5 : this.nextValue = new Set(this.previousValue);
      this.nextValue.delete(item);
      (_b2 = this.diff) != null ? _b2 : this.diff = {};
      if (wasAlreadyPresent) {
        (_d = (_c = this.diff).removed) != null ? _d : _c.removed = /* @__PURE__ */ new Set();
        this.diff.removed.add(item);
      } else {
        (_e = this.diff.added) == null ? void 0 : _e.delete(item);
      }
    }
    /**
     * Remove an item from the set.
     *
     * @param item - The item to remove.
     * @public
     */
    remove(item) {
      var _a5, _b2, _c, _d;
      const wasAlreadyPresent = this.previousValue.has(item);
      if (!wasAlreadyPresent) {
        const wasAdded = (_b2 = (_a5 = this.diff) == null ? void 0 : _a5.added) == null ? void 0 : _b2.has(item);
        if (!wasAdded)
          return;
        return this._remove(item, wasAlreadyPresent);
      }
      const hasAlreadyBeenRemoved = (_d = (_c = this.diff) == null ? void 0 : _c.removed) == null ? void 0 : _d.has(item);
      if (hasAlreadyBeenRemoved)
        return;
      this._remove(item, wasAlreadyPresent);
    }
  };

  // ../../../node_modules/nanoid/index.browser.js
  var nanoid = (size = 21) => crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
    byte &= 63;
    if (byte < 36) {
      id += byte.toString(36);
    } else if (byte < 62) {
      id += (byte - 26).toString(36).toUpperCase();
    } else if (byte > 62) {
      id += "-";
    } else {
      id += "_";
    }
    return id;
  }, "");

  // ../../../packages/tlstore/src/lib/RecordType.ts
  var RecordType = class {
    constructor(typeName, config) {
      this.typeName = typeName;
      __publicField(this, "createDefaultProperties");
      __publicField(this, "migrations");
      __publicField(this, "validator");
      __publicField(this, "scope");
      /**
       * Check whether a record is an instance of this record type.
       *
       * @example
       *
       * ```ts
       * const result = recordType.isInstance(someRecord)
       * ```
       *
       * @param record - The record to check.
       * @returns Whether the record is an instance of this record type.
       */
      __publicField(this, "isInstance", (record) => {
        return (record == null ? void 0 : record.typeName) === this.typeName;
      });
      var _a5, _b2;
      this.createDefaultProperties = config.createDefaultProperties;
      this.migrations = config.migrations;
      this.validator = (_a5 = config.validator) != null ? _a5 : { validate: (r3) => r3 };
      this.scope = (_b2 = config.scope) != null ? _b2 : "document";
    }
    /**
     * Create a new record of this type.
     *
     * @param properties - The properties of the record.
     * @returns The new record.
     */
    create(properties) {
      const result = __spreadProps(__spreadValues({}, this.createDefaultProperties()), { id: this.createId() });
      for (const [k2, v3] of Object.entries(properties)) {
        if (v3 !== void 0) {
          result[k2] = v3;
        }
      }
      result.typeName = this.typeName;
      return result;
    }
    /**
     * Clone a record of this type.
     *
     * @param record - The record to clone.
     * @returns The cloned record.
     * @public
     */
    clone(record) {
      return __spreadProps(__spreadValues({}, structuredClone(record)), { id: this.createId() });
    }
    /**
     * Create a new ID for this record type.
     *
     * @example
     *
     * ```ts
     * const id = recordType.createId()
     * ```
     *
     * @returns The new ID.
     * @public
     */
    createId() {
      return this.typeName + ":" + nanoid();
    }
    /**
     * Create a new ID for this record type based on the given ID.
     *
     * @example
     *
     * ```ts
     * const id = recordType.createCustomId('myId')
     * ```
     *
     * @param id - The ID to base the new ID on.
     * @returns The new ID.
     */
    createCustomId(id) {
      return this.typeName + ":" + id;
    }
    /**
     * Takes an id like `user:123` and returns the part after the colon `123`
     *
     * @param id - The id
     * @returns
     */
    parseId(id) {
      if (!this.isId(id)) {
        throw new Error(`ID "${id}" is not a valid ID for type "${this.typeName}"`);
      }
      return id.slice(this.typeName.length + 1);
    }
    /**
     * Check whether an id is an id of this type.
     *
     * @example
     *
     * ```ts
     * const result = recordType.isIn('someId')
     * ```
     *
     * @param id - The id to check.
     * @returns Whether the id is an id of this type.
     */
    isId(id) {
      if (!id)
        return false;
      for (let i3 = 0; i3 < this.typeName.length; i3++) {
        if (id[i3] !== this.typeName[i3])
          return false;
      }
      return id[this.typeName.length] === ":";
    }
    /**
     * Create a new RecordType that has the same type name as this RecordType and includes the given
     * default properties.
     *
     * @example
     *
     * ```ts
     * const authorType = createRecordType('author', () => ({ living: true }))
     * const deadAuthorType = authorType.withDefaultProperties({ living: false })
     * ```
     *
     * @param fn - A function that returns the default properties of the new RecordType.
     * @returns The new RecordType.
     */
    withDefaultProperties(createDefaultProperties) {
      return new RecordType(this.typeName, {
        createDefaultProperties,
        migrations: this.migrations,
        validator: this.validator,
        scope: this.scope
      });
    }
    /**
     * Check that the passed in record passes the validations for this type. Returns its input
     * correctly typed if it does, but throws an error otherwise.
     */
    validate(record) {
      return this.validator.validate(record);
    }
  };
  function createRecordType(typeName, config) {
    var _a5;
    return new RecordType(typeName, {
      createDefaultProperties: () => ({}),
      migrations: (_a5 = config.migrations) != null ? _a5 : { currentVersion: 0, firstVersion: 0, migrators: {} },
      validator: config.validator,
      scope: config.scope
    });
  }

  // ../../../node_modules/signia/dist/esm/ArraySet.mjs
  var ARRAY_SIZE_THRESHOLD = 8;
  var ArraySet = class {
    constructor() {
      __publicField(this, "arraySize", 0);
      __publicField(this, "array", Array(ARRAY_SIZE_THRESHOLD));
      __publicField(this, "set", null);
    }
    /**
     * Get whether this ArraySet has any elements.
     *
     * @returns True if this ArraySet has any elements, false otherwise.
     */
    get isEmpty() {
      if (this.array) {
        return this.arraySize === 0;
      }
      if (this.set) {
        return this.set.size === 0;
      }
      throw new Error("no set or array");
    }
    /**
     * Add an item to the ArraySet if it is not already present.
     *
     * @param elem - The element to add.
     */
    add(elem) {
      if (this.array) {
        const idx = this.array.indexOf(elem);
        if (idx !== -1) {
          return false;
        }
        if (this.arraySize < ARRAY_SIZE_THRESHOLD) {
          this.array[this.arraySize] = elem;
          this.arraySize++;
          return true;
        } else {
          this.set = new Set(this.array);
          this.array = null;
          this.set.add(elem);
          return true;
        }
      }
      if (this.set) {
        if (this.set.has(elem)) {
          return false;
        }
        this.set.add(elem);
        return true;
      }
      throw new Error("no set or array");
    }
    /**
     * Remove an item from the ArraySet if it is present.
     *
     * @param elem - The element to remove
     */
    remove(elem) {
      if (this.array) {
        const idx = this.array.indexOf(elem);
        if (idx === -1) {
          return false;
        }
        this.array[idx] = void 0;
        this.arraySize--;
        if (idx !== this.arraySize) {
          this.array[idx] = this.array[this.arraySize];
          this.array[this.arraySize] = void 0;
        }
        return true;
      }
      if (this.set) {
        if (!this.set.has(elem)) {
          return false;
        }
        this.set.delete(elem);
        return true;
      }
      throw new Error("no set or array");
    }
    /**
     * Run a callback for each element in the ArraySet.
     *
     * @param visitor The callback to run for each element.
     */
    visit(visitor) {
      if (this.array) {
        for (let i3 = 0; i3 < this.arraySize; i3++) {
          const elem = this.array[i3];
          if (typeof elem !== "undefined") {
            visitor(elem);
          }
        }
        return;
      }
      if (this.set) {
        this.set.forEach(visitor);
        return;
      }
      throw new Error("no set or array");
    }
  };

  // ../../../node_modules/signia/dist/esm/helpers.mjs
  function isChild(x3) {
    return x3 && typeof x3 === "object" && "parents" in x3;
  }
  function haveParentsChanged(child) {
    for (let i3 = 0, n3 = child.parents.length; i3 < n3; i3++) {
      child.parents[i3].__unsafe__getWithoutCapture();
      if (child.parents[i3].lastChangedEpoch !== child.parentEpochs[i3]) {
        return true;
      }
    }
    return false;
  }
  var detach = (parent, child) => {
    if (!parent.children.remove(child)) {
      return;
    }
    if (parent.children.isEmpty && isChild(parent)) {
      for (let i3 = 0, n3 = parent.parents.length; i3 < n3; i3++) {
        detach(parent.parents[i3], parent);
      }
    }
  };
  var attach = (parent, child) => {
    if (!parent.children.add(child)) {
      return;
    }
    if (isChild(parent)) {
      for (let i3 = 0, n3 = parent.parents.length; i3 < n3; i3++) {
        attach(parent.parents[i3], parent);
      }
    }
  };
  function equals(a3, b3) {
    const shallowEquals = a3 === b3 || Object.is(a3, b3) || Boolean(a3 && b3 && typeof a3.equals === "function" && a3.equals(b3));
    return shallowEquals;
  }
  var EMPTY_ARRAY = Object.freeze([]);

  // ../../../node_modules/signia/dist/esm/capture.mjs
  var signiaKey = Symbol.for("__signia__");
  var global2 = globalThis;
  if (global2[signiaKey]) {
    console.error(
      'Multiple versions of signia detected. This will cause unexpected behavior. Please add "resolutions" (yarn/pnpm) or "overrides" (npm) in your package.json to ensure only one version of signia is loaded.'
    );
  } else {
    global2[signiaKey] = true;
  }
  var CaptureStackFrame = class {
    constructor(below, child) {
      __publicField(this, "offset", 0);
      __publicField(this, "numNewParents", 0);
      __publicField(this, "maybeRemoved");
      this.below = below;
      this.child = child;
    }
  };
  var stack = null;
  function startCapturingParents(child) {
    stack = new CaptureStackFrame(stack, child);
  }
  function stopCapturingParents() {
    const frame2 = stack;
    stack = frame2.below;
    const didParentsChange = frame2.numNewParents > 0 || frame2.offset !== frame2.child.parents.length;
    if (!didParentsChange) {
      return;
    }
    for (let i3 = frame2.offset; i3 < frame2.child.parents.length; i3++) {
      const p3 = frame2.child.parents[i3];
      const parentWasRemoved = frame2.child.parents.indexOf(p3) >= frame2.offset;
      if (parentWasRemoved) {
        detach(p3, frame2.child);
      }
    }
    frame2.child.parents.length = frame2.offset;
    frame2.child.parentEpochs.length = frame2.offset;
    if (stack == null ? void 0 : stack.maybeRemoved) {
      for (let i3 = 0; i3 < stack.maybeRemoved.length; i3++) {
        const maybeRemovedParent = stack.maybeRemoved[i3];
        if (frame2.child.parents.indexOf(maybeRemovedParent) === -1) {
          detach(maybeRemovedParent, frame2.child);
        }
      }
    }
  }
  function maybeCaptureParent(p3) {
    if (stack) {
      const idx = stack.child.parents.indexOf(p3);
      if (idx < 0) {
        stack.numNewParents++;
        if (stack.child.isActivelyListening) {
          attach(p3, stack.child);
        }
      }
      if (idx < 0 || idx >= stack.offset) {
        if (idx !== stack.offset && idx > 0) {
          const maybeRemovedParent = stack.child.parents[stack.offset];
          if (!stack.maybeRemoved) {
            stack.maybeRemoved = [maybeRemovedParent];
          } else if (stack.maybeRemoved.indexOf(maybeRemovedParent) === -1) {
            stack.maybeRemoved.push(maybeRemovedParent);
          }
        }
        stack.child.parents[stack.offset] = p3;
        stack.child.parentEpochs[stack.offset] = p3.lastChangedEpoch;
        stack.offset++;
      }
    }
  }

  // ../../../node_modules/signia/dist/esm/types.mjs
  var RESET_VALUE = Symbol("RESET_VALUE");

  // ../../../node_modules/signia/dist/esm/HistoryBuffer.mjs
  var HistoryBuffer = class {
    constructor(capacity) {
      __publicField(this, "index", 0);
      // use a wrap around buffer to store the last N values
      __publicField(this, "buffer");
      this.capacity = capacity;
      this.buffer = new Array(capacity);
    }
    /**
     * Add a diff to the history buffer.
     *
     * @param lastComputedEpoch The epoch when the diff was computed.
     * @param currentEpoch The current epoch.
     * @param diff (optional) The diff to add, or else a reset value.
     */
    pushEntry(lastComputedEpoch, currentEpoch, diff) {
      if (diff === void 0) {
        return;
      }
      if (diff === RESET_VALUE) {
        this.clear();
        return;
      }
      this.buffer[this.index] = [lastComputedEpoch, currentEpoch, diff];
      this.index = (this.index + 1) % this.capacity;
    }
    /**
     * Clear the history buffer.
     */
    clear() {
      this.index = 0;
      this.buffer.fill(void 0);
    }
    /**
     * Get the diffs since the given epoch.
     *
     * @param epoch The epoch to get diffs since.
     * @returns An array of diffs or a flag to reset the history buffer.
     */
    getChangesSince(sinceEpoch) {
      const { index: index2, capacity, buffer } = this;
      for (let i3 = 0; i3 < capacity; i3++) {
        const offset = (index2 - 1 + capacity - i3) % capacity;
        const elem = buffer[offset];
        if (!elem) {
          return RESET_VALUE;
        }
        const [fromEpoch, toEpoch] = elem;
        if (i3 === 0 && sinceEpoch >= toEpoch) {
          return [];
        }
        if (fromEpoch <= sinceEpoch && sinceEpoch < toEpoch) {
          const len = i3 + 1;
          const result = new Array(len);
          for (let j = 0; j < len; j++) {
            result[j] = buffer[(offset + j) % capacity][2];
          }
          return result;
        }
      }
      return RESET_VALUE;
    }
  };

  // ../../../node_modules/signia/dist/esm/constants.mjs
  var GLOBAL_START_EPOCH = -1;

  // ../../../node_modules/signia/dist/esm/transactions.mjs
  var globalEpoch = GLOBAL_START_EPOCH + 1;
  var globalIsReacting = false;
  function advanceGlobalEpoch() {
    globalEpoch++;
  }
  var Transaction = class {
    constructor(parent) {
      __publicField(this, "initialAtomValues", /* @__PURE__ */ new Map());
      this.parent = parent;
    }
    /**
     * Get whether this transaction is a root (no parents).
     *
     * @public
     */
    get isRoot() {
      return this.parent === null;
    }
    /**
     * Commit the transaction's changes.
     *
     * @public
     */
    commit() {
      if (this.isRoot) {
        const atoms = this.initialAtomValues;
        this.initialAtomValues = /* @__PURE__ */ new Map();
        flushChanges(atoms.keys());
      } else {
        this.initialAtomValues.forEach((value, atom2) => {
          if (!this.parent.initialAtomValues.has(atom2)) {
            this.parent.initialAtomValues.set(atom2, value);
          }
        });
      }
    }
    /**
     * Abort the transaction.
     *
     * @public
     */
    abort() {
      globalEpoch++;
      this.initialAtomValues.forEach((value, atom2) => {
        var _a5;
        atom2.set(value);
        (_a5 = atom2.historyBuffer) == null ? void 0 : _a5.clear();
      });
      this.commit();
    }
  };
  function flushChanges(atoms) {
    if (globalIsReacting) {
      throw new Error("cannot change atoms during reaction cycle");
    }
    try {
      globalIsReacting = true;
      const reactors = /* @__PURE__ */ new Set();
      const traverse = (node) => {
        if (node.lastTraversedEpoch === globalEpoch) {
          return;
        }
        node.lastTraversedEpoch = globalEpoch;
        if ("maybeScheduleEffect" in node) {
          reactors.add(node);
        } else {
          ;
          node.children.visit(traverse);
        }
      };
      for (const atom2 of atoms) {
        atom2.children.visit(traverse);
      }
      for (const r3 of reactors) {
        r3.maybeScheduleEffect();
      }
    } finally {
      globalIsReacting = false;
    }
  }
  function atomDidChange(atom2, previousValue) {
    if (!currentTransaction) {
      flushChanges([atom2]);
    } else if (!currentTransaction.initialAtomValues.has(atom2)) {
      currentTransaction.initialAtomValues.set(atom2, previousValue);
    }
  }
  var currentTransaction = null;
  function transaction(fn) {
    const txn = new Transaction(currentTransaction);
    currentTransaction = txn;
    try {
      let rollback = false;
      const result = fn(() => rollback = true);
      if (rollback) {
        txn.abort();
      } else {
        txn.commit();
      }
      return result;
    } catch (e2) {
      txn.abort();
      throw e2;
    } finally {
      currentTransaction = currentTransaction.parent;
    }
  }
  function transact(fn) {
    if (currentTransaction) {
      return fn();
    }
    return transaction(fn);
  }

  // ../../../node_modules/signia/dist/esm/Atom.mjs
  var _Atom = class {
    constructor(name, current, options) {
      __publicField(this, "isEqual");
      __publicField(this, "computeDiff");
      __publicField(this, "lastChangedEpoch", globalEpoch);
      __publicField(this, "children", new ArraySet());
      __publicField(this, "historyBuffer");
      var _a5;
      this.name = name;
      this.current = current;
      this.isEqual = (_a5 = options == null ? void 0 : options.isEqual) != null ? _a5 : null;
      if (!options)
        return;
      if (options.historyLength) {
        this.historyBuffer = new HistoryBuffer(options.historyLength);
      }
      this.computeDiff = options.computeDiff;
    }
    __unsafe__getWithoutCapture() {
      return this.current;
    }
    get value() {
      maybeCaptureParent(this);
      return this.current;
    }
    set(value, diff) {
      var _a5, _b2, _c, _d;
      if ((_b2 = (_a5 = this.isEqual) == null ? void 0 : _a5.call(this, this.current, value)) != null ? _b2 : equals(this.current, value)) {
        return this.current;
      }
      advanceGlobalEpoch();
      if (this.historyBuffer) {
        this.historyBuffer.pushEntry(
          this.lastChangedEpoch,
          globalEpoch,
          (_d = diff != null ? diff : (_c = this.computeDiff) == null ? void 0 : _c.call(this, this.current, value, this.lastChangedEpoch, globalEpoch)) != null ? _d : RESET_VALUE
        );
      }
      this.lastChangedEpoch = globalEpoch;
      const oldValue = this.current;
      this.current = value;
      atomDidChange(this, oldValue);
      return value;
    }
    update(updater) {
      return this.set(updater(this.current));
    }
    getDiffSince(epoch) {
      var _a5, _b2;
      maybeCaptureParent(this);
      if (epoch >= this.lastChangedEpoch) {
        return EMPTY_ARRAY;
      }
      return (_b2 = (_a5 = this.historyBuffer) == null ? void 0 : _a5.getChangesSince(epoch)) != null ? _b2 : RESET_VALUE;
    }
  };
  function atom(name, initialValue, options) {
    return new _Atom(name, initialValue, options);
  }

  // ../../../node_modules/signia/dist/esm/Computed.mjs
  var UNINITIALIZED = Symbol("UNINITIALIZED");
  var isUninitialized = (value) => {
    return value === UNINITIALIZED;
  };
  var WithDiff = class {
    constructor(value, diff) {
      this.value = value;
      this.diff = diff;
    }
  };
  function withDiff(value, diff) {
    return new WithDiff(value, diff);
  }
  var _Computed = class {
    constructor(name, derive, options) {
      __publicField(this, "lastChangedEpoch", GLOBAL_START_EPOCH);
      __publicField(this, "lastTraversedEpoch", GLOBAL_START_EPOCH);
      /**
       * The epoch when the reactor was last checked.
       */
      __publicField(this, "lastCheckedEpoch", GLOBAL_START_EPOCH);
      __publicField(this, "parents", []);
      __publicField(this, "parentEpochs", []);
      __publicField(this, "children", new ArraySet());
      __publicField(this, "historyBuffer");
      // The last-computed value of this signal.
      __publicField(this, "state", UNINITIALIZED);
      __publicField(this, "computeDiff");
      __publicField(this, "isEqual");
      var _a5;
      this.name = name;
      this.derive = derive;
      if (options == null ? void 0 : options.historyLength) {
        this.historyBuffer = new HistoryBuffer(options.historyLength);
      }
      this.computeDiff = options == null ? void 0 : options.computeDiff;
      this.isEqual = (_a5 = options == null ? void 0 : options.isEqual) != null ? _a5 : equals;
    }
    get isActivelyListening() {
      return !this.children.isEmpty;
    }
    __unsafe__getWithoutCapture() {
      var _a5, _b2;
      const isNew = this.lastChangedEpoch === GLOBAL_START_EPOCH;
      if (!isNew && (this.lastCheckedEpoch === globalEpoch || !haveParentsChanged(this))) {
        this.lastCheckedEpoch = globalEpoch;
        return this.state;
      }
      try {
        startCapturingParents(this);
        const result = this.derive(this.state, this.lastCheckedEpoch);
        const newState = result instanceof WithDiff ? result.value : result;
        if (this.state === UNINITIALIZED || !this.isEqual(newState, this.state)) {
          if (this.historyBuffer && !isNew) {
            const diff = result instanceof WithDiff ? result.diff : void 0;
            this.historyBuffer.pushEntry(
              this.lastChangedEpoch,
              globalEpoch,
              (_b2 = diff != null ? diff : (_a5 = this.computeDiff) == null ? void 0 : _a5.call(this, this.state, newState, this.lastCheckedEpoch, globalEpoch)) != null ? _b2 : RESET_VALUE
            );
          }
          this.lastChangedEpoch = globalEpoch;
          this.state = newState;
        }
        this.lastCheckedEpoch = globalEpoch;
        return this.state;
      } finally {
        stopCapturingParents();
      }
    }
    get value() {
      const value = this.__unsafe__getWithoutCapture();
      maybeCaptureParent(this);
      return value;
    }
    getDiffSince(epoch) {
      var _a5, _b2;
      this.value;
      if (epoch >= this.lastChangedEpoch) {
        return EMPTY_ARRAY;
      }
      return (_b2 = (_a5 = this.historyBuffer) == null ? void 0 : _a5.getChangesSince(epoch)) != null ? _b2 : RESET_VALUE;
    }
  };
  function computedAnnotation(options = {}, _target, key, descriptor) {
    const originalMethod = descriptor.get;
    const derivationKey = Symbol.for("__signia__computed__" + key);
    descriptor.get = function() {
      let d3 = this[derivationKey];
      if (!d3) {
        d3 = new _Computed(key, originalMethod.bind(this), options);
        Object.defineProperty(this, derivationKey, {
          enumerable: false,
          configurable: false,
          writable: false,
          value: d3
        });
      }
      return d3.value;
    };
    return descriptor;
  }
  function computed() {
    if (arguments.length === 1) {
      const options = arguments[0];
      return (target, key, descriptor) => computedAnnotation(options, target, key, descriptor);
    } else if (typeof arguments[0] === "string") {
      return new _Computed(arguments[0], arguments[1], arguments[2]);
    } else {
      return computedAnnotation(void 0, arguments[0], arguments[1], arguments[2]);
    }
  }

  // ../../../node_modules/signia/dist/esm/EffectScheduler.mjs
  var EffectScheduler = class {
    constructor(name, runEffect, options) {
      __publicField(this, "_isActivelyListening", false);
      /** @internal */
      __publicField(this, "lastTraversedEpoch", GLOBAL_START_EPOCH);
      __publicField(this, "lastReactedEpoch", GLOBAL_START_EPOCH);
      __publicField(this, "_scheduleCount", 0);
      /** @internal */
      __publicField(this, "parentEpochs", []);
      /** @internal */
      __publicField(this, "parents", []);
      __publicField(this, "_scheduleEffect");
      __publicField(this, "maybeExecute", () => {
        if (!this._isActivelyListening)
          return;
        this.execute();
      });
      this.name = name;
      this.runEffect = runEffect;
      this._scheduleEffect = options == null ? void 0 : options.scheduleEffect;
    }
    /**
     * Whether this scheduler is attached and actively listening to its parents.
     * @public
     */
    get isActivelyListening() {
      return this._isActivelyListening;
    }
    /**
     * The number of times this effect has been scheduled.
     * @public
     */
    get scheduleCount() {
      return this._scheduleCount;
    }
    /** @internal */
    maybeScheduleEffect() {
      if (!this._isActivelyListening)
        return;
      if (this.lastReactedEpoch === globalEpoch)
        return;
      if (this.parents.length && !haveParentsChanged(this)) {
        this.lastReactedEpoch = globalEpoch;
        return;
      }
      this.scheduleEffect();
    }
    /** @internal */
    scheduleEffect() {
      this._scheduleCount++;
      if (this._scheduleEffect) {
        this._scheduleEffect(this.maybeExecute);
      } else {
        this.execute();
      }
    }
    /**
     * Makes this scheduler become 'actively listening' to its parents.
     * If it has been executed before it will immediately become eligible to receive 'maybeScheduleEffect' calls.
     * If it has not executed before it will need to be manually executed once to become eligible for scheduling, i.e. by calling [[EffectScheduler.execute]].
     * @public
     */
    attach() {
      this._isActivelyListening = true;
      for (let i3 = 0, n3 = this.parents.length; i3 < n3; i3++) {
        attach(this.parents[i3], this);
      }
    }
    /**
     * Makes this scheduler stop 'actively listening' to its parents.
     * It will no longer be eligible to receive 'maybeScheduleEffect' calls until [[EffectScheduler.attach]] is called again.
     */
    detach() {
      this._isActivelyListening = false;
      for (let i3 = 0, n3 = this.parents.length; i3 < n3; i3++) {
        detach(this.parents[i3], this);
      }
    }
    /**
     * Executes the effect immediately and returns the result.
     * @returns The result of the effect.
     */
    execute() {
      try {
        startCapturingParents(this);
        const result = this.runEffect(this.lastReactedEpoch);
        this.lastReactedEpoch = globalEpoch;
        return result;
      } finally {
        stopCapturingParents();
      }
    }
  };
  function react(name, fn, options) {
    const scheduler = new EffectScheduler(name, fn, options);
    scheduler.attach();
    scheduler.scheduleEffect();
    return () => {
      scheduler.detach();
    };
  }
  function reactor(name, fn, options) {
    const scheduler = new EffectScheduler(name, fn, options);
    return {
      scheduler,
      start: (options2) => {
        var _a5;
        const force = (_a5 = options2 == null ? void 0 : options2.force) != null ? _a5 : false;
        scheduler.attach();
        if (force) {
          scheduler.scheduleEffect();
        } else {
          scheduler.maybeScheduleEffect();
        }
      },
      stop: () => {
        scheduler.detach();
      }
    };
  }

  // ../../../packages/tlstore/src/lib/Cache.ts
  var Cache = class {
    constructor() {
      /** The map of items to their cached values. */
      __publicField(this, "items", /* @__PURE__ */ new WeakMap());
    }
    /**
     * Get the cached value for a given record. If the record is not present in the map, the callback
     * will be used to create the value (with the result being stored in the cache for next time).
     *
     * @param item - The item to get.
     * @param cb - The callback to use to create the value when a cached value is not found.
     */
    get(item, cb) {
      if (!this.items.has(item)) {
        this.items.set(item, cb(item));
      }
      return this.items.get(item);
    }
  };

  // ../../../packages/tlstore/src/lib/devFreeze.ts
  function devFreeze(object2) {
    if (true) {
      return object2;
    }
    const proto = Object.getPrototypeOf(object2);
    if (proto && !(proto === Array.prototype || proto === Object.prototype)) {
      console.error("cannot include non-js data in a record", object2);
      throw new Error("cannot include non-js data in a record");
    }
    const propNames = Object.getOwnPropertyNames(object2);
    for (const name of propNames) {
      const value = object2[name];
      if (value && typeof value === "object") {
        devFreeze(value);
      }
    }
    return Object.freeze(object2);
  }

  // ../../../packages/tlstore/src/lib/StoreQueries.ts
  var import_lodash = __toESM(require_lodash());

  // ../../../packages/tlstore/src/lib/setUtils.ts
  function intersectSets(sets) {
    if (sets.length === 0)
      return /* @__PURE__ */ new Set();
    const first = sets[0];
    const rest = sets.slice(1);
    const result = /* @__PURE__ */ new Set();
    for (const val of first) {
      if (rest.every((set) => set.has(val))) {
        result.add(val);
      }
    }
    return result;
  }
  function diffSets(prev, next) {
    var _a5, _b2;
    const result = {};
    for (const val of next) {
      if (!prev.has(val)) {
        (_a5 = result.added) != null ? _a5 : result.added = /* @__PURE__ */ new Set();
        result.added.add(val);
      }
    }
    for (const val of prev) {
      if (!next.has(val)) {
        (_b2 = result.removed) != null ? _b2 : result.removed = /* @__PURE__ */ new Set();
        result.removed.add(val);
      }
    }
    return result.added || result.removed ? result : void 0;
  }

  // ../../../packages/tlstore/src/lib/executeQuery.ts
  function objectMatchesQuery(query, object2) {
    for (const [key, _matcher] of Object.entries(query)) {
      const matcher = _matcher;
      const value = object2[key];
      if ("eq" in matcher && value !== matcher.eq)
        return false;
      if ("neq" in matcher && value === matcher.neq)
        return false;
      if ("gt" in matcher && (typeof value !== "number" || value <= matcher.gt))
        return false;
    }
    return true;
  }
  function executeQuery(store, typeName, query) {
    const matchIds = Object.fromEntries(Object.keys(query).map((key) => [key, /* @__PURE__ */ new Set()]));
    for (const [k2, matcher] of Object.entries(query)) {
      if ("eq" in matcher) {
        const index2 = store.index(typeName, k2);
        const ids = index2.value.get(matcher.eq);
        if (ids) {
          for (const id of ids) {
            matchIds[k2].add(id);
          }
        }
      } else if ("neq" in matcher) {
        const index2 = store.index(typeName, k2);
        for (const [value, ids] of index2.value) {
          if (value !== matcher.neq) {
            for (const id of ids) {
              matchIds[k2].add(id);
            }
          }
        }
      } else if ("gt" in matcher) {
        const index2 = store.index(typeName, k2);
        for (const [value, ids] of index2.value) {
          if (value > matcher.gt) {
            for (const id of ids) {
              matchIds[k2].add(id);
            }
          }
        }
      }
    }
    return intersectSets(Object.values(matchIds));
  }

  // ../../../packages/tlstore/src/lib/StoreQueries.ts
  var StoreQueries = class {
    constructor(atoms, history) {
      this.atoms = atoms;
      this.history = history;
      /**
       * A cache of derivations (indexes).
       *
       * @internal
       */
      __publicField(this, "indexCache", /* @__PURE__ */ new Map());
      /**
       * A cache of derivations (filtered histories).
       *
       * @internal
       */
      __publicField(this, "historyCache", /* @__PURE__ */ new Map());
    }
    /**
     * Create a derivation that contains the hisotry for a given type
     *
     * @param typeName - The name of the type to filter by.
     * @returns A derivation that returns the ids of all records of the given type.
     * @public
     */
    filterHistory(typeName) {
      if (this.historyCache.has(typeName)) {
        return this.historyCache.get(typeName);
      }
      const filtered = computed(
        "filterHistory:" + typeName,
        (lastValue, lastComputedEpoch) => {
          if (isUninitialized(lastValue)) {
            return this.history.value;
          }
          const diff = this.history.getDiffSince(lastComputedEpoch);
          if (diff === RESET_VALUE)
            return this.history.value;
          const res = { added: {}, removed: {}, updated: {} };
          let numAdded = 0;
          let numRemoved = 0;
          let numUpdated = 0;
          for (const changes of diff) {
            for (const added of Object.values(changes.added)) {
              if (added.typeName === typeName) {
                if (res.removed[added.id]) {
                  const original = res.removed[added.id];
                  delete res.removed[added.id];
                  numRemoved--;
                  if (original !== added) {
                    res.updated[added.id] = [original, added];
                    numUpdated++;
                  }
                } else {
                  res.added[added.id] = added;
                  numAdded++;
                }
              }
            }
            for (const [from, to] of Object.values(changes.updated)) {
              if (to.typeName === typeName) {
                if (res.added[to.id]) {
                  res.added[to.id] = to;
                } else if (res.updated[to.id]) {
                  res.updated[to.id] = [res.updated[to.id][0], to];
                } else {
                  res.updated[to.id] = [from, to];
                  numUpdated++;
                }
              }
            }
            for (const removed of Object.values(changes.removed)) {
              if (removed.typeName === typeName) {
                if (res.added[removed.id]) {
                  delete res.added[removed.id];
                  numAdded--;
                } else if (res.updated[removed.id]) {
                  res.removed[removed.id] = res.updated[removed.id][0];
                  delete res.updated[removed.id];
                  numUpdated--;
                  numRemoved++;
                } else {
                  res.removed[removed.id] = removed;
                  numRemoved++;
                }
              }
            }
          }
          if (numAdded || numRemoved || numUpdated) {
            return withDiff(this.history.value, res);
          } else {
            return lastValue;
          }
        },
        { historyLength: 100 }
      );
      this.historyCache.set(typeName, filtered);
      return filtered;
    }
    /**
     * Create a derivation that returns an index on a property for the given type.
     *
     * @param typeName - The name of the type.
     * @param property - The name of the property.
     * @public
     */
    index(typeName, property) {
      const cacheKey = typeName + ":" + property;
      if (this.indexCache.has(cacheKey)) {
        return this.indexCache.get(cacheKey);
      }
      const index2 = this.__uncached_createIndex(typeName, property);
      this.indexCache.set(cacheKey, index2);
      return index2;
    }
    /**
     * Create a derivation that returns an index on a property for the given type.
     *
     * @param typeName - The name of the type?.
     * @param property - The name of the property?.
     * @internal
     */
    __uncached_createIndex(typeName, property) {
      const typeHistory = this.filterHistory(typeName);
      const fromScratch = () => {
        typeHistory.value;
        const res = /* @__PURE__ */ new Map();
        for (const atom2 of Object.values(this.atoms.value)) {
          const record = atom2.value;
          if (record.typeName === typeName) {
            const value = record[property];
            if (!res.has(value)) {
              res.set(value, /* @__PURE__ */ new Set());
            }
            res.get(value).add(record.id);
          }
        }
        return res;
      };
      return computed(
        "index:" + typeName + ":" + property,
        (prevValue, lastComputedEpoch) => {
          if (isUninitialized(prevValue))
            return fromScratch();
          const history = typeHistory.getDiffSince(lastComputedEpoch);
          if (history === RESET_VALUE) {
            return fromScratch();
          }
          const setConstructors = /* @__PURE__ */ new Map();
          const add = (value, id) => {
            var _a5;
            let setConstructor = setConstructors.get(value);
            if (!setConstructor)
              setConstructor = new IncrementalSetConstructor((_a5 = prevValue.get(value)) != null ? _a5 : /* @__PURE__ */ new Set());
            setConstructor.add(id);
            setConstructors.set(value, setConstructor);
          };
          const remove = (value, id) => {
            var _a5;
            let set = setConstructors.get(value);
            if (!set)
              set = new IncrementalSetConstructor((_a5 = prevValue.get(value)) != null ? _a5 : /* @__PURE__ */ new Set());
            set.remove(id);
            setConstructors.set(value, set);
          };
          for (const changes of history) {
            for (const record of Object.values(changes.added)) {
              if (record.typeName === typeName) {
                const value = record[property];
                add(value, record.id);
              }
            }
            for (const [from, to] of Object.values(changes.updated)) {
              if (to.typeName === typeName) {
                const prev = from[property];
                const next = to[property];
                if (prev !== next) {
                  remove(prev, to.id);
                  add(next, to.id);
                }
              }
            }
            for (const record of Object.values(changes.removed)) {
              if (record.typeName === typeName) {
                const value = record[property];
                remove(value, record.id);
              }
            }
          }
          let nextValue = void 0;
          let nextDiff = void 0;
          for (const [value, setConstructor] of setConstructors) {
            const result = setConstructor.get();
            if (!result)
              continue;
            if (!nextValue)
              nextValue = new Map(prevValue);
            if (!nextDiff)
              nextDiff = /* @__PURE__ */ new Map();
            if (result.value.size === 0) {
              nextValue.delete(value);
            } else {
              nextValue.set(value, result.value);
            }
            nextDiff.set(value, result.diff);
          }
          if (nextValue && nextDiff) {
            return withDiff(nextValue, nextDiff);
          }
          return prevValue;
        },
        { historyLength: 100 }
      );
    }
    /**
     * Create a derivation that will return a signle record matching the given query.
     *
     * It will return undefined if there is no matching record
     *
     * @param typeName - The name of the type?
     * @param queryCreator - A function that returns the query expression.
     * @param name - (optinal) The name of the query.
     */
    record(typeName, queryCreator = () => ({}), name = "record:" + typeName + (queryCreator ? ":" + queryCreator.toString() : "")) {
      const ids = this.ids(typeName, queryCreator, name);
      return computed(name, () => {
        var _a5;
        for (const id of ids.value) {
          return (_a5 = this.atoms.value[id]) == null ? void 0 : _a5.value;
        }
        return void 0;
      });
    }
    /**
     * Create a derivation that will return an array of records matching the given query
     *
     * @param typeName - The name of the type?
     * @param queryCreator - A function that returns the query expression.
     * @param name - (optinal) The name of the query.
     */
    records(typeName, queryCreator = () => ({}), name = "records:" + typeName + (queryCreator ? ":" + queryCreator.toString() : "")) {
      const ids = this.ids(typeName, queryCreator, "ids:" + name);
      return computed(name, () => {
        return [...ids.value].map((id) => {
          const atom2 = this.atoms.value[id];
          if (!atom2) {
            throw new Error("no atom found for record id: " + id);
          }
          return atom2.value;
        });
      });
    }
    /**
     * Create a derivation that will return the ids of all records of the given type.
     *
     * @param typeName - The name of the type.
     * @param queryCreator - A function that returns the query expression.
     * @param name - (optinal) The name of the query.
     */
    ids(typeName, queryCreator = () => ({}), name = "ids:" + typeName + (queryCreator ? ":" + queryCreator.toString() : "")) {
      const typeHistory = this.filterHistory(typeName);
      const fromScratch = () => {
        typeHistory.value;
        const query = queryCreator();
        if (Object.keys(query).length === 0) {
          return new Set(
            Object.values(this.atoms.value).flatMap((v3) => {
              const r3 = v3.value;
              if (r3.typeName === typeName) {
                return r3.id;
              } else {
                return [];
              }
            })
          );
        }
        return executeQuery(this, typeName, query);
      };
      const fromScratchWithDiff = (prevValue) => {
        const nextValue = fromScratch();
        const diff = diffSets(prevValue, nextValue);
        if (diff) {
          return withDiff(nextValue, diff);
        } else {
          return prevValue;
        }
      };
      const cachedQuery = computed("ids_query:" + name, queryCreator, {
        isEqual: import_lodash.default
      });
      return computed(
        "query:" + name,
        (prevValue, lastComputedEpoch) => {
          const query = cachedQuery.value;
          if (isUninitialized(prevValue)) {
            return fromScratch();
          }
          if (lastComputedEpoch < cachedQuery.lastChangedEpoch) {
            return fromScratchWithDiff(prevValue);
          }
          const history = typeHistory.getDiffSince(lastComputedEpoch);
          if (history === RESET_VALUE) {
            return fromScratchWithDiff(prevValue);
          }
          const setConstructor = new IncrementalSetConstructor(
            prevValue
          );
          for (const changes of history) {
            for (const added of Object.values(changes.added)) {
              if (added.typeName === typeName && objectMatchesQuery(query, added)) {
                setConstructor.add(added.id);
              }
            }
            for (const [_, updated] of Object.values(changes.updated)) {
              if (updated.typeName === typeName) {
                if (objectMatchesQuery(query, updated)) {
                  setConstructor.add(updated.id);
                } else {
                  setConstructor.remove(updated.id);
                }
              }
            }
            for (const removed of Object.values(changes.removed)) {
              if (removed.typeName === typeName) {
                setConstructor.remove(removed.id);
              }
            }
          }
          const result = setConstructor.get();
          if (!result) {
            return prevValue;
          }
          return withDiff(result.value, result.diff);
        },
        { historyLength: 50 }
      );
    }
    exec(typeName, query) {
      const ids = executeQuery(this, typeName, query);
      if (ids.size === 0) {
        return EMPTY_ARRAY;
      }
      const atoms = this.atoms.value;
      return [...ids].map((id) => atoms[id].value);
    }
  };

  // ../../../packages/tlstore/src/lib/Store.ts
  var Store = class {
    constructor(config) {
      /**
       * An atom containing the store's atoms.
       *
       * @internal
       * @readonly
       */
      __publicField(this, "atoms", atom("store_atoms", {}));
      /**
       * An atom containing the store's history.
       *
       * @public
       * @readonly
       */
      __publicField(this, "history", atom("history", 0, {
        historyLength: 1e3
      }));
      /**
       * A StoreQueries instance for this store.
       *
       * @public
       * @readonly
       */
      __publicField(this, "query", new StoreQueries(this.atoms, this.history));
      /**
       * A set containing listeners that have been added to this store.
       *
       * @internal
       */
      __publicField(this, "listeners", /* @__PURE__ */ new Set());
      /**
       * An array of history entries that have not yet been flushed.
       *
       * @internal
       */
      __publicField(this, "historyAccumulator", new HistoryAccumulator());
      /**
       * A reactor that responds to changes to the history by squashing the accumulated history and
       * notifying listeners of the changes.
       *
       * @internal
       */
      __publicField(this, "historyReactor");
      __publicField(this, "schema");
      __publicField(this, "props");
      /**
       * A callback fired after a record is created. Use this to perform related updates to other
       * records in the store.
       *
       * @param record - The record to be created
       */
      __publicField(this, "onAfterCreate");
      /**
       * A callback fired after each record's change.
       *
       * @param prev - The previous value, if any.
       * @param next - The next value.
       */
      __publicField(this, "onAfterChange");
      /**
       * A callback fired before a record is deleted.
       *
       * @param prev - The record that will be deleted.
       */
      __publicField(this, "onBeforeDelete");
      /**
       * A callback fired after a record is deleted.
       *
       * @param prev - The record that will be deleted.
       */
      __publicField(this, "onAfterDelete");
      // used to avoid running callbacks when rolling back changes in sync client
      __publicField(this, "_runCallbacks", true);
      /**
       * Add some records to the store. It's an error if they already exist.
       *
       * @param records - The records to add.
       * @public
       */
      __publicField(this, "put", (records, phaseOverride) => {
        transact(() => {
          const updates = {};
          const additions = {};
          const currentMap = this.atoms.__unsafe__getWithoutCapture();
          let map = null;
          let record;
          let didChange = false;
          for (let i3 = 0, n3 = records.length; i3 < n3; i3++) {
            record = records[i3];
            const recordAtom = (map != null ? map : currentMap)[record.id];
            if (recordAtom) {
              const initialValue = recordAtom.__unsafe__getWithoutCapture();
              record = this.schema.validateRecord(
                this,
                record,
                phaseOverride != null ? phaseOverride : "updateRecord",
                initialValue
              );
              recordAtom.set(devFreeze(record));
              const finalValue = recordAtom.__unsafe__getWithoutCapture();
              if (initialValue !== finalValue) {
                didChange = true;
                updates[record.id] = [initialValue, finalValue];
              }
            } else {
              didChange = true;
              record = this.schema.validateRecord(
                this,
                record,
                phaseOverride != null ? phaseOverride : "createRecord",
                null
              );
              additions[record.id] = record;
              if (!map) {
                map = __spreadValues({}, currentMap);
              }
              map[record.id] = atom("atom:" + record.id, record);
            }
          }
          if (map) {
            this.atoms.set(map);
          }
          if (!didChange)
            return;
          this.updateHistory({
            added: additions,
            updated: updates,
            removed: {}
          });
          const { onAfterCreate, onAfterChange } = this;
          if (onAfterCreate && this._runCallbacks) {
            Object.values(additions).forEach((record2) => {
              onAfterCreate(record2);
            });
          }
          if (onAfterChange && this._runCallbacks) {
            Object.values(updates).forEach(([from, to]) => {
              onAfterChange(from, to);
            });
          }
        });
      });
      /**
       * Remove some records from the store via their ids.
       *
       * @param ids - The ids of the records to remove.
       * @public
       */
      __publicField(this, "remove", (ids) => {
        transact(() => {
          if (this.onBeforeDelete && this._runCallbacks) {
            for (const id of ids) {
              const atom2 = this.atoms.__unsafe__getWithoutCapture()[id];
              if (!atom2)
                continue;
              this.onBeforeDelete(atom2.value);
            }
          }
          let removed = void 0;
          this.atoms.update((atoms) => {
            let result = void 0;
            for (const id of ids) {
              if (!(id in atoms))
                continue;
              if (!result)
                result = __spreadValues({}, atoms);
              if (!removed)
                removed = {};
              delete result[id];
              removed[id] = atoms[id].value;
            }
            return result != null ? result : atoms;
          });
          if (!removed)
            return;
          this.updateHistory({ added: {}, updated: {}, removed });
          if (this.onAfterDelete && this._runCallbacks) {
            for (let i3 = 0, n3 = ids.length; i3 < n3; i3++) {
              this.onAfterDelete(removed[ids[i3]]);
            }
          }
        });
      });
      /**
       * Get the value of a store record by its id.
       *
       * @param id - The id of the record to get.
       * @public
       */
      __publicField(this, "get", (id) => {
        var _a5;
        return (_a5 = this.atoms.value[id]) == null ? void 0 : _a5.value;
      });
      /**
       * Get the value of a store record by its id without updating its epoch.
       *
       * @param id - The id of the record to get.
       * @public
       */
      __publicField(this, "unsafeGetWithoutCapture", (id) => {
        var _a5;
        return (_a5 = this.atoms.value[id]) == null ? void 0 : _a5.__unsafe__getWithoutCapture();
      });
      /**
       * Opposite of `deserialize`. Creates a JSON payload from the record store.
       *
       * @param filter - A function to filter structs that do not satisfy the predicate.
       * @returns The record store snapshot as a JSON payload.
       */
      __publicField(this, "serialize", (filter2) => {
        const result = {};
        for (const [id, atom2] of Object.entries(this.atoms.value)) {
          const record = atom2.value;
          if (typeof filter2 === "function" && !filter2(record))
            continue;
          result[id] = record;
        }
        return result;
      });
      /**
       * The same as `serialize`, but only serializes records with a scope of `document`.
       * @returns The record store snapshot as a JSON payload.
       */
      __publicField(this, "serializeDocumentState", () => {
        return this.serialize((r3) => {
          const type = this.schema.types[r3.typeName];
          return type.scope === "document";
        });
      });
      /**
       * Opposite of `serialize`. Replace the store's current records with records as defined by a
       * simple JSON structure into the stores.
       *
       * @param snapshot - The JSON snapshot to deserialize.
       * @public
       */
      __publicField(this, "deserialize", (snapshot) => {
        transact(() => {
          this.clear();
          this.put(Object.values(snapshot));
        });
      });
      /**
       * Get an array of all values in the store.
       *
       * @returns An array of all values in the store.
       * @public
       */
      __publicField(this, "allRecords", () => {
        return Object.values(this.atoms.value).map((atom2) => atom2.value);
      });
      /**
       * Removes all records from the store.
       *
       * @public
       */
      __publicField(this, "clear", () => {
        this.remove(Object.keys(this.atoms.value));
      });
      /**
       * Update a record. To update multiple records at once, use the `update` method of the
       * `TypedStore` class.
       *
       * @param id - The id of the record to update.
       * @param updater - A function that updates the record.
       */
      __publicField(this, "update", (id, updater) => {
        const atom2 = this.atoms.value[id];
        if (!atom2) {
          console.error(`Record ${id} not found. This is probably an error`);
          return;
        }
        this.put([updater(atom2.__unsafe__getWithoutCapture())]);
      });
      /**
       * Get whether the record store has a id.
       *
       * @param id - The id of the record to check.
       * @public
       */
      __publicField(this, "has", (id) => {
        return !!this.atoms.value[id];
      });
      /**
       * Add a new listener to the store.
       *
       * @param listener - The listener to call when the store updates.
       * @returns A function to remove the listener.
       */
      __publicField(this, "listen", (listener) => {
        this._flushHistory();
        this.listeners.add(listener);
        if (!this.historyReactor.scheduler.isActivelyListening) {
          this.historyReactor.start();
        }
        return () => {
          this.listeners.delete(listener);
          if (this.listeners.size === 0) {
            this.historyReactor.stop();
          }
        };
      });
      __publicField(this, "isMergingRemoteChanges", false);
      /**
       * Merge changes from a remote source without triggering listeners.
       *
       * @param fn - A function that merges the external changes.
       * @public
       */
      __publicField(this, "mergeRemoteChanges", (fn) => {
        if (this.isMergingRemoteChanges) {
          return fn();
        }
        try {
          this.isMergingRemoteChanges = true;
          transact(fn);
        } finally {
          this.isMergingRemoteChanges = false;
        }
      });
      /**
       * Create a computed cache.
       *
       * @param name - The name of the derivation cache.
       * @param derive - A function used to derive the value of the cache.
       * @public
       */
      __publicField(this, "createComputedCache", (name, derive) => {
        const cache = new Cache();
        return {
          get: (id) => {
            const atom2 = this.atoms.value[id];
            if (!atom2) {
              return void 0;
            }
            return cache.get(
              atom2,
              () => computed(name + ":" + id, () => derive(atom2.value))
            ).value;
          }
        };
      });
      /**
       * Create a computed cache from a selector
       *
       * @param name - The name of the derivation cache.
       * @param selector - A function that returns a subset of the original shape
       * @param derive - A function used to derive the value of the cache.
       * @public
       */
      __publicField(this, "createSelectedComputedCache", (name, selector, derive) => {
        const cache = new Cache();
        return {
          get: (id) => {
            const atom2 = this.atoms.value[id];
            if (!atom2) {
              return void 0;
            }
            const d3 = computed(
              name + ":" + id + ":selector",
              () => selector(atom2.value)
            );
            return cache.get(
              atom2,
              () => computed(name + ":" + id, () => derive(d3.value))
            ).value;
          }
        };
      });
      __publicField(this, "_integrityChecker");
      __publicField(this, "_isPossiblyCorrupted", false);
      const { initialData, schema } = config;
      this.schema = schema;
      this.props = config.props;
      if (initialData) {
        this.atoms.set(
          Object.fromEntries(
            Object.entries(initialData).map(([id, record]) => [
              id,
              atom("atom:" + id, this.schema.validateRecord(this, record, "initialize", null))
            ])
          )
        );
      }
      this.historyReactor = reactor(
        "Store.historyReactor",
        () => {
          this.history.value;
          this._flushHistory();
        },
        { scheduleEffect: (cb) => throttledRaf(cb) }
      );
    }
    _flushHistory() {
      if (this.historyAccumulator.hasChanges()) {
        const entries = this.historyAccumulator.flush();
        for (const { changes, source } of entries) {
          this.listeners.forEach((l3) => l3({ changes, source }));
        }
      }
    }
    /**
     * Update the history with a diff of changes.
     *
     * @param changes - The changes to add to the history.
     */
    updateHistory(changes) {
      this.historyAccumulator.add({
        changes,
        source: this.isMergingRemoteChanges ? "remote" : "user"
      });
      if (this.listeners.size === 0) {
        this.historyAccumulator.clear();
      }
      this.history.set(this.history.value + 1, changes);
    }
    validate(phase) {
      this.allRecords().forEach((record) => this.schema.validateRecord(this, record, phase, null));
    }
    extractingChanges(fn) {
      const changes = [];
      const dispose = this.historyAccumulator.intercepting((entry) => changes.push(entry.changes));
      try {
        transact(fn);
        return squashRecordDiffs(changes);
      } finally {
        dispose();
      }
    }
    applyDiff(diff, runCallbacks = true) {
      const prevRunCallbacks = this._runCallbacks;
      try {
        this._runCallbacks = runCallbacks;
        transact(() => {
          const toPut = Object.values(diff.added).concat(
            Object.values(diff.updated).map(([_from, to]) => to)
          );
          const toRemove = Object.keys(diff.removed);
          if (toPut.length) {
            this.put(toPut);
          }
          if (toRemove.length) {
            this.remove(toRemove);
          }
        });
      } finally {
        this._runCallbacks = prevRunCallbacks;
      }
    }
    /** @internal */
    ensureStoreIsUsable() {
      var _a5, _b2;
      (_a5 = this._integrityChecker) != null ? _a5 : this._integrityChecker = this.schema.createIntegrityChecker(this);
      (_b2 = this._integrityChecker) == null ? void 0 : _b2.call(this);
    }
    /** @internal */
    markAsPossiblyCorrupted() {
      this._isPossiblyCorrupted = true;
    }
    /** @internal */
    isPossiblyCorrupted() {
      return this._isPossiblyCorrupted;
    }
  };
  function squashRecordDiffs(diffs) {
    const result = { added: {}, removed: {}, updated: {} };
    for (const diff of diffs) {
      for (const [id, value] of Object.entries(diff.added)) {
        if (result.removed[id]) {
          const original = result.removed[id];
          delete result.removed[id];
          if (original !== value) {
            result.updated[id] = [original, value];
          }
        } else {
          result.added[id] = value;
        }
      }
      for (const [id, [_from, to]] of Object.entries(diff.updated)) {
        if (result.added[id]) {
          result.added[id] = to;
          delete result.updated[id];
          delete result.removed[id];
          continue;
        }
        if (result.updated[id]) {
          result.updated[id][1] = to;
          delete result.removed[id];
          continue;
        }
        result.updated[id] = diff.updated[id];
        delete result.removed[id];
      }
      for (const [id, value] of Object.entries(diff.removed)) {
        if (result.added[id]) {
          delete result.added[id];
        } else if (result.updated[id]) {
          result.removed[id] = result.updated[id][0];
          delete result.updated[id];
        } else {
          result.removed[id] = value;
        }
      }
    }
    return result;
  }
  function squashHistoryEntries(entries) {
    const result = [];
    let current = entries[0];
    let entry;
    for (let i3 = 1, n3 = entries.length; i3 < n3; i3++) {
      entry = entries[i3];
      if (current.source !== entry.source) {
        result.push(current);
        current = entry;
      } else {
        current = {
          source: current.source,
          changes: squashRecordDiffs([current.changes, entry.changes])
        };
      }
    }
    result.push(current);
    return result;
  }
  var HistoryAccumulator = class {
    constructor() {
      __publicField(this, "_history", []);
      __publicField(this, "_inteceptors", /* @__PURE__ */ new Set());
    }
    intercepting(fn) {
      this._inteceptors.add(fn);
      return () => {
        this._inteceptors.delete(fn);
      };
    }
    add(entry) {
      this._history.push(entry);
      for (const interceptor of this._inteceptors) {
        interceptor(entry);
      }
    }
    flush() {
      const history = squashHistoryEntries(this._history);
      this._history = [];
      return history;
    }
    clear() {
      this._history = [];
    }
    hasChanges() {
      return this._history.length > 0;
    }
  };

  // ../../../packages/tlstore/src/lib/BaseRecord.ts
  function isRecord(record) {
    return typeof record === "object" && record !== null && "id" in record && "typeName" in record;
  }

  // ../../../packages/tlstore/src/lib/migrate.ts
  function defineMigrations({
    firstVersion,
    currentVersion,
    migrators,
    subTypeKey,
    subTypeMigrations
  }) {
    return { currentVersion, firstVersion, migrators, subTypeKey, subTypeMigrations };
  }
  function migrateRecord({
    record,
    migrations,
    fromVersion,
    toVersion
  }) {
    let currentVersion = fromVersion;
    if (!isRecord(record))
      throw new Error("[migrateRecord] object is not a record");
    const _a5 = record, { typeName, id } = _a5, others = __objRest(_a5, ["typeName", "id"]);
    let recordWithoutMeta = others;
    while (currentVersion < toVersion) {
      const nextVersion = currentVersion + 1;
      const migrator = migrations.migrators[nextVersion];
      if (!migrator) {
        return {
          type: "error",
          reason: "target-version-too-new" /* TargetVersionTooNew */
        };
      }
      recordWithoutMeta = migrator.up(recordWithoutMeta);
      currentVersion = nextVersion;
    }
    while (currentVersion > toVersion) {
      const nextVersion = currentVersion - 1;
      const migrator = migrations.migrators[currentVersion];
      if (!migrator) {
        return {
          type: "error",
          reason: "target-version-too-old" /* TargetVersionTooOld */
        };
      }
      recordWithoutMeta = migrator.down(recordWithoutMeta);
      currentVersion = nextVersion;
    }
    return {
      type: "success",
      value: __spreadProps(__spreadValues({}, recordWithoutMeta), { id, typeName })
    };
  }
  function migrate({
    value,
    migrations,
    fromVersion,
    toVersion
  }) {
    let currentVersion = fromVersion;
    while (currentVersion < toVersion) {
      const nextVersion = currentVersion + 1;
      const migrator = migrations.migrators[nextVersion];
      if (!migrator) {
        return {
          type: "error",
          reason: "target-version-too-new" /* TargetVersionTooNew */
        };
      }
      value = migrator.up(value);
      currentVersion = nextVersion;
    }
    while (currentVersion > toVersion) {
      const nextVersion = currentVersion - 1;
      const migrator = migrations.migrators[currentVersion];
      if (!migrator) {
        return {
          type: "error",
          reason: "target-version-too-old" /* TargetVersionTooOld */
        };
      }
      value = migrator.down(value);
      currentVersion = nextVersion;
    }
    return {
      type: "success",
      value
    };
  }

  // ../../../packages/tlstore/src/lib/StoreSchema.ts
  var StoreSchema = class {
    constructor(types, options) {
      this.types = types;
      this.options = options;
    }
    static create(types, options) {
      return new StoreSchema(types, options != null ? options : {});
    }
    get currentStoreVersion() {
      var _a5, _b2;
      return (_b2 = (_a5 = this.options.snapshotMigrations) == null ? void 0 : _a5.currentVersion) != null ? _b2 : 0;
    }
    validateRecord(store, record, phase, recordBefore) {
      try {
        const recordType = getOwnProperty(this.types, record.typeName);
        if (!recordType) {
          throw new Error(`Missing definition for record type ${record.typeName}`);
        }
        return recordType.validate(record);
      } catch (error) {
        if (this.options.onValidationFailure) {
          return this.options.onValidationFailure({
            store,
            record,
            phase,
            recordBefore,
            error
          });
        } else {
          throw error;
        }
      }
    }
    migratePersistedRecord(record, persistedSchema, direction = "up") {
      var _a5;
      const ourType = getOwnProperty(this.types, record.typeName);
      const persistedType = persistedSchema.recordVersions[record.typeName];
      if (!persistedType || !ourType) {
        return { type: "error", reason: "unknown-type" /* UnknownType */ };
      }
      const ourVersion = ourType.migrations.currentVersion;
      const persistedVersion = persistedType.version;
      if (ourVersion !== persistedVersion) {
        const result2 = direction === "up" ? migrateRecord({
          record,
          migrations: ourType.migrations,
          fromVersion: persistedVersion,
          toVersion: ourVersion
        }) : migrateRecord({
          record,
          migrations: ourType.migrations,
          fromVersion: ourVersion,
          toVersion: persistedVersion
        });
        if (result2.type === "error") {
          return result2;
        }
        record = result2.value;
      }
      if (!ourType.migrations.subTypeKey) {
        return { type: "success", value: record };
      }
      const ourSubTypeMigrations = (_a5 = ourType.migrations.subTypeMigrations) == null ? void 0 : _a5[record[ourType.migrations.subTypeKey]];
      const persistedSubTypeVersion = "subTypeVersions" in persistedType ? persistedType.subTypeVersions[record[ourType.migrations.subTypeKey]] : null;
      if (ourSubTypeMigrations === void 0) {
        return { type: "error", reason: "unrecognized-subtype" /* UnrecognizedSubtype */ };
      }
      if (persistedSubTypeVersion == null) {
        return { type: "error", reason: "incompatible-subtype" /* IncompatibleSubtype */ };
      }
      const result = direction === "up" ? migrateRecord({
        record,
        migrations: ourSubTypeMigrations,
        fromVersion: persistedSubTypeVersion,
        toVersion: ourSubTypeMigrations.currentVersion
      }) : migrateRecord({
        record,
        migrations: ourSubTypeMigrations,
        fromVersion: ourSubTypeMigrations.currentVersion,
        toVersion: persistedSubTypeVersion
      });
      if (result.type === "error") {
        return result;
      }
      return { type: "success", value: result.value };
    }
    migrateStoreSnapshot(storeSnapshot, persistedSchema) {
      var _a5;
      const migrations = this.options.snapshotMigrations;
      if (!migrations) {
        return { type: "success", value: storeSnapshot };
      }
      const ourStoreVersion = migrations.currentVersion;
      const persistedStoreVersion = (_a5 = persistedSchema.storeVersion) != null ? _a5 : 0;
      if (ourStoreVersion < persistedStoreVersion) {
        return { type: "error", reason: "target-version-too-old" /* TargetVersionTooOld */ };
      }
      if (ourStoreVersion > persistedStoreVersion) {
        const result = migrate({
          value: storeSnapshot,
          migrations,
          fromVersion: persistedStoreVersion,
          toVersion: ourStoreVersion
        });
        if (result.type === "error") {
          return result;
        }
        storeSnapshot = result.value;
      }
      const updated = [];
      for (const r3 of Object.values(storeSnapshot)) {
        const result = this.migratePersistedRecord(r3, persistedSchema);
        if (result.type === "error") {
          return result;
        } else if (result.value && result.value !== r3) {
          updated.push(result.value);
        }
      }
      if (updated.length) {
        storeSnapshot = __spreadValues({}, storeSnapshot);
        for (const r3 of updated) {
          storeSnapshot[r3.id] = r3;
        }
      }
      return { type: "success", value: storeSnapshot };
    }
    /** @internal */
    createIntegrityChecker(store) {
      var _a5, _b2, _c;
      return (_c = (_b2 = (_a5 = this.options).createIntegrityChecker) == null ? void 0 : _b2.call(_a5, store)) != null ? _c : void 0;
    }
    /** @internal */
    derivePresenceState(store) {
      var _a5, _b2;
      return (_b2 = (_a5 = this.options).derivePresenceState) == null ? void 0 : _b2.call(_a5, store);
    }
    serialize() {
      var _a5, _b2;
      return {
        schemaVersion: 1,
        storeVersion: (_b2 = (_a5 = this.options.snapshotMigrations) == null ? void 0 : _a5.currentVersion) != null ? _b2 : 0,
        recordVersions: Object.fromEntries(
          objectMapValues(this.types).map((type) => [
            type.typeName,
            type.migrations.subTypeKey && type.migrations.subTypeMigrations ? {
              version: type.migrations.currentVersion,
              subTypeKey: type.migrations.subTypeKey,
              subTypeVersions: type.migrations.subTypeMigrations ? Object.fromEntries(
                Object.entries(type.migrations.subTypeMigrations).map(([k2, v3]) => [
                  k2,
                  v3.currentVersion
                ])
              ) : void 0
            } : {
              version: type.migrations.currentVersion
            }
          ])
        )
      };
    }
    serializeEarliestVersion() {
      var _a5, _b2;
      return {
        schemaVersion: 1,
        storeVersion: (_b2 = (_a5 = this.options.snapshotMigrations) == null ? void 0 : _a5.firstVersion) != null ? _b2 : 0,
        recordVersions: Object.fromEntries(
          objectMapValues(this.types).map((type) => [
            type.typeName,
            type.migrations.subTypeKey && type.migrations.subTypeMigrations ? {
              version: type.migrations.firstVersion,
              subTypeKey: type.migrations.subTypeKey,
              subTypeVersions: type.migrations.subTypeMigrations ? Object.fromEntries(
                Object.entries(type.migrations.subTypeMigrations).map(([k2, v3]) => [
                  k2,
                  v3.firstVersion
                ])
              ) : void 0
            } : {
              version: type.migrations.firstVersion
            }
          ])
        )
      };
    }
  };

  // ../../../packages/tlstore/src/lib/compareSchemas.ts
  var compareSchemas = (a3, b3) => {
    if (a3.schemaVersion > b3.schemaVersion) {
      return 1;
    }
    if (a3.schemaVersion < b3.schemaVersion) {
      return -1;
    }
    if (a3.storeVersion > b3.storeVersion) {
      return 1;
    }
    if (a3.storeVersion < b3.storeVersion) {
      return -1;
    }
    for (const key of Object.keys(a3.recordVersions)) {
      const aRecordVersion = a3.recordVersions[key];
      const bRecordVersion = b3.recordVersions[key];
      if (aRecordVersion.version > bRecordVersion.version) {
        return 1;
      }
      if (aRecordVersion.version < bRecordVersion.version) {
        return -1;
      }
      if ("subTypeVersions" in aRecordVersion && !("subTypeVersions" in bRecordVersion)) {
        return 1;
      }
      if (!("subTypeVersions" in aRecordVersion) && "subTypeVersions" in bRecordVersion) {
        return -1;
      }
      if (!("subTypeVersions" in aRecordVersion) || !("subTypeVersions" in bRecordVersion)) {
        continue;
      }
      for (const subType of Object.keys(aRecordVersion.subTypeVersions)) {
        const aSubTypeVersion = aRecordVersion.subTypeVersions[subType];
        const bSubTypeVersion = bRecordVersion.subTypeVersions[subType];
        if (aSubTypeVersion > bSubTypeVersion) {
          return 1;
        }
        if (aSubTypeVersion < bSubTypeVersion) {
          return -1;
        }
      }
    }
    return 0;
  };

  // ../../../packages/tlvalidate/src/lib/validation.ts
  var validation_exports = {};
  __export(validation_exports, {
    ArrayOfValidator: () => ArrayOfValidator,
    DictValidator: () => DictValidator,
    ObjectValidator: () => ObjectValidator,
    UnionValidator: () => UnionValidator,
    ValidationError: () => ValidationError,
    Validator: () => Validator,
    any: () => any,
    array: () => array,
    arrayOf: () => arrayOf,
    bigint: () => bigint,
    boolean: () => boolean,
    boxModel: () => boxModel,
    dict: () => dict,
    integer: () => integer,
    literal: () => literal,
    model: () => model,
    nonZeroInteger: () => nonZeroInteger,
    nonZeroNumber: () => nonZeroNumber,
    number: () => number,
    object: () => object,
    point: () => point,
    positiveInteger: () => positiveInteger,
    positiveNumber: () => positiveNumber,
    setEnum: () => setEnum,
    string: () => string,
    union: () => union,
    unknown: () => unknown,
    unknownObject: () => unknownObject
  });
  function formatPath(path) {
    if (!path.length) {
      return null;
    }
    let formattedPath = "";
    for (const item of path) {
      if (typeof item === "number") {
        formattedPath += `.${item}`;
      } else if (item.startsWith("(")) {
        if (formattedPath.endsWith(")")) {
          formattedPath = `${formattedPath.slice(0, -1)}, ${item.slice(1)}`;
        } else {
          formattedPath += item;
        }
      } else {
        formattedPath += `.${item}`;
      }
    }
    if (formattedPath.startsWith(".")) {
      return formattedPath.slice(1);
    }
    return formattedPath;
  }
  var ValidationError = class extends Error {
    constructor(rawMessage, path = []) {
      const formattedPath = formatPath(path);
      const indentedMessage = rawMessage.split("\n").map((line, i3) => i3 === 0 ? line : `  ${line}`).join("\n");
      super(path ? `At ${formattedPath}: ${indentedMessage}` : indentedMessage);
      this.rawMessage = rawMessage;
      this.path = path;
      __publicField(this, "name", "ValidationError");
    }
  };
  function prefixError(path, fn) {
    try {
      return fn();
    } catch (err) {
      if (err instanceof ValidationError) {
        throw new ValidationError(err.rawMessage, [path, ...err.path]);
      }
      throw new ValidationError(err.toString(), [path]);
    }
  }
  function typeToString(value) {
    if (value === null)
      return "null";
    if (Array.isArray(value))
      return "an array";
    const type = typeof value;
    switch (type) {
      case "bigint":
      case "boolean":
      case "function":
      case "number":
      case "string":
      case "symbol":
        return `a ${type}`;
      case "object":
        return `an ${type}`;
      case "undefined":
        return "undefined";
      default:
        exhaustiveSwitchError(type);
    }
  }
  var Validator = class {
    constructor(validationFn) {
      this.validationFn = validationFn;
    }
    /**
     * Asserts that the passed value is of the correct type and returns it. The returned value is
     * guaranteed to be referentially equal to the passed value.
     */
    validate(value) {
      const validated = this.validationFn(value);
      if (false) {
        throw new ValidationError("Validator functions must return the same value they were passed");
      }
      return validated;
    }
    /**
     * Returns a new validator that also accepts null or undefined. The resulting value will always be
     * null.
     */
    nullable() {
      return new Validator((value) => {
        if (value === null)
          return null;
        return this.validate(value);
      });
    }
    /**
     * Returns a new validator that also accepts null or undefined. The resulting value will always be
     * null.
     */
    optional() {
      return new Validator((value) => {
        if (value === void 0)
          return void 0;
        return this.validate(value);
      });
    }
    /**
     * Refine this validation to a new type. The passed-in validation function should throw an error
     * if the value can't be converted to the new type, or return the new type otherwise.
     */
    refine(otherValidationFn) {
      return new Validator((value) => {
        return otherValidationFn(this.validate(value));
      });
    }
    check(nameOrCheckFn, checkFn) {
      if (typeof nameOrCheckFn === "string") {
        return this.refine((value) => {
          prefixError(`(check ${nameOrCheckFn})`, () => checkFn(value));
          return value;
        });
      } else {
        return this.refine((value) => {
          nameOrCheckFn(value);
          return value;
        });
      }
    }
  };
  var ArrayOfValidator = class extends Validator {
    constructor(itemValidator) {
      super((value) => {
        const arr = array.validate(value);
        for (let i3 = 0; i3 < arr.length; i3++) {
          prefixError(i3, () => itemValidator.validate(arr[i3]));
        }
        return arr;
      });
      this.itemValidator = itemValidator;
    }
    nonEmpty() {
      return this.check((value) => {
        if (value.length === 0) {
          throw new ValidationError("Expected a non-empty array");
        }
      });
    }
    lengthGreaterThan1() {
      return this.check((value) => {
        if (value.length <= 1) {
          throw new ValidationError("Expected an array with length greater than 1");
        }
      });
    }
  };
  var ObjectValidator = class extends Validator {
    constructor(config, shouldAllowUnknownProperties = false) {
      super((object2) => {
        if (typeof object2 !== "object" || object2 === null) {
          throw new ValidationError(`Expected object, got ${typeToString(object2)}`);
        }
        for (const [key, validator] of Object.entries(config)) {
          prefixError(key, () => {
            ;
            validator.validate(getOwnProperty(object2, key));
          });
        }
        if (!shouldAllowUnknownProperties) {
          for (const key of Object.keys(object2)) {
            if (!hasOwnProperty(config, key)) {
              throw new ValidationError(`Unexpected property`, [key]);
            }
          }
        }
        return object2;
      });
      this.config = config;
      this.shouldAllowUnknownProperties = shouldAllowUnknownProperties;
    }
    allowUnknownProperties() {
      return new ObjectValidator(this.config, true);
    }
    /**
     * Extend an object validator by adding additional properties.
     *
     * @example
     *
     * ```ts
     * const animalValidator = T.object({
     * 	name: T.string,
     * })
     * const catValidator = animalValidator.extend({
     * 	meowVolume: T.number,
     * })
     * ```
     */
    extend(extension) {
      return new ObjectValidator(__spreadValues(__spreadValues({}, this.config), extension));
    }
  };
  var UnionValidator = class extends Validator {
    constructor(key, config, unknownValueValidation) {
      super((input) => {
        if (typeof input !== "object" || input === null) {
          throw new ValidationError(`Expected an object, got ${typeToString(input)}`, []);
        }
        const variant = getOwnProperty(input, key);
        if (typeof variant !== "string") {
          throw new ValidationError(
            `Expected a string for key "${key}", got ${typeToString(variant)}`
          );
        }
        const matchingSchema = hasOwnProperty(config, variant) ? config[variant] : void 0;
        if (matchingSchema === void 0) {
          return this.unknownValueValidation(input, variant);
        }
        return prefixError(`(${key} = ${variant})`, () => matchingSchema.validate(input));
      });
      this.key = key;
      this.config = config;
      this.unknownValueValidation = unknownValueValidation;
    }
    validateUnknownVariants(unknownValueValidation) {
      return new UnionValidator(this.key, this.config, unknownValueValidation);
    }
  };
  var DictValidator = class extends Validator {
    constructor(keyValidator, valueValidator) {
      super((object2) => {
        if (typeof object2 !== "object" || object2 === null) {
          throw new ValidationError(`Expected object, got ${typeToString(object2)}`);
        }
        for (const [key, value] of Object.entries(object2)) {
          prefixError(key, () => {
            keyValidator.validate(key);
            valueValidator.validate(value);
          });
        }
        return object2;
      });
      this.keyValidator = keyValidator;
      this.valueValidator = valueValidator;
    }
  };
  function typeofValidator(type) {
    return new Validator((value) => {
      if (typeof value !== type) {
        throw new ValidationError(`Expected ${type}, got ${typeToString(value)}`);
      }
      return value;
    });
  }
  var unknown = new Validator((value) => value);
  var any = new Validator((value) => value);
  var string = typeofValidator("string");
  var number = typeofValidator("number").check((number2) => {
    if (Number.isNaN(number2)) {
      throw new ValidationError("Expected a number, got NaN");
    }
    if (!Number.isFinite(number2)) {
      throw new ValidationError(`Expected a finite number, got ${number2}`);
    }
  });
  var positiveNumber = number.check((value) => {
    if (value < 0)
      throw new ValidationError(`Expected a positive number, got ${value}`);
  });
  var nonZeroNumber = number.check((value) => {
    if (value <= 0)
      throw new ValidationError(`Expected a non-zero positive number, got ${value}`);
  });
  var integer = number.check((value) => {
    if (!Number.isInteger(value))
      throw new ValidationError(`Expected an integer, got ${value}`);
  });
  var positiveInteger = integer.check((value) => {
    if (value < 0)
      throw new ValidationError(`Expected a positive integer, got ${value}`);
  });
  var nonZeroInteger = integer.check((value) => {
    if (value <= 0)
      throw new ValidationError(`Expected a non-zero positive integer, got ${value}`);
  });
  var boolean = typeofValidator("boolean");
  var bigint = typeofValidator("bigint");
  function literal(expectedValue) {
    return new Validator((actualValue) => {
      if (actualValue !== expectedValue) {
        throw new ValidationError(`Expected ${expectedValue}, got ${JSON.stringify(actualValue)}`);
      }
      return expectedValue;
    });
  }
  var array = new Validator((value) => {
    if (!Array.isArray(value)) {
      throw new ValidationError(`Expected an array, got ${typeToString(value)}`);
    }
    return value;
  });
  function arrayOf(itemValidator) {
    return new ArrayOfValidator(itemValidator);
  }
  var unknownObject = new Validator((value) => {
    if (typeof value !== "object" || value === null) {
      throw new ValidationError(`Expected object, got ${typeToString(value)}`);
    }
    return value;
  });
  function object(config) {
    return new ObjectValidator(config);
  }
  function dict(keyValidator, valueValidator) {
    return new DictValidator(keyValidator, valueValidator);
  }
  function union(key, config) {
    return new UnionValidator(key, config, (unknownValue, unknownVariant) => {
      throw new ValidationError(
        `Expected one of ${Object.keys(config).map((key2) => JSON.stringify(key2)).join(" or ")}, got ${JSON.stringify(unknownVariant)}`,
        [key]
      );
    });
  }
  function model(name, validator) {
    return new Validator((value) => {
      const prefix = value && typeof value === "object" && "id" in value && typeof value.id === "string" ? `${name}(id = ${value.id})` : name;
      return prefixError(prefix, () => validator.validate(value));
    });
  }
  function setEnum(values) {
    return new Validator((value) => {
      if (!values.has(value)) {
        const valuesString = Array.from(values, (value2) => JSON.stringify(value2)).join(" or ");
        throw new ValidationError(`Expected ${valuesString}, got ${value}`);
      }
      return value;
    });
  }
  var point = object({
    x: number,
    y: number,
    z: number.optional()
  });
  var boxModel = object({
    x: number,
    y: number,
    w: number,
    h: number
  });

  // ../../../packages/tlschema/src/style-types.ts
  var TL_STYLE_TYPES = /* @__PURE__ */ new Set([
    "color",
    "labelColor",
    "dash",
    "fill",
    "size",
    "opacity",
    "font",
    "align",
    "icon",
    "geo",
    "arrowheadStart",
    "arrowheadEnd",
    "spline"
  ]);
  var TL_COLOR_TYPES = /* @__PURE__ */ new Set([
    "black",
    "grey",
    "light-violet",
    "violet",
    "blue",
    "light-blue",
    "yellow",
    "orange",
    "green",
    "light-green",
    "light-red",
    "red"
  ]);
  var TL_DASH_TYPES = /* @__PURE__ */ new Set(["draw", "solid", "dashed", "dotted"]);
  var TL_FILL_TYPES = /* @__PURE__ */ new Set(["none", "semi", "solid", "pattern"]);
  var TL_SIZE_TYPES = /* @__PURE__ */ new Set(["s", "m", "l", "xl"]);
  var TL_OPACITY_TYPES = /* @__PURE__ */ new Set(["0.1", "0.25", "0.5", "0.75", "1"]);
  var TL_FONT_TYPES = /* @__PURE__ */ new Set(["draw", "sans", "serif", "mono"]);
  var TL_ALIGN_TYPES = /* @__PURE__ */ new Set(["start", "middle", "end"]);
  var TL_GEO_TYPES = /* @__PURE__ */ new Set([
    "rectangle",
    "ellipse",
    "triangle",
    "diamond",
    "pentagon",
    "hexagon",
    "octagon",
    "star",
    "rhombus",
    "rhombus-2",
    "oval",
    "trapezoid",
    "arrow-right",
    "arrow-left",
    "arrow-up",
    "arrow-down",
    "x-box",
    "check-box"
  ]);
  var TL_ARROWHEAD_TYPES = /* @__PURE__ */ new Set([
    "arrow",
    "triangle",
    "square",
    "dot",
    "pipe",
    "diamond",
    "inverted",
    "bar",
    "none"
  ]);
  var TL_SPLINE_TYPES = /* @__PURE__ */ new Set(["cubic", "line"]);
  var TL_ICON_TYPES = /* @__PURE__ */ new Set([
    "activity",
    "airplay",
    "alert-circle",
    "alert-octagon",
    "alert-triangle",
    "align-center",
    "align-justify",
    "align-left",
    "align-right",
    "anchor",
    "aperture",
    "archive",
    "arrow-down-circle",
    "arrow-down-left",
    "arrow-down-right",
    "arrow-down",
    "arrow-left-circle",
    "arrow-left",
    "arrow-right-circle",
    "arrow-right",
    "arrow-up-circle",
    "arrow-up-left",
    "arrow-up-right",
    "arrow-up",
    "at-sign",
    "award",
    "bar-chart-2",
    "bar-chart",
    "battery-charging",
    "battery",
    "bell-off",
    "bell",
    "bluetooth",
    "bold",
    "book-open",
    "book",
    "bookmark",
    "geo",
    "briefcase",
    "calendar",
    "camera-off",
    "camera",
    "cast",
    "check-circle",
    "check-square",
    "check",
    "chevron-down",
    "chevron-left",
    "chevron-right",
    "chevron-up",
    "chevrons-down",
    "chevrons-left",
    "chevrons-right",
    "chevrons-up",
    "chrome",
    "circle",
    "clipboard",
    "clock",
    "cloud-drizzle",
    "cloud-lightning",
    "cloud-off",
    "cloud-rain",
    "cloud-snow",
    "cloud",
    "codepen",
    "codesandbox",
    "coffee",
    "columns",
    "command",
    "compass",
    "copy",
    "corner-down-left",
    "corner-down-right",
    "corner-left-down",
    "corner-left-up",
    "corner-right-down",
    "corner-right-up",
    "corner-up-left",
    "corner-up-right",
    "cpu",
    "credit-card",
    "crop",
    "crosshair",
    "database",
    "delete",
    "disc",
    "divide-circle",
    "divide-square",
    "divide",
    "dollar-sign",
    "download-cloud",
    "download",
    "dribbble",
    "droplet",
    "edit-2",
    "edit-3",
    "edit",
    "external-link",
    "eye-off",
    "eye",
    "facebook",
    "fast-forward",
    "feather",
    "figma",
    "file-minus",
    "file-plus",
    "file-text",
    "file",
    "film",
    "filter",
    "flag",
    "folder-minus",
    "folder-plus",
    "folder",
    "framer",
    "frown",
    "gift",
    "git-branch",
    "git-commit",
    "git-merge",
    "git-pull-request",
    "github",
    "gitlab",
    "globe",
    "grid",
    "hard-drive",
    "hash",
    "headphones",
    "heart",
    "help-circle",
    "hexagon",
    "home",
    "image",
    "inbox",
    "info",
    "instagram",
    "italic",
    "key",
    "layers",
    "layout",
    "life-buoy",
    "link-2",
    "link",
    "linkedin",
    "list",
    "loader",
    "lock",
    "log-in",
    "log-out",
    "mail",
    "map-pin",
    "map",
    "maximize-2",
    "maximize",
    "meh",
    "menu",
    "message-circle",
    "message-square",
    "mic-off",
    "mic",
    "minimize-2",
    "minimize",
    "minus-circle",
    "minus-square",
    "minus",
    "monitor",
    "moon",
    "more-horizontal",
    "more-vertical",
    "mouse-pointer",
    "move",
    "music",
    "navigation-2",
    "navigation",
    "octagon",
    "package",
    "paperclip",
    "pause-circle",
    "pause",
    "pen-tool",
    "percent",
    "phone-call",
    "phone-forwarded",
    "phone-incoming",
    "phone-missed",
    "phone-off",
    "phone-outgoing",
    "phone",
    "pie-chart",
    "play-circle",
    "play",
    "plus-circle",
    "plus-square",
    "plus",
    "pocket",
    "power",
    "printer",
    "radio",
    "refresh-ccw",
    "refresh-cw",
    "repeat",
    "rewind",
    "rotate-ccw",
    "rotate-cw",
    "rss",
    "save",
    "scissors",
    "search",
    "send",
    "server",
    "settings",
    "share-2",
    "share",
    "shield-off",
    "shield",
    "shopping-bag",
    "shopping-cart",
    "shuffle",
    "sidebar",
    "skip-back",
    "skip-forward",
    "slack",
    "slash",
    "sliders",
    "smartphone",
    "smile",
    "speaker",
    "square",
    "star",
    "stop-circle",
    "sun",
    "sunrise",
    "sunset",
    "table",
    "tablet",
    "tag",
    "target",
    "terminal",
    "thermometer",
    "thumbs-down",
    "thumbs-up",
    "toggle-left",
    "toggle-right",
    "tool",
    "trash-2",
    "trash",
    "trello",
    "trending-down",
    "trending-up",
    "triangle",
    "truck",
    "tv",
    "twitch",
    "twitter",
    "type",
    "umbrella",
    "underline",
    "unlock",
    "upload-cloud",
    "upload",
    "user-check",
    "user-minus",
    "user-plus",
    "user-x",
    "user",
    "users",
    "video-off",
    "video",
    "voicemail",
    "volume-1",
    "volume-2",
    "volume-x",
    "volume",
    "watch",
    "wifi-off",
    "wifi",
    "wind",
    "x-circle",
    "x-octagon",
    "x-square",
    "x",
    "youtube",
    "zap-off",
    "zap",
    "zoom-in",
    "zoom-out"
  ]);

  // ../../../packages/tlschema/src/validation.ts
  function idValidator(prefix) {
    return validation_exports.string.refine((id) => {
      if (!id.startsWith(`${prefix}:`)) {
        throw new Error(`${prefix} ID must start with "${prefix}:"`);
      }
      return id;
    });
  }
  var userIdValidator = idValidator("user");
  var assetIdValidator = idValidator("asset");
  var pageIdValidator = idValidator("page");
  var shapeIdValidator = idValidator("shape");
  var instanceIdValidator = idValidator("instance");
  var parentIdValidator = validation_exports.string.refine((id) => {
    if (!id.startsWith("page:") && !id.startsWith("shape:")) {
      throw new Error('Parent ID must start with "page:" or "shape:"');
    }
    return id;
  });
  var colorValidator = validation_exports.setEnum(TL_COLOR_TYPES);
  var dashValidator = validation_exports.setEnum(TL_DASH_TYPES);
  var fillValidator = validation_exports.setEnum(TL_FILL_TYPES);
  var geoValidator = validation_exports.setEnum(TL_GEO_TYPES);
  var sizeValidator = validation_exports.setEnum(TL_SIZE_TYPES);
  var fontValidator = validation_exports.setEnum(TL_FONT_TYPES);
  var alignValidator = validation_exports.setEnum(TL_ALIGN_TYPES);
  var arrowheadValidator = validation_exports.setEnum(TL_ARROWHEAD_TYPES);
  var opacityValidator = validation_exports.setEnum(TL_OPACITY_TYPES);
  var iconValidator = validation_exports.setEnum(TL_ICON_TYPES);
  var splineValidator = validation_exports.setEnum(TL_SPLINE_TYPES);

  // ../../../packages/tlschema/src/records/TLCamera.ts
  var cameraTypeValidator = validation_exports.model(
    "camera",
    validation_exports.object({
      typeName: validation_exports.literal("camera"),
      id: idValidator("camera"),
      x: validation_exports.number,
      y: validation_exports.number,
      z: validation_exports.number
    })
  );
  var Versions = {
    Initial: 0
  };
  var cameraTypeMigrations = defineMigrations({
    firstVersion: Versions.Initial,
    // STEP 2: Update the current version to point to your latest version
    currentVersion: Versions.Initial,
    // STEP 3: Add an up+down migration for the new version here
    migrators: {}
  });
  var TLCamera = createRecordType("camera", {
    migrations: cameraTypeMigrations,
    validator: cameraTypeValidator,
    scope: "instance"
  }).withDefaultProperties(
    () => ({
      x: 0,
      y: 0,
      z: 1
    })
  );

  // ../../../packages/tlschema/src/records/TLDocument.ts
  var documentTypeValidator = validation_exports.model(
    "document",
    validation_exports.object({
      typeName: validation_exports.literal("document"),
      id: validation_exports.literal("document:document"),
      gridSize: validation_exports.number
    })
  );
  var Versions2 = {
    Initial: 0
  };
  var documentTypeMigrations = defineMigrations({
    firstVersion: Versions2.Initial,
    // STEP 2: Update the current version to point to your latest version
    currentVersion: Versions2.Initial,
    // STEP 3: Add an up+down migration for the new version here
    migrators: {}
  });
  var TLDocument = createRecordType("document", {
    migrations: documentTypeMigrations,
    validator: documentTypeValidator,
    scope: "document"
  }).withDefaultProperties(
    () => ({
      gridSize: 10
    })
  );
  var TLDOCUMENT_ID = TLDocument.createCustomId("document");

  // ../../../packages/tlschema/src/ui-types.ts
  var TL_UI_COLOR_TYPES = /* @__PURE__ */ new Set([
    "accent",
    "white",
    "black",
    "selection-stroke",
    "selection-fill",
    "muted-1"
  ]);
  var uiColorTypeValidator = validation_exports.setEnum(TL_UI_COLOR_TYPES);
  var TL_CURSOR_TYPES = /* @__PURE__ */ new Set([
    "none",
    "default",
    "pointer",
    "cross",
    "grab",
    "rotate",
    "grabbing",
    "resize-edge",
    "resize-corner",
    "text",
    "move",
    "ew-resize",
    "ns-resize",
    "nesw-resize",
    "nwse-resize",
    "nesw-rotate",
    "nwse-rotate",
    "swne-rotate",
    "senw-rotate",
    "zoom-in",
    "zoom-out"
  ]);
  var cursorTypeValidator = validation_exports.setEnum(TL_CURSOR_TYPES);
  var cursorValidator = validation_exports.object({
    color: uiColorTypeValidator,
    type: cursorTypeValidator,
    rotation: validation_exports.number
  });
  var TL_SCRIBBLE_STATES = /* @__PURE__ */ new Set(["starting", "paused", "active", "stopping"]);
  var scribbleTypeValidator = validation_exports.object({
    points: validation_exports.arrayOf(validation_exports.point),
    size: validation_exports.positiveNumber,
    color: uiColorTypeValidator,
    opacity: validation_exports.number,
    state: validation_exports.setEnum(TL_SCRIBBLE_STATES)
  });
  var TL_HANDLE_TYPES = /* @__PURE__ */ new Set(["vertex", "virtual", "create"]);
  var handleTypeValidator = validation_exports.object({
    id: validation_exports.string,
    type: validation_exports.setEnum(TL_HANDLE_TYPES),
    canBind: validation_exports.boolean.optional(),
    index: validation_exports.string,
    x: validation_exports.number,
    y: validation_exports.number
  });

  // ../../../packages/tlschema/src/records/TLInstance.ts
  var instanceTypeValidator = validation_exports.model(
    "instance",
    validation_exports.object({
      typeName: validation_exports.literal("instance"),
      id: idValidator("instance"),
      userId: userIdValidator,
      currentPageId: pageIdValidator,
      followingUserId: userIdValidator.nullable(),
      brush: validation_exports.boxModel.nullable(),
      propsForNextShape: validation_exports.object({
        color: colorValidator,
        labelColor: colorValidator,
        dash: dashValidator,
        fill: fillValidator,
        size: sizeValidator,
        opacity: opacityValidator,
        font: fontValidator,
        align: alignValidator,
        icon: iconValidator,
        geo: geoValidator,
        arrowheadStart: arrowheadValidator,
        arrowheadEnd: arrowheadValidator,
        spline: splineValidator
      }),
      cursor: cursorValidator,
      scribble: scribbleTypeValidator.nullable(),
      isFocusMode: validation_exports.boolean,
      isDebugMode: validation_exports.boolean,
      isToolLocked: validation_exports.boolean,
      exportBackground: validation_exports.boolean,
      screenBounds: validation_exports.boxModel,
      zoomBrush: validation_exports.boxModel.nullable()
    })
  );
  var Versions3 = {
    Initial: 0,
    AddTransparentExportBgs: 1,
    RemoveDialog: 2,
    AddToolLockMode: 3,
    RemoveExtraPropsForNextShape: 4,
    AddLabelColor: 5,
    AddFollowingUserId: 6,
    RemoveAlignJustify: 7,
    AddZoom: 8
  };
  var instanceTypeMigrations = defineMigrations({
    firstVersion: Versions3.Initial,
    // STEP 2: Update the current version to point to your latest version
    currentVersion: Versions3.AddZoom,
    // STEP 3: Add an up+down migration for the new version here
    migrators: {
      [Versions3.AddTransparentExportBgs]: {
        up: (instance) => {
          return __spreadProps(__spreadValues({}, instance), { exportBackground: true });
        },
        down: (_a5) => {
          var _b2 = _a5, { exportBackground: _ } = _b2, instance = __objRest(_b2, ["exportBackground"]);
          return instance;
        }
      },
      [Versions3.RemoveDialog]: {
        up: (_c) => {
          var _d = _c, { dialog: _ } = _d, instance = __objRest(_d, ["dialog"]);
          return instance;
        },
        down: (instance) => {
          return __spreadProps(__spreadValues({}, instance), { dialog: null });
        }
      },
      [Versions3.AddToolLockMode]: {
        up: (instance) => {
          return __spreadProps(__spreadValues({}, instance), { isToolLocked: false });
        },
        down: (_e) => {
          var _f = _e, { isToolLocked: _ } = _f, instance = __objRest(_f, ["isToolLocked"]);
          return instance;
        }
      },
      [Versions3.RemoveExtraPropsForNextShape]: {
        up: (_g) => {
          var _h = _g, { propsForNextShape } = _h, instance = __objRest(_h, ["propsForNextShape"]);
          return __spreadProps(__spreadValues({}, instance), {
            propsForNextShape: Object.fromEntries(
              Object.entries(propsForNextShape).filter(
                ([key]) => TL_STYLE_TYPES.has(key)
              )
            )
          });
        },
        down: (instance) => {
          return instance;
        }
      },
      [Versions3.AddLabelColor]: {
        up: (_i) => {
          var _j = _i, { propsForNextShape } = _j, instance = __objRest(_j, ["propsForNextShape"]);
          return __spreadProps(__spreadValues({}, instance), {
            propsForNextShape: __spreadProps(__spreadValues({}, propsForNextShape), {
              labelColor: "black"
            })
          });
        },
        down: (instance) => {
          const _a5 = instance.propsForNextShape, { labelColor: _ } = _a5, rest = __objRest(_a5, ["labelColor"]);
          return __spreadProps(__spreadValues({}, instance), {
            propsForNextShape: __spreadValues({}, rest)
          });
        }
      },
      [Versions3.AddFollowingUserId]: {
        up: (instance) => {
          return __spreadProps(__spreadValues({}, instance), { followingUserId: null });
        },
        down: (_k) => {
          var _l = _k, { followingUserId: _ } = _l, instance = __objRest(_l, ["followingUserId"]);
          return instance;
        }
      },
      [Versions3.RemoveAlignJustify]: {
        up: (instance) => {
          let newAlign = instance.propsForNextShape.align;
          if (newAlign === "justify") {
            newAlign = "start";
          }
          return __spreadProps(__spreadValues({}, instance), {
            propsForNextShape: __spreadProps(__spreadValues({}, instance.propsForNextShape), {
              align: newAlign
            })
          });
        },
        down: (instance) => {
          return __spreadValues({}, instance);
        }
      },
      [Versions3.AddZoom]: {
        up: (instance) => {
          return __spreadProps(__spreadValues({}, instance), { zoomBrush: null });
        },
        down: (_m) => {
          var _n = _m, { zoomBrush: _ } = _n, instance = __objRest(_n, ["zoomBrush"]);
          return instance;
        }
      }
    }
  });
  var TLInstance = createRecordType("instance", {
    migrations: instanceTypeMigrations,
    validator: instanceTypeValidator,
    scope: "instance"
  }).withDefaultProperties(
    () => ({
      followingUserId: null,
      propsForNextShape: {
        opacity: "1",
        color: "black",
        labelColor: "black",
        dash: "draw",
        fill: "none",
        size: "m",
        icon: "file",
        font: "draw",
        align: "middle",
        geo: "rectangle",
        arrowheadStart: "none",
        arrowheadEnd: "arrow",
        spline: "line"
      },
      brush: null,
      scribble: null,
      cursor: {
        type: "default",
        color: "black",
        rotation: 0
      },
      isFocusMode: false,
      exportBackground: false,
      isDebugMode: false,
      isToolLocked: false,
      screenBounds: { x: 0, y: 0, w: 1080, h: 720 },
      zoomBrush: null
    })
  );

  // ../../../packages/tlschema/src/records/TLInstancePageState.ts
  var instancePageStateTypeValidator = validation_exports.model(
    "instance_page_state",
    validation_exports.object({
      typeName: validation_exports.literal("instance_page_state"),
      id: idValidator("instance_page_state"),
      instanceId: instanceIdValidator,
      pageId: pageIdValidator,
      cameraId: idValidator("camera"),
      selectedIds: validation_exports.arrayOf(shapeIdValidator),
      hintingIds: validation_exports.arrayOf(shapeIdValidator),
      erasingIds: validation_exports.arrayOf(shapeIdValidator),
      hoveredId: shapeIdValidator.nullable(),
      editingId: shapeIdValidator.nullable(),
      croppingId: shapeIdValidator.nullable(),
      focusLayerId: shapeIdValidator.nullable()
    })
  );
  var Versions4 = {
    Initial: 0,
    AddCroppingId: 1
  };
  var instancePageStateMigrations = defineMigrations({
    firstVersion: Versions4.Initial,
    currentVersion: Versions4.AddCroppingId,
    migrators: {
      [Versions4.AddCroppingId]: {
        up(instance) {
          return __spreadProps(__spreadValues({}, instance), { croppingId: null });
        },
        down(_a5) {
          var _b2 = _a5, { croppingId: _croppingId } = _b2, instance = __objRest(_b2, ["croppingId"]);
          return instance;
        }
      }
    }
  });
  var TLInstancePageState = createRecordType("instance_page_state", {
    migrations: instancePageStateMigrations,
    validator: instancePageStateTypeValidator,
    scope: "instance"
  }).withDefaultProperties(
    () => ({
      editingId: null,
      croppingId: null,
      selectedIds: [],
      hoveredId: null,
      erasingIds: [],
      hintingIds: [],
      focusLayerId: null
    })
  );

  // ../../../packages/tlschema/src/records/TLPage.ts
  var pageTypeValidator = validation_exports.model(
    "page",
    validation_exports.object({
      typeName: validation_exports.literal("page"),
      id: pageIdValidator,
      name: validation_exports.string,
      index: validation_exports.string
    })
  );
  var Versions5 = {
    Initial: 0
  };
  var pageTypeMigrations = defineMigrations({
    firstVersion: Versions5.Initial,
    // STEP 2: Update the current version to point to your latest version
    currentVersion: Versions5.Initial,
    // STEP 3: Add an up+down migration for the new version here
    migrators: {}
  });
  var TLPage = createRecordType("page", {
    migrations: pageTypeMigrations,
    validator: pageTypeValidator,
    scope: "document"
  });

  // ../../../packages/tlschema/src/languages.ts
  var LANGUAGES = [
    { locale: "ar", label: "\u0639\u0631\u0628\u064A" },
    { locale: "ca", label: "Catal\xE0" },
    { locale: "da", label: "Danish" },
    { locale: "de", label: "Deutsch" },
    { locale: "en", label: "English" },
    { locale: "es", label: "Espa\xF1ol" },
    { locale: "fa", label: "\u0641\u0627\u0631\u0633\u06CC" },
    { locale: "fi", label: "Suomi" },
    { locale: "fr", label: "Fran\xE7ais" },
    { locale: "gl", label: "Galego" },
    { locale: "he", label: "\u05E2\u05D1\u05E8\u05D9\u05EA" },
    { locale: "it", label: "Italiano" },
    { locale: "ja", label: "\u65E5\u672C\u8A9E" },
    { locale: "ko-kr", label: "\uD55C\uAD6D\uC5B4" },
    { locale: "ku", label: "\u06A9\u0648\u0631\u062F\u06CC" },
    { locale: "hi-in", label: "\u0939\u093F\u0928\u094D\u0926\u0940" },
    { locale: "hu", label: "Magyar" },
    { locale: "my", label: "\u1019\u103C\u1014\u103A\u1019\u102C\u1005\u102C" },
    { locale: "ne", label: "\u0928\u0947\u092A\u093E\u0932\u0940" },
    { locale: "no", label: "Norwegian" },
    { locale: "pl", label: "Polski" },
    { locale: "pt-br", label: "Portugu\xEAs - Brasil" },
    { locale: "pt-pt", label: "Portugu\xEAs - Europeu" },
    { locale: "ro", label: "Rom\xE2n\u0103" },
    { locale: "ru", label: "Russian" },
    { locale: "sv", label: "Svenska" },
    { locale: "te", label: "\u0C24\u0C46\u0C32\u0C41\u0C17\u0C41" },
    { locale: "th", label: "\u0E20\u0E32\u0E29\u0E32\u0E44\u0E17\u0E22" },
    { locale: "tr", label: "T\xFCrk\xE7e" },
    { locale: "uk", label: "Ukrainian" },
    { locale: "vi", label: "Ti\u1EBFng Vi\u1EC7t" },
    { locale: "zh-cn", label: "Chinese - Simplified" },
    { locale: "zh-tw", label: "\u7E41\u9AD4\u4E2D\u6587 (\u53F0\u7063)" }
  ];

  // ../../../packages/tlschema/src/translations.ts
  function getDefaultTranslationLocale(locales) {
    for (const locale of locales) {
      const supportedLocale = getSupportedLocale(locale);
      if (supportedLocale) {
        return supportedLocale;
      }
    }
    return "en";
  }
  var DEFAULT_LOCALE_REGIONS = {
    zh: "zh-cn",
    pt: "pt-br",
    ko: "ko-kr",
    hi: "hi-in"
  };
  function getSupportedLocale(locale) {
    const exactMatch = LANGUAGES.find((t4) => t4.locale === locale.toLowerCase());
    if (exactMatch) {
      return exactMatch.locale;
    }
    const [language, region] = locale.split(/[-_]/).map((s3) => s3.toLowerCase());
    if (region) {
      const languageMatch = LANGUAGES.find((t4) => t4.locale === language);
      if (languageMatch) {
        return languageMatch.locale;
      }
    }
    if (language in DEFAULT_LOCALE_REGIONS) {
      return DEFAULT_LOCALE_REGIONS[language];
    }
    return null;
  }

  // ../../../packages/tlschema/src/records/TLUser.ts
  var userTypeValidator = validation_exports.model(
    "user",
    validation_exports.object({
      typeName: validation_exports.literal("user"),
      id: userIdValidator,
      name: validation_exports.string,
      locale: validation_exports.string
    })
  );
  var Versions6 = {
    Initial: 0
  };
  var userTypeMigrations = defineMigrations({
    // STEP 2: Update the current version to point to your latest version
    currentVersion: Versions6.Initial,
    firstVersion: Versions6.Initial,
    migrators: {
      // STEP 3: Add an up+down migration for the new version here
    }
  });
  var TLUser = createRecordType("user", {
    migrations: userTypeMigrations,
    validator: userTypeValidator,
    scope: "instance"
  }).withDefaultProperties(() => {
    let locale = "en";
    if (typeof window !== "undefined" && window.navigator) {
      locale = getDefaultTranslationLocale(window.navigator.languages);
    }
    return {
      name: "New User",
      locale
    };
  });

  // ../../../packages/tlschema/src/records/TLUserDocument.ts
  var userDocumentTypeValidator = validation_exports.model(
    "user_document",
    validation_exports.object({
      typeName: validation_exports.literal("user_document"),
      id: idValidator("user_document"),
      userId: userIdValidator,
      isPenMode: validation_exports.boolean,
      isGridMode: validation_exports.boolean,
      isDarkMode: validation_exports.boolean,
      isMobileMode: validation_exports.boolean,
      isSnapMode: validation_exports.boolean,
      lastUpdatedPageId: pageIdValidator.nullable(),
      lastUsedTabId: instanceIdValidator.nullable()
    })
  );
  var userDocumentVersions = {
    Initial: 0,
    AddSnapMode: 1,
    AddMissingIsMobileMode: 2,
    RemoveIsReadOnly: 3
  };
  var userDocumentTypeMigrations = defineMigrations({
    firstVersion: userDocumentVersions.Initial,
    // STEP 2: Update the current version to point to your latest version
    currentVersion: userDocumentVersions.RemoveIsReadOnly,
    // STEP 3: Add an up+down migration for the new version here
    migrators: {
      [userDocumentVersions.AddSnapMode]: {
        up: (userDocument) => {
          return __spreadProps(__spreadValues({}, userDocument), { isSnapMode: false });
        },
        down: (_a5) => {
          var _b2 = _a5, { isSnapMode: _ } = _b2, userDocument = __objRest(_b2, ["isSnapMode"]);
          return userDocument;
        }
      },
      [userDocumentVersions.AddMissingIsMobileMode]: {
        up: (userDocument) => {
          var _a5;
          return __spreadProps(__spreadValues({}, userDocument), { isMobileMode: (_a5 = userDocument.isMobileMode) != null ? _a5 : false });
        },
        down: (_c) => {
          var _d = _c, { isMobileMode: _ } = _d, userDocument = __objRest(_d, ["isMobileMode"]);
          return userDocument;
        }
      },
      [userDocumentVersions.RemoveIsReadOnly]: {
        up: (_e) => {
          var _f = _e, { isReadOnly: _ } = _f, userDocument = __objRest(_f, ["isReadOnly"]);
          return userDocument;
        },
        down: (userDocument) => {
          return __spreadProps(__spreadValues({}, userDocument), { isReadOnly: false });
        }
      }
    }
  });
  var TLUserDocument = createRecordType("user_document", {
    migrations: userDocumentTypeMigrations,
    validator: userDocumentTypeValidator,
    scope: "instance"
  }).withDefaultProperties(
    () => ({
      /* STEP 6: Add any new default values for properties here */
      isPenMode: false,
      isGridMode: false,
      isDarkMode: false,
      isMobileMode: false,
      isSnapMode: false,
      lastUpdatedPageId: null,
      lastUsedTabId: null
    })
  );

  // ../../../packages/tlschema/src/records/TLUserPresence.ts
  var userPresenceTypeValidator = validation_exports.model(
    "user_presence",
    validation_exports.object({
      typeName: validation_exports.literal("user_presence"),
      id: idValidator("user_presence"),
      userId: userIdValidator,
      lastUsedInstanceId: instanceIdValidator.nullable(),
      lastActivityTimestamp: validation_exports.number,
      cursor: validation_exports.point,
      viewportPageBounds: validation_exports.boxModel,
      color: validation_exports.string
    })
  );
  var Versions7 = {
    Initial: 0,
    AddViewportPageBounds: 1
  };
  var userPresenceTypeMigrations = defineMigrations({
    // STEP 2: Update the current version to point to your latest version
    currentVersion: Versions7.AddViewportPageBounds,
    firstVersion: Versions7.Initial,
    migrators: {
      // STEP 3: Add an up+down migration for the new version here
      [Versions7.AddViewportPageBounds]: {
        up: (record) => {
          return __spreadProps(__spreadValues({}, record), {
            viewportPageBounds: { x: 0, y: 0, w: 1, h: 1 }
          });
        },
        down: (_a5) => {
          var _b2 = _a5, { viewportPageBounds: _viewportPageBounds } = _b2, rest = __objRest(_b2, ["viewportPageBounds"]);
          return rest;
        }
      }
    }
  });
  var TLUserPresence = createRecordType("user_presence", {
    migrations: userPresenceTypeMigrations,
    validator: userPresenceTypeValidator,
    scope: "instance"
  }).withDefaultProperties(
    () => ({
      lastUsedInstanceId: null,
      lastActivityTimestamp: 0,
      cursor: { x: 0, y: 0 },
      viewportPageBounds: { x: 0, y: 0, w: 1, h: 1 },
      color: "#000000"
    })
  );

  // ../../../packages/tlschema/src/TLStore.ts
  function sortByIndex(a3, b3) {
    if (a3.index < b3.index) {
      return -1;
    } else if (a3.index > b3.index) {
      return 1;
    }
    return 0;
  }
  var USER_COLORS = [
    "#FF802B",
    "#EC5E41",
    "#F2555A",
    "#F04F88",
    "#E34BA9",
    "#BD54C6",
    "#9D5BD2",
    "#7B66DC",
    "#02B1CC",
    "#11B3A3",
    "#39B178",
    "#55B467"
  ];
  function redactRecordForErrorReporting(record) {
    if (record.typeName === "asset") {
      if ("src" in record) {
        record.src = "<redacted>";
      }
      if ("src" in record.props) {
        record.props.src = "<redacted>";
      }
    }
  }
  var onValidationFailure = ({ error, phase, record, recordBefore }) => {
    const isExistingValidationIssue = (
      // if we're initializing the store for the first time, we should
      // allow invalid records so people can load old buggy data:
      phase === "initialize"
    );
    annotateError(error, {
      tags: {
        origin: "store.validateRecord",
        storePhase: phase,
        isExistingValidationIssue
      },
      extras: {
        recordBefore: recordBefore ? redactRecordForErrorReporting(structuredClone(recordBefore)) : void 0,
        recordAfter: redactRecordForErrorReporting(structuredClone(record))
      }
    });
    throw error;
  };
  function getRandomColor() {
    return USER_COLORS[Math.floor(Math.random() * USER_COLORS.length)];
  }
  function getDefaultPages() {
    return [TLPage.create({ name: "Page 1", index: "a1" })];
  }
  function createIntegrityChecker(store) {
    const $pages = store.query.records("page");
    const $userDocumentSettings = store.query.record("user_document", () => ({
      userId: { eq: store.props.userId }
    }));
    const $instanceState = store.query.record("instance", () => ({
      id: { eq: store.props.instanceId }
    }));
    const $user = store.query.record("user", () => ({ id: { eq: store.props.userId } }));
    const $userPresences = store.query.records("user_presence");
    const $instancePageStates = store.query.records("instance_page_state");
    const ensureStoreIsUsable = () => {
      var _a5, _b2;
      const { userId, instanceId: tabId } = store.props;
      if (!store.has(TLDOCUMENT_ID)) {
        store.put([TLDocument.create({ id: TLDOCUMENT_ID })]);
        return ensureStoreIsUsable();
      }
      const userDocumentSettings = $userDocumentSettings.value;
      if (!userDocumentSettings) {
        store.put([TLUserDocument.create({ userId })]);
        return ensureStoreIsUsable();
      }
      const pages = $pages.value.sort(sortByIndex);
      if (pages.length === 0) {
        store.put(getDefaultPages());
        return ensureStoreIsUsable();
      }
      const instanceState = $instanceState.value;
      if (!instanceState) {
        const propsForNextShape = userDocumentSettings.lastUsedTabId ? (_a5 = store.get(userDocumentSettings.lastUsedTabId)) == null ? void 0 : _a5.propsForNextShape : void 0;
        const currentPageId2 = (_b2 = userDocumentSettings == null ? void 0 : userDocumentSettings.lastUpdatedPageId) != null ? _b2 : pages[0].id;
        store.put([
          TLInstance.create({
            id: tabId,
            userId,
            currentPageId: currentPageId2,
            propsForNextShape,
            exportBackground: true
          })
        ]);
        return ensureStoreIsUsable();
      }
      let currentPageId = instanceState.currentPageId;
      if (!pages.find((p3) => p3.id === currentPageId)) {
        currentPageId = pages[0].id;
        store.put([__spreadProps(__spreadValues({}, instanceState), { currentPageId })]);
        return ensureStoreIsUsable();
      }
      if (!$user.value) {
        store.put([TLUser.create({ id: userId })]);
        return ensureStoreIsUsable();
      }
      const userPresences = $userPresences.value.filter((r3) => r3.userId === userId);
      if (userPresences.length === 0) {
        store.put([TLUserPresence.create({ userId, color: getRandomColor() })]);
        return ensureStoreIsUsable();
      } else if (userPresences.length > 1) {
        store.remove(userPresences.slice(1).map((r3) => r3.id));
      }
      for (const page of pages) {
        const instancePageStates = $instancePageStates.value.filter(
          (tps) => tps.pageId === page.id && tps.instanceId === tabId
        );
        if (instancePageStates.length > 1) {
          store.remove(instancePageStates.slice(1).map((ips) => ips.id));
        } else if (instancePageStates.length === 0) {
          const camera2 = TLCamera.create({});
          store.put([
            camera2,
            TLInstancePageState.create({ pageId: page.id, instanceId: tabId, cameraId: camera2.id })
          ]);
          return ensureStoreIsUsable();
        }
        const camera = store.get(instancePageStates[0].cameraId);
        if (!camera) {
          store.put([TLCamera.create({ id: instancePageStates[0].cameraId })]);
          return ensureStoreIsUsable();
        }
      }
    };
    return ensureStoreIsUsable;
  }

  // ../../../packages/tlschema/src/assets/asset-validation.ts
  function createAssetValidator(type, props) {
    return validation_exports.object({
      id: assetIdValidator,
      typeName: validation_exports.literal("asset"),
      type: validation_exports.literal(type),
      props
    });
  }

  // ../../../packages/tlschema/src/assets/TLBookmarkAsset.ts
  var bookmarkAssetTypeValidator = createAssetValidator(
    "bookmark",
    validation_exports.object({
      title: validation_exports.string,
      description: validation_exports.string,
      image: validation_exports.string,
      src: validation_exports.string.nullable()
    })
  );
  var Versions8 = {
    Initial: 0
  };
  var bookmarkAssetMigrations = defineMigrations({
    firstVersion: Versions8.Initial,
    // STEP 2: Update the current version to point to your latest version
    currentVersion: Versions8.Initial,
    // STEP 3: Add an up+down migration for the new version here
    migrators: {}
  });

  // ../../../packages/tlschema/src/assets/TLImageAsset.ts
  var imageAssetTypeValidator = createAssetValidator(
    "image",
    validation_exports.object({
      w: validation_exports.number,
      h: validation_exports.number,
      name: validation_exports.string,
      isAnimated: validation_exports.boolean,
      mimeType: validation_exports.string.nullable(),
      src: validation_exports.string.nullable()
    })
  );
  var Versions9 = {
    Initial: 0,
    AddIsAnimated: 1,
    RenameWidthHeight: 2
  };
  var imageAssetMigrations = defineMigrations({
    firstVersion: Versions9.Initial,
    // STEP 2: Update the current version to point to your latest version
    currentVersion: Versions9.RenameWidthHeight,
    // STEP 3: Add an up+down migration for the new version here
    migrators: {
      [Versions9.AddIsAnimated]: {
        up: (asset) => {
          return __spreadProps(__spreadValues({}, asset), {
            props: __spreadProps(__spreadValues({}, asset.props), {
              isAnimated: false
            })
          });
        },
        down: (asset) => {
          const _a5 = asset.props, { isAnimated: isAnimated2 } = _a5, rest = __objRest(_a5, ["isAnimated"]);
          return __spreadProps(__spreadValues({}, asset), {
            props: rest
          });
        }
      },
      [Versions9.RenameWidthHeight]: {
        up: (asset) => {
          const _a5 = asset.props, { width, height } = _a5, others = __objRest(_a5, ["width", "height"]);
          return __spreadProps(__spreadValues({}, asset), { props: __spreadValues({ w: width, h: height }, others) });
        },
        down: (asset) => {
          const _a5 = asset.props, { w: w3, h: h3 } = _a5, others = __objRest(_a5, ["w", "h"]);
          return __spreadProps(__spreadValues({}, asset), { props: __spreadValues({ width: w3, height: h3 }, others) });
        }
      }
    }
  });

  // ../../../packages/tlschema/src/assets/TLVideoAsset.ts
  var videoAssetTypeValidator = createAssetValidator(
    "video",
    validation_exports.object({
      w: validation_exports.number,
      h: validation_exports.number,
      name: validation_exports.string,
      isAnimated: validation_exports.boolean,
      mimeType: validation_exports.string.nullable(),
      src: validation_exports.string.nullable()
    })
  );
  var Versions10 = {
    Initial: 0,
    AddIsAnimated: 1,
    RenameWidthHeight: 2
  };
  var videoAssetMigrations = defineMigrations({
    firstVersion: Versions10.Initial,
    // STEP 2: Update the current version to point to your latest version
    currentVersion: Versions10.RenameWidthHeight,
    // STEP 3: Add an up+down migration for the new version here
    migrators: {
      [Versions10.AddIsAnimated]: {
        up: (asset) => {
          return __spreadProps(__spreadValues({}, asset), {
            props: __spreadProps(__spreadValues({}, asset.props), {
              isAnimated: false
            })
          });
        },
        down: (asset) => {
          const _a5 = asset.props, { isAnimated: isAnimated2 } = _a5, rest = __objRest(_a5, ["isAnimated"]);
          return __spreadProps(__spreadValues({}, asset), {
            props: rest
          });
        }
      },
      [Versions10.RenameWidthHeight]: {
        up: (asset) => {
          const _a5 = asset.props, { width, height } = _a5, others = __objRest(_a5, ["width", "height"]);
          return __spreadProps(__spreadValues({}, asset), { props: __spreadValues({ w: width, h: height }, others) });
        },
        down: (asset) => {
          const _a5 = asset.props, { w: w3, h: h3 } = _a5, others = __objRest(_a5, ["w", "h"]);
          return __spreadProps(__spreadValues({}, asset), { props: __spreadValues({ width: w3, height: h3 }, others) });
        }
      }
    }
  });

  // ../../../packages/tlschema/src/records/TLInstancePresence.ts
  var instancePresenceTypeValidator = validation_exports.model(
    "instance_presence",
    validation_exports.object({
      instanceId: idValidator("instance"),
      typeName: validation_exports.literal("instance_presence"),
      id: idValidator("instance_presence"),
      userId: userIdValidator,
      userName: validation_exports.string,
      lastActivityTimestamp: validation_exports.number,
      followingUserId: userIdValidator.nullable(),
      cursor: validation_exports.object({
        x: validation_exports.number,
        y: validation_exports.number,
        type: cursorTypeValidator,
        rotation: validation_exports.number
      }),
      color: validation_exports.string,
      camera: validation_exports.object({
        x: validation_exports.number,
        y: validation_exports.number,
        z: validation_exports.number
      }),
      screenBounds: validation_exports.boxModel,
      selectedIds: validation_exports.arrayOf(idValidator("shape")),
      currentPageId: idValidator("page"),
      brush: validation_exports.boxModel.nullable(),
      scribble: scribbleTypeValidator.nullable()
    })
  );
  var Versions11 = {
    Initial: 0
  };
  var userPresenceTypeMigrations2 = defineMigrations({
    // STEP 2: Update the current version to point to your latest version
    currentVersion: Versions11.Initial,
    firstVersion: Versions11.Initial,
    migrators: {
      // STEP 3: Add an up+down migration for the new version here
    }
  });
  var TLInstancePresence = createRecordType("instance_presence", {
    migrations: userPresenceTypeMigrations2,
    validator: instancePresenceTypeValidator,
    scope: "presence"
  });

  // ../../../packages/tlschema/src/defaultDerivePresenceState.ts
  var defaultDerivePresenceState = (store) => {
    const $instance = store.query.record("instance", () => ({
      id: { eq: store.props.instanceId }
    }));
    const $user = store.query.record("user", () => ({ id: { eq: store.props.userId } }));
    const $userPresence = store.query.record("user_presence", () => ({
      userId: { eq: store.props.userId }
    }));
    const $pageState = store.query.record("instance_page_state", () => {
      var _a5, _b2;
      return {
        instanceId: { eq: store.props.instanceId },
        pageId: { eq: (_b2 = (_a5 = $instance.value) == null ? void 0 : _a5.currentPageId) != null ? _b2 : "" }
      };
    });
    const $camera = store.query.record("camera", () => {
      var _a5, _b2;
      return {
        id: { eq: (_b2 = (_a5 = $pageState.value) == null ? void 0 : _a5.cameraId) != null ? _b2 : "" }
      };
    });
    return computed("instancePresence", () => {
      const pageState = $pageState.value;
      const instance = $instance.value;
      const user = $user.value;
      const userPresence = $userPresence.value;
      const camera = $camera.value;
      if (!pageState || !instance || !user || !userPresence || !camera) {
        return null;
      }
      return TLInstancePresence.create({
        id: TLInstancePresence.createCustomId(store.props.instanceId),
        instanceId: store.props.instanceId,
        selectedIds: pageState.selectedIds,
        brush: instance.brush,
        scribble: instance.scribble,
        userId: store.props.userId,
        userName: user.name,
        followingUserId: instance.followingUserId,
        camera: {
          x: camera.x,
          y: camera.y,
          z: camera.z
        },
        color: userPresence.color,
        currentPageId: instance.currentPageId,
        cursor: {
          x: userPresence.cursor.x,
          y: userPresence.cursor.y,
          rotation: instance.cursor.rotation,
          type: instance.cursor.type
        },
        lastActivityTimestamp: userPresence.lastActivityTimestamp,
        screenBounds: instance.screenBounds
      });
    });
  };

  // ../../../packages/tlschema/src/records/TLAsset.ts
  var assetTypeValidator = validation_exports.model(
    "asset",
    validation_exports.union("type", {
      image: imageAssetTypeValidator,
      video: videoAssetTypeValidator,
      bookmark: bookmarkAssetTypeValidator
    })
  );
  var Versions12 = {
    Initial: 0
  };
  var assetTypeMigrations = defineMigrations({
    firstVersion: Versions12.Initial,
    // STEP 2: Update the current version to point to your latest version
    currentVersion: Versions12.Initial,
    // STEP 3: Add an up+down migration for the new version here
    migrators: {},
    subTypeKey: "type",
    subTypeMigrations: {
      image: imageAssetMigrations,
      video: videoAssetMigrations,
      bookmark: bookmarkAssetMigrations
    }
  });
  var TLAsset = createRecordType("asset", {
    migrations: assetTypeMigrations,
    validator: assetTypeValidator,
    scope: "document"
  });

  // ../../../packages/tlschema/src/records/TLShape.ts
  var Versions13 = {
    Initial: 0,
    AddIsLocked: 1
  };
  var rootShapeTypeMigrations = defineMigrations({
    // STEP 2: Update the current version to point to your latest version
    currentVersion: Versions13.AddIsLocked,
    firstVersion: Versions13.Initial,
    migrators: {
      // STEP 3: Add an up+down migration for the new version here
      [Versions13.AddIsLocked]: {
        up: (record) => {
          return __spreadProps(__spreadValues({}, record), {
            isLocked: false
          });
        },
        down: (record) => {
          const _a5 = record, { isLocked: _ } = _a5, rest = __objRest(_a5, ["isLocked"]);
          return __spreadValues({}, rest);
        }
      }
    }
  });
  function isShape(record) {
    if (!record)
      return false;
    return record.typeName === "shape";
  }
  function isShapeId(id) {
    if (!id)
      return false;
    return id.startsWith("shape:");
  }
  function createShapeId() {
    return `shape:${nanoid()}`;
  }
  function createCustomShapeId(id) {
    return `shape:${id}`;
  }

  // ../../../packages/tlschema/src/schema.ts
  var Versions14 = {
    Initial: 0,
    RemoveCodeAndIconShapeTypes: 1,
    AddInstancePresenceType: 2
  };
  var storeMigrations = defineMigrations({
    // STEP 2: Update the current version to point to your latest version
    firstVersion: Versions14.Initial,
    currentVersion: Versions14.AddInstancePresenceType,
    migrators: {
      // STEP 3: Add an up+down migration for the new version here
      [Versions14.RemoveCodeAndIconShapeTypes]: {
        up: (store) => {
          return Object.fromEntries(
            Object.entries(store).filter(
              ([_, v3]) => v3.typeName !== "shape" || v3.type !== "icon" && v3.type !== "code"
            )
          );
        },
        down: (store) => {
          return store;
        }
      },
      [Versions14.AddInstancePresenceType]: {
        up: (store) => {
          return store;
        },
        down: (store) => {
          return Object.fromEntries(
            Object.entries(store).filter(([_, v3]) => v3.typeName !== "instance_presence")
          );
        }
      }
    }
  });

  // ../../../packages/tlschema/src/shapes/shape-validation.ts
  function createShapeValidator(type, props) {
    return validation_exports.object({
      id: shapeIdValidator,
      typeName: validation_exports.literal("shape"),
      x: validation_exports.number,
      y: validation_exports.number,
      rotation: validation_exports.number,
      index: validation_exports.string,
      parentId: parentIdValidator,
      type: validation_exports.literal(type),
      isLocked: validation_exports.boolean,
      props
    });
  }

  // ../../../packages/tlschema/src/shapes/TLArrowShape.ts
  var arrowTerminalTypeValidator = validation_exports.union("type", {
    binding: validation_exports.object({
      type: validation_exports.literal("binding"),
      boundShapeId: shapeIdValidator,
      normalizedAnchor: validation_exports.point,
      isExact: validation_exports.boolean
    }),
    point: validation_exports.object({
      type: validation_exports.literal("point"),
      x: validation_exports.number,
      y: validation_exports.number
    })
  });
  var arrowShapeTypeValidator = createShapeValidator(
    "arrow",
    validation_exports.object({
      labelColor: colorValidator,
      color: colorValidator,
      fill: fillValidator,
      dash: dashValidator,
      size: sizeValidator,
      opacity: opacityValidator,
      arrowheadStart: arrowheadValidator,
      arrowheadEnd: arrowheadValidator,
      font: fontValidator,
      start: arrowTerminalTypeValidator,
      end: arrowTerminalTypeValidator,
      bend: validation_exports.number,
      text: validation_exports.string
    })
  );
  var Versions15 = {
    Initial: 0,
    AddLabelColor: 1
  };
  var arrowShapeMigrations = defineMigrations({
    // STEP 2: Update the current version to point to your latest version
    currentVersion: Versions15.AddLabelColor,
    firstVersion: Versions15.Initial,
    migrators: {
      // STEP 3: Add an up+down migration for the new version here
      [Versions15.AddLabelColor]: {
        up: (record) => {
          return __spreadProps(__spreadValues({}, record), {
            props: __spreadProps(__spreadValues({}, record.props), {
              labelColor: "black"
            })
          });
        },
        down: (record) => {
          const _a5 = record.props, { labelColor: _ } = _a5, props = __objRest(_a5, ["labelColor"]);
          return __spreadProps(__spreadValues({}, record), {
            props
          });
        }
      }
    }
  });

  // ../../../packages/tlschema/src/shapes/TLBookmarkShape.ts
  var bookmarkShapeTypeValidator = createShapeValidator(
    "bookmark",
    validation_exports.object({
      opacity: opacityValidator,
      w: validation_exports.nonZeroNumber,
      h: validation_exports.nonZeroNumber,
      assetId: assetIdValidator.nullable(),
      url: validation_exports.string
    })
  );
  var Versions16 = {
    Initial: 0,
    NullAssetId: 1
  };
  var bookmarkShapeMigrations = defineMigrations({
    firstVersion: Versions16.Initial,
    // STEP 2: Update the current version to point to your latest version
    currentVersion: Versions16.NullAssetId,
    // STEP 3: Add an up+down migration for the new version here
    migrators: {
      [Versions16.NullAssetId]: {
        up: (shape) => {
          if (shape.props.assetId === void 0) {
            return __spreadProps(__spreadValues({}, shape), { props: __spreadProps(__spreadValues({}, shape.props), { assetId: null }) });
          }
          return shape;
        },
        down: (shape) => {
          if (shape.props.assetId === null) {
            const _a5 = shape.props, { assetId: _ } = _a5, props = __objRest(_a5, ["assetId"]);
            return __spreadProps(__spreadValues({}, shape), { props });
          }
          return shape;
        }
      }
    }
  });

  // ../../../packages/tlschema/src/shapes/TLDrawShape.ts
  var TL_DRAW_SHAPE_SEGMENT_TYPE = /* @__PURE__ */ new Set(["free", "straight"]);
  var drawShapeTypeValidator = createShapeValidator(
    "draw",
    validation_exports.object({
      color: colorValidator,
      fill: fillValidator,
      dash: dashValidator,
      size: sizeValidator,
      opacity: opacityValidator,
      segments: validation_exports.arrayOf(
        validation_exports.object({
          type: validation_exports.setEnum(TL_DRAW_SHAPE_SEGMENT_TYPE),
          points: validation_exports.arrayOf(validation_exports.point)
        })
      ),
      isComplete: validation_exports.boolean,
      isClosed: validation_exports.boolean,
      isPen: validation_exports.boolean
    })
  );
  var Versions17 = {
    Initial: 0,
    AddInPen: 1
  };
  var drawShapeMigrations = defineMigrations({
    // STEP 2: Update the current version to point to your latest version
    firstVersion: Versions17.Initial,
    currentVersion: Versions17.AddInPen,
    migrators: {
      // STEP 3: Add an up+down migration for the new version here
      [Versions17.AddInPen]: {
        up: (shape) => {
          const { points: points2 } = shape.props.segments[0];
          if (points2.length === 0) {
            return __spreadProps(__spreadValues({}, shape), {
              props: __spreadProps(__spreadValues({}, shape.props), {
                isPen: false
              })
            });
          }
          let isPen = !(points2[0].z === 0 || points2[0].z === 0.5);
          if (points2[1]) {
            isPen = isPen && !(points2[1].z === 0 || points2[1].z === 0.5);
          }
          return __spreadProps(__spreadValues({}, shape), {
            props: __spreadProps(__spreadValues({}, shape.props), {
              isPen
            })
          });
        },
        down: (shape) => {
          const _a5 = shape.props, { isPen: _isPen } = _a5, propsWithOutIsPen = __objRest(_a5, ["isPen"]);
          return __spreadProps(__spreadValues({}, shape), {
            props: __spreadValues({}, propsWithOutIsPen)
          });
        }
      }
    }
  });

  // ../../../packages/tlschema/src/shapes/TLEmbedShape.ts
  var tlEmbedShapePermissionDefaults = {
    // ========================================================================================
    // Disabled permissions
    // ========================================================================================
    // [MDN] Experimental: Allows for downloads to occur without a gesture from the user.
    // [REASON] Disabled because otherwise the <iframe/> trick the user on behalf of us to performing an action
    "allow-downloads-without-user-activation": false,
    // [MDN] Allows for downloads to occur with a gesture from the user.
    // [REASON] Disabled because otherwise the <iframe/> trick the user on behalf of us to performing an action
    "allow-downloads": false,
    // [MDN] Lets the resource open modal windows.
    // [REASON] The <iframe/> could 'window.prompt("Enter your tldraw password")'
    "allow-modals": false,
    // [MDN] Lets the resource lock the screen orientation.
    // [REASON] Would interfer with tldraw interface
    "allow-orientation-lock": false,
    // [MDN] Lets the resource use the Pointer Lock API.
    // [REASON] Maybe we should allow this for games embeds (scratch/codepen/codesandbox)
    "allow-pointer-lock": false,
    // [MDN] Allows popups (such as window.open(), target="_blank", or showModalDialog()). If this keyword is not used, the popup will silently fail to open.
    // [REASON] We shouldn't allow popups as a embed could pretend to be us by opening a mocked version of tldraw. This is very unobvious when it is performed as an action within out app
    "allow-popups": true,
    // [MDN] Lets the sandboxed document open new windows without those windows inheriting the sandboxing. For example, this can safely sandbox an advertisement without forcing the same restrictions upon the page the ad links to.
    // [REASON] We're alread disabling popups.
    "allow-popups-to-escape-sandbox": false,
    // [MDN] Lets the resource start a presentation session.
    // [REASON] Prevents embed from navigating away from tldraw and pretending to be us
    "allow-presentation": false,
    // [MDN] Experimental: Lets the resource request access to the parent's storage capabilities with the Storage Access API.
    // [REASON] We don't want anyone else to access our storage
    "allow-storage-access-by-user-activation": false,
    // [MDN] Lets the resource navigate the top-level browsing context (the one named _top).
    // [REASON] Prevents embed from navigating away from tldraw and pretending to be us
    "allow-top-navigation": false,
    // [MDN] Lets the resource navigate the top-level browsing context, but only if initiated by a user gesture.
    // [REASON] Prevents embed from navigating away from tldraw and pretending to be us
    "allow-top-navigation-by-user-activation": false,
    // ========================================================================================
    // Enabled permissions
    // ========================================================================================
    // [MDN] Lets the resource run scripts (but not create popup windows).
    "allow-scripts": true,
    // [MDN] If this token is not used, the resource is treated as being from a special origin that always fails the same-origin policy (potentially preventing access to data storage/cookies and some JavaScript APIs).
    "allow-same-origin": true,
    // [MDN] Allows the resource to submit forms. If this keyword is not used, form submission is blocked.
    "allow-forms": true
  };
  var embedShapeTypeValidator = createShapeValidator(
    "embed",
    validation_exports.object({
      opacity: opacityValidator,
      w: validation_exports.nonZeroNumber,
      h: validation_exports.nonZeroNumber,
      url: validation_exports.string,
      tmpOldUrl: validation_exports.string.optional(),
      doesResize: validation_exports.boolean,
      overridePermissions: validation_exports.dict(
        validation_exports.setEnum(
          new Set(Object.keys(tlEmbedShapePermissionDefaults))
        ),
        validation_exports.boolean.optional()
      ).optional()
    })
  );
  var TLDRAW_APP_RE = /(^\/r\/[^/]+\/?$)/;
  var safeParseUrl = (url) => {
    try {
      return new URL(url);
    } catch (err) {
      return;
    }
  };
  var EMBED_DEFINITIONS = [
    {
      type: "tldraw",
      title: "tldraw",
      hostnames: ["beta.tldraw.com", "lite.tldraw.com", "www.tldraw.com"],
      minWidth: 300,
      minHeight: 300,
      width: 720,
      height: 500,
      doesResize: true,
      toEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        if (urlObj && urlObj.pathname.match(TLDRAW_APP_RE)) {
          return url;
        }
        return;
      },
      fromEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        if (urlObj && urlObj.pathname.match(TLDRAW_APP_RE)) {
          return url;
        }
        return;
      }
    },
    {
      type: "codesandbox",
      title: "CodeSandbox",
      hostnames: ["codesandbox.io"],
      minWidth: 300,
      minHeight: 300,
      width: 720,
      height: 500,
      doesResize: true,
      toEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        const matches = urlObj && urlObj.pathname.match(/\/s\/([^/]+)\/?/);
        if (matches) {
          return `https://codesandbox.io/embed/${matches[1]}`;
        }
        return;
      },
      fromEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        const matches = urlObj && urlObj.pathname.match(/\/embed\/([^/]+)\/?/);
        if (matches) {
          return `https://codesandbox.io/s/${matches[1]}`;
        }
        return;
      }
    },
    {
      type: "codepen",
      title: "Codepen",
      hostnames: ["codepen.io"],
      minWidth: 300,
      minHeight: 300,
      width: 520,
      height: 400,
      doesResize: true,
      toEmbedUrl: (url) => {
        const CODEPEN_URL_REGEXP = /https:\/\/codepen.io\/([^/]+)\/pen\/([^/]+)/;
        const matches = url.match(CODEPEN_URL_REGEXP);
        if (matches) {
          const [_, user, id] = matches;
          return `https://codepen.io/${user}/embed/${id}`;
        }
        return;
      },
      fromEmbedUrl: (url) => {
        const CODEPEN_EMBED_REGEXP = /https:\/\/codepen.io\/([^/]+)\/embed\/([^/]+)/;
        const matches = url.match(CODEPEN_EMBED_REGEXP);
        if (matches) {
          const [_, user, id] = matches;
          return `https://codepen.io/${user}/pen/${id}`;
        }
        return;
      }
    },
    {
      type: "scratch",
      title: "Scratch",
      hostnames: ["scratch.mit.edu"],
      width: 520,
      height: 400,
      doesResize: false,
      toEmbedUrl: (url) => {
        const SCRATCH_URL_REGEXP = /https?:\/\/scratch.mit.edu\/projects\/([^/]+)/;
        const matches = url.match(SCRATCH_URL_REGEXP);
        if (matches) {
          const [_, id] = matches;
          return `https://scratch.mit.edu/projects/embed/${id}`;
        }
        return;
      },
      fromEmbedUrl: (url) => {
        const SCRATCH_EMBED_REGEXP = /https:\/\/scratch.mit.edu\/projects\/embed\/([^/]+)/;
        const matches = url.match(SCRATCH_EMBED_REGEXP);
        if (matches) {
          const [_, id] = matches;
          return `https://scratch.mit.edu/projects/${id}`;
        }
        return;
      }
    },
    {
      type: "youtube",
      title: "YouTube",
      hostnames: ["*.youtube.com", "youtube.com", "youtu.be"],
      width: 800,
      height: 450,
      doesResize: true,
      overridePermissions: {
        "allow-presentation": true
      },
      isAspectRatioLocked: true,
      toEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        if (!urlObj)
          return;
        const hostname = urlObj.hostname.replace(/^www./, "");
        if (hostname === "youtu.be") {
          const videoId = urlObj.pathname.split("/").filter(Boolean)[0];
          return `https://www.youtube.com/embed/${videoId}`;
        } else if ((hostname === "youtube.com" || hostname === "m.youtube.com") && urlObj.pathname.match(/^\/watch/)) {
          const videoId = urlObj.searchParams.get("v");
          return `https://www.youtube.com/embed/${videoId}`;
        }
        return;
      },
      fromEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        if (!urlObj)
          return;
        const hostname = urlObj.hostname.replace(/^www./, "");
        if (hostname === "youtube.com") {
          const matches = urlObj.pathname.match(/^\/embed\/([^/]+)\/?/);
          if (matches) {
            return `https://www.youtube.com/watch?v=${matches[1]}`;
          }
        }
        return;
      }
    },
    {
      type: "figma",
      title: "Figma",
      hostnames: ["figma.com"],
      width: 720,
      height: 500,
      doesResize: true,
      toEmbedUrl: (url) => {
        if (!!url.match(
          // eslint-disable-next-line no-useless-escape
          /https:\/\/([\w\.-]+\.)?figma.com\/(file|proto)\/([0-9a-zA-Z]{22,128})(?:\/.*)?$/
        ) && !url.includes("figma.com/embed")) {
          return `https://www.figma.com/embed?embed_host=share&url=${url}`;
        }
        return;
      },
      fromEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        if (urlObj && urlObj.pathname.match(/^\/embed\/?$/)) {
          const outUrl = urlObj.searchParams.get("url");
          if (outUrl) {
            return outUrl;
          }
        }
        return;
      }
    },
    {
      type: "google_maps",
      title: "Google Maps",
      hostnames: ["google.*"],
      width: 720,
      height: 500,
      doesResize: true,
      toEmbedUrl: (url) => {
        if (url.includes("/maps/")) {
          const match = url.match(/@(.*),(.*),(.*)z/);
          let result;
          if (match) {
            const [, lat, lng, z2] = match;
            const host = new URL(url).host.replace("www.", "");
            result = `https://${host}/maps/embed/v1/view?key=${process.env.NEXT_PUBLIC_GC_API_KEY}&center=${lat},${lng}&zoom=${z2}`;
          } else {
            result = "";
          }
          return result;
        }
        return;
      },
      fromEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        if (!urlObj)
          return;
        const matches = urlObj.pathname.match(/^\/maps\/embed\/v1\/view\/?$/);
        if (matches && urlObj.searchParams.has("center") && urlObj.searchParams.get("zoom")) {
          const zoom = urlObj.searchParams.get("zoom");
          const [lat, lon] = urlObj.searchParams.get("center").split(",");
          return `https://www.google.com/maps/@${lat},${lon},${zoom}z`;
        }
        return;
      }
    },
    {
      type: "google_calendar",
      title: "Google Calendar",
      hostnames: ["calendar.google.*"],
      width: 720,
      height: 500,
      minWidth: 460,
      minHeight: 360,
      doesResize: true,
      instructionLink: "https://support.google.com/calendar/answer/41207?hl=en",
      toEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        const cidQs = urlObj == null ? void 0 : urlObj.searchParams.get("cid");
        if ((urlObj == null ? void 0 : urlObj.pathname.match(/\/calendar\/u\/0/)) && cidQs) {
          urlObj.pathname = "/calendar/embed";
          const keys = Array.from(urlObj.searchParams.keys());
          for (const key of keys) {
            urlObj.searchParams.delete(key);
          }
          urlObj.searchParams.set("src", cidQs);
          return urlObj.href;
        }
        return;
      },
      fromEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        const srcQs = urlObj == null ? void 0 : urlObj.searchParams.get("src");
        if ((urlObj == null ? void 0 : urlObj.pathname.match(/\/calendar\/embed/)) && srcQs) {
          urlObj.pathname = "/calendar/u/0";
          const keys = Array.from(urlObj.searchParams.keys());
          for (const key of keys) {
            urlObj.searchParams.delete(key);
          }
          urlObj.searchParams.set("cid", srcQs);
          return urlObj.href;
        }
        return;
      }
    },
    {
      type: "google_slides",
      title: "Google Slides",
      hostnames: ["docs.google.*"],
      width: 720,
      height: 500,
      minWidth: 460,
      minHeight: 360,
      doesResize: true,
      toEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        if ((urlObj == null ? void 0 : urlObj.pathname.match(/^\/presentation/)) && (urlObj == null ? void 0 : urlObj.pathname.match(/\/pub\/?$/))) {
          urlObj.pathname = urlObj.pathname.replace(/\/pub$/, "/embed");
          const keys = Array.from(urlObj.searchParams.keys());
          for (const key of keys) {
            urlObj.searchParams.delete(key);
          }
          return urlObj.href;
        }
        return;
      },
      fromEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        if ((urlObj == null ? void 0 : urlObj.pathname.match(/^\/presentation/)) && (urlObj == null ? void 0 : urlObj.pathname.match(/\/embed\/?$/))) {
          urlObj.pathname = urlObj.pathname.replace(/\/embed$/, "/pub");
          const keys = Array.from(urlObj.searchParams.keys());
          for (const key of keys) {
            urlObj.searchParams.delete(key);
          }
          return urlObj.href;
        }
        return;
      }
    },
    {
      type: "github_gist",
      title: "GitHub Gist",
      hostnames: ["gist.github.com"],
      width: 720,
      height: 500,
      doesResize: true,
      toEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        if (urlObj && urlObj.pathname.match(/\/([^/]+)\/([^/]+)/)) {
          return url;
        }
        return;
      },
      fromEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        if (urlObj && urlObj.pathname.match(/\/([^/]+)\/([^/]+)/)) {
          return url;
        }
        return;
      }
    },
    {
      type: "replit",
      title: "Replit",
      hostnames: ["replit.com"],
      width: 720,
      height: 500,
      doesResize: true,
      toEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        if (urlObj && urlObj.pathname.match(/\/@([^/]+)\/([^/]+)/)) {
          return `${url}?embed=true`;
        }
        return;
      },
      fromEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        if (urlObj && urlObj.pathname.match(/\/@([^/]+)\/([^/]+)/) && urlObj.searchParams.has("embed")) {
          urlObj.searchParams.delete("embed");
          return urlObj.href;
        }
        return;
      }
    },
    {
      type: "felt",
      title: "Felt",
      hostnames: ["felt.com"],
      width: 720,
      height: 500,
      doesResize: true,
      toEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        if (urlObj && urlObj.pathname.match(/^\/map\//)) {
          return urlObj.origin + "/embed" + urlObj.pathname;
        }
        return;
      },
      fromEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        if (urlObj && urlObj.pathname.match(/^\/embed\/map\//)) {
          urlObj.pathname = urlObj.pathname.replace(/^\/embed/, "");
          return urlObj.href;
        }
        return;
      }
    },
    {
      type: "spotify",
      title: "Spotify",
      hostnames: ["open.spotify.com"],
      width: 720,
      height: 500,
      minHeight: 500,
      overrideOutlineRadius: 12,
      doesResize: true,
      toEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        if (urlObj && urlObj.pathname.match(/^\/(artist|album)\//)) {
          return urlObj.origin + "/embed" + urlObj.pathname;
        }
        return;
      },
      fromEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        if (urlObj && urlObj.pathname.match(/^\/embed\/(artist|album)\//)) {
          return urlObj.origin + urlObj.pathname.replace(/^\/embed/, "");
        }
        return;
      }
    },
    {
      type: "vimeo",
      title: "Vimeo",
      hostnames: ["vimeo.com", "player.vimeo.com"],
      width: 640,
      height: 360,
      doesResize: true,
      isAspectRatioLocked: true,
      toEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        if (urlObj && urlObj.hostname === "vimeo.com") {
          if (urlObj.pathname.match(/^\/[0-9]+/)) {
            return "https://player.vimeo.com/video/" + urlObj.pathname.split("/")[1] + "?title=0&byline=0";
          }
        }
        return;
      },
      fromEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        if (urlObj && urlObj.hostname === "player.vimeo.com") {
          const matches = urlObj.pathname.match(/^\/video\/([^/]+)\/?$/);
          if (matches) {
            return "https://vimeo.com/" + matches[1];
          }
        }
        return;
      }
    },
    {
      type: "excalidraw",
      title: "Excalidraw",
      hostnames: ["excalidraw.com"],
      width: 720,
      height: 500,
      doesResize: true,
      isAspectRatioLocked: true,
      toEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        if (urlObj && urlObj.hash.match(/#room=/)) {
          return url;
        }
        return;
      },
      fromEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        if (urlObj && urlObj.hash.match(/#room=/)) {
          return url;
        }
        return;
      }
    },
    {
      type: "observable",
      title: "Observable",
      hostnames: ["observablehq.com"],
      width: 720,
      height: 500,
      doesResize: true,
      isAspectRatioLocked: false,
      backgroundColor: "#fff",
      toEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        if (urlObj && urlObj.pathname.match(/^\/@([^/]+)\/([^/]+)\/?$/)) {
          return `${urlObj.origin}/embed${urlObj.pathname}?cell=*`;
        }
        if (urlObj && urlObj.pathname.match(/^\/d\/([^/]+)\/?$/)) {
          const pathName = urlObj.pathname.replace(/^\/d/, "");
          return `${urlObj.origin}/embed${pathName}?cell=*`;
        }
        return;
      },
      fromEmbedUrl: (url) => {
        const urlObj = safeParseUrl(url);
        if (urlObj && urlObj.pathname.match(/^\/embed\/@([^/]+)\/([^/]+)\/?$/)) {
          return `${urlObj.origin}${urlObj.pathname.replace("/embed", "")}#cell-*`;
        }
        if (urlObj && urlObj.pathname.match(/^\/embed\/([^/]+)\/?$/)) {
          return `${urlObj.origin}${urlObj.pathname.replace("/embed", "/d")}#cell-*`;
        }
        return;
      }
    }
  ];
  var Versions18 = {
    Initial: 0,
    GenOriginalUrlInEmbed: 1
  };
  var embedShapeMigrations = defineMigrations({
    // STEP 2: Update the current version to point to your latest version
    currentVersion: Versions18.GenOriginalUrlInEmbed,
    firstVersion: Versions18.Initial,
    migrators: {
      // STEP 3: Add an up+down migration for the new version here
      [Versions18.GenOriginalUrlInEmbed]: {
        // add tmpOldUrl property
        up: (shape) => {
          const url = shape.props.url;
          const host = new URL(url).host.replace("www.", "");
          let originalUrl;
          for (const localEmbedDef of EMBED_DEFINITIONS) {
            if (localEmbedDef.hostnames.includes(host)) {
              try {
                originalUrl = localEmbedDef.fromEmbedUrl(url);
              } catch (err) {
                console.warn(err);
              }
            }
          }
          return __spreadProps(__spreadValues({}, shape), {
            props: __spreadProps(__spreadValues({}, shape.props), {
              tmpOldUrl: shape.props.url,
              url: originalUrl != null ? originalUrl : ""
            })
          });
        },
        // remove tmpOldUrl property
        down: (shape) => {
          let newUrl = shape.props.tmpOldUrl;
          if (!newUrl || newUrl === "") {
            const url = shape.props.url;
            const host = new URL(url).host.replace("www.", "");
            for (const localEmbedDef of EMBED_DEFINITIONS) {
              if (localEmbedDef.hostnames.includes(host)) {
                try {
                  newUrl = localEmbedDef.toEmbedUrl(url);
                } catch (err) {
                  console.warn(err);
                }
              }
            }
          }
          const _a5 = shape.props, { tmpOldUrl } = _a5, props = __objRest(_a5, ["tmpOldUrl"]);
          return __spreadProps(__spreadValues({}, shape), {
            props: __spreadProps(__spreadValues({}, props), {
              url: newUrl != null ? newUrl : ""
            })
          });
        }
      }
    }
  });

  // ../../../packages/tlschema/src/shapes/TLFrameShape.ts
  var frameShapeTypeValidator = createShapeValidator(
    "frame",
    validation_exports.object({
      opacity: opacityValidator,
      w: validation_exports.nonZeroNumber,
      h: validation_exports.nonZeroNumber,
      name: validation_exports.string
    })
  );
  var Versions19 = {
    Initial: 0
  };
  var frameShapeMigrations = defineMigrations({
    // STEP 2: Update the current version to point to your latest version
    currentVersion: Versions19.Initial,
    firstVersion: Versions19.Initial,
    migrators: {
      // STEP 3: Add an up+down migration for the new version here
    }
  });

  // ../../../packages/tlschema/src/shapes/TLGeoShape.ts
  var geoShapeTypeValidator = createShapeValidator(
    "geo",
    validation_exports.object({
      geo: geoValidator,
      labelColor: colorValidator,
      color: colorValidator,
      fill: fillValidator,
      dash: dashValidator,
      size: sizeValidator,
      opacity: opacityValidator,
      font: fontValidator,
      align: alignValidator,
      url: validation_exports.string,
      w: validation_exports.nonZeroNumber,
      h: validation_exports.nonZeroNumber,
      growY: validation_exports.positiveNumber,
      text: validation_exports.string
    })
  );
  var Versions20 = {
    Initial: 0,
    AddUrlProp: 1,
    AddLabelColor: 2,
    RemoveJustify: 3,
    AddCheckBox: 4
  };
  var geoShapeMigrations = defineMigrations({
    // STEP 2: Update the current version to point to your latest version
    firstVersion: Versions20.Initial,
    currentVersion: Versions20.AddCheckBox,
    migrators: {
      // STEP 3: Add an up+down migration for the new version here
      [Versions20.AddUrlProp]: {
        up: (shape) => {
          return __spreadProps(__spreadValues({}, shape), { props: __spreadProps(__spreadValues({}, shape.props), { url: "" }) });
        },
        down: (shape) => {
          const _a5 = shape.props, { url: _ } = _a5, props = __objRest(_a5, ["url"]);
          return __spreadProps(__spreadValues({}, shape), { props });
        }
      },
      [Versions20.AddLabelColor]: {
        up: (record) => {
          return __spreadProps(__spreadValues({}, record), {
            props: __spreadProps(__spreadValues({}, record.props), {
              labelColor: "black"
            })
          });
        },
        down: (record) => {
          const _a5 = record.props, { labelColor: _ } = _a5, props = __objRest(_a5, ["labelColor"]);
          return __spreadProps(__spreadValues({}, record), {
            props
          });
        }
      },
      [Versions20.RemoveJustify]: {
        up: (shape) => {
          let newAlign = shape.props.align;
          if (newAlign === "justify") {
            newAlign = "start";
          }
          return __spreadProps(__spreadValues({}, shape), {
            props: __spreadProps(__spreadValues({}, shape.props), {
              align: newAlign
            })
          });
        },
        down: (shape) => {
          return __spreadValues({}, shape);
        }
      },
      [Versions20.AddCheckBox]: {
        up: (shape) => {
          return __spreadValues({}, shape);
        },
        down: (shape) => {
          return __spreadProps(__spreadValues({}, shape), {
            props: __spreadProps(__spreadValues({}, shape.props), {
              geo: shape.props.geo === "check-box" ? "rectangle" : shape.props.geo
            })
          });
        }
      }
    }
  });

  // ../../../packages/tlschema/src/shapes/TLGroupShape.ts
  var groupShapeTypeValidator = createShapeValidator(
    "group",
    validation_exports.object({
      opacity: opacityValidator
    })
  );
  var Versions21 = {
    Initial: 0
  };
  var groupShapeMigrations = defineMigrations({
    // STEP 2: Update the current version to point to your latest version
    currentVersion: Versions21.Initial,
    firstVersion: Versions21.Initial,
    migrators: {
      // STEP 3: Add an up+down migration for the new version here
    }
  });

  // ../../../packages/tlschema/src/shapes/TLImageShape.ts
  var cropValidator = validation_exports.object({
    topLeft: validation_exports.point,
    bottomRight: validation_exports.point
  });
  var imageShapeTypeValidator = createShapeValidator(
    "image",
    validation_exports.object({
      opacity: opacityValidator,
      w: validation_exports.nonZeroNumber,
      h: validation_exports.nonZeroNumber,
      playing: validation_exports.boolean,
      url: validation_exports.string,
      assetId: assetIdValidator.nullable(),
      crop: cropValidator.nullable()
    })
  );
  var Versions22 = {
    Initial: 0,
    AddUrlProp: 1,
    AddCropProp: 2
  };
  var imageShapeMigrations = defineMigrations({
    // STEP 2: Update the current version to point to your latest version
    firstVersion: Versions22.Initial,
    currentVersion: Versions22.AddCropProp,
    migrators: {
      // STEP 3: Add an up+down migration for the new version here
      [Versions22.AddUrlProp]: {
        up: (shape) => {
          return __spreadProps(__spreadValues({}, shape), { props: __spreadProps(__spreadValues({}, shape.props), { url: "" }) });
        },
        down: (shape) => {
          const _a5 = shape.props, { url: _ } = _a5, props = __objRest(_a5, ["url"]);
          return __spreadProps(__spreadValues({}, shape), { props });
        }
      },
      [Versions22.AddCropProp]: {
        up: (shape) => {
          return __spreadProps(__spreadValues({}, shape), { props: __spreadProps(__spreadValues({}, shape.props), { crop: null }) });
        },
        down: (shape) => {
          const _a5 = shape.props, { crop: _ } = _a5, props = __objRest(_a5, ["crop"]);
          return __spreadProps(__spreadValues({}, shape), { props });
        }
      }
    }
  });

  // ../../../packages/tlschema/src/shapes/TLLineShape.ts
  var lineShapeTypeValidator = createShapeValidator(
    "line",
    validation_exports.object({
      color: colorValidator,
      dash: dashValidator,
      size: sizeValidator,
      opacity: opacityValidator,
      spline: splineValidator,
      handles: validation_exports.dict(validation_exports.string, handleTypeValidator)
    })
  );
  var Versions23 = {
    Initial: 0
  };
  var lineShapeMigrations = defineMigrations({
    // STEP 2: Update the current version to point to your latest version
    currentVersion: Versions23.Initial,
    firstVersion: Versions23.Initial,
    migrators: {
      // STEP 3: Add an up+down migration for the new version here
    }
  });

  // ../../../packages/tlschema/src/shapes/TLNoteShape.ts
  var noteShapeTypeValidator = createShapeValidator(
    "note",
    validation_exports.object({
      color: colorValidator,
      size: sizeValidator,
      font: fontValidator,
      align: alignValidator,
      opacity: opacityValidator,
      growY: validation_exports.positiveNumber,
      url: validation_exports.string,
      text: validation_exports.string
    })
  );
  var Versions24 = {
    Initial: 0,
    AddUrlProp: 1,
    RemoveJustify: 2
  };
  var noteShapeMigrations = defineMigrations({
    // STEP 2: Update the current version to point to your latest version
    firstVersion: Versions24.Initial,
    currentVersion: Versions24.RemoveJustify,
    migrators: {
      // STEP 3: Add an up+down migration for the new version here
      [Versions24.AddUrlProp]: {
        up: (shape) => {
          return __spreadProps(__spreadValues({}, shape), { props: __spreadProps(__spreadValues({}, shape.props), { url: "" }) });
        },
        down: (shape) => {
          const _a5 = shape.props, { url: _ } = _a5, props = __objRest(_a5, ["url"]);
          return __spreadProps(__spreadValues({}, shape), { props });
        }
      },
      [Versions24.RemoveJustify]: {
        up: (shape) => {
          let newAlign = shape.props.align;
          if (newAlign === "justify") {
            newAlign = "start";
          }
          return __spreadProps(__spreadValues({}, shape), {
            props: __spreadProps(__spreadValues({}, shape.props), {
              align: newAlign
            })
          });
        },
        down: (shape) => {
          return __spreadValues({}, shape);
        }
      }
    }
  });

  // ../../../packages/tlschema/src/shapes/TLTextShape.ts
  var textShapeTypeValidator = createShapeValidator(
    "text",
    validation_exports.object({
      color: colorValidator,
      size: sizeValidator,
      font: fontValidator,
      align: alignValidator,
      opacity: opacityValidator,
      w: validation_exports.nonZeroNumber,
      text: validation_exports.string,
      scale: validation_exports.nonZeroNumber,
      autoSize: validation_exports.boolean
    })
  );
  var Versions25 = {
    Initial: 0,
    RemoveJustify: 1
  };
  var textShapeMigrations = defineMigrations({
    // STEP 2: Update the current version to point to your latest version
    firstVersion: Versions25.Initial,
    currentVersion: Versions25.RemoveJustify,
    migrators: {
      [Versions25.RemoveJustify]: {
        up: (shape) => {
          let newAlign = shape.props.align;
          if (newAlign === "justify") {
            newAlign = "start";
          }
          return __spreadProps(__spreadValues({}, shape), {
            props: __spreadProps(__spreadValues({}, shape.props), {
              align: newAlign
            })
          });
        },
        down: (shape) => {
          return __spreadValues({}, shape);
        }
      }
    }
  });

  // ../../../packages/tlschema/src/shapes/TLVideoShape.ts
  var videoShapeTypeValidator = createShapeValidator(
    "video",
    validation_exports.object({
      opacity: opacityValidator,
      w: validation_exports.nonZeroNumber,
      h: validation_exports.nonZeroNumber,
      time: validation_exports.number,
      playing: validation_exports.boolean,
      url: validation_exports.string,
      assetId: assetIdValidator.nullable()
    })
  );
  var Versions26 = {
    Initial: 0,
    AddUrlProp: 1
  };
  var videoShapeMigrations = defineMigrations({
    // STEP 2: Update the current version to point to your latest version
    firstVersion: Versions26.Initial,
    currentVersion: Versions26.AddUrlProp,
    migrators: {
      // STEP 3: Add an up+down migration for the new version here
      [Versions26.AddUrlProp]: {
        up: (shape) => {
          return __spreadProps(__spreadValues({}, shape), { props: __spreadProps(__spreadValues({}, shape.props), { url: "" }) });
        },
        down: (shape) => {
          const _a5 = shape.props, { url: _ } = _a5, props = __objRest(_a5, ["url"]);
          return __spreadProps(__spreadValues({}, shape), { props });
        }
      }
    }
  });

  // ../../../packages/tlschema/src/createTLSchema.ts
  var CORE_SHAPE_DEFS = [
    { type: "draw", migrations: drawShapeMigrations, validator: drawShapeTypeValidator },
    { type: "text", migrations: textShapeMigrations, validator: textShapeTypeValidator },
    { type: "line", migrations: lineShapeMigrations, validator: lineShapeTypeValidator },
    { type: "arrow", migrations: arrowShapeMigrations, validator: arrowShapeTypeValidator },
    { type: "image", migrations: imageShapeMigrations, validator: imageShapeTypeValidator },
    { type: "video", migrations: videoShapeMigrations, validator: videoShapeTypeValidator },
    { type: "geo", migrations: geoShapeMigrations, validator: geoShapeTypeValidator },
    { type: "note", migrations: noteShapeMigrations, validator: noteShapeTypeValidator },
    { type: "group", migrations: groupShapeMigrations, validator: groupShapeTypeValidator },
    {
      type: "bookmark",
      migrations: bookmarkShapeMigrations,
      validator: bookmarkShapeTypeValidator
    },
    { type: "frame", migrations: frameShapeMigrations, validator: frameShapeTypeValidator },
    { type: "embed", migrations: embedShapeMigrations, validator: embedShapeTypeValidator }
  ];
  function createTLSchema({
    customShapeDefs,
    allowUnknownShapes,
    derivePresenceState
  }) {
    const allShapeDefs = [...CORE_SHAPE_DEFS, ...customShapeDefs != null ? customShapeDefs : []];
    const typeSet = /* @__PURE__ */ new Set();
    for (const shapeDef of allShapeDefs) {
      if (typeSet.has(shapeDef.type)) {
        throw new Error(`Shape type ${shapeDef.type} is already defined`);
      }
      typeSet.add(shapeDef.type);
    }
    const shapeTypeMigrations = defineMigrations({
      currentVersion: rootShapeTypeMigrations.currentVersion,
      firstVersion: rootShapeTypeMigrations.firstVersion,
      migrators: rootShapeTypeMigrations.migrators,
      subTypeKey: "type",
      subTypeMigrations: Object.fromEntries(allShapeDefs.map((def) => [def.type, def.migrations]))
    });
    let shapeValidator = validation_exports.union("type", __spreadValues({}, Object.fromEntries(allShapeDefs.map((def) => {
      var _a5;
      return [def.type, (_a5 = def.validator) != null ? _a5 : validation_exports.any];
    }))));
    if (allowUnknownShapes) {
      shapeValidator = shapeValidator.validateUnknownVariants((shape) => shape);
    }
    const shapeRecord = createRecordType("shape", {
      migrations: shapeTypeMigrations,
      validator: validation_exports.model("shape", shapeValidator),
      scope: "document"
    }).withDefaultProperties(() => ({ x: 0, y: 0, rotation: 0, isLocked: false }));
    return StoreSchema.create(
      {
        asset: TLAsset,
        camera: TLCamera,
        document: TLDocument,
        instance: TLInstance,
        instance_page_state: TLInstancePageState,
        page: TLPage,
        shape: shapeRecord,
        user: TLUser,
        user_document: TLUserDocument,
        user_presence: TLUserPresence,
        instance_presence: TLInstancePresence
      },
      {
        snapshotMigrations: storeMigrations,
        onValidationFailure,
        createIntegrityChecker,
        derivePresenceState: derivePresenceState != null ? derivePresenceState : defaultDerivePresenceState
      }
    );
  }

  // ../../../packages/tlschema/src/fixup.ts
  function CLIENT_FIXUP_SCRIPT(persistedStore) {
    const records = Object.values(persistedStore);
    for (let i3 = 0; i3 < records.length; i3++) {
      if (!records[i3])
        continue;
      const { record } = fixupRecord(records[i3]);
      if (record) {
        persistedStore[records[i3].id] = record;
      } else {
        delete persistedStore[records[i3].id];
      }
    }
    return persistedStore;
  }
  function fixupRecord(oldRecord) {
    const issues = [];
    let record = JSON.parse(JSON.stringify(oldRecord));
    switch (record.typeName) {
      case "user_presence": {
        if (!record.cursor) {
          issues.push("no cursor");
          record.cursor = { x: 0, y: 0 };
        }
        if (record.cursor.x === void 0 || record.cursor.x === null) {
          issues.push("no cursor x");
          record.cursor.x = 0;
        }
        if (record.cursor.y === void 0 || record.cursor.y === null) {
          issues.push("no cursor y");
          record.cursor.y = 0;
        }
        break;
      }
      case "asset": {
        switch (record.type) {
          case "image":
          case "video": {
            if (!record.props) {
              issues.push("no props in asset");
              record.props = {
                w: 100,
                h: 100,
                name: "old_asset",
                isAnimated: false,
                mimeType: null,
                src: null
              };
            }
            if (!record.props.mimeType) {
              issues.push("no mimeType in asset props");
              record.props.mimeType = "image/png";
            }
            if (!record.props.src) {
              issues.push("no src in asset props");
              record.props.src = "";
            }
            if (record.props.isAnimated == null) {
              issues.push("no isAnimated in asset props");
              record.props.isAnimated = false;
            }
            if (record.props.name === void 0) {
              record.props.name = "asset";
            }
            if ("width" in record) {
              issues.push("width in asset");
              record.props.w = record.width;
              delete record.width;
            }
            if ("width" in record.props && typeof record.props.width === "number" && record.props.width) {
              issues.push("no w in asset props");
              record.props.w = record.props.width;
              delete record.props.width;
            }
            if ("height" in record) {
              issues.push("height in asset");
              record.props.h = record.height;
              delete record.height;
            }
            if ("height" in record.props && typeof record.props.height === "number" && record.props.height) {
              issues.push("no h in asset props");
              record.props.h = record.props.height;
              delete record.props.height;
            }
            if (!record.props.w) {
              issues.push("no w in asset props");
              record.props.w = 100;
            }
            if (!record.props.h) {
              issues.push("no h in asset props");
              record.props.h = 100;
            }
            if ("src" in record) {
              issues.push("src in asset");
              record.props.src = record.src;
              delete record.src;
            }
            if ("name" in record) {
              issues.push("name in asset");
              delete record.name;
            }
            break;
          }
          case "bookmark":
            if (!record.props) {
              issues.push("no asset props");
              record.props = {
                title: "",
                description: "",
                image: "",
                src: "url" in record && typeof record.url === "string" ? record.url : ""
              };
            }
            if (!record.props.title) {
              issues.push("no title in bookmark asset props");
              record.props.title = "";
            }
            if (!record.props.description) {
              issues.push("no description in bookmark asset props");
              record.props.description = "";
            }
            if (!record.props.image) {
              issues.push("no image in bookmark asset props");
              record.props.image = "";
            }
            if ("src" in record) {
              issues.push("leftover src in bookmark asset");
              delete record.src;
            }
            if ("width" in record) {
              issues.push("leftover width in bookmark asset");
              delete record.width;
            }
            if ("height" in record) {
              issues.push("leftover height in bookmark asset");
              delete record.height;
            }
            if ("name" in record) {
              issues.push("leftover name in bookmark asset");
              delete record.name;
            }
            if ("meta" in record) {
              delete record.meta;
            }
            break;
        }
        break;
      }
      case "camera": {
        if (record.x === void 0 || record.x === null) {
          issues.push("no x in camera");
          record.x = 0;
        }
        if (record.y === void 0 || record.y === null) {
          issues.push("no y in camera");
          record.y = 0;
        }
        break;
      }
      case "instance": {
        if ("props" in record) {
          issues.push("leftover props in instance");
          delete record.props;
        }
        if (record.isToolLocked === void 0) {
          issues.push("no isToolLocked in instance");
          record.isToolLocked = false;
        }
        if (record.propsForNextShape === void 0) {
          issues.push("no props in instance");
          record.propsForNextShape = {
            opacity: "1",
            color: "black",
            dash: "draw",
            fill: "none",
            size: "m",
            icon: "file",
            font: "draw",
            align: "middle",
            geo: "rectangle",
            arrowheadStart: "none",
            arrowheadEnd: "arrow",
            spline: "line"
          };
        }
        if ("url" in record.propsForNextShape) {
          issues.push("leftover url in instance.propsForNextShape");
          delete record.propsForNextShape.url;
        }
        if ("lang" in record.propsForNextShape) {
          issues.push("leftover lang in instance.propsForNextShape");
          delete record.propsForNextShape.lang;
        }
        if (record.exportBackground === void 0) {
          issues.push(`no export background in ${record.typeName}`);
          record.exportBackground = false;
        }
        if (record.brush === void 0) {
          issues.push(`no brush in ${record.typeName}`);
          record.brush = null;
        }
        if (record.scribble === void 0) {
          issues.push(`no scribble in ${record.typeName}`);
          record.scribble = null;
        }
        if (record.dialog !== void 0) {
          issues.push(`no dialog in ${record.typeName}`);
          delete record.dialog;
        }
        if (record.screenBounds === void 0) {
          issues.push(`no screen bounds in ${record.typeName}`);
          record.screenBounds = { x: 0, y: 0, w: 1080, h: 720 };
        }
        break;
      }
      case "user": {
        if (!record.name) {
          issues.push(`no name in user`);
          record.name = "User";
        }
        if (!record.locale) {
          issues.push(`no locale in user`);
          record.locale = "en";
        }
        if ("cursor" in record) {
          issues.push("leftover cursor in user");
          delete record.cursor;
        }
        if ("color" in record) {
          issues.push("leftover color in user");
          delete record.color;
        }
        if ("brush" in record) {
          issues.push("leftover brush in user");
          delete record.brush;
        }
        if ("selectedIds" in record) {
          issues.push("leftover selectedIds in user");
          delete record.selectedIds;
        }
        if ("scribble" in record) {
          issues.push("leftover scribble in user");
          delete record.scribble;
        }
        if ("currentPageId" in record) {
          issues.push("leftover currentPageId in user");
          delete record.currentPageId;
        }
        break;
      }
      case "user_document": {
        if (record.isMobileMode === void 0) {
          issues.push(`no ismobilemode in user document`);
          record.isMobileMode = false;
        }
        if (record.isSnapMode === void 0) {
          issues.push(`no issnapmode in user document`);
          record.isSnapMode = false;
        }
        break;
      }
      case "shape": {
        if ("url" in record) {
          delete record.url;
        }
        if (record.x === void 0 || record.x === null) {
          issues.push(`some bug in ${record.typeName} ${record.type}`);
          record.x = 0;
        }
        if (record.y === void 0 || record.y === null) {
          issues.push(`some bug in ${record.typeName} ${record.type}`);
          record.y = 0;
        }
        if (record.type === "image") {
          if (record.props.playing === void 0) {
            issues.push(`some bug in ${record.typeName} ${record.type}`);
            record.props.playing = false;
          }
          if ("loaded" in record.props) {
            delete record.props.loaded;
          }
        }
        if (record.type === "arrow") {
          if (record.props.start.type === "binding") {
            if (record.props.start.normalizedAnchor.x === void 0 || record.props.start.normalizedAnchor.x === null) {
              issues.push(`some bug in ${record.typeName} ${record.type}`);
              record.props.start.normalizedAnchor.x = 0;
            }
            if (record.props.start.normalizedAnchor.y === void 0 || record.props.start.normalizedAnchor.y === null) {
              issues.push(`some bug in ${record.typeName} ${record.type}`);
              record.props.start.normalizedAnchor.y = 0;
            }
          } else {
            if (record.props.start.x === void 0 || record.props.start.x === null) {
              issues.push(`some bug in ${record.typeName} ${record.type}`);
              record.props.start.x = 0;
            }
            if (record.props.start.y === void 0 || record.props.start.y === null) {
              issues.push(`some bug in ${record.typeName} ${record.type}`);
              record.props.start.y = 0;
            }
            if ("boundShapeId" in record.props.start) {
              issues.push(`leftover bound shape id in arrow`);
              delete record.props.start.boundShapeId;
            }
            if ("normalizedAnchor" in record.props.start) {
              issues.push(`leftover normalize anchor in arrow`);
              delete record.props.start.normalizedAnchor;
            }
            if ("isExact" in record.props.start) {
              issues.push(`leftover isExact in arrow`);
              delete record.props.start.isExact;
            }
          }
          if (record.props.end.type === "binding") {
            if (record.props.end.normalizedAnchor.x === void 0 || record.props.end.normalizedAnchor.x === null) {
              issues.push(`some bug in ${record.typeName}  ${record.type}`);
              record.props.end.normalizedAnchor.x = 0;
            }
            if (record.props.end.normalizedAnchor.y === void 0 || record.props.end.normalizedAnchor.y === null) {
              issues.push(`some bug in ${record.typeName} ${record.type}`);
              record.props.end.normalizedAnchor.y = 0;
            }
          } else {
            if (record.props.end.x === void 0 || record.props.end.x === null) {
              issues.push(`no x in arrow end`);
              record.props.end.x = 0;
            }
            if (record.props.end.y === void 0 || record.props.end.y === null) {
              issues.push(`no y in arrow end`);
              record.props.end.y = 0;
            }
            if ("boundShapeId" in record.props.end) {
              issues.push(`leftover bound shape id in arrow`);
              delete record.props.end.boundShapeId;
            }
            if ("normalizedAnchor" in record.props.end) {
              issues.push(`leftover normalize anchor in arrow`);
              delete record.props.end.normalizedAnchor;
            }
            if ("isExact" in record.props.end) {
              issues.push(`leftover isExact in arrow`);
              delete record.props.end.isExact;
            }
          }
        }
        if (record.type === "note" || record.type === "video" || record.type === "image" || record.type === "geo" || record.type === "bookmark") {
          if (record.props.url === void 0) {
            issues.push(`missing url prop in ${record.type} shape`);
            record.props.url = "";
          }
        }
        if (record.type === "bookmark") {
          if (record.props.assetId === void 0) {
            issues.push(`some bug in ${record.typeName}  ${record.type}`);
            record.props.assetId = null;
          }
          if ("src" in record) {
            issues.push(`leftover src in bookmark`);
            delete record.src;
          }
        }
        if (record.type === "geo") {
          if ("width" in record.props) {
            issues.push(`leftover width in geo`);
            delete record.props.width;
          }
          if ("height" in record.props) {
            issues.push(`leftover height in geo`);
            delete record.props.height;
          }
        }
        if (record.type === "draw") {
          if (record.props.segments === void 0) {
            issues.push(`some bug in ${record.typeName}  ${record.type}`);
            record.props.segments = [
              {
                points: [
                  { x: 0, y: 0, z: 0.5 },
                  { x: 1, y: 1, z: 0.5 }
                ],
                type: "free"
              }
            ];
          }
          for (const segment of record.props.segments) {
            for (const point2 of segment.points) {
              if (point2.x === void 0 || point2.y === null) {
                issues.push(`some bug in ${record.typeName}`);
                point2.x = 0;
              }
              if (point2.y === void 0 || point2.y === null) {
                issues.push(`some bug in ${record.typeName}`);
                point2.y = 0;
              }
            }
          }
          if ("points" in record.props) {
            delete record.props.points;
          }
        }
        if (record.type === "bookmark") {
          if ("loaded" in record.props) {
            issues.push("leftover loaded in bookmark");
            delete record.props.loaded;
          }
        }
        if (record.type === "draw") {
          if ("points" in record.props && record.props.segments === void 0) {
            record.props.segments = [{ type: "free", points: record.props.points }];
          }
        }
        if (record.type === "image") {
          if (record.props.w < 1) {
            record.props.w = 1;
            issues.push(`zero w image in ${record.typeName}`);
          }
          if (record.props.h < 1) {
            record.props.h = 1;
            issues.push(`zero h image in ${record.typeName}`);
          }
        }
        if (record.type === "embed") {
          if ("loaded" in record.props) {
            issues.push("leftover loaded in embed");
            delete record.props.loaded;
          }
        }
        break;
      }
      case void 0: {
        record = null;
      }
    }
    return { record, issues };
  }

  // ../../../packages/tlschema/src/shapes/TLIconShape.ts
  var iconShapeTypeValidator = createShapeValidator(
    "icon",
    validation_exports.object({
      size: sizeValidator,
      icon: iconValidator,
      dash: dashValidator,
      color: colorValidator,
      opacity: opacityValidator,
      scale: validation_exports.number
    })
  );
  var Versions27 = {
    Initial: 0
  };
  var iconShapeMigrations = defineMigrations({
    // STEP 2: Update the current version to point to your latest version
    currentVersion: Versions27.Initial,
    firstVersion: Versions27.Initial,
    migrators: {
      // STEP 3: Add an up+down migration for the new version here
    }
  });

  // ../../../packages/editor/src/lib/TldrawEditor.tsx
  var import_react41 = __toESM(require_react());

  // ../../../packages/primitives/src/lib/easings.ts
  var EASINGS = {
    linear: (t4) => t4,
    easeInQuad: (t4) => t4 * t4,
    easeOutQuad: (t4) => t4 * (2 - t4),
    easeInOutQuad: (t4) => t4 < 0.5 ? 2 * t4 * t4 : -1 + (4 - 2 * t4) * t4,
    easeInCubic: (t4) => t4 * t4 * t4,
    easeOutCubic: (t4) => --t4 * t4 * t4 + 1,
    easeInOutCubic: (t4) => t4 < 0.5 ? 4 * t4 * t4 * t4 : (t4 - 1) * (2 * t4 - 2) * (2 * t4 - 2) + 1,
    easeInQuart: (t4) => t4 * t4 * t4 * t4,
    easeOutQuart: (t4) => 1 - --t4 * t4 * t4 * t4,
    easeInOutQuart: (t4) => t4 < 0.5 ? 8 * t4 * t4 * t4 * t4 : 1 - 8 * --t4 * t4 * t4 * t4,
    easeInQuint: (t4) => t4 * t4 * t4 * t4 * t4,
    easeOutQuint: (t4) => 1 + --t4 * t4 * t4 * t4 * t4,
    easeInOutQuint: (t4) => t4 < 0.5 ? 16 * t4 * t4 * t4 * t4 * t4 : 1 + 16 * --t4 * t4 * t4 * t4 * t4,
    easeInSine: (t4) => 1 - Math.cos(t4 * Math.PI / 2),
    easeOutSine: (t4) => Math.sin(t4 * Math.PI / 2),
    easeInOutSine: (t4) => -(Math.cos(Math.PI * t4) - 1) / 2,
    easeInExpo: (t4) => t4 <= 0 ? 0 : Math.pow(2, 10 * t4 - 10),
    easeOutExpo: (t4) => t4 >= 1 ? 1 : 1 - Math.pow(2, -10 * t4),
    easeInOutExpo: (t4) => t4 <= 0 ? 0 : t4 >= 1 ? 1 : t4 < 0.5 ? Math.pow(2, 20 * t4 - 10) / 2 : (2 - Math.pow(2, -20 * t4 + 10)) / 2
  };

  // ../../../packages/primitives/src/lib/Vec2d.ts
  var Vec2d = class {
    constructor(x3 = 0, y3 = 0, z2 = 1) {
      this.x = x3;
      this.y = y3;
      this.z = z2;
    }
    get pressure() {
      return this.z;
    }
    set(x3 = this.x, y3 = this.y, z2 = this.z) {
      this.x = x3;
      this.y = y3;
      this.z = z2;
      return this;
    }
    setTo({ x: x3 = 0, y: y3 = 0, z: z2 = 1 }) {
      this.x = x3;
      this.y = y3;
      this.z = z2;
      return this;
    }
    rot(r3) {
      if (r3 === 0)
        return this;
      const { x: x3, y: y3 } = this;
      const s3 = Math.sin(r3);
      const c3 = Math.cos(r3);
      this.x = x3 * c3 - y3 * s3;
      this.y = x3 * s3 + y3 * c3;
      return this;
    }
    rotWith(C2, r3) {
      if (r3 === 0)
        return this;
      const x3 = this.x - C2.x;
      const y3 = this.y - C2.y;
      const s3 = Math.sin(r3);
      const c3 = Math.cos(r3);
      this.x = C2.x + (x3 * c3 - y3 * s3);
      this.y = C2.y + (x3 * s3 + y3 * c3);
      return this;
    }
    clone() {
      const { x: x3, y: y3, z: z2 } = this;
      return new Vec2d(x3, y3, z2);
    }
    sub(V2) {
      this.x -= V2.x;
      this.y -= V2.y;
      return this;
    }
    subXY(x3, y3) {
      this.x -= x3;
      this.y -= y3;
      return this;
    }
    subScalar(n3) {
      this.x -= n3;
      this.y -= n3;
      return this;
    }
    add(V2) {
      this.x += V2.x;
      this.y += V2.y;
      return this;
    }
    addXY(x3, y3) {
      this.x += x3;
      this.y += y3;
      return this;
    }
    addScalar(n3) {
      this.x += n3;
      this.y += n3;
      return this;
    }
    clamp(min2, max) {
      this.x = Math.max(this.x, min2);
      this.y = Math.max(this.y, min2);
      if (max !== void 0) {
        this.x = Math.min(this.x, max);
        this.y = Math.min(this.y, max);
      }
      return this;
    }
    div(t4) {
      this.x /= t4;
      this.y /= t4;
      return this;
    }
    divV(V2) {
      this.x /= V2.x;
      this.y /= V2.y;
      return this;
    }
    mul(t4) {
      this.x *= t4;
      this.y *= t4;
      return this;
    }
    mulV(V2) {
      this.x *= V2.x;
      this.y *= V2.y;
      return this;
    }
    abs() {
      this.x = Math.abs(this.x);
      this.y = Math.abs(this.y);
      return this;
    }
    nudge(B, distance) {
      const tan = Vec2d.Tan(B, this);
      return this.add(tan.mul(distance));
    }
    neg() {
      this.x *= -1;
      this.y *= -1;
      return this;
    }
    cross(V2) {
      this.x = this.y * V2.z - this.z * V2.y;
      this.y = this.z * V2.x - this.x * V2.z;
      return this;
    }
    dpr(V2) {
      return Vec2d.Dpr(this, V2);
    }
    cpr(V2) {
      return Vec2d.Cpr(this, V2);
    }
    len2() {
      return Vec2d.Len2(this);
    }
    len() {
      return Vec2d.Len(this);
    }
    pry(V2) {
      return Vec2d.Pry(this, V2);
    }
    per() {
      const { x: x3, y: y3 } = this;
      this.x = y3;
      this.y = -x3;
      return this;
    }
    uni() {
      return Vec2d.Uni(this);
    }
    tan(V2) {
      return Vec2d.Tan(this, V2);
    }
    dist(V2) {
      return Vec2d.Dist(this, V2);
    }
    distanceToLineSegment(A2, B) {
      return Vec2d.DistanceToLineSegment(A2, B, this);
    }
    slope(B) {
      return Vec2d.Slope(this, B);
    }
    snapToGrid(gridSize) {
      this.x = Math.round(this.x / gridSize) * gridSize;
      this.y = Math.round(this.y / gridSize) * gridSize;
      return this;
    }
    angle(B) {
      return Vec2d.Angle(this, B);
    }
    toAngle() {
      return Vec2d.ToAngle(this);
    }
    lrp(B, t4) {
      this.x = this.x + (B.x - this.x) * t4;
      this.y = this.y + (B.y - this.y) * t4;
      return this;
    }
    equals(B) {
      return Vec2d.Equals(this, B);
    }
    equalsXY(x3, y3) {
      return Vec2d.EqualsXY(this, x3, y3);
    }
    norm() {
      const l3 = this.len();
      this.x = l3 === 0 ? 0 : this.x / l3;
      this.y = l3 === 0 ? 0 : this.y / l3;
      return this;
    }
    toFixed() {
      return Vec2d.ToFixed(this);
    }
    toString() {
      return Vec2d.ToString(Vec2d.ToFixed(this));
    }
    toJson() {
      return Vec2d.ToJson(this);
    }
    toArray() {
      return Vec2d.ToArray(this);
    }
    static Add(A2, B) {
      return new Vec2d(A2.x + B.x, A2.y + B.y);
    }
    static AddXY(A2, x3, y3) {
      return new Vec2d(A2.x + x3, A2.y + y3);
    }
    static Sub(A2, B) {
      return new Vec2d(A2.x - B.x, A2.y - B.y);
    }
    static SubXY(A2, x3, y3) {
      return new Vec2d(A2.x - x3, A2.y - y3);
    }
    static AddScalar(A2, n3) {
      return new Vec2d(A2.x + n3, A2.y + n3);
    }
    static SubScalar(A2, n3) {
      return new Vec2d(A2.x - n3, A2.y - n3);
    }
    static Div(A2, t4) {
      return new Vec2d(A2.x / t4, A2.y / t4);
    }
    static Mul(A2, t4) {
      return new Vec2d(A2.x * t4, A2.y * t4);
    }
    static DivV(A2, B) {
      return new Vec2d(A2.x / B.x, A2.y / B.y);
    }
    static MulV(A2, B) {
      return new Vec2d(A2.x * B.x, A2.y * B.y);
    }
    static Neg(A2) {
      return new Vec2d(-A2.x, -A2.y);
    }
    static Per(A2) {
      return new Vec2d(A2.y, -A2.x);
    }
    static Dist2(A2, B) {
      return Vec2d.Sub(A2, B).len2();
    }
    static Abs(A2) {
      return new Vec2d(Math.abs(A2.x), Math.abs(A2.y));
    }
    static Dist(A2, B) {
      return Math.hypot(A2.y - B.y, A2.x - B.x);
    }
    static Dpr(A2, B) {
      return A2.x * B.x + A2.y * B.y;
    }
    static Cross(A2, V2) {
      return new Vec2d(
        A2.y * V2.z - A2.z * V2.y,
        A2.z * V2.x - A2.x * V2.z
        // A.z = A.x * V.y - A.y * V.x
      );
    }
    static Cpr(A2, B) {
      return A2.x * B.y - B.x * A2.y;
    }
    static Len2(A2) {
      return A2.x * A2.x + A2.y * A2.y;
    }
    static Len(A2) {
      return Math.sqrt(Vec2d.Len2(A2));
    }
    static Pry(A2, B) {
      return Vec2d.Dpr(A2, B) / Vec2d.Len(B);
    }
    static Uni(A2) {
      return Vec2d.Div(A2, Vec2d.Len(A2));
    }
    static Tan(A2, B) {
      return Vec2d.Uni(Vec2d.Sub(A2, B));
    }
    static Min(A2, B) {
      return new Vec2d(Math.min(A2.x, B.x), Math.min(A2.y, B.y));
    }
    static Max(A2, B) {
      return new Vec2d(Math.max(A2.x, B.x), Math.max(A2.y, B.y));
    }
    static From({ x: x3, y: y3, z: z2 = 1 }) {
      return new Vec2d(x3, y3, z2);
    }
    static FromArray(v3) {
      return new Vec2d(v3[0], v3[1]);
    }
    static Rot(A2, r3 = 0) {
      const s3 = Math.sin(r3);
      const c3 = Math.cos(r3);
      return new Vec2d(A2.x * c3 - A2.y * s3, A2.x * s3 + A2.y * c3);
    }
    static RotWith(A2, C2, r3) {
      const x3 = A2.x - C2.x;
      const y3 = A2.y - C2.y;
      const s3 = Math.sin(r3);
      const c3 = Math.cos(r3);
      return new Vec2d(C2.x + (x3 * c3 - y3 * s3), C2.y + (x3 * s3 + y3 * c3));
    }
    /**
     * Get the nearest point on a line with a known unit vector that passes through point A
     *
     * ```ts
     * Vec.nearestPointOnLineThroughPoint(A, u, Point)
     * ```
     *
     * @param A - Any point on the line
     * @param u - The unit vector for the line.
     * @param P - A point not on the line to test.
     */
    static NearestPointOnLineThroughPoint(A2, u3, P2) {
      return Vec2d.Mul(u3, Vec2d.Sub(P2, A2).pry(u3)).add(A2);
    }
    static NearestPointOnLineSegment(A2, B, P2, clamp3 = true) {
      const u3 = Vec2d.Tan(B, A2);
      const C2 = Vec2d.Add(A2, Vec2d.Mul(u3, Vec2d.Sub(P2, A2).pry(u3)));
      if (clamp3) {
        if (C2.x < Math.min(A2.x, B.x))
          return Vec2d.Cast(A2.x < B.x ? A2 : B);
        if (C2.x > Math.max(A2.x, B.x))
          return Vec2d.Cast(A2.x > B.x ? A2 : B);
        if (C2.y < Math.min(A2.y, B.y))
          return Vec2d.Cast(A2.y < B.y ? A2 : B);
        if (C2.y > Math.max(A2.y, B.y))
          return Vec2d.Cast(A2.y > B.y ? A2 : B);
      }
      return C2;
    }
    static DistanceToLineThroughPoint(A2, u3, P2) {
      return Vec2d.Dist(P2, Vec2d.NearestPointOnLineThroughPoint(A2, u3, P2));
    }
    static DistanceToLineSegment(A2, B, P2, clamp3 = true) {
      return Vec2d.Dist(P2, Vec2d.NearestPointOnLineSegment(A2, B, P2, clamp3));
    }
    static Snap(A2, step = 1) {
      return new Vec2d(Math.round(A2.x / step) * step, Math.round(A2.y / step) * step);
    }
    static Cast(A2) {
      if (A2 instanceof Vec2d)
        return A2;
      return Vec2d.From(A2);
    }
    static Slope(A2, B) {
      if (A2.x === B.y)
        return NaN;
      return (A2.y - B.y) / (A2.x - B.x);
    }
    static Angle(A2, B) {
      return Math.atan2(B.y - A2.y, B.x - A2.x);
    }
    static Lrp(A2, B, t4) {
      return Vec2d.Sub(B, A2).mul(t4).add(A2);
    }
    static Med(A2, B) {
      return new Vec2d((A2.x + B.x) / 2, (A2.y + B.y) / 2);
    }
    static Equals(A2, B) {
      return Math.abs(A2.x - B.x) < 1e-4 && Math.abs(A2.y - B.y) < 1e-4;
    }
    static EqualsXY(A2, x3, y3) {
      return A2.x === x3 && A2.y === y3;
    }
    static Clockwise(A2, B, C2) {
      return (C2.x - A2.x) * (B.y - A2.y) - (B.x - A2.x) * (C2.y - A2.y) < 0;
    }
    static Rescale(A2, n3) {
      const l3 = Vec2d.Len(A2);
      return new Vec2d(n3 * A2.x / l3, n3 * A2.y / l3);
    }
    static ScaleWithOrigin(A2, scale, origin) {
      return Vec2d.Sub(A2, origin).mul(scale).add(origin);
    }
    static ToFixed(A2, n3 = 2) {
      return new Vec2d(+A2.x.toFixed(n3), +A2.y.toFixed(n3), +A2.z.toFixed(n3));
    }
    static Nudge(A2, B, distance) {
      return Vec2d.Add(A2, Vec2d.Tan(B, A2).mul(distance));
    }
    static ToString(A2) {
      return `${A2.x}, ${A2.y}`;
    }
    static ToAngle(A2) {
      let r3 = Math.atan2(A2.y, A2.x);
      if (r3 < 0)
        r3 += Math.PI * 2;
      return r3;
    }
    static ToArray(A2) {
      return [A2.x, A2.y, A2.z];
    }
    static ToJson(A2) {
      const { x: x3, y: y3, z: z2 } = A2;
      return { x: x3, y: y3, z: z2 };
    }
    static Average(arr) {
      const len = arr.length;
      const avg = new Vec2d(0, 0);
      for (let i3 = 0; i3 < len; i3++) {
        avg.add(arr[i3]);
      }
      return avg.div(len);
    }
    static Clamp(A2, min2, max) {
      if (max === void 0) {
        return new Vec2d(Math.min(Math.max(A2.x, min2)), Math.min(Math.max(A2.y, min2)));
      }
      return new Vec2d(Math.min(Math.max(A2.x, min2), max), Math.min(Math.max(A2.y, min2), max));
    }
    /**
     * Get an array of points (with simulated pressure) between two points.
     *
     * @param A - The first point.
     * @param B - The second point.
     * @param steps - The number of points to return.
     */
    static PointsBetween(A2, B, steps = 6) {
      const results = [];
      for (let i3 = 0; i3 < steps; i3++) {
        const t4 = EASINGS.easeInQuad(i3 / (steps - 1));
        const point2 = Vec2d.Lrp(A2, B, t4);
        point2.z = Math.min(1, 0.5 + Math.abs(0.5 - ease(t4)) * 0.65);
        results.push(point2);
      }
      return results;
    }
    static SnapToGrid(A2, gridSize = 8) {
      return new Vec2d(Math.round(A2.x / gridSize) * gridSize, Math.round(A2.y / gridSize) * gridSize);
    }
  };
  var ease = (t4) => t4 < 0.5 ? 2 * t4 * t4 : -1 + (4 - 2 * t4) * t4;

  // ../../../packages/primitives/src/lib/utils.ts
  var PI = Math.PI;
  var TAU = PI / 2;
  var PI2 = PI * 2;
  var EPSILON = Math.PI / 180;
  var SIN = Math.sin;
  function clamp(n3, min2, max) {
    return Math.max(min2, typeof max !== "undefined" ? Math.min(n3, max) : n3);
  }
  function toPrecision(n3, precision = 1e10) {
    if (!n3)
      return 0;
    return Math.round(n3 * precision) / precision;
  }
  function approximately(a3, b3, precision = 1e-6) {
    return Math.abs(a3 - b3) <= precision;
  }
  function perimeterOfEllipse(rx, ry) {
    const h3 = Math.pow(rx - ry, 2) / Math.pow(rx + ry, 2);
    const p3 = PI * (rx + ry) * (1 + 3 * h3 / (10 + Math.sqrt(4 - 3 * h3)));
    return p3;
  }
  function canolicalizeRotation(a3) {
    a3 = a3 % PI2;
    if (a3 < 0) {
      a3 = a3 + PI2;
    } else if (a3 === 0) {
      a3 = 0;
    }
    return a3;
  }
  function shortAngleDist(a0, a1) {
    const da = (a1 - a0) % PI2;
    return 2 * da % PI2 - da;
  }
  function longAngleDist(a0, a1) {
    return PI2 - shortAngleDist(a0, a1);
  }
  function lerpAngles(a0, a1, t4) {
    return a0 + shortAngleDist(a0, a1) * t4;
  }
  function angleDelta(a0, a1) {
    return shortAngleDist(a0, a1);
  }
  function getSweep(C2, A2, B) {
    return angleDelta(Vec2d.Angle(C2, A2), Vec2d.Angle(C2, B));
  }
  function clampRadians(r3) {
    return (PI2 + r3) % PI2;
  }
  function snapAngle(r3, segments) {
    const seg = PI2 / segments;
    let ang = Math.floor((clampRadians(r3) + seg / 2) / seg) * seg % PI2;
    if (ang < PI)
      ang += PI2;
    if (ang > PI)
      ang -= PI2;
    return ang;
  }
  function areAnglesCompatible(a3, b3) {
    return a3 === b3 || approximately(a3 % (Math.PI / 2) - b3 % (Math.PI / 2), 0);
  }
  function degreesToRadians(d3) {
    return d3 * PI / 180;
  }
  function radiansToDegrees(r3) {
    return r3 * 180 / PI;
  }
  function getArcLength(C2, r3, A2, B) {
    const sweep = getSweep(C2, A2, B);
    return r3 * PI2 * (sweep / PI2);
  }
  function getPointOnCircle(cx, cy, r3, a3) {
    return new Vec2d(cx + r3 * Math.cos(a3), cy + r3 * Math.sin(a3));
  }
  function getPolygonVertices(width, height, sides) {
    const cx = width / 2;
    const cy = height / 2;
    const pointsOnPerimeter = [];
    for (let i3 = 0; i3 < sides; i3++) {
      const step = PI2 / sides;
      const t4 = -TAU + i3 * step;
      pointsOnPerimeter.push(new Vec2d(cx + cx * Math.cos(t4), cy + cy * Math.sin(t4)));
    }
    return pointsOnPerimeter;
  }
  function rangesOverlap(a0, a1, b0, b1) {
    return a0 < b1 && b0 < a1;
  }
  function rangeIntersection(a0, a1, b0, b1) {
    const min2 = Math.max(a0, b0);
    const max = Math.min(a1, b1);
    if (min2 <= max) {
      return [min2, max];
    }
    return null;
  }
  var getStarBounds = (sides, w3, h3) => {
    const step = PI2 / sides / 2;
    const rightMostIndex = Math.floor(sides / 4) * 2;
    const leftMostIndex = sides * 2 - rightMostIndex;
    const topMostIndex = 0;
    const bottomMostIndex = Math.floor(sides / 2) * 2;
    const maxX = Math.cos(-TAU + rightMostIndex * step) * w3 / 2;
    const minX = Math.cos(-TAU + leftMostIndex * step) * w3 / 2;
    const minY = Math.sin(-TAU + topMostIndex * step) * h3 / 2;
    const maxY = Math.sin(-TAU + bottomMostIndex * step) * h3 / 2;
    return new Box2d(0, 0, maxX - minX, maxY - minY);
  };
  function cross(x3, y3, z2) {
    return (y3.x - x3.x) * (z2.y - x3.y) - (z2.x - x3.x) * (y3.y - x3.y);
  }
  function pointInPolygon(A2, points2) {
    let windingNumber = 0;
    let a3;
    let b3;
    for (let i3 = 0; i3 < points2.length; i3++) {
      a3 = points2[i3];
      b3 = points2[(i3 + 1) % points2.length];
      if (a3.y <= A2.y) {
        if (b3.y > A2.y && cross(a3, b3, A2) > 0) {
          windingNumber += 1;
        }
      } else if (b3.y <= A2.y && cross(a3, b3, A2) < 0) {
        windingNumber -= 1;
      }
    }
    return windingNumber !== 0;
  }
  function pointNearToPolyline(A2, points2, distance = 8) {
    const len = points2.length;
    for (let i3 = 1; i3 < len; i3++) {
      const p1 = points2[i3 - 1];
      const p22 = points2[i3];
      const d3 = Vec2d.DistanceToLineSegment(p1, p22, A2);
      if (d3 < distance)
        return true;
    }
    return false;
  }
  function toDomPrecision(v3) {
    return +v3.toFixed(4);
  }

  // ../../../packages/primitives/src/lib/Box2d.ts
  var _Box2d = class {
    constructor(x3 = 0, y3 = 0, w3 = 0, h3 = 0) {
      __publicField(this, "x", 0);
      __publicField(this, "y", 0);
      __publicField(this, "w", 0);
      __publicField(this, "h", 0);
      this.x = x3;
      this.y = y3;
      this.w = w3;
      this.h = h3;
    }
    get point() {
      return new Vec2d(this.x, this.y);
    }
    set point(val) {
      this.x = val.x;
      this.y = val.y;
    }
    get minX() {
      return this.x;
    }
    set minX(n3) {
      this.x = n3;
    }
    get midX() {
      return this.x + this.w / 2;
    }
    get maxX() {
      return this.x + this.w;
    }
    get minY() {
      return this.y;
    }
    set minY(n3) {
      this.y = n3;
    }
    get midY() {
      return this.y + this.h / 2;
    }
    get maxY() {
      return this.y + this.h;
    }
    get width() {
      return this.w;
    }
    set width(n3) {
      this.w = n3;
    }
    get height() {
      return this.h;
    }
    set height(n3) {
      this.h = n3;
    }
    get aspectRatio() {
      return this.width / this.height;
    }
    get center() {
      return new Vec2d(this.midX, this.midY);
    }
    set center(v3) {
      this.minX = v3.x - this.width / 2;
      this.minY = v3.y - this.height / 2;
    }
    get corners() {
      return [
        new Vec2d(this.minX, this.minY),
        new Vec2d(this.maxX, this.minY),
        new Vec2d(this.maxX, this.maxY),
        new Vec2d(this.minX, this.maxY)
      ];
    }
    get snapPoints() {
      return [
        new Vec2d(this.minX, this.minY),
        new Vec2d(this.maxX, this.minY),
        new Vec2d(this.maxX, this.maxY),
        new Vec2d(this.minX, this.maxY),
        this.center
      ];
    }
    get sides() {
      const { corners } = this;
      return [
        [corners[0], corners[1]],
        [corners[1], corners[2]],
        [corners[2], corners[3]],
        [corners[3], corners[0]]
      ];
    }
    get size() {
      return new Vec2d(this.w, this.h);
    }
    toFixed() {
      this.x = toPrecision(this.x);
      this.y = toPrecision(this.y);
      this.w = toPrecision(this.w);
      this.h = toPrecision(this.h);
      return this;
    }
    setTo(B) {
      this.x = B.x;
      this.y = B.y;
      this.w = B.w;
      this.h = B.h;
      return this;
    }
    set(x3 = 0, y3 = 0, w3 = 0, h3 = 0) {
      this.x = x3;
      this.y = y3;
      this.w = w3;
      this.h = h3;
      return this;
    }
    expand(A2) {
      const minX = Math.min(this.minX, A2.minX);
      const minY = Math.min(this.minY, A2.minY);
      const maxX = Math.max(this.maxX, A2.maxX);
      const maxY = Math.max(this.maxY, A2.maxY);
      this.x = minX;
      this.y = minY;
      this.w = maxX - minX;
      this.h = maxY - minY;
      return this;
    }
    expandBy(n3) {
      this.x -= n3;
      this.y -= n3;
      this.w += n3 * 2;
      this.h += n3 * 2;
      return this;
    }
    scale(n3) {
      this.x /= n3;
      this.y /= n3;
      this.w /= n3;
      this.h /= n3;
      return this;
    }
    clone() {
      const { x: x3, y: y3, w: w3, h: h3 } = this;
      return new _Box2d(x3, y3, w3, h3);
    }
    translate(delta) {
      this.x += delta.x;
      this.y += delta.y;
      return this;
    }
    snapToGrid(size) {
      const minX = Math.round(this.minX / size) * size;
      const minY = Math.round(this.minY / size) * size;
      const maxX = Math.round(this.maxX / size) * size;
      const maxY = Math.round(this.maxY / size) * size;
      this.minX = minX;
      this.minY = minY;
      this.width = Math.max(1, maxX - minX);
      this.height = Math.max(1, maxY - minY);
    }
    collides(B) {
      return _Box2d.Collides(this, B);
    }
    contains(B) {
      return _Box2d.Contains(this, B);
    }
    includes(B) {
      return _Box2d.Includes(this, B);
    }
    containsPoint(V2, y3) {
      return _Box2d.ContainsPoint(this, V2, y3);
    }
    getHandlePoint(handle) {
      switch (handle) {
        case "top_left":
          return new Vec2d(this.minX, this.minY);
        case "top_right":
          return new Vec2d(this.maxX, this.minY);
        case "bottom_left":
          return new Vec2d(this.minX, this.maxY);
        case "bottom_right":
          return new Vec2d(this.maxX, this.maxY);
        case "top":
          return new Vec2d(this.midX, this.minY);
        case "right":
          return new Vec2d(this.maxX, this.midY);
        case "bottom":
          return new Vec2d(this.midX, this.maxY);
        case "left":
          return new Vec2d(this.minX, this.midY);
      }
    }
    toJson() {
      return { x: this.minX, y: this.minY, w: this.w, h: this.h };
    }
    resize(handle, dx, dy) {
      const { minX: a0x, minY: a0y, maxX: a1x, maxY: a1y } = this;
      let { minX: b0x, minY: b0y, maxX: b1x, maxY: b1y } = this;
      switch (handle) {
        case "left":
        case "top_left":
        case "bottom_left": {
          b0x += dx;
          break;
        }
        case "right":
        case "top_right":
        case "bottom_right": {
          b1x += dx;
          break;
        }
      }
      switch (handle) {
        case "top":
        case "top_left":
        case "top_right": {
          b0y += dy;
          break;
        }
        case "bottom":
        case "bottom_left":
        case "bottom_right": {
          b1y += dy;
          break;
        }
      }
      const scaleX = (b1x - b0x) / (a1x - a0x);
      const scaleY = (b1y - b0y) / (a1y - a0y);
      const flipX = scaleX < 0;
      const flipY = scaleY < 0;
      if (flipX) {
        const t4 = b1x;
        b1x = b0x;
        b0x = t4;
      }
      if (flipY) {
        const t4 = b1y;
        b1y = b0y;
        b0y = t4;
      }
      this.minX = b0x;
      this.minY = b0y;
      this.width = Math.abs(b1x - b0x);
      this.height = Math.abs(b1y - b0y);
    }
    static From(box) {
      return new _Box2d(box.x, box.y, box.w, box.h);
    }
    static FromPoints(points2) {
      if (points2.length === 0)
        return new _Box2d();
      let minX = Infinity;
      let minY = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      let point2;
      for (let i3 = 0, n3 = points2.length; i3 < n3; i3++) {
        point2 = points2[i3];
        minX = Math.min(point2.x, minX);
        minY = Math.min(point2.y, minY);
        maxX = Math.max(point2.x, maxX);
        maxY = Math.max(point2.y, maxY);
      }
      return new _Box2d(minX, minY, maxX - minX, maxY - minY);
    }
    static Expand(A2, B) {
      const minX = Math.min(B.minX, A2.minX);
      const minY = Math.min(B.minY, A2.minY);
      const maxX = Math.max(B.maxX, A2.maxX);
      const maxY = Math.max(B.maxY, A2.maxY);
      return new _Box2d(minX, minY, maxX - minX, maxY - minY);
    }
    static ExpandBy(A2, n3) {
      return new _Box2d(A2.minX - n3, A2.minY - n3, A2.width + n3 * 2, A2.height + n3 * 2);
    }
    static Resize(box, handle, dx, dy, isAspectRatioLocked = false) {
      const { minX: a0x, minY: a0y, maxX: a1x, maxY: a1y } = box;
      let { minX: b0x, minY: b0y, maxX: b1x, maxY: b1y } = box;
      switch (handle) {
        case "left":
        case "top_left":
        case "bottom_left": {
          b0x += dx;
          break;
        }
        case "right":
        case "top_right":
        case "bottom_right": {
          b1x += dx;
          break;
        }
      }
      switch (handle) {
        case "top":
        case "top_left":
        case "top_right": {
          b0y += dy;
          break;
        }
        case "bottom":
        case "bottom_left":
        case "bottom_right": {
          b1y += dy;
          break;
        }
      }
      const scaleX = (b1x - b0x) / (a1x - a0x);
      const scaleY = (b1y - b0y) / (a1y - a0y);
      const flipX = scaleX < 0;
      const flipY = scaleY < 0;
      if (isAspectRatioLocked) {
        const aspectRatio = (a1x - a0x) / (a1y - a0y);
        const bw = Math.abs(b1x - b0x);
        const bh = Math.abs(b1y - b0y);
        const tw = bw * (scaleY < 0 ? 1 : -1) * (1 / aspectRatio);
        const th = bh * (scaleX < 0 ? 1 : -1) * aspectRatio;
        const isTall = aspectRatio < bw / bh;
        switch (handle) {
          case "top_left": {
            if (isTall)
              b0y = b1y + tw;
            else
              b0x = b1x + th;
            break;
          }
          case "top_right": {
            if (isTall)
              b0y = b1y + tw;
            else
              b1x = b0x - th;
            break;
          }
          case "bottom_right": {
            if (isTall)
              b1y = b0y - tw;
            else
              b1x = b0x - th;
            break;
          }
          case "bottom_left": {
            if (isTall)
              b1y = b0y - tw;
            else
              b0x = b1x + th;
            break;
          }
          case "bottom":
          case "top": {
            const m3 = (b0x + b1x) / 2;
            const w3 = bh * aspectRatio;
            b0x = m3 - w3 / 2;
            b1x = m3 + w3 / 2;
            break;
          }
          case "left":
          case "right": {
            const m3 = (b0y + b1y) / 2;
            const h3 = bw / aspectRatio;
            b0y = m3 - h3 / 2;
            b1y = m3 + h3 / 2;
            break;
          }
        }
      }
      if (flipX) {
        const t4 = b1x;
        b1x = b0x;
        b0x = t4;
      }
      if (flipY) {
        const t4 = b1y;
        b1y = b0y;
        b0y = t4;
      }
      const final = new _Box2d(b0x, b0y, Math.abs(b1x - b0x), Math.abs(b1y - b0y));
      return {
        box: final,
        scaleX: +(final.width / box.width * (scaleX > 0 ? 1 : -1)).toFixed(5),
        scaleY: +(final.height / box.height * (scaleY > 0 ? 1 : -1)).toFixed(5)
      };
    }
    equals(other) {
      return _Box2d.Equals(this, other);
    }
    static Equals(a3, b3) {
      return b3.x === a3.x && b3.y === a3.y && b3.w === a3.w && b3.h === a3.h;
    }
  };
  var Box2d = _Box2d;
  __publicField(Box2d, "Collides", (A2, B) => {
    return !(A2.maxX < B.minX || A2.minX > B.maxX || A2.maxY < B.minY || A2.minY > B.maxY);
  });
  __publicField(Box2d, "Contains", (A2, B) => {
    return A2.minX < B.minX && A2.minY < B.minY && A2.maxY > B.maxY && A2.maxX > B.maxX;
  });
  __publicField(Box2d, "Includes", (A2, B) => {
    return _Box2d.Collides(A2, B) || _Box2d.Contains(A2, B);
  });
  __publicField(Box2d, "ContainsPoint", (A2, B, y3) => {
    if (typeof B === "number") {
      return !(B < A2.minX || y3 < A2.minY || B > A2.maxX || y3 > A2.maxY);
    }
    return !(B.x < A2.minX || B.y < A2.minY || B.x > A2.maxX || B.y > A2.maxY);
  });
  __publicField(Box2d, "Common", (boxes) => {
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    for (let i3 = 0; i3 < boxes.length; i3++) {
      const B = boxes[i3];
      minX = Math.min(minX, B.minX);
      minY = Math.min(minY, B.minY);
      maxX = Math.max(maxX, B.maxX);
      maxY = Math.max(maxY, B.maxY);
    }
    return new _Box2d(minX, minY, maxX - minX, maxY - minY);
  });
  __publicField(Box2d, "Sides", (A2, inset = 0) => {
    const { corners } = A2;
    if (inset) {
    }
    return [
      [corners[0], corners[1]],
      [corners[1], corners[2]],
      [corners[2], corners[3]],
      [corners[3], corners[0]]
    ];
  });
  function flipSelectionHandleY(handle) {
    switch (handle) {
      case "top":
        return "bottom";
      case "bottom":
        return "top";
      case "top_left":
        return "bottom_left";
      case "top_right":
        return "bottom_right";
      case "bottom_left":
        return "top_left";
      case "bottom_right":
        return "top_right";
      default:
        return handle;
    }
  }
  function flipSelectionHandleX(handle) {
    switch (handle) {
      case "left":
        return "right";
      case "right":
        return "left";
      case "top_left":
        return "top_right";
      case "top_right":
        return "top_left";
      case "bottom_left":
        return "bottom_right";
      case "bottom_right":
        return "bottom_left";
      default:
        return handle;
    }
  }
  function isSelectionCorner(selection) {
    return selection === "top_left" || selection === "top_right" || selection === "bottom_right" || selection === "bottom_left";
  }

  // ../../../packages/primitives/src/lib/BaseSegment2d.ts
  var BaseSegment2d = class {
    constructor(values) {
      /**
       * The segment's values. Do not modify these directly. Instead, use the `values` setter or
       * `update` method.
       *
       * @internal
       */
      __publicField(this, "_values");
      /**
       * A private set of cached values, used for lookups and computations. Changing any of the
       * segment's values will clear this object.
       *
       * @internal
       */
      __publicField(this, "_computed", {});
      this._values = values;
    }
    /**
     * The values for the curve segment.
     *
     * @public
     */
    get values() {
      return this._values;
    }
    set values(values) {
      this._values = values;
      this._computed = {};
    }
    /**
     * The length of the curve segment.
     *
     * @public
     */
    get length() {
      if (this._computed.length !== void 0) {
        return this._computed.length;
      }
      const { lut } = this;
      let prev = lut[0];
      let result = 0;
      for (let i3 = 1; i3 < lut.length; i3++) {
        const curr = lut[i3];
        result += prev.dist(curr);
        prev = curr;
      }
      this._computed.length = result;
      return result;
    }
    /**
     * The bounding box containing the curve segment.
     *
     * @public
     */
    get bounds() {
      if (this._computed.bounds !== void 0) {
        return this._computed.bounds;
      }
      let minX = Infinity;
      let minY = Infinity;
      let maxX = -Infinity;
      let maxY = -Infinity;
      const { lut } = this;
      for (const pt of lut) {
        minX = Math.min(pt.x, minX);
        minY = Math.min(pt.y, minY);
        maxX = Math.max(pt.x, maxX);
        maxY = Math.max(pt.y, maxY);
      }
      const result = new Box2d(minX, minY, maxX - minX, maxY - minY);
      this._computed.bounds = result;
      return result;
    }
    /**
     * A lookup table consisting of values.p points along the segment. Used to compute lengths,
     * closest points, etc. This should only be _computed once (when first requested) per set of
     * values.
     *
     * @public
     */
    get lut() {
      if (this._computed.lut) {
        return this._computed.lut;
      }
      const { p: p3 } = this.values;
      const result = [];
      for (let i3 = 0; i3 < p3 + 1; i3++) {
        result.push(this.getPoint(i3 / p3));
      }
      this._computed.lut = result;
      return result;
    }
    /**
     * A point half-way along the length of the segment.
     *
     * @public
     */
    get midPoint() {
      if (this._computed.midPoint) {
        return this._computed.midPoint;
      }
      const result = this.getPoint(0.5);
      this._computed.midPoint = result;
      return result;
    }
    /**
     * An SVG path for the segment.
     *
     * @public
     */
    get path() {
      if (this._computed.path) {
        return this._computed.path;
      }
      const result = this.getPath();
      this._computed.path = result;
      return result;
    }
    /**
     * Evaluate a point at a length along the curve segment.
     *
     * @param length - The length to find the point value.
     * @public
     */
    getPointAtLength(length) {
      const t4 = Math.max(0, Math.min(1, length / this.length));
      return this.getPoint(t4);
    }
    /**
     * Get the normal at distance t along the curve segment.
     *
     * @param t - The distance (0-1) to find the normal.
     * @public
     */
    getNormal(t4) {
      return this.getPoint(t4 - 25e-4).tan(this.getPoint(t4 + 25e-4)).per().uni().toFixed();
    }
    /**
     * Get the normal at a length along the curve segment.
     *
     * @param length - The length to find the normal.
     * @public
     */
    getNormalAtLength(length) {
      return this.getNormal(length / this.length);
    }
    /**
     * Get the closest point on the segment to an arbitrary point.
     *
     * @param point - The arbitrary point.
     * @public
     */
    getClosestPointTo(point2) {
      const { lut } = this;
      let closestT = 0;
      let closestPoint = lut[0];
      let closestDistance = lut[0].dist(point2);
      for (let i3 = 1; i3 < lut.length; i3++) {
        const distance = Vec2d.Dist(lut[i3], point2);
        if (distance < closestDistance) {
          closestDistance = distance;
          closestPoint = lut[i3];
          closestT = i3 / lut.length;
        }
      }
      const step = 1 / this.values.p;
      for (let t4 = Math.max(0, closestT - step / 2); t4 < Math.min(1, closestT + step / 2); t4 += step / 10) {
        const pt = this.getPoint(t4);
        const distance = Vec2d.Dist(pt, point2);
        if (distance < closestDistance) {
          closestDistance = distance;
          closestPoint = pt;
        }
      }
      return { point: closestPoint, distance: closestDistance };
    }
    /**
     * Set one or more values. Updating the segment will clear cached values.
     *
     * @param values - A partial of the segment's values object.
     * @public
     */
    update(values) {
      this._computed = {};
      this.values = __spreadValues(__spreadValues({}, this.values), values);
    }
  };

  // ../../../packages/primitives/src/lib/CubicSegment2d.ts
  var _a;
  var CubicSegment2d = class extends BaseSegment2d {
    constructor(a3, b3, c3, d3, p3 = 25) {
      super({ a: a3, b: b3, c: c3, d: d3, p: p3 });
      __publicField(this, _a, function* () {
        const { a: a3, b: b3, c: c3, d: d3 } = this.values;
        yield* [a3, b3, c3, d3];
      });
    }
    getPath(head = true) {
      const { a: a3, b: b3, c: c3, d: d3 } = this.values;
      if (Vec2d.Equals(a3, d3))
        return "";
      return `${head ? `M${a3.x.toFixed(2)},${a3.y.toFixed(2)}C` : ``}${b3.x.toFixed(2)},${b3.y.toFixed(
        2
      )} ${c3.x.toFixed(2)},${c3.y.toFixed(2)} ${d3.x.toFixed(2)},${d3.y.toFixed(2)}`;
    }
    getPoint(t4) {
      const { a: a3, b: b3, c: c3, d: d3 } = this.values;
      return new Vec2d(
        (1 - t4) * (1 - t4) * (1 - t4) * a3.x + 3 * ((1 - t4) * (1 - t4)) * t4 * b3.x + 3 * (1 - t4) * (t4 * t4) * c3.x + t4 * t4 * t4 * d3.x,
        (1 - t4) * (1 - t4) * (1 - t4) * a3.y + 3 * ((1 - t4) * (1 - t4)) * t4 * b3.y + 3 * (1 - t4) * (t4 * t4) * c3.y + t4 * t4 * t4 * d3.y
      );
    }
    getX(t4) {
      const { a: a3, b: b3, c: c3, d: d3 } = this.values;
      return (1 - t4) * (1 - t4) * (1 - t4) * a3.x + 3 * ((1 - t4) * (1 - t4)) * t4 * b3.x + 3 * (1 - t4) * (t4 * t4) * c3.x + t4 * t4 * t4 * d3.x;
    }
    getY(t4) {
      const { a: a3, b: b3, c: c3, d: d3 } = this.values;
      return (1 - t4) * (1 - t4) * (1 - t4) * a3.y + 3 * ((1 - t4) * (1 - t4)) * t4 * b3.y + 3 * (1 - t4) * (t4 * t4) * c3.y + t4 * t4 * t4 * d3.y;
    }
  };
  _a = Symbol.iterator;

  // ../../../packages/primitives/src/lib/BaseSpline2d.ts
  var BaseSpline2d = class {
    constructor(points2, p3 = 50, k2 = 1) {
      this.points = points2;
      this.p = p3;
      this.k = k2;
      __publicField(this, "computed", {});
    }
    get length() {
      if (this.computed.length !== void 0) {
        return this.computed.length;
      }
      const { segments } = this;
      const result = segments.reduce((acc, curr) => acc + curr.length, 0);
      this.computed.length = result;
      return result;
    }
    get bounds() {
      if (this.computed.bounds !== void 0) {
        return this.computed.bounds;
      }
      const { segments } = this;
      const result = Box2d.Common(segments.map((segment) => segment.bounds));
      this.computed.bounds = result;
      return result;
    }
    get head() {
      const { points: points2 } = this;
      return points2[0];
    }
    get tail() {
      const { points: points2 } = this;
      return points2[points2.length - 1];
    }
    get path() {
      if (this.computed.path !== void 0) {
        return this.computed.path;
      }
      const result = this.segments.map((segment) => segment.path).filter((i3) => i3 !== void 0 && i3 !== null && i3 !== "").join(" ");
      this.computed.path = result;
      return result;
    }
    addPoint(point2) {
      const { points: points2, k: k2, p: p3 } = this;
      points2.push(point2);
      this.computed = {};
      this.getSegmentsFromPoints(this.points, p3, k2);
      return this;
    }
    removePoint(point2) {
      const { points: points2, k: k2, p: p3 } = this;
      const index2 = typeof point2 === "number" ? Math.floor(point2) : points2.indexOf(point2);
      if (index2 === -1)
        return this;
      points2.splice(index2, 1);
      this.computed = {};
      this.getSegmentsFromPoints(this.points, p3, k2);
      return this;
    }
    getPointAtLength(length) {
      const { segments } = this;
      let remaining = length;
      if (length <= 0)
        return segments[0].getPoint(0);
      if (length >= this.length)
        return segments[segments.length - 1].getPoint(1);
      for (let i3 = 0; i3 < segments.length; i3++) {
        const segment = segments[i3];
        const { length: segmentLength } = segment;
        if (remaining < segmentLength) {
          return segment.getPoint(remaining / segmentLength);
        }
        remaining -= segment.length;
      }
      return segments[segments.length - 1].getPoint(1);
    }
    getPoint(t4) {
      if (t4 <= 0)
        return this.segments[0].getPoint(0);
      if (t4 >= 1)
        return this.segments[this.segments.length - 1].getPoint(1);
      return this.getPointAtLength(t4 * this.length);
    }
    getNormal(t4) {
      const { length } = this;
      return this.getNormalAtLength(t4 * length);
    }
    getNormalAtLength(t4) {
      const { segments } = this;
      if (t4 < 0)
        return new Vec2d(0, 0);
      let remaining = t4;
      for (const segment of segments) {
        const segmentLength = segment.length;
        if (remaining <= segmentLength) {
          return segment.getNormal(remaining / segmentLength);
        }
        remaining -= segmentLength;
      }
      return new Vec2d(0, 0);
    }
    getClosestPointTo(point2) {
      const { head, segments } = this;
      let closestPoint = head;
      let closestDistance = Vec2d.Dist(point2, head);
      for (const segment of segments) {
        const p3 = segment.getClosestPointTo(point2);
        if (p3.distance < closestDistance) {
          closestDistance = p3.distance;
          closestPoint = p3.point;
        }
      }
      return { point: closestPoint, distance: closestDistance };
    }
  };

  // ../../../packages/primitives/src/lib/CubicSpline2d.ts
  var CubicSpline2d = class extends BaseSpline2d {
    constructor(points2, k2 = 1.2, p3 = 20) {
      super(points2, k2, p3);
      __publicField(this, "segments");
      this.segments = this.getSegmentsFromPoints(points2, k2, p3);
    }
    getSegmentsFromPoints(points2, k2 = 1.25, p3 = 20) {
      const len = points2.length;
      const last2 = len - 2;
      const results = [];
      for (let i3 = 0; i3 < len - 1; i3++) {
        const p0 = i3 === 0 ? points2[0] : points2[i3 - 1];
        const p1 = points2[i3];
        const p22 = points2[i3 + 1];
        const p32 = i3 === last2 ? p22 : points2[i3 + 2];
        results.push(
          new CubicSegment2d(
            p1,
            i3 === 0 ? p0 : new Vec2d(p1.x + (p22.x - p0.x) / 6 * k2, p1.y + (p22.y - p0.y) / 6 * k2),
            i3 === last2 ? p22 : new Vec2d(p22.x - (p32.x - p1.x) / 6 * k2, p22.y - (p32.y - p1.y) / 6 * k2),
            p22,
            p3
          )
        );
      }
      return results;
    }
    static FromPoints(points2) {
      return new CubicSpline2d(points2);
    }
  };

  // ../../../packages/primitives/src/lib/LineSegment2d.ts
  var LineSegment2d = class extends BaseSegment2d {
    constructor(a3, b3, p3 = 2) {
      super({ a: a3, b: b3, p: p3 });
      this.a = a3;
      this.b = b3;
      this.values.p = Math.max(10, Math.ceil(this.length / 20));
    }
    get length() {
      return Vec2d.Dist(this.a, this.b);
    }
    get tangent() {
      return Vec2d.Tan(this.a, this.b);
    }
    get angle() {
      return Vec2d.Angle(this.a, this.b);
    }
    get bounds() {
      return Box2d.FromPoints([this.a, this.b]);
    }
    getX(t4) {
      const { a: a3, b: b3 } = this.values;
      return a3.x + (b3.x - a3.x) * t4;
    }
    getY(t4) {
      const { a: a3, b: b3 } = this.values;
      return a3.y + (b3.y - a3.y) * t4;
    }
    getPoint(t4) {
      const { a: a3, b: b3 } = this.values;
      return Vec2d.Lrp(a3, b3, t4);
    }
    getPath(head = true) {
      const { a: a3, b: b3 } = this.values;
      if (Vec2d.Equals(a3, b3))
        return "";
      return head ? `M${a3.x},${a3.y}L${b3.x},${b3.y}` : `${b3.x},${b3.y}`;
    }
    getNormal() {
      const { a: a3, b: b3 } = this.values;
      return Vec2d.Sub(a3, b3).per().uni().toFixed();
    }
    /**
     * Get the closest point on the segment to an arbitrary point.
     *
     * @param point - The arbitrary point.
     * @public
     */
    getClosestPointTo(point2) {
      const { a: a3, b: b3 } = this.values;
      const closestPoint = Vec2d.NearestPointOnLineSegment(a3, b3, point2);
      const closestDistance = closestPoint.dist(point2);
      return { point: closestPoint, distance: closestDistance };
    }
    static Length(A2) {
      return Vec2d.Dist(A2.a, A2.b);
    }
    static Tangent(A2) {
      return Vec2d.Tan(A2.a, A2.b);
    }
    static Angle(A2) {
      return Vec2d.Angle(A2.a, A2.b);
    }
  };

  // ../../../packages/primitives/src/lib/Matrix2d.ts
  var _Matrix2d = class {
    constructor(a3, b3, c3, d3, e2, f3) {
      __publicField(this, "a", 1);
      __publicField(this, "b", 0);
      __publicField(this, "c", 0);
      __publicField(this, "d", 1);
      __publicField(this, "e", 0);
      __publicField(this, "f", 0);
      this.a = a3;
      this.b = b3;
      this.c = c3;
      this.d = d3;
      this.e = e2;
      this.f = f3;
    }
    equals(m3) {
      return this.a === m3.a && this.b === m3.b && this.c === m3.c && this.d === m3.d && this.e === m3.e && this.f === m3.f;
    }
    identity() {
      this.a = 1;
      this.b = 0;
      this.c = 0;
      this.d = 1;
      this.e = 0;
      this.f = 0;
      return this;
    }
    multiply(m3) {
      const m22 = m3;
      const { a: a3, b: b3, c: c3, d: d3, e: e2, f: f3 } = this;
      this.a = a3 * m22.a + c3 * m22.b;
      this.c = a3 * m22.c + c3 * m22.d;
      this.e = a3 * m22.e + c3 * m22.f + e2;
      this.b = b3 * m22.a + d3 * m22.b;
      this.d = b3 * m22.c + d3 * m22.d;
      this.f = b3 * m22.e + d3 * m22.f + f3;
      return this;
    }
    rotate(r3, cx, cy) {
      if (r3 === 0)
        return this;
      if (cx === void 0)
        return this.multiply(_Matrix2d.Rotate(r3));
      return this.translate(cx, cy).multiply(_Matrix2d.Rotate(r3)).translate(-cx, -cy);
    }
    translate(x3, y3) {
      return this.multiply(_Matrix2d.Translate(x3, y3));
    }
    scale(x3, y3) {
      return this.multiply(_Matrix2d.Scale(x3, y3));
    }
    invert() {
      const { a: a3, b: b3, c: c3, d: d3, e: e2, f: f3 } = this;
      const denom = a3 * d3 - b3 * c3;
      this.a = d3 / denom;
      this.b = b3 / -denom;
      this.c = c3 / -denom;
      this.d = a3 / denom;
      this.e = (d3 * e2 - c3 * f3) / -denom;
      this.f = (b3 * e2 - a3 * f3) / denom;
      return this;
    }
    applyToPoint(point2) {
      return _Matrix2d.applyToPoint(this, point2);
    }
    applyToPoints(points2) {
      return _Matrix2d.applyToPoints(this, points2);
    }
    decomposed() {
      return _Matrix2d.Decompose(this);
    }
    toCssString() {
      return _Matrix2d.toCssString(this);
    }
    setTo(model2) {
      Object.assign(this, model2);
      return this;
    }
    decompose() {
      return _Matrix2d.Decompose(this);
    }
    clone() {
      return new _Matrix2d(this.a, this.b, this.c, this.d, this.e, this.f);
    }
    /* --------------------- Static --------------------- */
    static Identity() {
      return new _Matrix2d(1, 0, 0, 1, 0, 0);
    }
    static Translate(x3, y3) {
      return new _Matrix2d(1, 0, 0, 1, x3, y3);
    }
    static Rotate(r3, cx, cy) {
      if (r3 === 0)
        return _Matrix2d.Identity();
      const cosAngle = Math.cos(r3);
      const sinAngle = Math.sin(r3);
      const rotationMatrix2d = new _Matrix2d(cosAngle, sinAngle, -sinAngle, cosAngle, 0, 0);
      if (cx === void 0)
        return rotationMatrix2d;
      return _Matrix2d.Compose(
        _Matrix2d.Translate(cx, cy),
        rotationMatrix2d,
        _Matrix2d.Translate(-cx, -cy)
      );
    }
    static Multiply(m1, m22) {
      return {
        a: m1.a * m22.a + m1.c * m22.b,
        c: m1.a * m22.c + m1.c * m22.d,
        e: m1.a * m22.e + m1.c * m22.f + m1.e,
        b: m1.b * m22.a + m1.d * m22.b,
        d: m1.b * m22.c + m1.d * m22.d,
        f: m1.b * m22.e + m1.d * m22.f + m1.f
      };
    }
    static Inverse(m3) {
      const denom = m3.a * m3.d - m3.b * m3.c;
      return {
        a: m3.d / denom,
        b: m3.b / -denom,
        c: m3.c / -denom,
        d: m3.a / denom,
        e: (m3.d * m3.e - m3.c * m3.f) / -denom,
        f: (m3.b * m3.e - m3.a * m3.f) / denom
      };
    }
    static Absolute(m3) {
      const denom = m3.a * m3.d - m3.b * m3.c;
      return {
        a: m3.d / denom,
        b: m3.b / -denom,
        c: m3.c / -denom,
        d: m3.a / denom,
        e: (m3.d * m3.e - m3.c * m3.f) / denom,
        f: (m3.b * m3.e - m3.a * m3.f) / -denom
      };
    }
    static Compose(...matrices) {
      const matrix = _Matrix2d.Identity();
      for (let i3 = 0, n3 = matrices.length; i3 < n3; i3++) {
        matrix.multiply(matrices[i3]);
      }
      return matrix;
    }
    static Decompose(m3) {
      let scaleX, scaleY, rotation;
      if (m3.a !== 0 || m3.c !== 0) {
        const hypotAc = Math.hypot(m3.a, m3.c);
        scaleX = hypotAc;
        scaleY = (m3.a * m3.d - m3.b * m3.c) / hypotAc;
        rotation = Math.acos(m3.a / hypotAc) * (m3.c > 0 ? -1 : 1);
      } else if (m3.b !== 0 || m3.d !== 0) {
        const hypotBd = Math.hypot(m3.b, m3.d);
        scaleX = (m3.a * m3.d - m3.b * m3.c) / hypotBd;
        scaleY = hypotBd;
        rotation = TAU + Math.acos(m3.b / hypotBd) * (m3.d > 0 ? -1 : 1);
      } else {
        scaleX = 0;
        scaleY = 0;
        rotation = 0;
      }
      return {
        x: m3.e,
        y: m3.f,
        scaleX,
        scaleY,
        rotation: clampRadians(rotation)
      };
    }
    static Smooth(m3, precision = 1e10) {
      m3.a = Math.round(m3.a * precision) / precision;
      m3.b = Math.round(m3.b * precision) / precision;
      m3.c = Math.round(m3.c * precision) / precision;
      m3.d = Math.round(m3.d * precision) / precision;
      m3.e = Math.round(m3.e * precision) / precision;
      m3.f = Math.round(m3.f * precision) / precision;
      return m3;
    }
    static toCssString(m3) {
      return `matrix(${toDomPrecision(m3.a)}, ${toDomPrecision(m3.b)}, ${toDomPrecision(
        m3.c
      )}, ${toDomPrecision(m3.d)}, ${toDomPrecision(m3.e)}, ${toDomPrecision(m3.f)})`;
    }
    static applyToPoint(m3, point2) {
      return new Vec2d(
        m3.a * point2.x + m3.c * point2.y + m3.e,
        m3.b * point2.x + m3.d * point2.y + m3.f,
        point2.z
      );
    }
    static applyToXY(m3, x3, y3) {
      return [m3.a * x3 + m3.c * y3 + m3.e, m3.b * x3 + m3.d * y3 + m3.f];
    }
    static applyToPoints(m3, points2) {
      return points2.map(
        (point2) => new Vec2d(m3.a * point2.x + m3.c * point2.y + m3.e, m3.b * point2.x + m3.d * point2.y + m3.f, point2.z)
      );
    }
    static applyToBounds(m3, box) {
      return new Box2d(m3.e + box.minX, m3.f + box.minY, box.width, box.height);
    }
    static From(m3) {
      return new _Matrix2d(m3.a, m3.b, m3.c, m3.d, m3.e, m3.f);
    }
  };
  var Matrix2d = _Matrix2d;
  __publicField(Matrix2d, "Scale", (x3, y3, cx, cy) => {
    const scaleMatrix2d = new _Matrix2d(x3, 0, 0, 0, y3, 0);
    if (cx === void 0)
      return scaleMatrix2d;
    return _Matrix2d.Compose(
      _Matrix2d.Translate(cx, cy),
      scaleMatrix2d,
      _Matrix2d.Translate(-cx, -cy)
    );
  });

  // ../../../packages/primitives/src/lib/Polyline2d.ts
  var Polyline2d = class extends BaseSpline2d {
    constructor(points2, k2 = 1.2, p3 = 20) {
      super(points2, k2, p3);
      __publicField(this, "segments");
      this.segments = this.getSegmentsFromPoints(points2, p3);
    }
    getSegmentsFromPoints(points2, p3 = 50) {
      const segments = [];
      for (let i3 = 0; i3 < points2.length - 1; i3++) {
        segments.push(new LineSegment2d(points2[i3], points2[i3 + 1], p3));
      }
      return segments;
    }
    static FromPoints(points2) {
      return new Polyline2d(points2);
    }
  };

  // ../../../packages/primitives/src/lib/freehand/getStrokeOutlinePoints.ts
  var { PI: PI3 } = Math;
  var FIXED_PI = PI3 + 1e-4;
  function getStrokeOutlinePoints(strokePoints, options = {}) {
    const { size = 16, smoothing = 0.5, start = {}, end = {}, last: isComplete = false } = options;
    const { cap: capStart = true } = start;
    const { cap: capEnd = true } = end;
    if (strokePoints.length === 0 || size <= 0) {
      return [];
    }
    const firstStrokePoint = strokePoints[0];
    const lastStrokePoint = strokePoints[strokePoints.length - 1];
    const totalLength = lastStrokePoint.runningLength;
    const taperStart = start.taper === false ? 0 : start.taper === true ? Math.max(size, totalLength) : start.taper;
    const taperEnd = end.taper === false ? 0 : end.taper === true ? Math.max(size, totalLength) : end.taper;
    const minDistance = Math.pow(size * smoothing, 2);
    const leftPts = [];
    const rightPts = [];
    let prevVector = strokePoints[0].vector;
    let pl = strokePoints[0].point;
    let pr = pl;
    let tl = pl;
    let tr = pr;
    let isPrevPointSharpCorner = false;
    let strokePoint;
    for (let i3 = 0; i3 < strokePoints.length; i3++) {
      strokePoint = strokePoints[i3];
      const { point: point2, vector } = strokePoints[i3];
      const prevDpr = strokePoint.vector.dpr(prevVector);
      const nextVector = (i3 < strokePoints.length - 1 ? strokePoints[i3 + 1] : strokePoints[i3]).vector;
      const nextDpr = i3 < strokePoints.length - 1 ? nextVector.dpr(strokePoint.vector) : 1;
      const isPointSharpCorner = prevDpr < 0 && !isPrevPointSharpCorner;
      const isNextPointSharpCorner = nextDpr !== null && nextDpr < 0.2;
      if (isPointSharpCorner || isNextPointSharpCorner) {
        if (nextDpr > -0.62 && totalLength - strokePoint.runningLength > strokePoint.radius) {
          const offset2 = prevVector.clone().mul(strokePoint.radius);
          const cpr = prevVector.clone().cpr(nextVector);
          if (cpr < 0) {
            tl = Vec2d.Add(point2, offset2);
            tr = Vec2d.Sub(point2, offset2);
          } else {
            tl = Vec2d.Sub(point2, offset2);
            tr = Vec2d.Add(point2, offset2);
          }
          leftPts.push(tl);
          rightPts.push(tr);
        } else {
          const offset2 = prevVector.clone().mul(strokePoint.radius).per();
          const start2 = Vec2d.Sub(strokePoint.input, offset2);
          for (let step = 1 / 13, t4 = 0; t4 < 1; t4 += step) {
            tl = Vec2d.RotWith(start2, strokePoint.input, FIXED_PI * t4);
            leftPts.push(tl);
            tr = Vec2d.RotWith(start2, strokePoint.input, FIXED_PI + FIXED_PI * -t4);
            rightPts.push(tr);
          }
        }
        pl = tl;
        pr = tr;
        if (isNextPointSharpCorner) {
          isPrevPointSharpCorner = true;
        }
        continue;
      }
      isPrevPointSharpCorner = false;
      if (strokePoint === firstStrokePoint || strokePoint === lastStrokePoint) {
        const offset2 = Vec2d.Per(vector).mul(strokePoint.radius);
        leftPts.push(Vec2d.Sub(point2, offset2));
        rightPts.push(Vec2d.Add(point2, offset2));
        continue;
      }
      const offset = Vec2d.Lrp(nextVector, vector, nextDpr).per().mul(strokePoint.radius);
      tl = Vec2d.Sub(point2, offset);
      if (i3 <= 1 || Vec2d.Dist2(pl, tl) > minDistance) {
        leftPts.push(tl);
        pl = tl;
      }
      tr = Vec2d.Add(point2, offset);
      if (i3 <= 1 || Vec2d.Dist2(pr, tr) > minDistance) {
        rightPts.push(tr);
        pr = tr;
      }
      prevVector = vector;
      continue;
    }
    const firstPoint = firstStrokePoint.point;
    const lastPoint = strokePoints.length > 1 ? strokePoints[strokePoints.length - 1].point : Vec2d.AddXY(firstStrokePoint.point, 1, 1);
    if (strokePoints.length === 1) {
      if (!(taperStart || taperEnd) || isComplete) {
        const start2 = Vec2d.Add(
          firstPoint,
          Vec2d.Sub(firstPoint, lastPoint).uni().per().mul(-firstStrokePoint.radius)
        );
        const dotPts = [];
        for (let step = 1 / 13, t4 = step; t4 <= 1; t4 += step) {
          dotPts.push(Vec2d.RotWith(start2, firstPoint, FIXED_PI * 2 * t4));
        }
        return dotPts;
      }
    }
    const startCap = [];
    if (taperStart || taperEnd && strokePoints.length === 1) {
    } else if (capStart) {
      for (let step = 1 / 8, t4 = step; t4 <= 1; t4 += step) {
        const pt = Vec2d.RotWith(rightPts[0], firstPoint, FIXED_PI * t4);
        startCap.push(pt);
      }
    } else {
      const cornersVector = Vec2d.Sub(leftPts[0], rightPts[0]);
      const offsetA = Vec2d.Mul(cornersVector, 0.5);
      const offsetB = Vec2d.Mul(cornersVector, 0.51);
      startCap.push(
        Vec2d.Sub(firstPoint, offsetA),
        Vec2d.Sub(firstPoint, offsetB),
        Vec2d.Add(firstPoint, offsetB),
        Vec2d.Add(firstPoint, offsetA)
      );
    }
    const endCap = [];
    const direction = lastStrokePoint.vector.clone().per().neg();
    if (taperEnd || taperStart && strokePoints.length === 1) {
      endCap.push(lastPoint);
    } else if (capEnd) {
      const start2 = Vec2d.Add(lastPoint, Vec2d.Mul(direction, lastStrokePoint.radius));
      for (let step = 1 / 29, t4 = step; t4 < 1; t4 += step) {
        endCap.push(Vec2d.RotWith(start2, lastPoint, FIXED_PI * 3 * t4));
      }
    } else {
      endCap.push(
        Vec2d.Add(lastPoint, Vec2d.Mul(direction, lastStrokePoint.radius)),
        Vec2d.Add(lastPoint, Vec2d.Mul(direction, lastStrokePoint.radius * 0.99)),
        Vec2d.Sub(lastPoint, Vec2d.Mul(direction, lastStrokePoint.radius * 0.99)),
        Vec2d.Sub(lastPoint, Vec2d.Mul(direction, lastStrokePoint.radius))
      );
    }
    return leftPts.concat(endCap, rightPts.reverse(), startCap);
  }

  // ../../../packages/primitives/src/lib/freehand/getStrokePoints.ts
  var MIN_START_PRESSURE = 0.025;
  var MIN_END_PRESSURE = 0.01;
  function getStrokePoints(rawInputPoints, options = {}) {
    var _a5;
    const { streamline = 0.5, size = 16, simulatePressure = false } = options;
    if (rawInputPoints.length === 0)
      return [];
    const t4 = 0.15 + (1 - streamline) * 0.85;
    let pts = rawInputPoints.map(Vec2d.From);
    let pointsRemovedFromNearEnd = 0;
    if (!simulatePressure) {
      let pt2 = pts[0];
      while (pt2) {
        if (pt2.z >= MIN_START_PRESSURE)
          break;
        pts.shift();
        pt2 = pts[0];
      }
    }
    if (!simulatePressure) {
      let pt2 = pts[pts.length - 1];
      while (pt2) {
        if (pt2.z >= MIN_END_PRESSURE)
          break;
        pts.pop();
        pt2 = pts[pts.length - 1];
      }
    }
    if (pts.length === 0)
      return [
        {
          point: Vec2d.From(rawInputPoints[0]),
          input: Vec2d.From(rawInputPoints[0]),
          pressure: simulatePressure ? 0.5 : 0.15,
          vector: new Vec2d(1, 1),
          distance: 0,
          runningLength: 0,
          radius: 1
        }
      ];
    let pt = pts[1];
    while (pt) {
      if (Vec2d.Dist(pt, pts[0]) > size / 3)
        break;
      pts[0].z = Math.max(pts[0].z, pt.z);
      pts.splice(1, 1);
      pt = pts[1];
    }
    const last2 = pts.pop();
    pt = pts[pts.length - 1];
    while (pt) {
      if (Vec2d.Dist(pt, last2) > size / 3)
        break;
      pts.pop();
      pt = pts[pts.length - 1];
      pointsRemovedFromNearEnd++;
    }
    pts.push(last2);
    const isComplete = options.last || !options.simulatePressure || pts.length > 1 && Vec2d.Dist(pts[pts.length - 1], pts[pts.length - 2]) < size || pointsRemovedFromNearEnd > 0;
    if (pts.length === 2 && options.simulatePressure) {
      const last3 = pts[1];
      pts = pts.slice(0, -1);
      for (let i3 = 1; i3 < 5; i3++) {
        const next = Vec2d.Lrp(pts[0], last3, i3 / 4);
        next.z = (pts[0].z + (last3.z - pts[0].z)) * i3 / 4;
        pts.push(next);
      }
    }
    const strokePoints = [
      {
        point: pts[0],
        input: pts[0],
        pressure: simulatePressure ? 0.5 : pts[0].z,
        vector: new Vec2d(1, 1),
        distance: 0,
        runningLength: 0,
        radius: 1
      }
    ];
    let totalLength = 0;
    let prev = strokePoints[0];
    let point2, distance;
    if (isComplete && streamline > 0) {
      pts.push(pts[pts.length - 1].clone());
    }
    for (let i3 = 1, n3 = pts.length; i3 < n3; i3++) {
      point2 = !t4 || options.last && i3 === n3 - 1 ? pts[i3].clone() : pts[i3].clone().lrp(prev.point, 1 - t4);
      if (prev.point.equals(point2))
        continue;
      distance = Vec2d.Dist(point2, prev.point);
      totalLength += distance;
      if (i3 < 4 && totalLength < size) {
        continue;
      }
      prev = {
        input: pts[i3],
        // The adjusted point
        point: point2,
        // The input pressure (or .5 if not specified)
        pressure: simulatePressure ? 0.5 : pts[i3].z,
        // The vector from the current point to the previous point
        vector: Vec2d.Sub(prev.point, point2).uni(),
        // The distance between the current point and the previous point
        distance,
        // The total distance so far
        runningLength: totalLength,
        // The stroke point's radius
        radius: 1
      };
      strokePoints.push(prev);
    }
    if ((_a5 = strokePoints[1]) == null ? void 0 : _a5.vector) {
      strokePoints[0].vector = strokePoints[1].vector.clone();
    }
    if (totalLength < 1) {
      const maxPressureAmongPoints = Math.max(0.5, ...strokePoints.map((s3) => s3.pressure));
      strokePoints.forEach((s3) => s3.pressure = maxPressureAmongPoints);
    }
    return strokePoints;
  }

  // ../../../packages/primitives/src/lib/freehand/setStrokePointRadii.ts
  var { min } = Math;
  var RATE_OF_PRESSURE_CHANGE = 0.275;
  function setStrokePointRadii(strokePoints, options) {
    const {
      size = 16,
      thinning = 0.5,
      simulatePressure = true,
      easing = (t4) => t4,
      start = {},
      end = {}
    } = options;
    const { easing: taperStartEase = EASINGS.easeOutQuad } = start;
    const { easing: taperEndEase = EASINGS.easeOutCubic } = end;
    const totalLength = strokePoints[strokePoints.length - 1].runningLength;
    let firstRadius;
    let prevPressure = strokePoints[0].pressure;
    let strokePoint;
    if (!simulatePressure && totalLength < size) {
      const max = strokePoints.reduce((max2, curr) => Math.max(max2, curr.pressure), 0.5);
      strokePoints.forEach((sp) => {
        sp.pressure = max;
        sp.radius = size * easing(0.5 - thinning * (0.5 - sp.pressure));
      });
      return strokePoints;
    } else {
      let p3;
      for (let i3 = 0, n3 = strokePoints.length; i3 < n3; i3++) {
        strokePoint = strokePoints[i3];
        if (strokePoint.runningLength > size * 5)
          break;
        const sp = min(1, strokePoint.distance / size);
        if (simulatePressure) {
          const rp = min(1, 1 - sp);
          p3 = min(1, prevPressure + (rp - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE));
        } else {
          p3 = min(1, prevPressure + (strokePoint.pressure - prevPressure) * 0.5);
        }
        prevPressure = prevPressure + (p3 - prevPressure) * 0.5;
      }
      for (let i3 = 0; i3 < strokePoints.length; i3++) {
        strokePoint = strokePoints[i3];
        if (thinning) {
          let { pressure } = strokePoint;
          const sp = min(1, strokePoint.distance / size);
          if (simulatePressure) {
            const rp = min(1, 1 - sp);
            pressure = min(1, prevPressure + (rp - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE));
          } else {
            pressure = min(
              1,
              prevPressure + (pressure - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE)
            );
          }
          strokePoint.radius = size * easing(0.5 - thinning * (0.5 - pressure));
          prevPressure = pressure;
        } else {
          strokePoint.radius = size / 2;
        }
        if (firstRadius === void 0) {
          firstRadius = strokePoint.radius;
        }
      }
    }
    const taperStart = start.taper === false ? 0 : start.taper === true ? Math.max(size, totalLength) : start.taper;
    const taperEnd = end.taper === false ? 0 : end.taper === true ? Math.max(size, totalLength) : end.taper;
    if (taperStart || taperEnd) {
      for (let i3 = 0; i3 < strokePoints.length; i3++) {
        strokePoint = strokePoints[i3];
        const { runningLength } = strokePoint;
        const ts = runningLength < taperStart ? taperStartEase(runningLength / taperStart) : 1;
        const te = totalLength - runningLength < taperEnd ? taperEndEase((totalLength - runningLength) / taperEnd) : 1;
        strokePoint.radius = Math.max(0.01, strokePoint.radius * Math.min(ts, te));
      }
    }
    return strokePoints;
  }

  // ../../../packages/primitives/src/lib/freehand/getStroke.ts
  function getStroke(points2, options = {}) {
    return getStrokeOutlinePoints(
      setStrokePointRadii(getStrokePoints(points2, options), options),
      options
    );
  }

  // ../../../packages/primitives/src/lib/intersect.ts
  function intersectLineSegmentLineSegment(a1, a22, b1, b22) {
    const ABx = a1.x - b1.x;
    const ABy = a1.y - b1.y;
    const BVx = b22.x - b1.x;
    const BVy = b22.y - b1.y;
    const AVx = a22.x - a1.x;
    const AVy = a22.y - a1.y;
    const ua_t = BVx * ABy - BVy * ABx;
    const ub_t = AVx * ABy - AVy * ABx;
    const u_b = BVy * AVx - BVx * AVy;
    if (ua_t === 0 || ub_t === 0)
      return null;
    if (u_b === 0)
      return null;
    if (u_b !== 0) {
      const ua = ua_t / u_b;
      const ub = ub_t / u_b;
      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
        return Vec2d.AddXY(a1, ua * AVx, ua * AVy);
      }
    }
    return null;
  }
  function intersectLineSegmentCircle(a1, a22, c3, r3) {
    const a3 = (a22.x - a1.x) * (a22.x - a1.x) + (a22.y - a1.y) * (a22.y - a1.y);
    const b3 = 2 * ((a22.x - a1.x) * (a1.x - c3.x) + (a22.y - a1.y) * (a1.y - c3.y));
    const cc = c3.x * c3.x + c3.y * c3.y + a1.x * a1.x + a1.y * a1.y - 2 * (c3.x * a1.x + c3.y * a1.y) - r3 * r3;
    const deter = b3 * b3 - 4 * a3 * cc;
    if (deter < 0)
      return null;
    if (deter === 0)
      return null;
    const e2 = Math.sqrt(deter);
    const u1 = (-b3 + e2) / (2 * a3);
    const u22 = (-b3 - e2) / (2 * a3);
    if ((u1 < 0 || u1 > 1) && (u22 < 0 || u22 > 1)) {
      return null;
    }
    const result = [];
    if (0 <= u1 && u1 <= 1)
      result.push(Vec2d.Lrp(a1, a22, u1));
    if (0 <= u22 && u22 <= 1)
      result.push(Vec2d.Lrp(a1, a22, u22));
    if (result.length === 0)
      return null;
    return result;
  }
  function intersectLineSegmentPolyline(a1, a22, points2) {
    const result = [];
    let segmentIntersection;
    for (let i3 = 0, n3 = points2.length - 1; i3 < n3; i3++) {
      segmentIntersection = intersectLineSegmentLineSegment(a1, a22, points2[i3], points2[i3 + 1]);
      if (segmentIntersection)
        result.push(segmentIntersection);
    }
    if (result.length === 0)
      return null;
    return result;
  }
  function intersectLineSegmentPolygon(a1, a22, points2) {
    const result = [];
    let segmentIntersection;
    for (let i3 = 1, n3 = points2.length; i3 < n3 + 1; i3++) {
      segmentIntersection = intersectLineSegmentLineSegment(
        a1,
        a22,
        points2[i3 - 1],
        points2[i3 % points2.length]
      );
      if (segmentIntersection)
        result.push(segmentIntersection);
    }
    if (result.length === 0)
      return null;
    return result;
  }
  function intersectCircleCircle(c1, r1, c22, r22) {
    let dx = c22.x - c1.x;
    let dy = c22.y - c1.y;
    const d3 = Math.sqrt(dx * dx + dy * dy), x3 = (d3 * d3 - r22 * r22 + r1 * r1) / (2 * d3), y3 = Math.sqrt(r1 * r1 - x3 * x3);
    dx /= d3;
    dy /= d3;
    return [
      new Vec2d(c1.x + dx * x3 - dy * y3, c1.y + dy * x3 + dx * y3),
      new Vec2d(c1.x + dx * x3 + dy * y3, c1.y + dy * x3 - dx * y3)
    ];
  }
  function intersectCirclePolygon(c3, r3, points2) {
    const result = [];
    let a3, b3, int;
    for (let i3 = 0, n3 = points2.length; i3 < n3; i3++) {
      a3 = points2[i3];
      b3 = points2[(i3 + 1) % points2.length];
      int = intersectLineSegmentCircle(a3, b3, c3, r3);
      if (int)
        result.push(...int);
    }
    if (result.length === 0)
      return null;
    return result;
  }
  function intersectCirclePolyline(c3, r3, points2) {
    const result = [];
    let a3, b3, int;
    for (let i3 = 1, n3 = points2.length; i3 < n3; i3++) {
      a3 = points2[i3 - 1];
      b3 = points2[i3];
      int = intersectLineSegmentCircle(a3, b3, c3, r3);
      if (int)
        result.push(...int);
    }
    if (result.length === 0)
      return null;
    return result;
  }
  function ccw(A2, B, C2) {
    return (C2.y - A2.y) * (B.x - A2.x) > (B.y - A2.y) * (C2.x - A2.x);
  }
  function linesIntersect(A2, B, C2, D3) {
    return ccw(A2, C2, D3) !== ccw(B, C2, D3) && ccw(A2, B, C2) !== ccw(A2, B, D3);
  }
  function intersectPolygonPolygon(polygonA, polygonB) {
    const result = [];
    let a3, b3, c3, d3;
    for (let i3 = 0, n3 = polygonA.length; i3 < n3; i3++) {
      a3 = polygonA[i3];
      if (pointInPolygon(a3, polygonB)) {
        result.push(a3);
      }
    }
    for (let i3 = 0, n3 = polygonB.length; i3 < n3; i3++) {
      a3 = polygonB[i3];
      if (pointInPolygon(a3, polygonA)) {
        result.push(a3);
      }
    }
    for (let i3 = 0, n3 = polygonA.length; i3 < n3; i3++) {
      a3 = polygonA[i3];
      b3 = polygonA[(i3 + 1) % polygonA.length];
      for (let j = 0, m3 = polygonB.length; j < m3; j++) {
        c3 = polygonB[j];
        d3 = polygonB[(j + 1) % polygonB.length];
        const intersection = intersectLineSegmentLineSegment(a3, b3, c3, d3);
        if (intersection !== null) {
          result.push(intersection);
        }
      }
    }
    if (result.length === 0)
      return null;
    return orderClockwise(result);
  }
  function orderClockwise(points2) {
    const C2 = Vec2d.Average(points2);
    return points2.sort((A2, B) => Vec2d.Angle(C2, A2) - Vec2d.Angle(C2, B));
  }
  function polygonsIntersect(a3, b3) {
    let a0, a1, b0, b1;
    for (let i3 = 0, n3 = a3.length; i3 < n3; i3++) {
      a0 = a3[i3];
      a1 = a3[(i3 + 1) % n3];
      for (let j = 0, m3 = b3.length; j < m3; j++) {
        b0 = b3[j];
        b1 = b3[(j + 1) % m3];
        if (linesIntersect(a0, a1, b0, b1))
          return true;
      }
    }
    return false;
  }

  // ../../../packages/primitives/src/lib/polygon-helpers.ts
  function precise(A2) {
    return `${toDomPrecision(A2.x)},${toDomPrecision(A2.y)} `;
  }
  function rng2(seed = "") {
    let x3 = 0;
    let y3 = 0;
    let z2 = 0;
    let w3 = 0;
    function next() {
      const t4 = x3 ^ x3 << 11;
      x3 = y3;
      y3 = z2;
      z2 = w3;
      w3 ^= (w3 >>> 19 ^ t4 ^ t4 >>> 8) >>> 0;
      return w3 / 4294967296 * 2;
    }
    for (let k2 = 0; k2 < seed.length + 64; k2++) {
      x3 ^= seed.charCodeAt(k2) | 0;
      next();
    }
    return next;
  }
  function getRoundedInkyPolygonPath(points2) {
    let polylineA = `M`;
    const len = points2.length;
    let p0;
    let p1;
    let p22;
    for (let i3 = 0, n3 = len; i3 < n3; i3 += 3) {
      p0 = points2[i3];
      p1 = points2[i3 + 1];
      p22 = points2[i3 + 2];
      polylineA += `${precise(p0)}L${precise(p1)}Q${precise(p22)}`;
    }
    polylineA += `${precise(points2[0])}`;
    return polylineA;
  }
  function getRoundedPolygonPoints(id, outline, offset, roundness, passes) {
    const results = [];
    const random = rng2(id);
    let p0 = outline[0];
    let p1;
    const len = outline.length;
    for (let i3 = 0, n3 = len * passes; i3 < n3; i3++) {
      p1 = Vec2d.AddXY(outline[(i3 + 1) % len], random() * offset, random() * offset);
      const delta = Vec2d.Sub(p1, p0);
      const distance = Vec2d.Len(delta);
      const vector = Vec2d.Div(delta, distance).mul(Math.min(distance / 4, roundness));
      results.push(Vec2d.Add(p0, vector), Vec2d.Add(p1, vector.neg()), p1);
      p0 = p1;
    }
    return results;
  }
  function getDrawLinePathData(id, outline, strokeWidth) {
    let innerPathData = `M${precise(outline[0])}L`;
    let outerPathData1 = `M${precise(outline[0])}L`;
    let outerPathData2 = `M${precise(outline[0])}L`;
    const offset = strokeWidth / 3;
    const roundness = strokeWidth * 2;
    const random = rng2(id);
    let p0 = outline[0];
    let p1;
    let s0 = outline[0];
    let s1;
    const len = outline.length;
    for (let i3 = 0, n3 = len - 1; i3 < n3; i3++) {
      p1 = Vec2d.AddXY(outline[i3 + 1], random() * offset, random() * offset);
      s1 = Vec2d.AddXY(outline[i3 + 1], random(), random() * offset);
      const delta = Vec2d.Sub(p1, p0);
      const distance = Vec2d.Len(delta);
      const vector = Vec2d.Div(delta, distance).mul(Math.min(distance / 4, roundness));
      const q0 = Vec2d.Add(p0, vector);
      const q1 = Vec2d.Add(p1, vector.neg());
      const sDelta = Vec2d.Sub(s1, s0);
      const sDistance = Vec2d.Len(sDelta);
      const sVector = Vec2d.Div(sDelta, sDistance).mul(Math.min(sDistance / 4, roundness));
      const sq0 = Vec2d.Add(s0, sVector);
      const sq1 = Vec2d.Add(s1, sVector.neg());
      if (i3 === n3 - 1) {
        innerPathData += `${precise(q0)} L ${precise(p1)}`;
        outerPathData1 += `${precise(q0)} L ${precise(p1)}`;
        outerPathData2 += `${precise(sq0)} L ${precise(s1)}`;
      } else {
        innerPathData += `${precise(q0)}L ${precise(q1)}Q ${precise(p1)}`;
        outerPathData1 += `${precise(q0)}L ${precise(q1)}Q ${precise(p1)}`;
        outerPathData2 += `${precise(sq0)}L ${precise(sq1)}Q ${precise(s1)}`;
        p0 = p1;
        s0 = s1;
      }
    }
    return [innerPathData, outerPathData1 + outerPathData2];
  }

  // ../../../packages/editor/src/lib/app/App.ts
  var import_eventemitter3 = __toESM(require_eventemitter3());

  // ../../../packages/editor/src/lib/app/shapeutils/TLArrowUtil/TLArrowUtil.tsx
  var React7 = __toESM(require_react());

  // ../../../packages/editor/src/lib/components/SVGContainer.tsx
  var import_jsx_runtime = __toESM(require_jsx_runtime());
  function SVGContainer(_a5) {
    var _b2 = _a5, { children, className = "" } = _b2, rest = __objRest(_b2, ["children", "className"]);
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)("svg", __spreadProps(__spreadValues({}, rest), { className: `tl-svg-container ${className}`, children }));
  }

  // ../../../packages/editor/src/lib/config/TLShapeDefinition.ts
  function defineShape({
    type,
    getShapeUtil,
    validator,
    migrations = { currentVersion: 0, firstVersion: 0, migrators: {} }
  }) {
    if (!validator && false) {
      console.warn(
        `No validator provided for shape type ${type}! Validators are highly recommended for use in production.`
      );
    }
    return {
      type,
      createShapeUtils: (app) => {
        const ShapeUtil = getShapeUtil();
        return new ShapeUtil(app, type);
      },
      is: (shape) => shape.type === type,
      validator,
      migrations
    };
  }

  // ../../../packages/editor/src/lib/constants.ts
  var MAX_SHAPES_PER_PAGE = 2e3;
  var MAX_PAGES = 40;
  var REMOVE_SYMBOL = Symbol("remove");
  var ANIMATION_MEDIUM_MS = 320;
  var ZOOMS = [0.1, 0.25, 0.5, 1, 2, 4, 8];
  var MIN_ZOOM = 0.1;
  var MAX_ZOOM = 8;
  var FOLLOW_CHASE_PROPORTION = 0.5;
  var FOLLOW_CHASE_PAN_SNAP = 0.1;
  var FOLLOW_CHASE_PAN_UNSNAP = 0.2;
  var FOLLOW_CHASE_ZOOM_SNAP = 5e-3;
  var FOLLOW_CHASE_ZOOM_UNSNAP = 0.05;
  var MAJOR_NUDGE_FACTOR = 10;
  var MINOR_NUDGE_FACTOR = 1;
  var MAX_ASSET_WIDTH = 1e3;
  var MAX_ASSET_HEIGHT = 1e3;
  var GRID_INCREMENT = 5;
  var MIN_CROP_SIZE = 8;
  var DOUBLE_CLICK_DURATION = 450;
  var MULTI_CLICK_DURATION = 200;
  var COARSE_DRAG_DISTANCE = 6;
  var DRAG_DISTANCE = 4;
  var SVG_PADDING = 32;
  var HASH_PATERN_ZOOM_NAMES = {};
  for (let zoom = 1; zoom <= Math.ceil(MAX_ZOOM); zoom++) {
    HASH_PATERN_ZOOM_NAMES[zoom + "_dark"] = `hash_pattern_zoom_${zoom}_dark`;
    HASH_PATERN_ZOOM_NAMES[zoom + "_light"] = `hash_pattern_zoom_${zoom}_light`;
  }
  var DEFAULT_ANIMATION_OPTIONS = {
    duration: 0,
    easing: EASINGS.easeInOutCubic
  };
  var HAND_TOOL_FRICTION = 0.09;
  var MIN_ARROW_LENGTH = 48;
  var BOUND_ARROW_OFFSET = 10;
  var WAY_TOO_BIG_ARROW_BEND_FACTOR = 10;
  var DEFAULT_BOOKMARK_WIDTH = 300;
  var DEFAULT_BOOKMARK_HEIGHT = 320;
  var ROTATING_SHADOWS = [
    {
      offsetX: 0,
      offsetY: 2,
      blur: 4,
      spread: 0,
      color: "#00000029"
    },
    {
      offsetX: 0,
      offsetY: 3,
      blur: 6,
      spread: 0,
      color: "#0000001f"
    }
  ];
  var GRID_STEPS = [
    { min: -1, mid: 0.15, step: 100 },
    { min: 0.05, mid: 0.375, step: 25 },
    { min: 0.15, mid: 1, step: 5 },
    { min: 0.7, mid: 2.5, step: 1 }
  ];
  var TEXT_PROPS = {
    lineHeight: 1.35,
    fontWeight: "normal",
    fontVariant: "normal",
    fontStyle: "normal",
    padding: "0px",
    maxWidth: "auto"
  };
  var FONT_SIZES = {
    s: 18,
    m: 24,
    l: 36,
    xl: 44
  };
  var LABEL_FONT_SIZES = {
    s: 18,
    m: 22,
    l: 26,
    xl: 32
  };
  var ARROW_LABEL_FONT_SIZES = {
    s: 18,
    m: 20,
    l: 24,
    xl: 28
  };
  var FONT_FAMILIES = {
    draw: "var(--tl-font-draw)",
    sans: "var(--tl-font-sans)",
    serif: "var(--tl-font-serif)",
    mono: "var(--tl-font-mono)"
  };
  var STYLES = {
    color: [
      { id: "black", type: "color", icon: "color" },
      { id: "grey", type: "color", icon: "color" },
      { id: "light-violet", type: "color", icon: "color" },
      { id: "violet", type: "color", icon: "color" },
      { id: "blue", type: "color", icon: "color" },
      { id: "light-blue", type: "color", icon: "color" },
      { id: "yellow", type: "color", icon: "color" },
      { id: "orange", type: "color", icon: "color" },
      { id: "green", type: "color", icon: "color" },
      { id: "light-green", type: "color", icon: "color" },
      { id: "light-red", type: "color", icon: "color" },
      { id: "red", type: "color", icon: "color" }
    ],
    fill: [
      { id: "none", type: "fill", icon: "fill-none" },
      { id: "semi", type: "fill", icon: "fill-semi" },
      { id: "solid", type: "fill", icon: "fill-solid" },
      { id: "pattern", type: "fill", icon: "fill-pattern" }
    ],
    dash: [
      { id: "draw", type: "dash", icon: "dash-draw" },
      { id: "dashed", type: "dash", icon: "dash-dashed" },
      { id: "dotted", type: "dash", icon: "dash-dotted" },
      { id: "solid", type: "dash", icon: "dash-solid" }
    ],
    size: [
      { id: "s", type: "size", icon: "size-small" },
      { id: "m", type: "size", icon: "size-medium" },
      { id: "l", type: "size", icon: "size-large" },
      { id: "xl", type: "size", icon: "size-extra-large" }
    ],
    opacity: [
      { id: "0.1", type: "opacity", icon: "color" },
      { id: "0.25", type: "opacity", icon: "color" },
      { id: "0.5", type: "opacity", icon: "color" },
      { id: "0.75", type: "opacity", icon: "color" },
      { id: "1", type: "opacity", icon: "color" }
    ],
    font: [
      { id: "draw", type: "font", icon: "font-draw" },
      { id: "sans", type: "font", icon: "font-sans" },
      { id: "serif", type: "font", icon: "font-serif" },
      { id: "mono", type: "font", icon: "font-mono" }
    ],
    align: [
      { id: "start", type: "align", icon: "text-align-left" },
      { id: "middle", type: "align", icon: "text-align-center" },
      { id: "end", type: "align", icon: "text-align-right" }
    ],
    geo: [
      { id: "rectangle", type: "geo", icon: "geo-rectangle" },
      { id: "ellipse", type: "geo", icon: "geo-ellipse" },
      { id: "triangle", type: "geo", icon: "geo-triangle" },
      { id: "diamond", type: "geo", icon: "geo-diamond" },
      { id: "pentagon", type: "geo", icon: "geo-pentagon" },
      { id: "hexagon", type: "geo", icon: "geo-hexagon" },
      { id: "octagon", type: "geo", icon: "geo-octagon" },
      { id: "star", type: "geo", icon: "geo-star" },
      { id: "rhombus", type: "geo", icon: "geo-rhombus" },
      { id: "rhombus-2", type: "geo", icon: "geo-rhombus-2" },
      { id: "oval", type: "geo", icon: "geo-oval" },
      { id: "trapezoid", type: "geo", icon: "geo-trapezoid" },
      { id: "arrow-right", type: "geo", icon: "geo-arrow-right" },
      { id: "arrow-left", type: "geo", icon: "geo-arrow-left" },
      { id: "arrow-up", type: "geo", icon: "geo-arrow-up" },
      { id: "arrow-down", type: "geo", icon: "geo-arrow-down" },
      { id: "x-box", type: "geo", icon: "geo-x-box" },
      { id: "check-box", type: "geo", icon: "geo-check-box" }
    ],
    arrowheadStart: [
      { id: "none", type: "arrowheadStart", icon: "arrowhead-none" },
      { id: "arrow", type: "arrowheadStart", icon: "arrowhead-arrow" },
      { id: "triangle", type: "arrowheadStart", icon: "arrowhead-triangle" },
      { id: "square", type: "arrowheadStart", icon: "arrowhead-square" },
      { id: "dot", type: "arrowheadStart", icon: "arrowhead-dot" },
      { id: "diamond", type: "arrowheadStart", icon: "arrowhead-diamond" },
      { id: "inverted", type: "arrowheadStart", icon: "arrowhead-triangle-inverted" },
      { id: "bar", type: "arrowheadStart", icon: "arrowhead-bar" }
    ],
    arrowheadEnd: [
      { id: "none", type: "arrowheadEnd", icon: "arrowhead-none" },
      { id: "arrow", type: "arrowheadEnd", icon: "arrowhead-arrow" },
      { id: "triangle", type: "arrowheadEnd", icon: "arrowhead-triangle" },
      { id: "square", type: "arrowheadEnd", icon: "arrowhead-square" },
      { id: "dot", type: "arrowheadEnd", icon: "arrowhead-dot" },
      { id: "diamond", type: "arrowheadEnd", icon: "arrowhead-diamond" },
      { id: "inverted", type: "arrowheadEnd", icon: "arrowhead-triangle-inverted" },
      { id: "bar", type: "arrowheadEnd", icon: "arrowhead-bar" }
    ],
    spline: [
      { id: "line", type: "spline", icon: "spline-line" },
      { id: "cubic", type: "spline", icon: "spline-cubic" }
    ]
  };
  var BLACKLISTED_PROPS = /* @__PURE__ */ new Set([
    "bend",
    "w",
    "h",
    "start",
    "end",
    "text",
    "name",
    "url",
    "growY"
  ]);

  // ../../../packages/editor/src/lib/app/shapeutils/shared/getPerfectDashProps.ts
  function getPerfectDashProps(totalLength, strokeWidth, opts = {}) {
    const {
      closed = false,
      snap = 1,
      start = "outset",
      end = "outset",
      lengthRatio = 2,
      style = "dashed"
    } = opts;
    let dashLength = 0;
    let dashCount = 0;
    let ratio = 1;
    let gapLength = 0;
    let strokeDashoffset = 0;
    switch (style) {
      case "dashed": {
        ratio = 1;
        dashLength = Math.min(strokeWidth * lengthRatio, totalLength / 4);
        break;
      }
      case "dotted": {
        ratio = 100;
        dashLength = strokeWidth / ratio;
        break;
      }
      default: {
        return {
          strokeDasharray: "none",
          strokeDashoffset: "none"
        };
      }
    }
    if (!closed) {
      if (start === "outset") {
        totalLength += dashLength / 2;
        strokeDashoffset += dashLength / 2;
      } else if (start === "skip") {
        totalLength -= dashLength;
        strokeDashoffset -= dashLength;
      }
      if (end === "outset") {
        totalLength += dashLength / 2;
      } else if (end === "skip") {
        totalLength -= dashLength;
      }
    }
    dashCount = Math.floor(totalLength / dashLength / (2 * ratio));
    dashCount -= dashCount % snap;
    if (dashCount < 3 && style === "dashed") {
      if (totalLength / strokeWidth < 5) {
        dashLength = totalLength;
        dashCount = 1;
        gapLength = 0;
      } else {
        dashLength = totalLength * 0.333;
        gapLength = totalLength * 0.333;
      }
    } else {
      dashCount = Math.max(dashCount, 3);
      dashLength = totalLength / dashCount / (2 * ratio);
      if (closed) {
        strokeDashoffset = dashLength / 2;
        gapLength = (totalLength - dashCount * dashLength) / dashCount;
      } else {
        gapLength = (totalLength - dashCount * dashLength) / Math.max(1, dashCount - 1);
      }
    }
    return {
      strokeDasharray: [dashLength, gapLength].join(" "),
      strokeDashoffset: strokeDashoffset.toString()
    };
  }

  // ../../../packages/editor/src/lib/utils/string.ts
  function defaultEmptyAs(str, dflt) {
    if (str.match(/^\s*$/)) {
      return dflt;
    }
    return str;
  }
  function correctSpacesToNbsp(input) {
    return input.replace(/\s/g, "\xA0");
  }

  // ../../../packages/editor/src/lib/app/shapeutils/shared/getTextSvgElement.ts
  function getTextSvgElement(app, opts) {
    const { padding = 0 } = opts;
    const textElm = document.createElementNS("http://www.w3.org/2000/svg", "text");
    textElm.setAttribute("font-size", opts.fontSize + "px");
    textElm.setAttribute("font-family", opts.fontFamily);
    textElm.setAttribute("font-style", opts.fontStyle);
    textElm.setAttribute("font-weight", opts.fontWeight);
    textElm.setAttribute("line-height", opts.lineHeight * opts.fontSize + "px");
    textElm.setAttribute("dominant-baseline", "mathematical");
    textElm.setAttribute("alignment-baseline", "mathematical");
    const lines = opts.lines.map((line) => line);
    const tspans = [];
    const innerHeight = lines.length * (opts.lineHeight * opts.fontSize);
    const offsetY = (Math.ceil(opts.height) - innerHeight) / 2;
    const offsetX = padding;
    for (let i3 = 0; i3 < lines.length; i3++) {
      const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      tspan.setAttribute("alignment-baseline", "mathematical");
      const cleanText = correctSpacesToNbsp(lines[i3]);
      tspan.textContent = cleanText;
      if (lines.length > 1 && i3 < lines.length - 1) {
        tspan.textContent += "\n";
      }
      tspan.setAttribute(
        "y",
        offsetY + opts.fontSize / 2 + opts.lineHeight * opts.fontSize * i3 + "px"
      );
      textElm.appendChild(tspan);
      tspans.push(tspan);
    }
    if (opts.stroke && opts.strokeWidth) {
      textElm.setAttribute("stroke", opts.stroke);
      textElm.setAttribute("stroke-width", opts.strokeWidth + "px");
    }
    if (opts.fill) {
      textElm.setAttribute("fill", opts.fill);
    }
    switch (opts.textAlign) {
      case "middle": {
        textElm.setAttribute("text-align", "center");
        textElm.setAttribute("text-anchor", "start");
        tspans.forEach((tspan, i3) => {
          const w3 = app.textMeasure.measureText(__spreadProps(__spreadValues({}, TEXT_PROPS), {
            text: lines[i3],
            fontFamily: opts.fontFamily,
            fontSize: opts.fontSize,
            width: "fit-content",
            padding: `${padding}px`
          })).w;
          tspan.setAttribute("x", offsetX + (opts.width - w3) / 2 + "");
        });
        break;
      }
      case "end": {
        textElm.setAttribute("text-align", "right");
        textElm.setAttribute("text-anchor", "start");
        tspans.forEach((tspan, i3) => {
          const w3 = app.textMeasure.measureText(__spreadProps(__spreadValues({}, TEXT_PROPS), {
            text: lines[i3],
            fontFamily: opts.fontFamily,
            fontSize: opts.fontSize,
            width: "fit-content",
            padding: `${padding}px`
          })).w;
          tspan.setAttribute("x", offsetX + opts.width - w3 + "");
        });
        break;
      }
      default: {
        textElm.setAttribute("text-align", "left");
        textElm.setAttribute("text-anchor", "start");
        tspans.forEach((tspan) => tspan.setAttribute("x", offsetX + ""));
      }
    }
    return textElm;
  }

  // ../../../packages/editor/src/lib/app/shapeutils/shared/ShapeFill.tsx
  var React3 = __toESM(require_react());

  // ../../../node_modules/signia-react/dist/esm/track.mjs
  var import_react2 = __toESM(require_react(), 1);

  // ../../../node_modules/signia-react/dist/esm/useStateTracking.mjs
  var import_react = __toESM(require_react(), 1);
  function useStateTracking(name, render) {
    const renderRef = import_react.default.useRef(render);
    renderRef.current = render;
    const [scheduler, subscribe, getSnapshot] = import_react.default.useMemo(() => {
      let scheduleUpdate = null;
      const subscribe2 = (cb) => {
        scheduleUpdate = cb;
        return () => {
          scheduleUpdate = null;
        };
      };
      const scheduler2 = new EffectScheduler(
        `useStateTracking(${name})`,
        // this is what `scheduler.execute()` will call
        () => {
          var _a5;
          return (_a5 = renderRef.current) == null ? void 0 : _a5.call(renderRef);
        },
        // this is what will be invoked when signia detects a change in an upstream reactive value
        {
          scheduleEffect() {
            scheduleUpdate == null ? void 0 : scheduleUpdate();
          }
        }
      );
      const getSnapshot2 = () => scheduler2.scheduleCount;
      return [scheduler2, subscribe2, getSnapshot2];
    }, [name]);
    import_react.default.useSyncExternalStore(subscribe, getSnapshot, getSnapshot);
    import_react.default.useEffect(() => {
      scheduler.attach();
      scheduler.maybeScheduleEffect();
      return () => {
        scheduler.detach();
      };
    }, [scheduler]);
    return scheduler.execute();
  }

  // ../../../node_modules/signia-react/dist/esm/track.mjs
  var ProxyHandlers = {
    /**
     * This is a function call trap for functional components. When this is called, we know it means
     * React did run 'Component()', that means we can use any hooks here to setup our effect and
     * store.
     *
     * With the native Proxy, all other calls such as access/setting to/of properties will be
     * forwarded to the target Component, so we don't need to copy the Component's own or inherited
     * properties.
     *
     * @see https://github.com/facebook/react/blob/2d80a0cd690bb5650b6c8a6c079a87b5dc42bd15/packages/react-reconciler/src/ReactFiberHooks.old.js#L460
     */
    apply(Component3, thisArg, argumentsList) {
      var _a5, _b2;
      return useStateTracking(
        (_b2 = (_a5 = Component3.displayName) != null ? _a5 : Component3.name) != null ? _b2 : "tracked(???)",
        () => Component3.apply(thisArg, argumentsList)
      );
    }
  };
  var ReactMemoSymbol = Symbol.for("react.memo");
  var ReactForwardRefSymbol = Symbol.for("react.forward_ref");
  function track(baseComponent) {
    let compare = null;
    const $$typeof = baseComponent["$$typeof"];
    if ($$typeof === ReactMemoSymbol) {
      baseComponent = baseComponent.type;
      compare = baseComponent.compare;
    }
    if ($$typeof === ReactForwardRefSymbol) {
      return (0, import_react2.memo)((0, import_react2.forwardRef)(new Proxy(baseComponent.render, ProxyHandlers)));
    }
    return (0, import_react2.memo)(new Proxy(baseComponent, ProxyHandlers), compare);
  }

  // ../../../node_modules/signia-react/dist/esm/useAtom.mjs
  var import_react3 = __toESM(require_react(), 1);
  function useAtom(name, valueOrInitialiser, options) {
    return (0, import_react3.useMemo)(() => {
      const initialValue = typeof valueOrInitialiser === "function" ? valueOrInitialiser() : valueOrInitialiser;
      return atom(`useAtom(${name})`, initialValue, options);
    }, []);
  }

  // ../../../node_modules/signia-react/dist/esm/useComputed.mjs
  var import_react4 = __toESM(require_react(), 1);
  function useComputed() {
    const name = arguments[0];
    const compute = arguments[1];
    const opts = arguments.length === 3 ? void 0 : arguments[2];
    const deps = arguments.length === 3 ? arguments[2] : arguments[3];
    return (0, import_react4.useMemo)(() => computed(`useComputed(${name})`, compute, opts), deps);
  }

  // ../../../node_modules/signia-react/dist/esm/useValue.mjs
  var import_react5 = __toESM(require_react(), 1);
  function useValue() {
    const args = arguments;
    const deps = args.length === 3 ? args[2] : [args[0]];
    const name = args.length === 3 ? args[0] : `useValue(${args[0].name})`;
    const isInRender = (0, import_react5.useRef)(true);
    isInRender.current = true;
    const $val = (0, import_react5.useMemo)(() => {
      if (args.length === 1) {
        return args[0];
      }
      return computed(name, () => {
        if (isInRender.current) {
          return args[1]();
        } else {
          try {
            return args[1]();
          } catch (e2) {
            return {};
          }
        }
      });
    }, deps);
    try {
      const { subscribe, getSnapshot } = (0, import_react5.useMemo)(() => {
        return {
          subscribe: (listen) => {
            return react(`useValue(${name})`, () => {
              $val.value;
              listen();
            });
          },
          getSnapshot: () => $val.value
        };
      }, [$val]);
      return (0, import_react5.useSyncExternalStore)(subscribe, getSnapshot, getSnapshot);
    } finally {
      isInRender.current = false;
    }
  }

  // ../../../node_modules/signia-react/dist/esm/wrapJsx.mjs
  var import_react6 = __toESM(require_react(), 1);
  var ReactMemoType = Symbol.for("react.memo");
  var ReactForwardRefType = Symbol.for("react.forward_ref");

  // ../../../packages/editor/src/lib/hooks/useApp.ts
  var import_react7 = __toESM(require_react());
  var AppContext = import_react7.default.createContext({});
  var useApp = () => {
    return import_react7.default.useContext(AppContext);
  };

  // ../../../packages/editor/src/lib/app/shapeutils/shared/ShapeFill.tsx
  var import_jsx_runtime2 = __toESM(require_jsx_runtime());
  var ShapeFill = React3.memo(function ShapeFill2({ d: d3, color, fill }) {
    switch (fill) {
      case "none": {
        return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { className: "tl-hitarea-stroke", fill: "none", d: d3 });
      }
      case "solid": {
        return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { className: "tl-hitarea-fill-solid", fill: `var(--palette-${color}-semi)`, d: d3 });
      }
      case "semi": {
        return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { className: "tl-hitarea-fill-solid", fill: `var(--palette-solid)`, d: d3 });
      }
      case "pattern": {
        return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(PatternFill, { color, fill, d: d3 });
      }
    }
  });
  var PatternFill = function PatternFill2({ d: d3, color }) {
    const app = useApp();
    const zoomLevel = useValue("zoomLevel", () => app.zoomLevel, [app]);
    const isDarkMode = useValue("isDarkMode", () => app.userDocumentSettings.isDarkMode, [app]);
    const intZoom = Math.ceil(zoomLevel);
    const teenyTiny = app.zoomLevel <= 0.18;
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsxs)(import_jsx_runtime2.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)("path", { className: "tl-hitarea-fill-solid", fill: `var(--palette-${color}-pattern)`, d: d3 }),
      /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(
        "path",
        {
          fill: teenyTiny ? `var(--palette-${color}-semi)` : `url(#${HASH_PATERN_ZOOM_NAMES[intZoom + (isDarkMode ? "_dark" : "_light")]})`,
          d: d3
        }
      )
    ] });
  };
  function getShapeFillSvg({
    d: d3,
    color,
    fill,
    colors
  }) {
    if (fill === "none") {
      return;
    }
    if (fill === "pattern") {
      const gEl = document.createElementNS("http://www.w3.org/2000/svg", "g");
      const path1El = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path1El.setAttribute("d", d3);
      path1El.setAttribute("fill", colors.pattern[color]);
      const path2El = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path2El.setAttribute("d", d3);
      path2El.setAttribute("fill", `url(#hash_pattern)`);
      gEl.appendChild(path1El);
      gEl.appendChild(path2El);
      return gEl;
    }
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", d3);
    switch (fill) {
      case "semi": {
        path.setAttribute("fill", colors.solid);
        break;
      }
      case "solid": {
        {
          path.setAttribute("fill", colors.semi[color]);
        }
        break;
      }
    }
    return path;
  }
  function getSvgWithShapeFill(foregroundPath, backgroundPath) {
    if (backgroundPath) {
      const g3 = document.createElementNS("http://www.w3.org/2000/svg", "g");
      g3.appendChild(backgroundPath);
      g3.appendChild(foregroundPath);
      return g3;
    } else {
      return foregroundPath;
    }
  }

  // ../../../packages/editor/src/lib/utils/WeakMapCache.ts
  var WeakMapCache = class {
    constructor() {
      __publicField(this, "items", /* @__PURE__ */ new WeakMap());
    }
    get(item, cb) {
      if (!this.items.has(item)) {
        this.items.set(item, cb(item));
      }
      return this.items.get(item);
    }
    access(item) {
      return this.items.get(item);
    }
    set(item, value) {
      this.items.set(item, value);
    }
    has(item) {
      return this.items.has(item);
    }
    invalidate(item) {
      this.items.delete(item);
    }
    bust() {
      this.items = /* @__PURE__ */ new WeakMap();
    }
  };

  // ../../../packages/editor/src/lib/app/shapeutils/TLShapeUtil.ts
  var points = new WeakMapCache();
  var transforms = new WeakMapCache();
  var TLShapeUtil = class {
    constructor(app, type) {
      this.app = app;
      this.type = type;
      /**
       * Whether the shape can be scrolled while editing.
       *
       * @public
       */
      __publicField(this, "canScroll", () => false);
      /**
       * Whether the shape can be bound to by an arrow.
       *
       * @public
       */
      __publicField(this, "canUnmount", () => true);
      /**
       * Whether the shape can be bound to by an arrow.
       *
       * @param _otherShape - The other shape attempting to bind to this shape.
       * @public
       */
      __publicField(this, "canBind", (_shape, _otherShape) => true);
      /**
       * Whether the shape can be double clicked to edit.
       *
       * @public
       */
      __publicField(this, "canEdit", () => false);
      /**
       * Whether the shape can be resized.
       *
       * @public
       */
      __publicField(this, "canResize", () => true);
      /**
       * Whether the shape can be cropped.
       *
       * @public
       */
      __publicField(this, "canCrop", () => false);
      /**
       * Bounds of the shape to edit.
       *
       * Note: this could be a text area within a shape for example arrow labels.
       *
       * @public
       */
      __publicField(this, "getEditingBounds", (shape) => {
        return this.bounds(shape);
      });
      /**
       * Whether the shape's outline is closed.
       *
       * @public
       */
      __publicField(this, "isClosed", () => true);
      /**
       * Whether the shape should hide its resize handles when selected.
       *
       * @public
       */
      __publicField(this, "hideResizeHandles", () => false);
      /**
       * Whether the shape should hide its resize handles when selected.
       *
       * @public
       */
      __publicField(this, "hideRotateHandle", () => false);
      /**
       * Whether the shape should hide its selection bounds background when selected.
       *
       * @public
       */
      __publicField(this, "hideSelectionBoundsBg", () => false);
      /**
       * Whether the shape should hide its selection bounds foreground when selected.
       *
       * @public
       */
      __publicField(this, "hideSelectionBoundsFg", () => false);
      /**
       * Whether the shape's aspect ratio is locked.
       *
       * @public
       */
      __publicField(this, "isAspectRatioLocked", () => false);
      //  Events
      /**
       * A callback called just before a shape is created. This method provides a last chance to modify
       * the created shape.
       *
       * @example
       *
       * ```ts
       * onBeforeCreate = (next) => {
       * 	return { ...next, x: next.x + 1 }
       * }
       * ```
       *
       * @param next - The next shape.
       * @returns The next shape or void.
       * @public
       */
      __publicField(this, "onBeforeCreate");
      /**
       * A callback called just before a shape is updated. This method provides a last chance to modify
       * the updated shape.
       *
       * @example
       *
       * ```ts
       * onBeforeUpdate = (prev, next) => {
       * 	if (prev.x === next.x) {
       * 		return { ...next, x: next.x + 1 }
       * 	}
       * }
       * ```
       *
       * @param prev - The previous shape.
       * @param next - The next shape.
       * @returns The next shape or void.
       * @public
       */
      __publicField(this, "onBeforeUpdate");
      /**
       * A callback called when some other shapes are dragged over this one.
       *
       * @example
       *
       * ```ts
       * onDragShapesOver = (shape, shapes) => {
       * 	return { shouldHint: true }
       * }
       * ```
       *
       * @param shape - The shape.
       * @param shapes - The shapes that are being dragged over this one.
       * @returns An object specifying whether the shape should hint that it can receive the dragged shapes.
       * @public
       */
      __publicField(this, "onDragShapesOver");
      /**
       * A callback called when some other shapes are dragged out of this one.
       *
       * @param shape - The shape.
       * @param shapes - The shapes that are being dragged out.
       * @public
       */
      __publicField(this, "onDragShapesOut");
      /**
       * A callback called when some other shapes are dropped over this one.
       *
       * @param shape - The shape.
       * @param shapes - The shapes that are being dropped over this one.
       * @public
       */
      __publicField(this, "onDropShapesOver");
      /**
       * A callback called when a shape starts being resized.
       *
       * @param shape - The shape.
       * @returns A change to apply to the shape, or void.
       * @public
       */
      __publicField(this, "onResizeStart");
      /**
       * A callback called when a shape changes from a resize.
       *
       * @param shape - The shape at the start of the resize.
       * @param info - Info about the resize.
       * @returns A change to apply to the shape, or void.
       * @public
       */
      __publicField(this, "onResize");
      /**
       * A callback called when a shape finishes resizing.
       *
       * @param initial - The shape at the start of the resize.
       * @param current - The current shape.
       * @returns A change to apply to the shape, or void.
       * @public
       */
      __publicField(this, "onResizeEnd");
      /**
       * A callback called when a shape starts being translated.
       *
       * @param shape - The shape.
       * @returns A change to apply to the shape, or void.
       * @public
       */
      __publicField(this, "onTranslateStart");
      /**
       * A callback called when a shape changes from a translation.
       *
       * @param initial - The shape at the start of the translation.
       * @param current - The current shape.
       * @returns A change to apply to the shape, or void.
       * @public
       */
      __publicField(this, "onTranslate");
      /**
       * A callback called when a shape finishes translating.
       *
       * @param initial - The shape at the start of the translation.
       * @param current - The current shape.
       * @returns A change to apply to the shape, or void.
       * @public
       */
      __publicField(this, "onTranslateEnd");
      /**
       * A callback called when a shape starts being rotated.
       *
       * @param shape - The shape.
       * @returns A change to apply to the shape, or void.
       * @public
       */
      __publicField(this, "onRotateStart");
      /**
       * A callback called when a shape changes from a rotation.
       *
       * @param initial - The shape at the start of the rotation.
       * @param current - The current shape.
       * @returns A change to apply to the shape, or void.
       * @public
       */
      __publicField(this, "onRotate");
      /**
       * A callback called when a shape finishes rotating.
       *
       * @param initial - The shape at the start of the rotation.
       * @param current - The current shape.
       * @returns A change to apply to the shape, or void.
       * @public
       */
      __publicField(this, "onRotateEnd");
      /**
       * A callback called when a shape's handle changes.
       *
       * @param shape - The shape.
       * @param info - An object containing the handle and whether the handle is 'precise' or not.
       * @returns A change to apply to the shape, or void.
       * @public
       */
      __publicField(this, "onHandleChange");
      /**
       * Not currently used.
       *
       * @internal
       */
      __publicField(this, "onBindingChange");
      /**
       * A callback called when a shape's children change.
       *
       * @param shape - The shape.
       * @returns An array of shape updates, or void.
       * @public
       */
      __publicField(this, "onChildrenChange");
      /**
       * A callback called when a shape's handle is double clicked.
       *
       * @param shape - The shape.
       * @param handle - The handle that is double-clicked.
       * @returns A change to apply to the shape, or void.
       * @public
       */
      __publicField(this, "onDoubleClickHandle");
      /**
       * A callback called when a shape's edge is double clicked.
       *
       * @param shape - The shape.
       * @returns A change to apply to the shape, or void.
       * @public
       */
      __publicField(this, "onDoubleClickEdge");
      /**
       * A callback called when a shape is double clicked.
       *
       * @param shape - The shape.
       * @returns A change to apply to the shape, or void.
       * @public
       */
      __publicField(this, "onDoubleClick");
      /**
       * A callback called when a shape is clicked.
       *
       * @param shape - The shape.
       * @returns A change to apply to the shape, or void.
       * @public
       */
      __publicField(this, "onClick");
      /**
       * A callback called when a shape finishes being editing.
       *
       * @param shape - The shape.
       * @public
       */
      __publicField(this, "onEditEnd");
    }
    /**
     * Check if a shape is of this type.
     *
     * @param shape - The shape to check.
     * @returns Whether the shape is of this type.
     * @public
     */
    is(shape) {
      return shape.type === this.type;
    }
    get handlesCache() {
      return this.app.store.createComputedCache("handles:" + this.type, (shape) => {
        return this.getHandles(shape);
      });
    }
    /**
     * Get the cached handles (this should not be overridden!)
     *
     * @param shape - The shape.
     * @public
     */
    handles(shape) {
      var _a5;
      if (!this.getHandles)
        return EMPTY_ARRAY;
      return (_a5 = this.handlesCache.get(shape.id)) != null ? _a5 : EMPTY_ARRAY;
    }
    get boundsCache() {
      return this.app.store.createComputedCache("bounds:" + this.type, (shape) => {
        return this.getBounds(shape);
      });
    }
    /**
     * Get the cached bounds for the shape.
     *
     * @param shape - The shape.
     * @public
     */
    bounds(shape) {
      var _a5;
      const result = (_a5 = this.boundsCache.get(shape.id)) != null ? _a5 : new Box2d();
      if (result.width === 0 || result.height === 0) {
        return new Box2d(result.x, result.y, Math.max(result.width, 1), Math.max(result.height, 1));
      }
      return result;
    }
    /**
     * Get the cached transform. Do not override this method!
     *
     * @param shape - The shape.
     * @public
     */
    transform(shape) {
      return transforms.get(
        shape,
        (shape2) => Matrix2d.Compose(Matrix2d.Translate(shape2.x, shape2.y), Matrix2d.Rotate(shape2.rotation))
      );
    }
    /**
     * Get the cached point. Do not override this method!
     *
     * @param shape - The shape.
     * @public
     */
    point(shape) {
      return points.get(shape, (shape2) => ({ x: shape2.x, y: shape2.y }));
    }
    get outlineCache() {
      return this.app.store.createComputedCache("outline:" + this.type, (shape) => {
        return this.getOutline(shape);
      });
    }
    /**
     * Get the shape's outline. Do not override this method!
     *
     * @param shape - The shape.
     * @public
     */
    outline(shape) {
      var _a5;
      return (_a5 = this.outlineCache.get(shape.id)) != null ? _a5 : EMPTY_ARRAY;
    }
    /**
     * Get the shape's snap points.
     *
     * @param shape - The shape.
     * @public
     */
    snapPoints(shape) {
      return this.bounds(shape).snapPoints;
    }
    /**
     * Get the shape's cached center.
     *
     * @param shape - The shape.
     * @public
     */
    center(shape) {
      return this.getCenter(shape);
    }
    /**
     * Get whether the shape can receive children of a given type.
     *
     * @param type - The shape type.
     * @public
     */
    canReceiveNewChildrenOfType(type) {
      return false;
    }
    /**
     * Get whether the shape can receive children of a given type.
     *
     * @param shape - The shape type.
     * @param shapes - The shapes that are being dropped.
     * @public
     */
    canDropShapes(shape, shapes) {
      return false;
    }
    /**
     * Get whether a point intersects the shape.
     *
     * @param shape - The shape.
     * @param point - The point to test.
     * @returns Whether the point intersects the shape.
     * @public
     */
    hitTestPoint(shape, point2) {
      return this.bounds(shape).containsPoint(point2);
    }
    /**
     * Get whether a point intersects the shape.
     *
     * @param shape - The shape.
     * @param A - The line segment's first point.
     * @param B - The line segment's second point.
     * @returns Whether the line segment intersects the shape.
     * @public
     */
    hitTestLineSegment(shape, A2, B) {
      const outline = this.outline(shape);
      for (let i3 = 0; i3 < outline.length; i3++) {
        const C2 = outline[i3];
        const D3 = outline[(i3 + 1) % outline.length];
        if (linesIntersect(A2, B, C2, D3))
          return true;
      }
      return false;
    }
    /** @internal */
    expandSelectionOutlinePx(shape) {
      return 0;
    }
  };
  __decorateClass([
    computed
  ], TLShapeUtil.prototype, "handlesCache", 1);
  __decorateClass([
    computed
  ], TLShapeUtil.prototype, "boundsCache", 1);
  __decorateClass([
    computed
  ], TLShapeUtil.prototype, "outlineCache", 1);

  // ../../../packages/editor/src/lib/app/shapeutils/TLArrowUtil/arrow/arrowheads.ts
  function getArrowPoints(info, side, strokeWidth) {
    const PT = side === "end" ? info.end.point : info.start.point;
    const PB = side === "end" ? info.start.point : info.end.point;
    const compareLength = info.isStraight ? Vec2d.Dist(PB, PT) : Math.abs(info.bodyArc.length);
    const length = Math.max(Math.min(compareLength / 5, strokeWidth * 3), strokeWidth);
    let P0;
    if (info.isStraight) {
      P0 = Vec2d.Nudge(PT, PB, length);
    } else {
      const ints = intersectCircleCircle(PT, length, info.handleArc.center, info.handleArc.radius);
      P0 = side === "end" ? info.handleArc.sweepFlag ? ints[0] : ints[1] : info.handleArc.sweepFlag ? ints[1] : ints[0];
    }
    return {
      point: PT,
      int: P0
    };
  }
  function getArrowhead({ point: point2, int }) {
    const PL = Vec2d.RotWith(int, point2, PI / 6);
    const PR = Vec2d.RotWith(int, point2, -PI / 6);
    return `M ${PL.x} ${PL.y} L ${point2.x} ${point2.y} L ${PR.x} ${PR.y}`;
  }
  function getTriangleHead({ point: point2, int }) {
    const PL = Vec2d.RotWith(int, point2, PI / 6);
    const PR = Vec2d.RotWith(int, point2, -PI / 6);
    return `M ${PL.x} ${PL.y} L ${point2.x} ${point2.y} L ${PR.x} ${PR.y} Z`;
  }
  function getInvertedTriangleHead({ point: point2, int }) {
    const d3 = Vec2d.Sub(int, point2).div(2);
    const PL = Vec2d.Add(point2, Vec2d.Rot(d3, TAU));
    const PR = Vec2d.Sub(point2, Vec2d.Rot(d3, TAU));
    return `M ${PL.x} ${PL.y} L ${int.x} ${int.y} L ${PR.x} ${PR.y} Z`;
  }
  function getDotHead({ point: point2, int }) {
    const A2 = Vec2d.Lrp(point2, int, 0.45);
    const r3 = Vec2d.Dist(A2, point2);
    return `M ${A2.x - r3},${A2.y}
  a ${r3},${r3} 0 1,0 ${r3 * 2},0
  a ${r3},${r3} 0 1,0 -${r3 * 2},0 `;
  }
  function getDiamondHead({ point: point2, int }) {
    const PB = Vec2d.Lrp(point2, int, 0.75);
    const PL = Vec2d.RotWith(PB, point2, PI / 4);
    const PR = Vec2d.RotWith(PB, point2, -PI / 4);
    const PQ = Vec2d.Lrp(PL, PR, 0.5);
    PQ.add(Vec2d.Sub(PQ, point2));
    return `M ${PQ.x} ${PQ.y} L ${PL.x} ${PL.y} ${point2.x} ${point2.y} L ${PR.x} ${PR.y} Z`;
  }
  function getSquareHead({ int, point: point2 }) {
    const PB = Vec2d.Lrp(point2, int, 0.85);
    const d3 = Vec2d.Sub(PB, point2).div(2);
    const PL1 = Vec2d.Add(point2, Vec2d.Rot(d3, TAU));
    const PR1 = Vec2d.Sub(point2, Vec2d.Rot(d3, TAU));
    const PL2 = Vec2d.Add(PB, Vec2d.Rot(d3, TAU));
    const PR2 = Vec2d.Sub(PB, Vec2d.Rot(d3, TAU));
    return `M ${PL1.x} ${PL1.y} L ${PL2.x} ${PL2.y} L ${PR2.x} ${PR2.y} L ${PR1.x} ${PR1.y} Z`;
  }
  function getBarHead({ int, point: point2 }) {
    const d3 = Vec2d.Sub(int, point2).div(2);
    const PL = Vec2d.Add(point2, Vec2d.Rot(d3, TAU));
    const PR = Vec2d.Sub(point2, Vec2d.Rot(d3, TAU));
    return `M ${PL.x} ${PL.y} L ${PR.x} ${PR.y}`;
  }
  function getArrowheadPathForType(info, side, strokeWidth) {
    const type = side === "end" ? info.end.arrowhead : info.start.arrowhead;
    if (type === "none")
      return;
    const points2 = getArrowPoints(info, side, strokeWidth);
    if (!points2)
      return;
    switch (type) {
      case "bar":
        return getBarHead(points2);
      case "square":
        return getSquareHead(points2);
      case "diamond":
        return getDiamondHead(points2);
      case "dot":
        return getDotHead(points2);
      case "inverted":
        return getInvertedTriangleHead(points2);
      case "arrow":
        return getArrowhead(points2);
      case "triangle":
        return getTriangleHead(points2);
    }
    return "";
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLArrowUtil/arrow/shared.ts
  function getIsArrowStraight(shape) {
    return Math.abs(shape.props.bend) < 8;
  }
  function getBoundShapeInfoForTerminal(app, terminal) {
    if (terminal.type === "point") {
      return;
    }
    const shape = app.getShapeById(terminal.boundShapeId);
    const util = app.getShapeUtil(shape);
    const transform = app.getPageTransform(shape);
    return {
      shape,
      util,
      transform,
      isExact: terminal.isExact,
      didIntersect: false
    };
  }
  function getArrowTerminalInArrowSpace(app, arrowPageTransform, terminal) {
    if (terminal.type === "point") {
      return Vec2d.From(terminal);
    }
    const boundShape = app.getShapeById(terminal.boundShapeId);
    if (!boundShape) {
      console.error("Expected a bound shape!");
      return new Vec2d(0, 0);
    } else {
      const { point: point2, size } = app.getBounds(boundShape);
      const shapePoint = Vec2d.Add(point2, Vec2d.MulV(terminal.normalizedAnchor, size));
      const pagePoint = Matrix2d.applyToPoint(app.getPageTransform(boundShape), shapePoint);
      const arrowPoint = Matrix2d.applyToPoint(Matrix2d.Inverse(arrowPageTransform), pagePoint);
      return arrowPoint;
    }
  }
  function getArrowTerminalsInArrowSpace(app, shape) {
    const arrowPageTransform = app.getPageTransform(shape);
    const start = getArrowTerminalInArrowSpace(app, arrowPageTransform, shape.props.start);
    const end = getArrowTerminalInArrowSpace(app, arrowPageTransform, shape.props.end);
    return { start, end };
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLArrowUtil/arrow/straight-arrow.ts
  function getStraightArrowInfo(app, shape) {
    const { start, end, arrowheadStart, arrowheadEnd } = shape.props;
    const terminalsInArrowSpace = getArrowTerminalsInArrowSpace(app, shape);
    const a3 = terminalsInArrowSpace.start.clone();
    const b3 = terminalsInArrowSpace.end.clone();
    const c3 = Vec2d.Med(a3, b3);
    const uAB = Vec2d.Sub(b3, a3).uni();
    const startShapeInfo = getBoundShapeInfoForTerminal(app, start);
    const endShapeInfo = getBoundShapeInfoForTerminal(app, end);
    const arrowPageTransform = app.getPageTransform(shape);
    updateArrowheadPointWithBoundShape(
      b3,
      // <-- will be mutated
      terminalsInArrowSpace.start,
      arrowPageTransform,
      endShapeInfo
    );
    updateArrowheadPointWithBoundShape(
      a3,
      // <-- will be mutated
      terminalsInArrowSpace.end,
      arrowPageTransform,
      startShapeInfo
    );
    let minDist = MIN_ARROW_LENGTH;
    const isSelfIntersection = startShapeInfo && endShapeInfo && startShapeInfo.shape === endShapeInfo.shape;
    if (startShapeInfo && endShapeInfo && !isSelfIntersection && !startShapeInfo.isExact && !endShapeInfo.isExact) {
      if (endShapeInfo.didIntersect && !startShapeInfo.didIntersect) {
        if (startShapeInfo.util.isClosed(startShapeInfo.shape)) {
          a3.setTo(Vec2d.Nudge(b3, a3, minDist));
        }
      } else if (!endShapeInfo.didIntersect) {
        if (endShapeInfo.util.isClosed(endShapeInfo.shape)) {
          b3.setTo(Vec2d.Nudge(a3, b3, minDist));
        }
      }
    }
    const u3 = Vec2d.Sub(b3, a3).uni();
    const didFlip = !Vec2d.Equals(u3, uAB);
    if (!isSelfIntersection) {
      if (startShapeInfo && arrowheadStart !== "none" && !startShapeInfo.isExact) {
        const offset = BOUND_ARROW_OFFSET + app.getStrokeWidth(shape.props.size) / 2 + ("size" in startShapeInfo.shape.props ? app.getStrokeWidth(startShapeInfo.shape.props.size) / 2 : 0);
        minDist -= offset;
        a3.nudge(b3, offset * (didFlip ? -1 : 1));
      }
      if (endShapeInfo && arrowheadEnd !== "none" && !endShapeInfo.isExact) {
        const offset = BOUND_ARROW_OFFSET + app.getStrokeWidth(shape.props.size) / 2 + ("size" in endShapeInfo.shape.props ? app.getStrokeWidth(endShapeInfo.shape.props.size) / 2 : 0);
        minDist -= offset;
        b3.nudge(a3, offset * (didFlip ? -1 : 1));
      }
    }
    if (startShapeInfo && endShapeInfo) {
      if (didFlip) {
        b3.setTo(Vec2d.Add(a3, u3.mul(-minDist)));
      } else if (Vec2d.Dist(a3, b3) < MIN_ARROW_LENGTH / 2) {
        b3.setTo(Vec2d.Add(a3, u3.mul(MIN_ARROW_LENGTH / 2)));
      }
    }
    if (didFlip) {
      c3.setTo(Vec2d.Med(terminalsInArrowSpace.start, terminalsInArrowSpace.end));
    } else {
      c3.setTo(Vec2d.Med(a3, b3));
    }
    const length = Vec2d.Dist(a3, b3);
    return {
      isStraight: true,
      start: {
        handle: terminalsInArrowSpace.start,
        point: a3,
        arrowhead: shape.props.arrowheadStart
      },
      end: {
        handle: terminalsInArrowSpace.end,
        point: b3,
        arrowhead: shape.props.arrowheadEnd
      },
      middle: c3,
      isValid: length > 0,
      length
    };
  }
  function updateArrowheadPointWithBoundShape(point2, opposite, arrowPageTransform, targetShapeInfo) {
    var _a5;
    if (targetShapeInfo === void 0) {
      return;
    }
    if (targetShapeInfo.isExact) {
      return;
    }
    const pageFrom = Matrix2d.applyToPoint(arrowPageTransform, opposite);
    const pageTo = Matrix2d.applyToPoint(arrowPageTransform, point2);
    const targetFrom = Matrix2d.applyToPoint(Matrix2d.Inverse(targetShapeInfo.transform), pageFrom);
    const targetTo = Matrix2d.applyToPoint(Matrix2d.Inverse(targetShapeInfo.transform), pageTo);
    const isClosed = targetShapeInfo.util.isClosed(targetShapeInfo.shape);
    const fn = isClosed ? intersectLineSegmentPolygon : intersectLineSegmentPolyline;
    const intersection = fn(targetFrom, targetTo, targetShapeInfo.util.outline(targetShapeInfo.shape));
    let targetInt;
    if (intersection !== null) {
      targetInt = (_a5 = intersection.sort((p1, p22) => Vec2d.Dist(p1, targetFrom) - Vec2d.Dist(p22, targetFrom))[0]) != null ? _a5 : isClosed ? void 0 : targetTo;
    }
    if (targetInt === void 0) {
      return;
    }
    const pageInt = Matrix2d.applyToPoint(targetShapeInfo.transform, targetInt);
    const arrowInt = Matrix2d.applyToPoint(Matrix2d.Inverse(arrowPageTransform), pageInt);
    point2.setTo(arrowInt);
    targetShapeInfo.didIntersect = true;
  }
  function getStraightArrowHandlePath(info) {
    return getArrowPath(info.start.handle, info.end.handle);
  }
  function getSolidStraightArrowPath(info) {
    return getArrowPath(info.start.point, info.end.point);
  }
  function getArrowPath(start, end) {
    return `M${start.x},${start.y}L${end.x},${end.y}`;
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLArrowUtil/arrow/curved-arrow.ts
  function getCurvedArrowInfo(app, shape, extraBend = 0) {
    var _a5, _b2;
    const { arrowheadEnd, arrowheadStart } = shape.props;
    const bend = shape.props.bend + extraBend;
    if (Math.abs(bend) > Math.abs(shape.props.bend * WAY_TOO_BIG_ARROW_BEND_FACTOR)) {
      return getStraightArrowInfo(app, shape);
    }
    const terminalsInArrowSpace = getArrowTerminalsInArrowSpace(app, shape);
    const med = Vec2d.Med(terminalsInArrowSpace.start, terminalsInArrowSpace.end);
    const u3 = Vec2d.Sub(terminalsInArrowSpace.end, terminalsInArrowSpace.start).uni();
    const middle = Vec2d.Add(med, u3.per().mul(-bend));
    const startShapeInfo = getBoundShapeInfoForTerminal(app, shape.props.start);
    const endShapeInfo = getBoundShapeInfoForTerminal(app, shape.props.end);
    const a3 = terminalsInArrowSpace.start.clone();
    const b3 = terminalsInArrowSpace.end.clone();
    const c3 = middle.clone();
    const handleArc = getArcInfo(a3, b3, c3);
    const arrowPageTransform = app.getPageTransform(shape);
    if (startShapeInfo && !startShapeInfo.isExact) {
      const startInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, a3);
      const endInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, b3);
      const centerInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, handleArc.center);
      const inverseTransform = Matrix2d.Inverse(startShapeInfo.transform);
      const startInStartShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, startInPageSpace);
      const endInStartShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, endInPageSpace);
      const centerInStartShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, centerInPageSpace);
      const isClosed = startShapeInfo.util.isClosed(startShapeInfo.shape);
      const fn = isClosed ? intersectCirclePolygon : intersectCirclePolyline;
      let point2;
      let intersections = fn(
        centerInStartShapeLocalSpace,
        handleArc.radius,
        startShapeInfo.util.outline(startShapeInfo.shape)
      );
      if (intersections) {
        intersections = intersections.filter(
          (pt) => +Vec2d.Clockwise(startInStartShapeLocalSpace, pt, endInStartShapeLocalSpace) === handleArc.sweepFlag
        );
        const angleToMiddle = Vec2d.Angle(handleArc.center, middle);
        const angleToStart = Vec2d.Angle(handleArc.center, terminalsInArrowSpace.start);
        const comparisonAngle = lerpAngles(angleToMiddle, angleToStart, 0.5);
        intersections.sort(
          (p0, p1) => Math.abs(shortAngleDist(comparisonAngle, centerInStartShapeLocalSpace.angle(p0))) - Math.abs(shortAngleDist(comparisonAngle, centerInStartShapeLocalSpace.angle(p1)))
        );
        point2 = (_a5 = intersections[0]) != null ? _a5 : isClosed ? void 0 : startInStartShapeLocalSpace;
      } else {
        point2 = isClosed ? void 0 : startInStartShapeLocalSpace;
      }
      if (point2) {
        a3.setTo(
          app.getPointInShapeSpace(shape, Matrix2d.applyToPoint(startShapeInfo.transform, point2))
        );
        startShapeInfo.didIntersect = true;
        if (arrowheadStart !== "none") {
          const offset = BOUND_ARROW_OFFSET + app.getStrokeWidth(shape.props.size) / 2 + ("size" in startShapeInfo.shape.props ? app.getStrokeWidth(startShapeInfo.shape.props.size) / 2 : 0);
          a3.setTo(
            getPointOnCircle(
              handleArc.center.x,
              handleArc.center.y,
              handleArc.radius,
              lerpAngles(
                Vec2d.Angle(handleArc.center, a3),
                Vec2d.Angle(handleArc.center, middle),
                offset / Math.abs(getArcLength(handleArc.center, handleArc.radius, a3, middle))
              )
            )
          );
        }
      }
    }
    if (endShapeInfo && !endShapeInfo.isExact) {
      const startInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, a3);
      const endInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, b3);
      const centerInPageSpace = Matrix2d.applyToPoint(arrowPageTransform, handleArc.center);
      const inverseTransform = Matrix2d.Inverse(endShapeInfo.transform);
      const startInEndShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, startInPageSpace);
      const endInEndShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, endInPageSpace);
      const centerInEndShapeLocalSpace = Matrix2d.applyToPoint(inverseTransform, centerInPageSpace);
      const isClosed = endShapeInfo.util.isClosed(endShapeInfo.shape);
      const fn = isClosed ? intersectCirclePolygon : intersectCirclePolyline;
      const angleToMiddle = Vec2d.Angle(handleArc.center, middle);
      const angleToEnd = Vec2d.Angle(handleArc.center, terminalsInArrowSpace.end);
      const comparisonAngle = lerpAngles(angleToMiddle, angleToEnd, 0.5);
      let point2;
      let intersections = fn(
        centerInEndShapeLocalSpace,
        handleArc.radius,
        endShapeInfo.util.outline(endShapeInfo.shape)
      );
      if (intersections) {
        intersections = intersections.filter(
          (pt) => +Vec2d.Clockwise(startInEndShapeLocalSpace, pt, endInEndShapeLocalSpace) === handleArc.sweepFlag
        );
        intersections.sort(
          (p0, p1) => Math.abs(shortAngleDist(comparisonAngle, centerInEndShapeLocalSpace.angle(p0))) - Math.abs(shortAngleDist(comparisonAngle, centerInEndShapeLocalSpace.angle(p1)))
        );
        point2 = (_b2 = intersections[0]) != null ? _b2 : isClosed ? void 0 : endInEndShapeLocalSpace;
      } else {
        point2 = isClosed ? void 0 : endInEndShapeLocalSpace;
      }
      if (point2) {
        b3.setTo(app.getPointInShapeSpace(shape, Matrix2d.applyToPoint(endShapeInfo.transform, point2)));
        endShapeInfo.didIntersect = true;
        if (arrowheadEnd !== "none") {
          let offset = BOUND_ARROW_OFFSET + app.getStrokeWidth(shape.props.size) / 2 + ("size" in endShapeInfo.shape.props ? app.getStrokeWidth(endShapeInfo.shape.props.size) / 2 : 0);
          if (Vec2d.Dist(a3, b3) < MIN_ARROW_LENGTH) {
            offset *= -2;
          }
          b3.setTo(
            getPointOnCircle(
              handleArc.center.x,
              handleArc.center.y,
              handleArc.radius,
              lerpAngles(
                Vec2d.Angle(handleArc.center, b3),
                Vec2d.Angle(handleArc.center, middle),
                offset / Math.abs(getArcLength(handleArc.center, handleArc.radius, b3, middle))
              )
            )
          );
        }
      }
    }
    const length = Math.abs(getArcLength(handleArc.center, handleArc.radius, a3, b3));
    if (length < MIN_ARROW_LENGTH / 2) {
      a3.setTo(terminalsInArrowSpace.start);
      b3.setTo(terminalsInArrowSpace.end);
    }
    if (startShapeInfo && endShapeInfo && startShapeInfo.shape !== endShapeInfo.shape && !startShapeInfo.isExact && !endShapeInfo.isExact) {
      const startAngle = Vec2d.Angle(handleArc.center, a3);
      const endAngle = Vec2d.Angle(handleArc.center, b3);
      const offset = handleArc.sweepFlag ? MIN_ARROW_LENGTH : -MIN_ARROW_LENGTH;
      const arcLength = getArcLength(handleArc.center, handleArc.radius, b3, a3);
      const {
        center: { x: x3, y: y3 },
        radius
      } = handleArc;
      if (startShapeInfo && !startShapeInfo.didIntersect) {
        a3.setTo(getPointOnCircle(x3, y3, radius, lerpAngles(startAngle, endAngle, offset / arcLength)));
      }
      if (endShapeInfo && !endShapeInfo.didIntersect) {
        b3.setTo(getPointOnCircle(x3, y3, radius, lerpAngles(startAngle, endAngle, -offset / arcLength)));
      }
    }
    let midAngle = lerpAngles(Vec2d.Angle(handleArc.center, a3), Vec2d.Angle(handleArc.center, b3), 0.5);
    let midPoint = getPointOnCircle(
      handleArc.center.x,
      handleArc.center.y,
      handleArc.radius,
      midAngle
    );
    if (+Vec2d.Clockwise(a3, midPoint, b3) !== handleArc.sweepFlag) {
      midAngle += PI;
      midPoint = getPointOnCircle(handleArc.center.x, handleArc.center.y, handleArc.radius, midAngle);
    }
    c3.setTo(midPoint);
    const bodyArc = getArcInfo(a3, b3, c3);
    return {
      isStraight: false,
      start: {
        point: a3,
        handle: terminalsInArrowSpace.start,
        arrowhead: shape.props.arrowheadStart
      },
      end: {
        point: b3,
        handle: terminalsInArrowSpace.end,
        arrowhead: shape.props.arrowheadEnd
      },
      middle: c3,
      handleArc,
      bodyArc,
      isValid: bodyArc.length !== 0 && isFinite(bodyArc.center.x) && isFinite(bodyArc.center.y)
    };
  }
  function getCurvedArrowHandlePath(info) {
    const {
      start,
      end,
      handleArc: { radius, largeArcFlag, sweepFlag }
    } = info;
    return `M${start.handle.x},${start.handle.y} A${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${end.handle.x},${end.handle.y}`;
  }
  function getSolidCurvedArrowPath(info) {
    const {
      start,
      end,
      bodyArc: { radius, largeArcFlag, sweepFlag }
    } = info;
    return `M${start.point.x},${start.point.y} A${radius} ${radius} 0 ${largeArcFlag} ${sweepFlag} ${end.point.x},${end.point.y}`;
  }
  function getArcInfo(a3, b3, c3) {
    const u3 = -2 * (a3.x * (b3.y - c3.y) - a3.y * (b3.x - c3.x) + b3.x * c3.y - c3.x * b3.y);
    const center = {
      x: ((a3.x * a3.x + a3.y * a3.y) * (c3.y - b3.y) + (b3.x * b3.x + b3.y * b3.y) * (a3.y - c3.y) + (c3.x * c3.x + c3.y * c3.y) * (b3.y - a3.y)) / u3,
      y: ((a3.x * a3.x + a3.y * a3.y) * (b3.x - c3.x) + (b3.x * b3.x + b3.y * b3.y) * (c3.x - a3.x) + (c3.x * c3.x + c3.y * c3.y) * (a3.x - b3.x)) / u3
    };
    const radius = Vec2d.Dist(center, a3);
    const sweepFlag = +Vec2d.Clockwise(a3, c3, b3);
    const ab = Math.hypot(a3.y - b3.y, a3.x - b3.x);
    const bc = Math.hypot(b3.y - c3.y, b3.x - c3.x);
    const ca = Math.hypot(c3.y - a3.y, c3.x - a3.x);
    const theta = Math.acos((bc * bc + ca * ca - ab * ab) / (2 * bc * ca)) * 2;
    const largeArcFlag = +(PI > theta);
    const size = (PI2 - theta) * (sweepFlag ? 1 : -1);
    const length = size * radius;
    return {
      center,
      radius,
      size,
      length,
      largeArcFlag,
      sweepFlag
    };
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLArrowUtil/components/ArrowTextLabel.tsx
  var React6 = __toESM(require_react());

  // ../../../packages/editor/src/lib/utils/dom.ts
  var import_react8 = __toESM(require_react());

  // ../../../packages/editor/src/lib/utils/debug-flags.ts
  var debugFlags = {
    preventDefaultLogging: createDebugValue("tldrawPreventDefaultLogging", false),
    pointerCaptureLogging: createDebugValue("tldrawPointerCaptureLogging", false),
    pointerCaptureTracking: createDebugValue("tldrawPointerCaptureTracking", false),
    pointerCaptureTrackingObject: createDebugValue(
      "tldrawPointerCaptureTrackingObject",
      // ideally we wouldn't store this mutable value in an atom but it's not
      // a big deal for debug values
      /* @__PURE__ */ new Map(),
      false
    ),
    elementRemovalLogging: createDebugValue("tldrawElementRemovalLogging", false),
    debugSvg: createDebugValue("tldrawDebugSvg", false),
    throwToBlob: createDebugValue("tldrawThrowToBlob", false),
    peopleMenu: createDebugValue("tldrawPeopleMenu", false),
    logMessages: createDebugValue("tldrawUiLog", []),
    resetConnectionEveryPing: createDebugValue("tldrawResetConnectionEveryPing", false),
    newLiveCollaborators: createDebugValue("tldrawNewLiveCollaborators", false)
  };
  debugFlags.logMessages.set([]);
  if (typeof window !== "undefined") {
    window.tldrawLog = (message) => {
      debugFlags.logMessages.set(debugFlags.logMessages.value.concat(message));
    };
  }
  if (typeof Element !== "undefined") {
    const nativeElementRemoveChild = Element.prototype.removeChild;
    react("element removal logging", () => {
      if (debugFlags.elementRemovalLogging.value) {
        Element.prototype.removeChild = function(child) {
          console.warn("[tldraw] removing child:", child);
          return nativeElementRemoveChild.call(this, child);
        };
      } else {
        Element.prototype.removeChild = nativeElementRemoveChild;
      }
    });
  }
  function createDebugValue(name, initialValue, shouldStore = true) {
    if (typeof window === "undefined") {
      return atom(`debug:${name}`, initialValue);
    }
    const storedValue = shouldStore ? getStoredInitialValue(name) : null;
    const value = atom(`debug:${name}`, storedValue != null ? storedValue : initialValue);
    if (shouldStore) {
      react(`debug:${name}`, () => {
        const currentValue = value.value;
        try {
          if (currentValue === initialValue) {
            window.sessionStorage.removeItem(`debug:${name}`);
          } else {
            window.sessionStorage.setItem(`debug:${name}`, JSON.stringify(currentValue));
          }
        } catch (e2) {
        }
      });
    }
    Object.defineProperty(window, name, {
      get() {
        return value.value;
      },
      set(newValue) {
        value.set(newValue);
      },
      configurable: true
    });
    return value;
  }
  function getStoredInitialValue(name) {
    var _a5;
    try {
      return JSON.parse((_a5 = window.sessionStorage.getItem(`debug:${name}`)) != null ? _a5 : "null");
    } catch (err) {
      return null;
    }
  }

  // ../../../packages/editor/src/lib/utils/dom.ts
  function loopToHtmlElement(elm) {
    if (elm instanceof HTMLElement)
      return elm;
    if (elm.parentElement)
      return loopToHtmlElement(elm.parentElement);
    else
      throw Error("Could not find a parent element of an HTML type!");
  }
  function preventDefault(event) {
    event.preventDefault();
    if (debugFlags.preventDefaultLogging.value) {
      console.warn("preventDefault called on event:", event);
    }
  }
  function setPointerCapture(element, event) {
    var _a5;
    element.setPointerCapture(event.pointerId);
    if (debugFlags.pointerCaptureTracking.value) {
      const trackingObj = debugFlags.pointerCaptureTrackingObject.value;
      trackingObj.set(element, ((_a5 = trackingObj.get(element)) != null ? _a5 : 0) + 1);
    }
    if (debugFlags.pointerCaptureLogging.value) {
      console.warn("setPointerCapture called on element:", element, event);
    }
  }
  function releasePointerCapture(element, event) {
    if (!element.hasPointerCapture(event.pointerId)) {
      return;
    }
    element.releasePointerCapture(event.pointerId);
    if (debugFlags.pointerCaptureTracking.value) {
      const trackingObj = debugFlags.pointerCaptureTrackingObject.value;
      if (trackingObj.get(element) === 1) {
        trackingObj.delete(element);
      } else if (trackingObj.has(element)) {
        trackingObj.set(element, trackingObj.get(element) - 1);
      } else {
        console.warn("Release without capture");
      }
    }
    if (debugFlags.pointerCaptureLogging.value) {
      console.warn("releasePointerCapture called on element:", element, event);
    }
  }
  function rotateBoxShadow(rotation, shadows) {
    const cssStrings = shadows.map((shadow) => {
      const { offsetX, offsetY, blur, spread, color } = shadow;
      const vec = new Vec2d(offsetX, offsetY);
      const { x: x3, y: y3 } = vec.rot(-rotation);
      return `${x3}px ${y3}px ${blur}px ${spread}px ${color}`;
    });
    return cssStrings.join(", ");
  }
  function usePrefersReducedMotion() {
    const [prefersReducedMotion, setPrefersReducedMotion] = (0, import_react8.useState)(false);
    (0, import_react8.useEffect)(() => {
      const mql = window.matchMedia("(prefers-reduced-motion: reduce)");
      const handler = () => {
        setPrefersReducedMotion(mql.matches);
      };
      handler();
      mql.addEventListener("change", handler);
      return () => mql.removeEventListener("change", handler);
    }, []);
    return prefersReducedMotion;
  }
  var truncateStringWithEllipsis = (str, maxLength) => {
    return str.length <= maxLength ? str : str.substring(0, maxLength - 3) + "...";
  };
  var stopEventPropagation = (e2) => e2.stopPropagation();

  // ../../../packages/editor/src/lib/app/shapeutils/TLTextUtil/TextHelpers.ts
  var INDENT = "  ";
  var _TextHelpers = class {
    static insertTextFirefox(field, text) {
      field.setRangeText(
        text,
        field.selectionStart || 0,
        field.selectionEnd || 0,
        "end"
        // Without this, the cursor is either at the beginning or text remains selected
      );
      field.dispatchEvent(
        new InputEvent("input", {
          data: text,
          inputType: "insertText",
          isComposing: false
          // TODO: fix @types/jsdom, this shouldn't be required
        })
      );
    }
    /**
     * Inserts text at the cursor’s position, replacing any selection, with **undo** support and by
     * firing the input event.
     */
    static insert(field, text) {
      const document2 = field.ownerDocument;
      const initialFocus = document2.activeElement;
      if (initialFocus !== field) {
        field.focus();
      }
      if (!document2.execCommand("insertText", false, text)) {
        _TextHelpers.insertTextFirefox(field, text);
      }
      if (initialFocus === document2.body) {
        field.blur();
      } else if (initialFocus instanceof HTMLElement && initialFocus !== field) {
        initialFocus.focus();
      }
    }
    /**
     * Replaces the entire content, equivalent to field.value = text but with **undo** support and by
     * firing the input event.
     */
    static set(field, text) {
      field.select();
      _TextHelpers.insert(field, text);
    }
    /** Get the selected text in a field or an empty string if nothing is selected. */
    static getSelection(field) {
      const { selectionStart, selectionEnd } = field;
      return field.value.slice(
        selectionStart ? selectionStart : void 0,
        selectionEnd ? selectionEnd : void 0
      );
    }
    /**
     * Adds the wrappingText before and after field’s selection (or cursor). If endWrappingText is
     * provided, it will be used instead of wrappingText at on the right.
     */
    static wrapSelection(field, wrap2, wrapEnd) {
      const { selectionStart, selectionEnd } = field;
      const selection = _TextHelpers.getSelection(field);
      _TextHelpers.insert(field, wrap2 + selection + (wrapEnd != null ? wrapEnd : wrap2));
      field.selectionStart = (selectionStart || 0) + wrap2.length;
      field.selectionEnd = (selectionEnd || 0) + wrap2.length;
    }
    /** Finds and replaces strings and regex in the field’s value. */
    static replace(field, searchValue, replacer) {
      let drift = 0;
      field.value.replace(searchValue, (...args) => {
        const matchStart = drift + args[args.length - 2];
        const matchLength = args[0].length;
        field.selectionStart = matchStart;
        field.selectionEnd = matchStart + matchLength;
        const replacement = typeof replacer === "string" ? replacer : replacer(...args);
        _TextHelpers.insert(field, replacement);
        field.selectionStart = matchStart;
        drift += replacement.length - matchLength;
        return replacement;
      });
    }
    static findLineEnd(value, currentEnd) {
      const lastLineStart = value.lastIndexOf("\n", currentEnd - 1) + 1;
      if (value.charAt(lastLineStart) !== "	") {
        return currentEnd;
      }
      return lastLineStart + 1;
    }
    static indent(element) {
      var _a5;
      const { selectionStart, selectionEnd, value } = element;
      const selectedContrast = value.slice(selectionStart, selectionEnd);
      const lineBreakCount = (_a5 = /\n/g.exec(selectedContrast)) == null ? void 0 : _a5.length;
      if (lineBreakCount && lineBreakCount > 0) {
        const firstLineStart = value.lastIndexOf("\n", selectionStart - 1) + 1;
        const newSelection = element.value.slice(firstLineStart, selectionEnd - 1);
        const indentedText = newSelection.replace(
          /^|\n/g,
          // Match all line starts
          `$&${INDENT}`
        );
        const replacementsCount = indentedText.length - newSelection.length;
        element.setSelectionRange(firstLineStart, selectionEnd - 1);
        _TextHelpers.insert(element, indentedText);
        element.setSelectionRange(selectionStart + 1, selectionEnd + replacementsCount);
      } else {
        _TextHelpers.insert(element, INDENT);
      }
    }
    // The first line should always be unindented
    // The last line should only be unindented if the selection includes any characters after \n
    static unindent(element) {
      const { selectionStart, selectionEnd, value } = element;
      const firstLineStart = value.lastIndexOf("\n", selectionStart - 1) + 1;
      const minimumSelectionEnd = _TextHelpers.findLineEnd(value, selectionEnd);
      const newSelection = element.value.slice(firstLineStart, minimumSelectionEnd);
      const indentedText = newSelection.replace(/(^|\n)(\t| {1,2})/g, "$1");
      const replacementsCount = newSelection.length - indentedText.length;
      element.setSelectionRange(firstLineStart, minimumSelectionEnd);
      _TextHelpers.insert(element, indentedText);
      const firstLineIndentation = /\t| {1,2}/.exec(value.slice(firstLineStart, selectionStart));
      const difference = firstLineIndentation ? firstLineIndentation[0].length : 0;
      const newSelectionStart = selectionStart - difference;
      element.setSelectionRange(
        selectionStart - difference,
        Math.max(newSelectionStart, selectionEnd - replacementsCount)
      );
    }
    static indentCE(element) {
      var _a5, _b2, _c;
      const selection = window.getSelection();
      const value = element.innerText;
      const selectionStart = (_a5 = getCaretIndex(element)) != null ? _a5 : 0;
      const selectionEnd = (_b2 = getCaretIndex(element)) != null ? _b2 : 0;
      const selectedContrast = value.slice(selectionStart, selectionEnd);
      const lineBreakCount = (_c = /\n/g.exec(selectedContrast)) == null ? void 0 : _c.length;
      if (lineBreakCount && lineBreakCount > 0) {
        const firstLineStart = value.lastIndexOf("\n", selectionStart - 1) + 1;
        const newSelection = value.slice(firstLineStart, selectionEnd - 1);
        const indentedText = newSelection.replace(
          /^|\n/g,
          // Match all line starts
          `$&${INDENT}`
        );
        const replacementsCount = indentedText.length - newSelection.length;
        if (selection) {
          selection.setBaseAndExtent(
            element,
            selectionStart + 1,
            element,
            selectionEnd + replacementsCount
          );
        }
      } else {
        const selection2 = window.getSelection();
        element.innerText = value.slice(0, selectionStart) + INDENT + value.slice(selectionStart);
        selection2 == null ? void 0 : selection2.setBaseAndExtent(element, selectionStart + 1, element, selectionStart + 2);
      }
    }
    static unindentCE(element) {
      var _a5, _b2;
      const selection = window.getSelection();
      const value = element.innerText;
      const selectionStart = (_a5 = getCaretIndex(element)) != null ? _a5 : 0;
      const selectionEnd = (_b2 = getCaretIndex(element)) != null ? _b2 : 0;
      const firstLineStart = value.lastIndexOf("\n", selectionStart - 1) + 1;
      const minimumSelectionEnd = _TextHelpers.findLineEnd(value, selectionEnd);
      const newSelection = value.slice(firstLineStart, minimumSelectionEnd);
      const indentedText = newSelection.replace(/(^|\n)(\t| {1,2})/g, "$1");
      const replacementsCount = newSelection.length - indentedText.length;
      if (selection) {
        selection.setBaseAndExtent(element, firstLineStart, element, minimumSelectionEnd);
        const firstLineIndentation = /\t| {1,2}/.exec(value.slice(firstLineStart, selectionStart));
        const difference = firstLineIndentation ? firstLineIndentation[0].length : 0;
        const newSelectionStart = selectionStart - difference;
        selection.setBaseAndExtent(
          element,
          selectionStart - difference,
          element,
          Math.max(newSelectionStart, selectionEnd - replacementsCount)
        );
      }
    }
    static normalizeText(text) {
      return text.replace(_TextHelpers.fixNewLines, "\n");
    }
    static normalizeTextForDom(text) {
      return text.replace(_TextHelpers.fixNewLines, "\n").split("\n").map((x3) => x3 || " ").join("\n");
    }
  };
  var TextHelpers = _TextHelpers;
  __publicField(TextHelpers, "fixNewLines", /\r?\n|\r/g);
  function getCaretIndex(element) {
    if (typeof window.getSelection === "undefined")
      return;
    const selection = window.getSelection();
    if (!selection)
      return;
    let position = 0;
    if (selection.rangeCount !== 0) {
      const range = selection.getRangeAt(0);
      const preCaretRange = range.cloneRange();
      preCaretRange.selectNodeContents(element);
      preCaretRange.setEnd(range.endContainer, range.endOffset);
      position = preCaretRange.toString().length;
    }
    return position;
  }

  // ../../../packages/editor/src/lib/app/shapeutils/shared/useEditableText.ts
  var import_react9 = __toESM(require_react());
  function useEditableText(id, type, text) {
    const app = useApp();
    const rInput = (0, import_react9.useRef)(null);
    const isEditing = useValue("isEditing", () => app.pageState.editingId === id, [app, id]);
    const rSkipSelectOnFocus = (0, import_react9.useRef)(false);
    const rSelectionRanges = (0, import_react9.useRef)();
    const isEditableFromHover = useValue(
      "is editable hovering",
      () => {
        if (type === "text" && app.isIn("text") && app.hoveredId === id) {
          return true;
        }
        if (app.isIn("select.editing_shape")) {
          const { editingShape } = app;
          if (!editingShape)
            return false;
          return (
            // The shape must be hovered
            app.hoveredId === id && // the editing shape must be the same type as this shape
            editingShape.type === type && // and this shape must be capable of being editing in its current form
            app.getShapeUtil(editingShape).canEdit(editingShape)
          );
        }
        return false;
      },
      [type, id]
    );
    const handleFocus = (0, import_react9.useCallback)(() => {
      if (isEditableFromHover)
        return;
      requestAnimationFrame(() => {
        const elm = rInput.current;
        if (!elm)
          return;
        const shape = app.getShapeById(id);
        if (shape) {
          elm.value = shape.props.text;
          if (elm.value.length && !rSkipSelectOnFocus.current) {
            elm.select();
          }
          rSkipSelectOnFocus.current = false;
        }
      });
    }, [app, id, isEditableFromHover]);
    const handleBlur = (0, import_react9.useCallback)(() => {
      const ranges = rSelectionRanges.current;
      requestAnimationFrame(() => {
        var _a5;
        const elm = rInput.current;
        if (app.isIn("select.editing_shape") && elm) {
          if (ranges) {
            if (!ranges.length) {
              elm.focus();
            } else {
              rSkipSelectOnFocus.current = true;
              elm.focus();
              const selection = window.getSelection();
              if (selection) {
                ranges.forEach((range) => selection.addRange(range));
              }
            }
          } else {
            elm.focus();
          }
        } else {
          (_a5 = window.getSelection()) == null ? void 0 : _a5.removeAllRanges();
          app.complete();
        }
      });
    }, [app]);
    const handleKeyDown = (0, import_react9.useCallback)(
      (e2) => {
        if (e2.ctrlKey || e2.metaKey)
          stopEventPropagation(e2);
        switch (e2.key) {
          case "Enter": {
            if (e2.ctrlKey || e2.metaKey) {
              app.complete();
            }
            break;
          }
          case "Tab": {
            preventDefault(e2);
            if (e2.shiftKey) {
              TextHelpers.unindent(e2.currentTarget);
            } else {
              TextHelpers.indent(e2.currentTarget);
            }
            break;
          }
        }
      },
      [app]
    );
    const handleChange = (0, import_react9.useCallback)(
      (e2) => {
        let text2 = TextHelpers.normalizeText(e2.currentTarget.value);
        const untabbedText = text2.replace(/\t/g, INDENT);
        if (untabbedText !== text2) {
          const selectionStart = e2.currentTarget.selectionStart;
          e2.currentTarget.value = untabbedText;
          e2.currentTarget.selectionStart = selectionStart + (untabbedText.length - text2.length);
          e2.currentTarget.selectionEnd = selectionStart + (untabbedText.length - text2.length);
          text2 = untabbedText;
        }
        app.updateShapes([{ id, type, props: { text: text2 } }]);
      },
      [app, id, type]
    );
    const isEmpty = text.trim().length === 0;
    (0, import_react9.useEffect)(() => {
      const elm = rInput.current;
      if (elm) {
        let updateSelection2 = function() {
          var _a5, _b2;
          const selection = (_a5 = window.getSelection) == null ? void 0 : _a5.call(window);
          if (selection && selection.type !== "None") {
            const ranges = [];
            if (selection) {
              for (let i3 = 0; i3 < selection.rangeCount; i3++) {
                ranges.push((_b2 = selection.getRangeAt) == null ? void 0 : _b2.call(selection, i3));
              }
            }
            rSelectionRanges.current = ranges;
          }
        };
        var updateSelection = updateSelection2;
        document.addEventListener("selectionchange", updateSelection2);
        return () => {
          document.removeEventListener("selectionchange", updateSelection2);
        };
      }
    });
    return {
      rInput,
      isEditing,
      isEditableFromHover,
      handleFocus,
      handleBlur,
      handleKeyDown,
      handleChange,
      isEmpty
    };
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLArrowUtil/components/ArrowTextLabel.tsx
  var import_jsx_runtime3 = __toESM(require_jsx_runtime());
  var ArrowTextLabel = React6.memo(function ArrowTextLabel2({
    id,
    text,
    size,
    font,
    position,
    width,
    labelColor
  }) {
    const { rInput, isEditing, handleFocus, handleBlur, handleKeyDown, handleChange, isEmpty } = useEditableText(id, "arrow", text);
    if (!isEditing && isEmpty) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
      "div",
      {
        className: "tl-arrow-label",
        "data-font": font,
        "data-align": "center",
        "data-hastext": !isEmpty,
        "data-isediting": isEditing,
        style: {
          textAlign: "center",
          fontSize: ARROW_LABEL_FONT_SIZES[size],
          lineHeight: ARROW_LABEL_FONT_SIZES[size] * TEXT_PROPS.lineHeight + "px",
          transform: `translate(${position.x}px, ${position.y}px)`,
          color: labelColor
        },
        children: /* @__PURE__ */ (0, import_jsx_runtime3.jsxs)("div", { className: "tl-arrow-label__inner", children: [
          /* @__PURE__ */ (0, import_jsx_runtime3.jsx)("p", { style: { width: width ? width : "9px" }, children: text ? TextHelpers.normalizeTextForDom(text) : " " }),
          isEditing && // Consider replacing with content-editable
          /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(
            "textarea",
            {
              ref: rInput,
              className: "tl-text tl-text-input",
              name: "text",
              tabIndex: -1,
              autoComplete: "false",
              autoCapitalize: "false",
              autoCorrect: "false",
              autoSave: "false",
              autoFocus: true,
              placeholder: "",
              spellCheck: "true",
              wrap: "off",
              dir: "auto",
              datatype: "wysiwyg",
              defaultValue: text,
              onFocus: handleFocus,
              onChange: handleChange,
              onKeyDown: handleKeyDown,
              onBlur: handleBlur,
              onContextMenu: stopEventPropagation
            }
          )
        ] })
      }
    );
  });

  // ../../../packages/editor/src/lib/app/shapeutils/TLArrowUtil/TLArrowUtil.tsx
  var import_jsx_runtime4 = __toESM(require_jsx_runtime());
  var globalRenderIndex = 0;
  var TLArrowUtil = class extends TLShapeUtil {
    constructor() {
      super(...arguments);
      __publicField(this, "canEdit", () => true);
      __publicField(this, "canBind", () => false);
      __publicField(this, "isClosed", () => false);
      __publicField(this, "hideResizeHandles", () => true);
      __publicField(this, "hideRotateHandle", () => true);
      __publicField(this, "hideSelectionBoundsFg", () => true);
      __publicField(this, "hideSelectionBoundsBg", () => true);
      __publicField(this, "onHandleChange", (shape, { handle, isPrecise: isPrecise2 }) => {
        const next = deepCopy(shape);
        switch (handle.id) {
          case "start":
          case "end": {
            const pageTransform = this.app.getPageTransformById(next.id);
            const pointInPageSpace = Matrix2d.applyToPoint(pageTransform, handle);
            if (this.app.inputs.ctrlKey) {
              next.props[handle.id] = {
                type: "point",
                x: handle.x,
                y: handle.y
              };
            } else {
              const target = last(
                this.app.sortedShapesArray.filter((hitShape) => {
                  if (hitShape.id === shape.id) {
                    return;
                  }
                  const util = this.app.getShapeUtil(hitShape);
                  if (!util.canBind(hitShape)) {
                    return;
                  }
                  const pageMask = this.app.getPageMaskById(hitShape.id);
                  if (pageMask) {
                    if (!pointInPolygon(pointInPageSpace, pageMask))
                      return;
                  }
                  const pointInTargetSpace = this.app.getPointInShapeSpace(hitShape, pointInPageSpace);
                  if (util.isClosed(hitShape)) {
                    return pointInPolygon(pointInTargetSpace, util.outline(hitShape));
                  }
                  return util.hitTestPoint(hitShape, pointInTargetSpace);
                })
              );
              if (target) {
                const targetBounds = this.app.getBounds(target);
                const pointInTargetSpace = this.app.getPointInShapeSpace(target, pointInPageSpace);
                const prevHandle = next.props[handle.id];
                const startBindingId = shape.props.start.type === "binding" && shape.props.start.boundShapeId;
                const endBindingId = shape.props.end.type === "binding" && shape.props.end.boundShapeId;
                let precise3 = (
                  // If externally precise, then always precise
                  isPrecise2 || // If the other handle is bound to the same shape, then precise
                  (startBindingId || endBindingId) && startBindingId === endBindingId || // If the other shape is not closed, then precise
                  !this.app.getShapeUtil(target).isClosed(next)
                );
                if (
                  // If we're switching to a new bound shape, then precise only if moving slowly
                  prevHandle.type === "point" || prevHandle.type === "binding" && target.id !== prevHandle.boundShapeId
                ) {
                  precise3 = this.app.inputs.pointerVelocity.len() < 0.5;
                }
                if (precise3) {
                  precise3 = Vec2d.Dist(pointInTargetSpace, targetBounds.center) > Math.max(
                    4,
                    Math.min(Math.min(targetBounds.width, targetBounds.height) * 0.15, 16)
                  ) / this.app.zoomLevel;
                }
                next.props[handle.id] = {
                  type: "binding",
                  boundShapeId: target.id,
                  normalizedAnchor: precise3 ? {
                    x: (pointInTargetSpace.x - targetBounds.minX) / targetBounds.width,
                    y: (pointInTargetSpace.y - targetBounds.minY) / targetBounds.height
                  } : { x: 0.5, y: 0.5 },
                  isExact: this.app.inputs.altKey
                };
              } else {
                next.props[handle.id] = {
                  type: "point",
                  x: handle.x,
                  y: handle.y
                };
              }
            }
            break;
          }
          case "middle": {
            const { start, end } = getArrowTerminalsInArrowSpace(this.app, next);
            const delta = Vec2d.Sub(end, start);
            const v3 = Vec2d.Per(delta);
            const med = Vec2d.Med(end, start);
            const A2 = Vec2d.Sub(med, v3);
            const B = Vec2d.Add(med, v3);
            const point2 = Vec2d.NearestPointOnLineSegment(A2, B, handle, false);
            let bend = Vec2d.Dist(point2, med);
            if (Vec2d.Clockwise(point2, end, med))
              bend *= -1;
            next.props.bend = bend;
            break;
          }
        }
        return next;
      });
      __publicField(this, "onTranslateStart", (shape) => {
        let startBinding = shape.props.start.type === "binding" ? shape.props.start.boundShapeId : null;
        let endBinding = shape.props.end.type === "binding" ? shape.props.end.boundShapeId : null;
        if (startBinding && this.app.isWithinSelection(startBinding) || endBinding && this.app.isWithinSelection(endBinding)) {
          return;
        }
        startBinding = null;
        endBinding = null;
        const { start, end } = getArrowTerminalsInArrowSpace(this.app, shape);
        return {
          id: shape.id,
          type: shape.type,
          props: __spreadProps(__spreadValues({}, shape.props), {
            start: {
              type: "point",
              x: start.x,
              y: start.y
            },
            end: {
              type: "point",
              x: end.x,
              y: end.y
            }
          })
        };
      });
      __publicField(this, "onResize", (shape, info) => {
        const { scaleX, scaleY } = info;
        const terminals = getArrowTerminalsInArrowSpace(this.app, shape);
        const { start, end } = deepCopy(shape.props);
        let { bend } = shape.props;
        if (start.type === "point") {
          start.x = terminals.start.x * scaleX;
          start.y = terminals.start.y * scaleY;
        }
        if (end.type === "point") {
          end.x = terminals.end.x * scaleX;
          end.y = terminals.end.y * scaleY;
        }
        const mx = Math.abs(scaleX);
        const my = Math.abs(scaleY);
        if (scaleX < 0 && scaleY >= 0) {
          if (bend !== 0) {
            bend *= -1;
            bend *= Math.max(mx, my);
          }
          if (start.type === "binding") {
            start.normalizedAnchor.x = 1 - start.normalizedAnchor.x;
          }
          if (end.type === "binding") {
            end.normalizedAnchor.x = 1 - end.normalizedAnchor.x;
          }
        } else if (scaleX >= 0 && scaleY < 0) {
          if (bend !== 0) {
            bend *= -1;
            bend *= Math.max(mx, my);
          }
          if (start.type === "binding") {
            start.normalizedAnchor.y = 1 - start.normalizedAnchor.y;
          }
          if (end.type === "binding") {
            end.normalizedAnchor.y = 1 - end.normalizedAnchor.y;
          }
        } else if (scaleX >= 0 && scaleY >= 0) {
          if (bend !== 0) {
            bend *= Math.max(mx, my);
          }
        } else if (scaleX < 0 && scaleY < 0) {
          if (bend !== 0) {
            bend *= Math.max(mx, my);
          }
          if (start.type === "binding") {
            start.normalizedAnchor.x = 1 - start.normalizedAnchor.x;
            start.normalizedAnchor.y = 1 - start.normalizedAnchor.y;
          }
          if (end.type === "binding") {
            end.normalizedAnchor.x = 1 - end.normalizedAnchor.x;
            end.normalizedAnchor.y = 1 - end.normalizedAnchor.y;
          }
        }
        const next = {
          props: {
            start,
            end,
            bend
          }
        };
        return next;
      });
      __publicField(this, "onDoubleClickHandle", (shape, handle) => {
        switch (handle.id) {
          case "start": {
            return {
              id: shape.id,
              type: shape.type,
              props: __spreadProps(__spreadValues({}, shape.props), {
                arrowheadStart: shape.props.arrowheadStart === "none" ? "arrow" : "none"
              })
            };
          }
          case "end": {
            return {
              id: shape.id,
              type: shape.type,
              props: __spreadProps(__spreadValues({}, shape.props), {
                arrowheadEnd: shape.props.arrowheadEnd === "none" ? "arrow" : "none"
              })
            };
          }
        }
      });
      __publicField(this, "getEditingBounds", (shape) => {
        var _a5;
        return (_a5 = this.getLabelBounds(shape)) != null ? _a5 : new Box2d();
      });
      __publicField(this, "onEditEnd", (shape) => {
        const {
          id,
          type,
          props: { text }
        } = shape;
        if (text.trimEnd() !== shape.props.text) {
          this.app.updateShapes([
            {
              id,
              type,
              props: {
                text: text.trimEnd()
              }
            }
          ]);
        }
      });
    }
    defaultProps() {
      return {
        opacity: "1",
        dash: "draw",
        size: "m",
        fill: "none",
        color: "black",
        labelColor: "black",
        bend: 0,
        start: { type: "point", x: 0, y: 0 },
        end: { type: "point", x: 0, y: 0 },
        arrowheadStart: "none",
        arrowheadEnd: "arrow",
        text: "",
        font: "draw"
      };
    }
    getCenter(shape) {
      return this.bounds(shape).center;
    }
    getBounds(shape) {
      return Box2d.FromPoints(this.getOutlineWithoutLabel(shape));
    }
    getOutlineWithoutLabel(shape) {
      const info = this.getArrowInfo(shape);
      if (!info) {
        return [];
      }
      if (info.isStraight) {
        if (info.isValid) {
          return [info.start.point, info.end.point];
        } else {
          return [new Vec2d(0, 0), new Vec2d(1, 1)];
        }
      }
      if (!info.isValid) {
        return [new Vec2d(0, 0), new Vec2d(1, 1)];
      }
      const pointsToPush = Math.max(5, Math.ceil(Math.abs(info.bodyArc.length) / 16));
      if (pointsToPush <= 0 && !isFinite(pointsToPush)) {
        return [new Vec2d(0, 0), new Vec2d(1, 1)];
      }
      const results = Array(pointsToPush);
      const startAngle = Vec2d.Angle(info.bodyArc.center, info.start.point);
      const endAngle = Vec2d.Angle(info.bodyArc.center, info.end.point);
      const a3 = info.bodyArc.sweepFlag ? endAngle : startAngle;
      const b3 = info.bodyArc.sweepFlag ? startAngle : endAngle;
      const l3 = info.bodyArc.largeArcFlag ? -longAngleDist(a3, b3) : shortAngleDist(a3, b3);
      const r3 = Math.max(1, info.bodyArc.radius);
      for (let i3 = 0; i3 < pointsToPush; i3++) {
        const t4 = i3 / (pointsToPush - 1);
        const angle = a3 + l3 * t4;
        const point2 = getPointOnCircle(info.bodyArc.center.x, info.bodyArc.center.y, r3, angle);
        results[i3] = point2;
      }
      return results;
    }
    getOutline(shape) {
      const outlineWithoutLabel = this.getOutlineWithoutLabel(shape);
      const labelBounds = this.getLabelBounds(shape);
      if (!labelBounds) {
        return outlineWithoutLabel;
      }
      const sides = labelBounds.sides;
      const sideIndexes = [0, 1, 2, 3];
      let prevPoint = outlineWithoutLabel[0];
      let didAddLabel = false;
      const result = [prevPoint];
      for (let i3 = 1; i3 < outlineWithoutLabel.length; i3++) {
        const nextPoint = outlineWithoutLabel[i3];
        if (!didAddLabel) {
          const nearestIntersectingSideIndex = minBy(
            sideIndexes.filter(
              (sideIndex) => linesIntersect(sides[sideIndex][0], sides[sideIndex][1], prevPoint, nextPoint)
            ),
            (sideIndex) => Vec2d.DistanceToLineSegment(sides[sideIndex][0], sides[sideIndex][1], prevPoint)
          );
          if (nearestIntersectingSideIndex !== void 0) {
            const intersectingPoint = Vec2d.NearestPointOnLineSegment(
              sides[nearestIntersectingSideIndex][0],
              sides[nearestIntersectingSideIndex][1],
              prevPoint
            );
            result.push(intersectingPoint);
            for (let j = 0; j < 4; j++) {
              const sideIndex = (nearestIntersectingSideIndex + j) % 4;
              result.push(sides[sideIndex][1]);
            }
            result.push(intersectingPoint);
            didAddLabel = true;
          }
        }
        result.push(nextPoint);
        prevPoint = nextPoint;
      }
      return result;
    }
    snapPoints(_shape) {
      return EMPTY_ARRAY;
    }
    get infoCache() {
      return this.app.store.createComputedCache(
        "arrow infoCache",
        (shape) => {
          return getIsArrowStraight(shape) ? getStraightArrowInfo(this.app, shape) : getCurvedArrowInfo(this.app, shape);
        }
      );
    }
    getArrowInfo(shape) {
      return this.infoCache.get(shape.id);
    }
    getHandles(shape) {
      const info = this.infoCache.get(shape.id);
      return [
        {
          id: "start",
          type: "vertex",
          index: "a0",
          x: info.start.handle.x,
          y: info.start.handle.y,
          canBind: true
        },
        {
          id: "middle",
          type: "vertex",
          index: "a2",
          x: info.middle.x,
          y: info.middle.y,
          canBind: false
        },
        {
          id: "end",
          type: "vertex",
          index: "a3",
          x: info.end.handle.x,
          y: info.end.handle.y,
          canBind: true
        }
      ];
    }
    hitTestPoint(shape, point2) {
      const outline = this.outline(shape);
      const zoomLevel = this.app.zoomLevel;
      const offsetDist = this.app.getStrokeWidth(shape.props.size) / zoomLevel;
      for (let i3 = 0; i3 < outline.length - 1; i3++) {
        const C2 = outline[i3];
        const D3 = outline[i3 + 1];
        if (Vec2d.DistanceToLineSegment(C2, D3, point2) < offsetDist)
          return true;
      }
      return false;
    }
    hitTestLineSegment(shape, A2, B) {
      const outline = this.outline(shape);
      for (let i3 = 0; i3 < outline.length - 1; i3++) {
        const C2 = outline[i3];
        const D3 = outline[i3 + 1];
        if (linesIntersect(A2, B, C2, D3))
          return true;
      }
      return false;
    }
    render(shape) {
      var _a5;
      const onlySelectedShape = this.app.onlySelectedShape;
      const shouldDisplayHandles = this.app.isInAny(
        "select.idle",
        "select.pointing_handle",
        "select.dragging_handle",
        "arrow.dragging"
      ) && !this.app.isReadOnly;
      const info = this.getArrowInfo(shape);
      const bounds = this.bounds(shape);
      const labelSize = this.getLabelBounds(shape);
      const changeIndex = React7.useMemo(() => {
        return this.app.isSafari ? globalRenderIndex += 1 : 0;
      }, [shape]);
      if (!(info == null ? void 0 : info.isValid))
        return null;
      const strokeWidth = this.app.getStrokeWidth(shape.props.size);
      const as = info.start.arrowhead && getArrowheadPathForType(info, "start", strokeWidth);
      const ae = info.end.arrowhead && getArrowheadPathForType(info, "end", strokeWidth);
      const path = info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info);
      let handlePath = null;
      if (onlySelectedShape === shape && shouldDisplayHandles) {
        const sw = 2;
        const { strokeDasharray: strokeDasharray2, strokeDashoffset: strokeDashoffset2 } = getPerfectDashProps(
          info.isStraight ? Vec2d.Dist(info.start.handle, info.end.handle) : Math.abs(info.handleArc.length),
          sw,
          {
            end: "skip",
            start: "skip",
            lengthRatio: 2.5
          }
        );
        handlePath = shape.props.start.type === "binding" || shape.props.end.type === "binding" ? /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
          "path",
          {
            className: "tl-arrow-hint",
            d: info.isStraight ? getStraightArrowHandlePath(info) : getCurvedArrowHandlePath(info),
            strokeDasharray: strokeDasharray2,
            strokeDashoffset: strokeDashoffset2,
            strokeWidth: sw,
            markerStart: shape.props.start.type === "binding" ? shape.props.start.isExact ? "" : isPrecise(shape.props.start.normalizedAnchor) ? "url(#arrowhead-cross)" : "url(#arrowhead-dot)" : "",
            markerEnd: shape.props.end.type === "binding" ? shape.props.end.isExact ? "" : isPrecise(shape.props.end.normalizedAnchor) ? "url(#arrowhead-cross)" : "url(#arrowhead-dot)" : "",
            opacity: 0.16
          }
        ) : null;
      }
      const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
        info.isStraight ? info.length : Math.abs(info.bodyArc.length),
        strokeWidth,
        {
          style: shape.props.dash
        }
      );
      const maskStartArrowhead = !(info.start.arrowhead === "none" || info.start.arrowhead === "arrow");
      const maskEndArrowhead = !(info.end.arrowhead === "none" || info.end.arrowhead === "arrow");
      const includeMask = maskStartArrowhead || maskEndArrowhead || labelSize;
      const maskId = (shape.id + "_clip_" + changeIndex).replace(":", "_");
      return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(import_jsx_runtime4.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(SVGContainer, { id: shape.id, style: { minWidth: 50, minHeight: 50 }, children: [
          includeMask && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("mask", { id: maskId, children: [
            /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
              "rect",
              {
                x: toDomPrecision(-100 + bounds.minX),
                y: toDomPrecision(-100 + bounds.minY),
                width: toDomPrecision(bounds.width + 200),
                height: toDomPrecision(bounds.height + 200),
                fill: "white"
              }
            ),
            labelSize && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
              "rect",
              {
                x: toDomPrecision(labelSize.x),
                y: toDomPrecision(labelSize.y),
                width: toDomPrecision(labelSize.w),
                height: toDomPrecision(labelSize.h),
                fill: "black",
                rx: 4,
                ry: 4
              }
            ),
            as && maskStartArrowhead && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
              "path",
              {
                d: as,
                fill: info.start.arrowhead === "arrow" ? "none" : "black",
                stroke: "none"
              }
            ),
            ae && maskEndArrowhead && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
              "path",
              {
                d: ae,
                fill: info.end.arrowhead === "arrow" ? "none" : "black",
                stroke: "none"
              }
            )
          ] }) }),
          /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)(
            "g",
            {
              fill: "none",
              stroke: "currentColor",
              strokeWidth,
              strokeLinejoin: "round",
              strokeLinecap: "round",
              pointerEvents: "none",
              children: [
                handlePath,
                /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("g", __spreadProps(__spreadValues({}, includeMask ? { mask: `url(#${maskId})` } : void 0), { children: [
                  includeMask && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
                    "rect",
                    {
                      x: toDomPrecision(bounds.minX - 100),
                      y: toDomPrecision(bounds.minY - 100),
                      width: toDomPrecision(bounds.width + 200),
                      height: toDomPrecision(bounds.height + 200),
                      opacity: 0
                    }
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
                    "path",
                    {
                      d: path,
                      strokeDasharray,
                      strokeDashoffset
                    }
                  )
                ] })),
                as && maskStartArrowhead && shape.props.fill !== "none" && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(ShapeFill, { d: as, color: shape.props.color, fill: shape.props.fill }),
                ae && maskEndArrowhead && shape.props.fill !== "none" && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(ShapeFill, { d: ae, color: shape.props.color, fill: shape.props.fill }),
                as && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: as }),
                ae && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: ae })
              ]
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: path, className: "tl-hitarea-stroke" })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
          ArrowTextLabel,
          {
            id: shape.id,
            text: shape.props.text,
            font: shape.props.font,
            size: shape.props.size,
            position: info.middle,
            width: (_a5 = labelSize == null ? void 0 : labelSize.w) != null ? _a5 : 0,
            labelColor: this.app.getCssColor(shape.props.labelColor)
          }
        )
      ] });
    }
    indicator(shape) {
      const { start, end } = getArrowTerminalsInArrowSpace(this.app, shape);
      const info = this.getArrowInfo(shape);
      const bounds = this.bounds(shape);
      const labelSize = this.getLabelBounds(shape);
      if (!info)
        return null;
      if (Vec2d.Equals(start, end))
        return null;
      const strokeWidth = this.app.getStrokeWidth(shape.props.size);
      const as = info.start.arrowhead && getArrowheadPathForType(info, "start", strokeWidth);
      const ae = info.end.arrowhead && getArrowheadPathForType(info, "end", strokeWidth);
      const path = info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info);
      const includeMask = as && info.start.arrowhead !== "arrow" || ae && info.end.arrowhead !== "arrow" || labelSize !== null;
      const maskId = (shape.id + "_clip").replace(":", "_");
      return /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("g", { children: [
        includeMask && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("defs", { children: /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("mask", { id: maskId, children: [
          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
            "rect",
            {
              x: bounds.minX - 100,
              y: bounds.minY - 100,
              width: bounds.w + 200,
              height: bounds.h + 200,
              fill: "white"
            }
          ),
          labelSize && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
            "rect",
            {
              x: labelSize.x,
              y: labelSize.y,
              width: labelSize.w,
              height: labelSize.h,
              fill: "black",
              rx: 4,
              ry: 4
            }
          ),
          as && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
            "path",
            {
              d: as,
              fill: info.start.arrowhead === "arrow" ? "none" : "black",
              stroke: "none"
            }
          ),
          ae && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
            "path",
            {
              d: ae,
              fill: info.end.arrowhead === "arrow" ? "none" : "black",
              stroke: "none"
            }
          )
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime4.jsxs)("g", __spreadProps(__spreadValues({}, includeMask ? { mask: `url(#${maskId})` } : void 0), { children: [
          includeMask && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
            "rect",
            {
              x: bounds.minX - 100,
              y: bounds.minY - 100,
              width: bounds.width + 200,
              height: bounds.height + 200,
              opacity: 0
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: path })
        ] })),
        as && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: as }),
        ae && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)("path", { d: ae }),
        labelSize && /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(
          "rect",
          {
            x: labelSize.x,
            y: labelSize.y,
            width: labelSize.w,
            height: labelSize.h,
            rx: 4,
            ry: 4
          }
        )
      ] });
    }
    get labelBoundsCache() {
      return this.app.store.createComputedCache("labelBoundsCache", (shape) => {
        const info = this.getArrowInfo(shape);
        const bounds = this.bounds(shape);
        const { text, font, size } = shape.props;
        if (!info)
          return null;
        if (!text.trim())
          return null;
        const { w: w3, h: h3 } = this.app.textMeasure.measureText(__spreadProps(__spreadValues({}, TEXT_PROPS), {
          text,
          fontFamily: FONT_FAMILIES[font],
          fontSize: ARROW_LABEL_FONT_SIZES[size],
          width: "fit-content"
        }));
        let width = w3;
        let height = h3;
        if (bounds.width > bounds.height) {
          width = Math.max(Math.min(w3, 64), Math.min(bounds.width - 64, w3));
          const { w: squishedWidth, h: squishedHeight } = this.app.textMeasure.measureText(__spreadProps(__spreadValues({}, TEXT_PROPS), {
            text,
            fontFamily: FONT_FAMILIES[font],
            fontSize: ARROW_LABEL_FONT_SIZES[size],
            width: width + "px"
          }));
          width = squishedWidth;
          height = squishedHeight;
        }
        if (width > 16 * ARROW_LABEL_FONT_SIZES[size]) {
          width = 16 * ARROW_LABEL_FONT_SIZES[size];
          const { w: squishedWidth, h: squishedHeight } = this.app.textMeasure.measureText(__spreadProps(__spreadValues({}, TEXT_PROPS), {
            text,
            fontFamily: FONT_FAMILIES[font],
            fontSize: ARROW_LABEL_FONT_SIZES[size],
            width: width + "px"
          }));
          width = squishedWidth;
          height = squishedHeight;
        }
        return new Box2d(
          info.middle.x - (width + 8) / 2,
          info.middle.y - (height + 8) / 2,
          width + 8,
          height + 8
        );
      });
    }
    getLabelBounds(shape) {
      return this.labelBoundsCache.get(shape.id) || null;
    }
    toSvg(shape, font, colors) {
      const color = colors.fill[shape.props.color];
      const info = this.getArrowInfo(shape);
      const strokeWidth = this.app.getStrokeWidth(shape.props.size);
      const g3 = document.createElementNS("http://www.w3.org/2000/svg", "g");
      if (!info)
        return g3;
      const as = info.start.arrowhead && getArrowheadPathForType(info, "start", strokeWidth);
      const ae = info.end.arrowhead && getArrowheadPathForType(info, "end", strokeWidth);
      const bounds = this.bounds(shape);
      const labelSize = this.getLabelBounds(shape);
      const maskId = (shape.id + "_clip").replace(":", "_");
      if (as || ae || labelSize) {
        const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
        const mask = document.createElementNS("http://www.w3.org/2000/svg", "mask");
        mask.id = maskId;
        const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        rect.setAttribute("x", bounds.minX - 100 + "");
        rect.setAttribute("y", bounds.minY - 100 + "");
        rect.setAttribute("width", bounds.width + 200 + "");
        rect.setAttribute("height", bounds.height + 200 + "");
        rect.setAttribute("fill", "white");
        mask.appendChild(rect);
        if (as)
          mask.appendChild(getArrowheadSvgMask(as, info.start.arrowhead));
        if (ae)
          mask.appendChild(getArrowheadSvgMask(ae, info.end.arrowhead));
        if (labelSize) {
          const labelMask = document.createElementNS("http://www.w3.org/2000/svg", "rect");
          labelMask.setAttribute("x", labelSize.x + "");
          labelMask.setAttribute("y", labelSize.y + "");
          labelMask.setAttribute("width", labelSize.w + "");
          labelMask.setAttribute("height", labelSize.h + "");
          labelMask.setAttribute("fill", "black");
          mask.appendChild(labelMask);
        }
        defs.appendChild(mask);
        g3.appendChild(defs);
      }
      const g22 = document.createElementNS("http://www.w3.org/2000/svg", "g");
      g22.setAttribute("mask", `url(#${maskId})`);
      g3.appendChild(g22);
      const rect2 = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      rect2.setAttribute("x", "-100");
      rect2.setAttribute("y", "-100");
      rect2.setAttribute("width", bounds.width + 200 + "");
      rect2.setAttribute("height", bounds.height + 200 + "");
      rect2.setAttribute("fill", "transparent");
      rect2.setAttribute("stroke", "none");
      g22.appendChild(rect2);
      const path = getArrowSvgPath(
        info.isStraight ? getSolidStraightArrowPath(info) : getSolidCurvedArrowPath(info),
        color,
        strokeWidth
      );
      const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
        info.isStraight ? info.length : Math.abs(info.bodyArc.length),
        strokeWidth,
        {
          style: shape.props.dash
        }
      );
      path.setAttribute("stroke-dasharray", strokeDasharray);
      path.setAttribute("stroke-dashoffset", strokeDashoffset);
      g22.appendChild(path);
      if (as) {
        g3.appendChild(
          getArrowheadSvgPath(
            as,
            shape.props.color,
            strokeWidth,
            shape.props.arrowheadStart === "arrow" ? "none" : shape.props.fill,
            colors
          )
        );
      }
      if (ae) {
        g3.appendChild(
          getArrowheadSvgPath(
            ae,
            shape.props.color,
            strokeWidth,
            shape.props.arrowheadEnd === "arrow" ? "none" : shape.props.fill,
            colors
          )
        );
      }
      if (labelSize) {
        const opts = {
          fontSize: ARROW_LABEL_FONT_SIZES[shape.props.size],
          lineHeight: TEXT_PROPS.lineHeight,
          fontFamily: font,
          padding: 0,
          textAlign: "middle",
          width: labelSize.w,
          height: labelSize.h,
          fontStyle: "normal",
          fontWeight: "normal"
        };
        const lines = this.app.textMeasure.getTextLines(__spreadProps(__spreadValues({
          text: shape.props.text,
          wrap: true
        }, opts), {
          width: labelSize.w - 8
        }));
        const textElm = getTextSvgElement(this.app, __spreadProps(__spreadValues({
          lines
        }, opts), {
          width: labelSize.w - 8
        }));
        textElm.setAttribute("fill", colors.fill[shape.props.labelColor]);
        const children = Array.from(textElm.children);
        children.forEach((child) => {
          const x3 = parseFloat(child.getAttribute("x") || "0");
          const y3 = parseFloat(child.getAttribute("y") || "0");
          child.setAttribute("x", x3 + 4 + labelSize.x + "px");
          child.setAttribute("y", y3 + labelSize.y + "px");
        });
        g3.appendChild(textElm);
      }
      return g3;
    }
  };
  __publicField(TLArrowUtil, "type", "arrow");
  __decorateClass([
    computed
  ], TLArrowUtil.prototype, "infoCache", 1);
  __decorateClass([
    computed
  ], TLArrowUtil.prototype, "labelBoundsCache", 1);
  function getArrowheadSvgMask(d3, arrowhead) {
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", d3);
    path.setAttribute("fill", arrowhead === "arrow" ? "none" : "black");
    path.setAttribute("stroke", "none");
    return path;
  }
  function getArrowSvgPath(d3, color, strokeWidth) {
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", d3);
    path.setAttribute("fill", "none");
    path.setAttribute("stroke", color);
    path.setAttribute("stroke-width", strokeWidth + "");
    return path;
  }
  function getArrowheadSvgPath(d3, color, strokeWidth, fill, colors) {
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", d3);
    path.setAttribute("fill", "none");
    path.setAttribute("stroke", colors.fill[color]);
    path.setAttribute("stroke-width", strokeWidth + "");
    const shapeFill = getShapeFillSvg({
      d: d3,
      fill,
      color,
      colors
    });
    if (shapeFill) {
      const g3 = document.createElementNS("http://www.w3.org/2000/svg", "g");
      g3.appendChild(shapeFill);
      g3.appendChild(path);
      return g3;
    } else {
      return path;
    }
  }
  function isPrecise(normalizedAnchor) {
    return normalizedAnchor.x !== 0.5 || normalizedAnchor.y !== 0.5;
  }
  var TLArrowShapeDef = defineShape({
    type: "arrow",
    getShapeUtil: () => TLArrowUtil,
    validator: arrowShapeTypeValidator,
    migrations: arrowShapeMigrations
  });

  // ../../../packages/editor/src/lib/components/HTMLContainer.tsx
  var import_jsx_runtime5 = __toESM(require_jsx_runtime());
  function HTMLContainer(_a5) {
    var _b2 = _a5, { children, className = "" } = _b2, rest = __objRest(_b2, ["children", "className"]);
    return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)("div", __spreadProps(__spreadValues({}, rest), { className: `tl-html-container ${className}`, children }));
  }

  // ../../../packages/editor/src/lib/app/shapeutils/shared/HyperlinkButton.tsx
  var import_classnames = __toESM(require_classnames());
  var import_jsx_runtime6 = __toESM(require_jsx_runtime());
  var LINK_ICON = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' fill='none'%3E%3Cpath stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 5H7a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6M19 5h6m0 0v6m0-6L13 17'/%3E%3C/svg%3E";
  function HyperlinkButton({ url, zoomLevel }) {
    return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
      "a",
      {
        className: (0, import_classnames.default)("tl-hyperlink-button", {
          "tl-hyperlink-button__hidden": zoomLevel < 0.5
        }),
        href: url,
        target: "_blank",
        rel: "noopener noreferrer",
        onPointerDown: stopEventPropagation,
        onPointerUp: stopEventPropagation,
        title: url,
        draggable: false,
        children: /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(
          "div",
          {
            className: "tl-hyperlink-button__icon",
            style: {
              mask: `url("${LINK_ICON}") center 100% / 100% no-repeat`,
              WebkitMask: `url("${LINK_ICON}") center 100% / 100% no-repeat`
            }
          }
        )
      }
    );
  }

  // ../../../packages/editor/src/lib/app/shapeutils/shared/resizeBox.ts
  var resizeBox = (shape, info, opts = {}) => {
    const { newPoint, handle, scaleX, scaleY } = info;
    const { minWidth = 1, maxWidth = Infinity, minHeight = 1, maxHeight = Infinity } = opts;
    let w3 = shape.props.w * scaleX;
    let h3 = shape.props.h * scaleY;
    const offset = new Vec2d(0, 0);
    if (w3 > 0) {
      if (w3 < minWidth) {
        switch (handle) {
          case "top_left":
          case "left":
          case "bottom_left": {
            offset.x = w3 - minWidth;
            break;
          }
          case "top":
          case "bottom": {
            offset.x = (w3 - minWidth) / 2;
            break;
          }
          default: {
            offset.x = 0;
          }
        }
        w3 = minWidth;
      }
    } else {
      offset.x = w3;
      w3 = -w3;
      if (w3 < minWidth) {
        switch (handle) {
          case "top_left":
          case "left":
          case "bottom_left": {
            offset.x = -w3;
            break;
          }
          default: {
            offset.x = -minWidth;
          }
        }
        w3 = minWidth;
      }
    }
    if (h3 > 0) {
      if (h3 < minHeight) {
        switch (handle) {
          case "top_left":
          case "top":
          case "top_right": {
            offset.y = h3 - minHeight;
            break;
          }
          case "right":
          case "left": {
            offset.y = (h3 - minHeight) / 2;
            break;
          }
          default: {
            offset.y = 0;
          }
        }
        h3 = minHeight;
      }
    } else {
      offset.y = h3;
      h3 = -h3;
      if (h3 < minHeight) {
        switch (handle) {
          case "top_left":
          case "top":
          case "top_right": {
            offset.y = -h3;
            break;
          }
          default: {
            offset.y = -minHeight;
          }
        }
        h3 = minHeight;
      }
    }
    const { x: x3, y: y3 } = offset.rot(shape.rotation).add(newPoint);
    return {
      x: x3,
      y: y3,
      props: {
        w: Math.min(maxWidth, w3),
        h: Math.min(maxHeight, h3)
      }
    };
  };

  // ../../../packages/editor/src/lib/app/shapeutils/TLBoxUtil.tsx
  var TLBoxUtil = class extends TLShapeUtil {
    constructor() {
      super(...arguments);
      __publicField(this, "onResize", (shape, info) => {
        return resizeBox(shape, info);
      });
    }
    getBounds(shape) {
      return new Box2d(0, 0, shape.props.w, shape.props.h);
    }
    getCenter(shape) {
      return new Vec2d(shape.props.w / 2, shape.props.h / 2);
    }
    getOutline(shape) {
      return this.bounds(shape).corners;
    }
    hitTestPoint(shape, point2) {
      return pointInPolygon(point2, this.outline(shape));
    }
    hitTestLineSegment(shape, A2, B) {
      const outline = this.outline(shape);
      for (let i3 = 0; i3 < outline.length; i3++) {
        const C2 = outline[i3];
        const D3 = outline[(i3 + 1) % outline.length];
        if (linesIntersect(A2, B, C2, D3))
          return true;
      }
      return false;
    }
  };

  // ../../../packages/editor/src/lib/app/shapeutils/TLBookmarkUtil/TLBookmarkUtil.tsx
  var import_jsx_runtime7 = __toESM(require_jsx_runtime());
  var TLBookmarkUtil = class extends TLBoxUtil {
    constructor() {
      super(...arguments);
      __publicField(this, "canResize", () => false);
      __publicField(this, "hideSelectionBoundsBg", () => true);
      __publicField(this, "hideSelectionBoundsFg", () => true);
      __publicField(this, "onBeforeCreate", (shape) => {
        this.updateBookmarkAsset(shape);
      });
      __publicField(this, "onBeforeUpdate", (prev, shape) => {
        if (prev.props.url !== shape.props.url) {
          this.updateBookmarkAsset(shape);
        }
      });
      __publicField(this, "updateBookmarkAsset", debounce((shape) => {
        const { url } = shape.props;
        const assetId = TLAsset.createCustomId(getHashForString(url));
        const existing = this.app.getAssetById(assetId);
        if (existing) {
          if (shape.props.assetId !== existing.id) {
            this.app.updateShapes([
              {
                id: shape.id,
                type: shape.type,
                props: { assetId }
              }
            ]);
          }
        } else if (this.app.onCreateBookmarkFromUrl) {
          this.app.onCreateBookmarkFromUrl(url).then((meta) => {
            if (!meta) {
              this.app.updateShapes([
                {
                  id: shape.id,
                  type: shape.type,
                  props: { assetId: void 0 }
                }
              ]);
              return;
            }
            this.app.batch(() => {
              this.app.createAssets([
                {
                  id: assetId,
                  typeName: "asset",
                  type: "bookmark",
                  props: {
                    src: url,
                    description: meta.description,
                    image: meta.image,
                    title: meta.title
                  }
                }
              ]).updateShapes([
                {
                  id: shape.id,
                  type: shape.type,
                  props: { assetId }
                }
              ]);
            });
          });
        }
      }, 500));
    }
    defaultProps() {
      return {
        opacity: "1",
        url: "",
        w: DEFAULT_BOOKMARK_WIDTH,
        h: DEFAULT_BOOKMARK_HEIGHT,
        assetId: null
      };
    }
    render(shape) {
      const asset = shape.props.assetId ? this.app.getAssetById(shape.props.assetId) : null;
      const pageRotation = this.app.getPageRotation(shape);
      const address = this.getHumanReadableAddress(shape);
      return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(HTMLContainer, { children: /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)(
        "div",
        {
          className: "tl-bookmark__container tl-hitarea-stroke",
          style: {
            boxShadow: rotateBoxShadow(pageRotation, ROTATING_SHADOWS)
          },
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "tl-bookmark__image_container", children: [
              (asset == null ? void 0 : asset.props.image) ? /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
                "img",
                {
                  className: "tl-bookmark__image",
                  draggable: false,
                  src: asset == null ? void 0 : asset.props.image,
                  alt: (asset == null ? void 0 : asset.props.title) || ""
                }
              ) : /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("div", { className: "tl-bookmark__placeholder" }),
              /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(HyperlinkButton, { url: shape.props.url, zoomLevel: this.app.zoomLevel })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime7.jsxs)("div", { className: "tl-bookmark__copy_container", children: [
              (asset == null ? void 0 : asset.props.title) && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("h2", { className: "tl-bookmark__heading", children: truncateStringWithEllipsis((asset == null ? void 0 : asset.props.title) || "", 54) }),
              (asset == null ? void 0 : asset.props.description) && /* @__PURE__ */ (0, import_jsx_runtime7.jsx)("p", { className: "tl-bookmark__description", children: truncateStringWithEllipsis((asset == null ? void 0 : asset.props.description) || "", 128) }),
              /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
                "a",
                {
                  className: "tl-bookmark__link",
                  href: shape.props.url || "",
                  target: "_blank",
                  rel: "noopener noreferrer",
                  onPointerDown: stopEventPropagation,
                  onPointerUp: stopEventPropagation,
                  onClick: stopEventPropagation,
                  children: truncateStringWithEllipsis(address, 45)
                }
              )
            ] })
          ]
        }
      ) });
    }
    indicator(shape) {
      return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(
        "rect",
        {
          width: toDomPrecision(shape.props.w),
          height: toDomPrecision(shape.props.h),
          rx: "8",
          ry: "8"
        }
      );
    }
    getHumanReadableAddress(shape) {
      try {
        const url = new URL(shape.props.url);
        const path = url.pathname.replace(/\/*$/, "");
        return `${url.hostname}${path}`;
      } catch (e2) {
        return shape.props.url;
      }
    }
  };
  __publicField(TLBookmarkUtil, "type", "bookmark");
  var TLBookmarkShapeDef = defineShape({
    type: "bookmark",
    getShapeUtil: () => TLBookmarkUtil,
    validator: bookmarkShapeTypeValidator,
    migrations: bookmarkShapeMigrations
  });

  // ../../../packages/editor/src/lib/utils/svg.ts
  function getPointerInfo(e2, container) {
    ;
    e2.isKilled = true;
    const { top, left } = container.getBoundingClientRect();
    return {
      point: {
        x: e2.clientX - left,
        y: e2.clientY - top,
        z: e2.pressure
      },
      shiftKey: e2.shiftKey,
      altKey: e2.altKey,
      ctrlKey: e2.metaKey || e2.ctrlKey,
      pointerId: e2.pointerId,
      button: e2.button,
      isPen: e2.pointerType === "pen"
    };
  }
  function precise2(A2) {
    return `${toDomPrecision(A2.x)},${toDomPrecision(A2.y)} `;
  }
  function average(A2, B) {
    return `${toDomPrecision((A2.x + B.x) / 2)},${toDomPrecision((A2.y + B.y) / 2)} `;
  }
  function getSvgPathFromStroke(points2, closed = true) {
    const len = points2.length;
    if (len < 2) {
      return "";
    }
    let a3 = points2[0];
    let b3 = points2[1];
    if (len === 2) {
      return `M${precise2(a3)}L${precise2(b3)}`;
    }
    let result = "";
    for (let i3 = 2, max = len - 1; i3 < max; i3++) {
      a3 = points2[i3];
      b3 = points2[i3 + 1];
      result += average(a3, b3);
    }
    if (closed) {
      return `M${average(points2[0], points2[1])}Q${precise2(points2[1])}${average(
        points2[1],
        points2[2]
      )}T${result}${average(points2[len - 1], points2[0])}${average(points2[0], points2[1])}Z`;
    } else {
      return `M${precise2(points2[0])}Q${precise2(points2[1])}${average(points2[1], points2[2])}${points2.length > 3 ? "T" : ""}${result}L${precise2(points2[len - 1])}`;
    }
  }
  function getSvgPathFromStrokePoints(points2, closed = false) {
    const len = points2.length;
    if (len < 2) {
      return "";
    }
    let a3 = points2[0].point;
    let b3 = points2[1].point;
    if (len === 2) {
      return `M${precise2(a3)}L${precise2(b3)}`;
    }
    let result = "";
    for (let i3 = 2, max = len - 1; i3 < max; i3++) {
      a3 = points2[i3].point;
      b3 = points2[i3 + 1].point;
      result += average(a3, b3);
    }
    if (closed) {
      return `M${average(points2[0].point, points2[1].point)}Q${precise2(points2[1].point)}${average(
        points2[1].point,
        points2[2].point
      )}T${result}${average(points2[len - 1].point, points2[0].point)}${average(
        points2[0].point,
        points2[1].point
      )}Z`;
    } else {
      return `M${precise2(points2[0].point)}Q${precise2(points2[1].point)}${average(
        points2[1].point,
        points2[2].point
      )}${points2.length > 3 ? "T" : ""}${result}L${precise2(points2[len - 1].point)}`;
    }
  }

  // ../../../packages/editor/src/lib/app/shapeutils/shared/useForceSolid.ts
  function useForceSolid() {
    const app = useApp();
    return useValue("zoom", () => app.zoomLevel < 0.35, [app]);
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLDrawUtil/getPath.ts
  var PEN_EASING = (t4) => t4 * 0.65 + SIN(t4 * PI / 2) * 0.35;
  var simulatePressureSettings = (strokeWidth) => {
    return {
      size: 1 + strokeWidth,
      thinning: 0.5,
      streamline: 0.62 + (1 + strokeWidth) / 8 * 0.06,
      smoothing: 0.62,
      easing: EASINGS.easeOutSine,
      simulatePressure: true
    };
  };
  var realPressureSettings = (strokeWidth) => {
    return {
      size: 1 + strokeWidth * 1.2,
      thinning: 0.62,
      streamline: 0.62,
      smoothing: 0.62,
      simulatePressure: false,
      easing: PEN_EASING
    };
  };
  var solidSettings = (strokeWidth) => {
    return {
      size: 1 + strokeWidth,
      thinning: 0,
      streamline: 0.62 + (1 + strokeWidth) / 8 * 0.06,
      smoothing: 0.62,
      simulatePressure: false,
      easing: EASINGS.linear
    };
  };
  function getFreehandOptions(shape, strokeWidth, forceComplete, forceSolid) {
    return __spreadProps(__spreadValues({}, forceSolid ? solidSettings(strokeWidth) : shape.props.dash === "draw" ? shape.props.isPen ? realPressureSettings(strokeWidth) : simulatePressureSettings(strokeWidth) : solidSettings(strokeWidth)), {
      last: shape.props.isComplete || forceComplete
    });
  }
  function getPointsFromSegments(segments) {
    const points2 = [];
    for (const segment of segments) {
      if (segment.type === "free" || segment.points.length < 2) {
        points2.push(...segment.points.map(Vec2d.Cast));
      } else {
        const pointsToInterpolate = Math.max(
          4,
          Math.floor(Vec2d.Dist(segment.points[0], segment.points[1]) / 16)
        );
        points2.push(...Vec2d.PointsBetween(segment.points[0], segment.points[1], pointsToInterpolate));
      }
    }
    return points2;
  }
  function getDrawShapeStrokeDashArray(shape, strokeWidth) {
    return {
      draw: "none",
      solid: `none`,
      dotted: `0.1 ${strokeWidth * 2}`,
      dashed: `${strokeWidth * 2} ${strokeWidth * 2}`
    }[shape.props.dash];
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLDrawUtil/TLDrawUtil.tsx
  var import_jsx_runtime8 = __toESM(require_jsx_runtime());
  var TLDrawUtil = class extends TLShapeUtil {
    constructor() {
      super(...arguments);
      __publicField(this, "hideResizeHandles", (shape) => this.getIsDot(shape));
      __publicField(this, "hideRotateHandle", (shape) => this.getIsDot(shape));
      __publicField(this, "hideSelectionBoundsBg", (shape) => this.getIsDot(shape));
      __publicField(this, "hideSelectionBoundsFg", (shape) => this.getIsDot(shape));
      __publicField(this, "isClosed", (shape) => shape.props.isClosed);
      __publicField(this, "onResize", (shape, info) => {
        const { scaleX, scaleY } = info;
        const newSegments = [];
        for (const segment of shape.props.segments) {
          newSegments.push(__spreadProps(__spreadValues({}, segment), {
            points: segment.points.map(({ x: x3, y: y3, z: z2 }) => {
              return {
                x: scaleX * x3,
                y: scaleY * y3,
                z: z2
              };
            })
          }));
        }
        return {
          props: {
            segments: newSegments
          }
        };
      });
    }
    defaultProps() {
      return {
        segments: [],
        color: "black",
        fill: "none",
        dash: "draw",
        size: "m",
        opacity: "1",
        isComplete: false,
        isClosed: false,
        isPen: false
      };
    }
    getIsDot(shape) {
      return shape.props.segments.length === 1 && shape.props.segments[0].points.length < 2;
    }
    getBounds(shape) {
      return Box2d.FromPoints(this.outline(shape));
    }
    getOutline(shape) {
      return getPointsFromSegments(shape.props.segments);
    }
    getCenter(shape) {
      return this.bounds(shape).center;
    }
    hitTestPoint(shape, point2) {
      const outline = this.outline(shape);
      const zoomLevel = this.app.zoomLevel;
      const offsetDist = this.app.getStrokeWidth(shape.props.size) / zoomLevel;
      if (shape.props.segments.length === 1 && shape.props.segments[0].points.length < 4) {
        if (shape.props.segments[0].points.some((pt) => Vec2d.Dist(point2, pt) < offsetDist * 1.5)) {
          return true;
        }
      }
      if (this.isClosed(shape)) {
        return pointInPolygon(point2, outline);
      }
      if (this.bounds(shape).containsPoint(point2)) {
        for (let i3 = 0; i3 < outline.length; i3++) {
          const C2 = outline[i3];
          const D3 = outline[(i3 + 1) % outline.length];
          if (Vec2d.DistanceToLineSegment(C2, D3, point2) < offsetDist)
            return true;
        }
      }
      return false;
    }
    hitTestLineSegment(shape, A2, B) {
      const outline = this.outline(shape);
      if (shape.props.segments.length === 1 && shape.props.segments[0].points.length < 4) {
        const zoomLevel = this.app.zoomLevel;
        const offsetDist = this.app.getStrokeWidth(shape.props.size) / zoomLevel;
        if (shape.props.segments[0].points.some(
          (pt) => Vec2d.DistanceToLineSegment(A2, B, pt) < offsetDist * 1.5
        )) {
          return true;
        }
      }
      if (this.isClosed(shape)) {
        for (let i3 = 0; i3 < outline.length; i3++) {
          const C2 = outline[i3];
          const D3 = outline[(i3 + 1) % outline.length];
          if (linesIntersect(A2, B, C2, D3))
            return true;
        }
      } else {
        for (let i3 = 0; i3 < outline.length - 1; i3++) {
          const C2 = outline[i3];
          const D3 = outline[i3 + 1];
          if (linesIntersect(A2, B, C2, D3))
            return true;
        }
      }
      return false;
    }
    render(shape) {
      var _a5;
      const forceSolid = useForceSolid();
      const strokeWidth = this.app.getStrokeWidth(shape.props.size);
      const allPointsFromSegments = getPointsFromSegments(shape.props.segments);
      const showAsComplete = shape.props.isComplete || ((_a5 = last(shape.props.segments)) == null ? void 0 : _a5.type) === "straight";
      let sw = strokeWidth;
      if (!forceSolid && !shape.props.isPen && shape.props.dash === "draw" && allPointsFromSegments.length === 1) {
        sw += rng(shape.id)() * (strokeWidth / 6);
      }
      const options = getFreehandOptions(shape, sw, showAsComplete, forceSolid);
      const strokePoints = getStrokePoints(allPointsFromSegments, options);
      const solidStrokePath = strokePoints.length > 1 ? getSvgPathFromStrokePoints(strokePoints, shape.props.isClosed) : getDot(allPointsFromSegments[0], sw);
      if (!forceSolid && shape.props.dash === "draw" || strokePoints.length < 2) {
        setStrokePointRadii(strokePoints, options);
        const strokeOutlinePoints = getStrokeOutlinePoints(strokePoints, options);
        return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(SVGContainer, { id: shape.id, children: [
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
            ShapeFill,
            {
              fill: shape.props.isClosed ? shape.props.fill : "none",
              color: shape.props.color,
              d: solidStrokePath
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
            "path",
            {
              d: getSvgPathFromStroke(strokeOutlinePoints, true),
              strokeLinecap: "round",
              fill: "currentColor"
            }
          )
        ] });
      }
      return /* @__PURE__ */ (0, import_jsx_runtime8.jsxs)(SVGContainer, { id: shape.id, children: [
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
          ShapeFill,
          {
            color: shape.props.color,
            fill: shape.props.isClosed ? shape.props.fill : "none",
            d: solidStrokePath
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime8.jsx)(
          "path",
          {
            d: solidStrokePath,
            strokeLinecap: "round",
            fill: "none",
            stroke: "currentColor",
            strokeWidth,
            strokeDasharray: getDrawShapeStrokeDashArray(shape, strokeWidth),
            strokeDashoffset: "0"
          }
        )
      ] });
    }
    indicator(shape) {
      var _a5;
      const forceSolid = useForceSolid();
      const strokeWidth = this.app.getStrokeWidth(shape.props.size);
      const allPointsFromSegments = getPointsFromSegments(shape.props.segments);
      let sw = strokeWidth;
      if (!forceSolid && !shape.props.isPen && shape.props.dash === "draw" && allPointsFromSegments.length === 1) {
        sw += rng(shape.id)() * (strokeWidth / 6);
      }
      const showAsComplete = shape.props.isComplete || ((_a5 = last(shape.props.segments)) == null ? void 0 : _a5.type) === "straight";
      const options = getFreehandOptions(shape, sw, showAsComplete, true);
      const strokePoints = getStrokePoints(allPointsFromSegments, options);
      const solidStrokePath = strokePoints.length > 1 ? getSvgPathFromStrokePoints(strokePoints, shape.props.isClosed) : getDot(allPointsFromSegments[0], sw);
      return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("path", { d: solidStrokePath });
    }
    toSvg(shape, _font, colors) {
      var _a5;
      const { color } = shape.props;
      const strokeWidth = this.app.getStrokeWidth(shape.props.size);
      const allPointsFromSegments = getPointsFromSegments(shape.props.segments);
      const showAsComplete = shape.props.isComplete || ((_a5 = last(shape.props.segments)) == null ? void 0 : _a5.type) === "straight";
      let sw = strokeWidth;
      if (!shape.props.isPen && shape.props.dash === "draw" && allPointsFromSegments.length === 1) {
        sw += rng(shape.id)() * (strokeWidth / 6);
      }
      const options = getFreehandOptions(shape, sw, showAsComplete, false);
      const strokePoints = getStrokePoints(allPointsFromSegments, options);
      const solidStrokePath = strokePoints.length > 1 ? getSvgPathFromStrokePoints(strokePoints, shape.props.isClosed) : getDot(allPointsFromSegments[0], sw);
      let foregroundPath;
      if (shape.props.dash === "draw" || strokePoints.length < 2) {
        setStrokePointRadii(strokePoints, options);
        const strokeOutlinePoints = getStrokeOutlinePoints(strokePoints, options);
        const p3 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        p3.setAttribute("d", getSvgPathFromStroke(strokeOutlinePoints, true));
        p3.setAttribute("fill", colors.fill[color]);
        p3.setAttribute("stroke-linecap", "round");
        foregroundPath = p3;
      } else {
        const p3 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        p3.setAttribute("d", solidStrokePath);
        p3.setAttribute("stroke", colors.fill[color]);
        p3.setAttribute("fill", "none");
        p3.setAttribute("stroke-linecap", "round");
        p3.setAttribute("stroke-width", strokeWidth.toString());
        p3.setAttribute("stroke-dasharray", getDrawShapeStrokeDashArray(shape, strokeWidth));
        p3.setAttribute("stroke-dashoffset", "0");
        foregroundPath = p3;
      }
      const fillPath = getShapeFillSvg({
        fill: shape.props.isClosed ? shape.props.fill : "none",
        d: solidStrokePath,
        color: shape.props.color,
        colors
      });
      if (fillPath) {
        const g3 = document.createElementNS("http://www.w3.org/2000/svg", "g");
        g3.appendChild(fillPath);
        g3.appendChild(foregroundPath);
        return g3;
      }
      return foregroundPath;
    }
    expandSelectionOutlinePx(shape) {
      const multiplier = shape.props.dash === "draw" ? 1.6 : 1;
      return this.app.getStrokeWidth(shape.props.size) * multiplier / 2;
    }
  };
  __publicField(TLDrawUtil, "type", "draw");
  var TLDrawShapeDef = defineShape({
    type: "draw",
    getShapeUtil: () => TLDrawUtil,
    migrations: drawShapeMigrations,
    validator: drawShapeTypeValidator
  });
  function getDot(point2, sw) {
    const r3 = (sw + 1) * 0.5;
    return `M ${point2.x} ${point2.y} m -${r3}, 0 a ${r3},${r3} 0 1,0 ${r3 * 2},0 a ${r3},${r3} 0 1,0 -${r3 * 2},0`;
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLEmbedUtil/TLEmbedUtil.tsx
  var React20 = __toESM(require_react());
  var import_react32 = __toESM(require_react());

  // ../../../packages/editor/src/lib/hooks/useEditorComponents.tsx
  var import_react31 = __toESM(require_react());

  // ../../../packages/editor/src/lib/components/DefaultBackground.tsx
  var import_jsx_runtime9 = __toESM(require_jsx_runtime());
  function DefaultBackground() {
    return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)("div", { className: "tl-background" });
  }

  // ../../../packages/editor/src/lib/components/DefaultBrush.tsx
  var import_react11 = __toESM(require_react());

  // ../../../packages/editor/src/lib/hooks/useTransform.ts
  var import_react10 = __toESM(require_react());
  function useTransform(ref, x3, y3, scale, rotate, additionalOffset) {
    (0, import_react10.useLayoutEffect)(() => {
      const elm = ref.current;
      if (!elm)
        return;
      if (x3 === void 0)
        return;
      let trans = `translate(${x3}px, ${y3}px)`;
      if (scale !== void 0) {
        trans += ` scale(${scale})`;
      }
      if (rotate !== void 0) {
        trans += ` rotate(${rotate}rad)`;
      }
      if (additionalOffset) {
        trans += ` translate(${additionalOffset.x}px, ${additionalOffset.y}px)`;
      }
      elm.style.transform = trans;
    });
  }

  // ../../../packages/editor/src/lib/components/DefaultBrush.tsx
  var import_jsx_runtime10 = __toESM(require_jsx_runtime());
  var DefaultBrush = ({ brush, color, opacity }) => {
    const rSvg = (0, import_react11.useRef)(null);
    useTransform(rSvg, brush.x, brush.y);
    return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)("svg", { className: "tl-overlays__item", ref: rSvg, children: color ? /* @__PURE__ */ (0, import_jsx_runtime10.jsxs)("g", { className: "tl-brush", opacity, children: [
      /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
        "rect",
        {
          width: toDomPrecision(Math.max(1, brush.w)),
          height: toDomPrecision(Math.max(1, brush.h)),
          fill: color,
          opacity: 0.75
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
        "rect",
        {
          width: toDomPrecision(Math.max(1, brush.w)),
          height: toDomPrecision(Math.max(1, brush.h)),
          fill: "none",
          stroke: color,
          opacity: 0.1
        }
      )
    ] }) : /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(
      "rect",
      {
        className: "tl-brush tl-brush__default",
        width: toDomPrecision(Math.max(1, brush.w)),
        height: toDomPrecision(Math.max(1, brush.h))
      }
    ) });
  };

  // ../../../packages/editor/src/lib/components/DefaultCollaboratorHint.tsx
  var import_classnames2 = __toESM(require_classnames());
  var import_react12 = __toESM(require_react());
  var import_jsx_runtime11 = __toESM(require_jsx_runtime());
  var DefaultCollaboratorHint = ({
    className,
    zoom,
    point: point2,
    color,
    viewport,
    opacity = 1
  }) => {
    const rSvg = (0, import_react12.useRef)(null);
    useTransform(
      rSvg,
      clamp(point2.x, viewport.minX + 5 / zoom, viewport.maxX - 5 / zoom),
      clamp(point2.y, viewport.minY + 5 / zoom, viewport.maxY - 5 / zoom),
      1 / zoom,
      Vec2d.Angle(viewport.center, point2)
    );
    return /* @__PURE__ */ (0, import_jsx_runtime11.jsxs)("svg", { ref: rSvg, className: (0, import_classnames2.default)("tl-overlays__item", className), children: [
      /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("use", { href: "#cursor_hint", color, strokeWidth: 3, stroke: "var(--color-background)" }),
      /* @__PURE__ */ (0, import_jsx_runtime11.jsx)("use", { href: "#cursor_hint", color, opacity })
    ] });
  };

  // ../../../packages/editor/src/lib/components/DefaultCursor.tsx
  var import_classnames3 = __toESM(require_classnames());
  var import_react13 = __toESM(require_react());
  var import_jsx_runtime12 = __toESM(require_jsx_runtime());
  var _Cursor = ({ className, zoom, point: point2, color, name }) => {
    const rDiv = (0, import_react13.useRef)(null);
    useTransform(rDiv, point2 == null ? void 0 : point2.x, point2 == null ? void 0 : point2.y, 1 / zoom);
    if (!point2)
      return null;
    return /* @__PURE__ */ (0, import_jsx_runtime12.jsxs)("div", { ref: rDiv, className: (0, import_classnames3.default)("tl-overlays__item", className), children: [
      /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("svg", { className: "tl-cursor", children: /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("use", { href: "#cursor", color }) }),
      name !== null && name !== "" && /* @__PURE__ */ (0, import_jsx_runtime12.jsx)("div", { className: "tl-nametag", style: { backgroundColor: color }, children: name })
    ] });
  };
  var DefaultCursor = (0, import_react13.memo)(_Cursor);

  // ../../../packages/editor/src/lib/components/DefaultErrorFallback.tsx
  var import_classnames7 = __toESM(require_classnames());
  var import_react30 = __toESM(require_react());

  // ../../../packages/editor/src/lib/utils/runtime.ts
  var runtime = {
    openWindow: (url, target) => window.open(url, target, "noopener noreferrer"),
    refreshPage: () => window.location.reload(),
    hardReset: () => __async(void 0, null, function* () {
      var _a5;
      return yield (_a5 = window.__tldraw__hardReset) == null ? void 0 : _a5.call(window);
    })
  };
  function setRuntimeOverrides(input) {
    Object.assign(runtime, input);
  }

  // ../../../packages/editor/src/lib/utils/hard-reset.ts
  function hardResetApp() {
    runtime.hardReset();
  }

  // ../../../packages/editor/src/lib/utils/refresh-page.ts
  function refreshPage() {
    runtime.refreshPage();
  }

  // ../../../packages/editor/src/lib/components/Canvas.tsx
  var React18 = __toESM(require_react());

  // ../../../packages/editor/src/lib/hooks/useCanvasEvents.ts
  var import_react14 = __toESM(require_react());

  // ../../../packages/editor/src/lib/utils/assets.ts
  var import_lodash2 = __toESM(require_lodash2());

  // ../../../packages/editor/src/lib/utils/is-gif-animated.ts
  function getDataBlocksLength(buffer, offset) {
    let length = 0;
    while (buffer[offset + length]) {
      length += buffer[offset + length] + 1;
    }
    return length + 1;
  }
  function isGIF(buffer) {
    const enc = new TextDecoder("ascii");
    const header = enc.decode(buffer.slice(0, 3));
    return header === "GIF";
  }
  function isAnimated(buffer) {
    const view = new Uint8Array(buffer);
    let hasColorTable, colorTableSize;
    let offset = 0;
    let imagesCount = 0;
    if (!isGIF(buffer)) {
      return false;
    }
    hasColorTable = view[10] & 128;
    colorTableSize = view[10] & 7;
    offset += 6;
    offset += 7;
    offset += hasColorTable ? 3 * Math.pow(2, colorTableSize + 1) : 0;
    while (imagesCount < 2 && offset < view.length) {
      switch (view[offset]) {
        case 44:
          imagesCount += 1;
          hasColorTable = view[offset + 9] & 128;
          colorTableSize = view[offset + 9] & 7;
          offset += 10;
          offset += hasColorTable ? 3 * Math.pow(2, colorTableSize + 1) : 0;
          offset += getDataBlocksLength(view, offset + 1) + 1;
          break;
        case 33:
          offset += 2;
          offset += getDataBlocksLength(view, offset);
          break;
        case 59:
          offset = view.length;
          break;
        default:
          offset = view.length;
          break;
      }
    }
    return imagesCount > 1;
  }

  // ../../../node_modules/crc/mjs/calculators/crc32.js
  var TABLE = [
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918e3,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
  ];
  if (typeof Int32Array !== "undefined") {
    TABLE = new Int32Array(TABLE);
  }
  var crc32 = (current, previous) => {
    let crc2 = previous === 0 ? 0 : ~~previous ^ -1;
    for (let index2 = 0; index2 < current.length; index2++) {
      crc2 = TABLE[(crc2 ^ current[index2]) & 255] ^ crc2 >>> 8;
    }
    return crc2 ^ -1;
  };
  var crc32_default = crc32;

  // ../../../node_modules/crc/mjs/create_buffer.js
  var import_buffer = __toESM(require_buffer(), 1);
  var createBuffer = (value, encoding) => import_buffer.Buffer.from(value, encoding);
  var create_buffer_default = createBuffer;

  // ../../../node_modules/crc/mjs/define_crc.js
  function defineCrc(model2, calculator) {
    const result = (value, previous) => calculator(create_buffer_default(value), previous) >>> 0;
    result.signed = (value, previous) => calculator(create_buffer_default(value), previous);
    result.unsigned = result;
    result.model = model2;
    return result;
  }

  // ../../../node_modules/crc/mjs/crc32.js
  var crc32_default2 = defineCrc("crc-32", crc32_default);

  // ../../../packages/editor/src/lib/utils/png.ts
  function isPng(view, offset) {
    if (view.getUint8(offset + 0) === 137 && view.getUint8(offset + 1) === 80 && view.getUint8(offset + 2) === 78 && view.getUint8(offset + 3) === 71 && view.getUint8(offset + 4) === 13 && view.getUint8(offset + 5) === 10 && view.getUint8(offset + 6) === 26 && view.getUint8(offset + 7) === 10) {
      return true;
    }
    return false;
  }
  function getChunkType(view, offset) {
    return [
      String.fromCharCode(view.getUint8(offset)),
      String.fromCharCode(view.getUint8(offset + 1)),
      String.fromCharCode(view.getUint8(offset + 2)),
      String.fromCharCode(view.getUint8(offset + 3))
    ].join("");
  }
  function crc(arrayBuffer) {
    return crc32_default2(arrayBuffer);
  }
  var LEN_SIZE = 4;
  var CRC_SIZE = 4;
  function readChunks(view, offset = 0) {
    const chunks = {};
    if (!isPng(view, offset)) {
      throw new Error("Not a PNG");
    }
    offset += 8;
    while (offset <= view.buffer.byteLength) {
      const start = offset;
      const len = view.getInt32(offset);
      offset += 4;
      const chunkType = getChunkType(view, offset);
      if (chunkType === "IDAT" && chunks[chunkType]) {
        offset += len + LEN_SIZE + CRC_SIZE;
        continue;
      }
      if (chunkType === "IEND") {
        break;
      }
      chunks[chunkType] = {
        start,
        dataOffset: offset + 4,
        size: len
      };
      offset += len + LEN_SIZE + CRC_SIZE;
    }
    return chunks;
  }
  function parsePhys(view, offset) {
    return {
      ppux: view.getUint32(offset),
      ppuy: view.getUint32(offset + 4),
      unit: view.getUint8(offset + 4)
    };
  }
  function findChunk(view, type) {
    const chunks = readChunks(view);
    return chunks[type];
  }
  function setPhysChunk(view, dpr = 1, options) {
    let offset = 46;
    let size = 0;
    const res1 = findChunk(view, "pHYs");
    if (res1) {
      offset = res1.start;
      size = res1.size;
    }
    const res2 = findChunk(view, "IDAT");
    if (res2) {
      offset = res2.start;
      size = 0;
    }
    const pHYsData = new ArrayBuffer(21);
    const pHYsDataView = new DataView(pHYsData);
    pHYsDataView.setUint32(0, 9);
    pHYsDataView.setUint8(4, "p".charCodeAt(0));
    pHYsDataView.setUint8(5, "H".charCodeAt(0));
    pHYsDataView.setUint8(6, "Y".charCodeAt(0));
    pHYsDataView.setUint8(7, "s".charCodeAt(0));
    const DPI_96 = 2835.5;
    pHYsDataView.setInt32(8, DPI_96 * dpr);
    pHYsDataView.setInt32(12, DPI_96 * dpr);
    pHYsDataView.setInt8(16, 1);
    const crcBit = new Uint8Array(pHYsData.slice(4, 17));
    pHYsDataView.setInt32(17, crc(crcBit));
    const startBuf = view.buffer.slice(0, offset);
    const endBuf = view.buffer.slice(offset + size);
    return new Blob([startBuf, pHYsData, endBuf], options);
  }

  // ../../../packages/editor/src/lib/utils/assets.ts
  var ACCEPTED_IMG_TYPE = ["image/jpeg", "image/png", "image/gif", "image/svg+xml"];
  var ACCEPTED_VID_TYPE = ["video/mp4", "video/quicktime"];
  var ACCEPTED_ASSET_TYPE = ACCEPTED_IMG_TYPE.concat(ACCEPTED_VID_TYPE).join(", ");
  var isImage = (ext) => ACCEPTED_IMG_TYPE.includes(ext);
  function getVideoSizeFromSrc(src) {
    return __async(this, null, function* () {
      return yield new Promise((resolve, reject) => {
        const video = document.createElement("video");
        video.onloadeddata = () => resolve({ w: video.videoWidth, h: video.videoHeight });
        video.onerror = (e2) => {
          console.error(e2);
          reject(new Error("Could not get video size"));
        };
        video.crossOrigin = "anonymous";
        video.src = src;
      });
    });
  }
  function base64ToFile(dataURL) {
    return __async(this, null, function* () {
      return fetch(dataURL).then(function(result) {
        return result.arrayBuffer();
      });
    });
  }
  function getImageSizeFromSrc(dataURL) {
    return __async(this, null, function* () {
      return yield new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => __async(this, null, function* () {
          try {
            const blob = yield base64ToFile(dataURL);
            const view = new DataView(blob);
            if (isPng(view, 0)) {
              const physChunk = findChunk(view, "pHYs");
              if (physChunk) {
                const physData = parsePhys(view, physChunk.dataOffset);
                if (physData.unit === 0 && physData.ppux === physData.ppuy) {
                  const pixelRatio = Math.round(physData.ppux / 2834.5);
                  resolve({ w: img.width / pixelRatio, h: img.height / pixelRatio });
                  return;
                }
              }
            }
            resolve({ w: img.width, h: img.height });
          } catch (err) {
            console.error(err);
            resolve({ w: img.width, h: img.height });
          }
        });
        img.onerror = (err) => {
          console.error(err);
          reject(new Error("Could not get image size"));
        };
        img.crossOrigin = "anonymous";
        img.src = dataURL;
      });
    });
  }
  function getResizedImageDataUrl(dataURLForImage, width, height) {
    return __async(this, null, function* () {
      return yield new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");
          if (!ctx)
            return;
          canvas.width = width * 2;
          canvas.height = height * 2;
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          const newDataURL = canvas.toDataURL();
          resolve(newDataURL);
        };
        img.crossOrigin = "anonymous";
        img.src = dataURLForImage;
      });
    });
  }
  function getMediaAssetFromFile(file) {
    return __async(this, null, function* () {
      return yield new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onerror = () => reject(reader.error);
        reader.onload = () => __async(this, null, function* () {
          let dataUrl = reader.result;
          const isImageType = isImage(file.type);
          const sizeFn = isImageType ? getImageSizeFromSrc : getVideoSizeFromSrc;
          if (file.type === "video/quicktime" && dataUrl.includes("video/quicktime")) {
            dataUrl = dataUrl.replace("video/quicktime", "video/mp4");
          }
          const originalSize = yield sizeFn(dataUrl);
          const size = containBoxSize(originalSize, { w: MAX_ASSET_WIDTH, h: MAX_ASSET_HEIGHT });
          if (size !== originalSize && (file.type === "image/jpeg" || file.type === "image/png")) {
            dataUrl = yield getResizedImageDataUrl(dataUrl, size.w, size.h);
          }
          const assetId = TLAsset.createCustomId(getHashForString(dataUrl));
          const metadata = yield getFileMetaData(file);
          const asset = {
            id: assetId,
            type: isImageType ? "image" : "video",
            typeName: "asset",
            props: {
              name: file.name,
              src: dataUrl,
              w: size.w,
              h: size.h,
              mimeType: file.type,
              isAnimated: metadata.isAnimated
            }
          };
          resolve(asset);
        });
        reader.readAsDataURL(file);
      });
    });
  }
  function getFileMetaData(file) {
    return __async(this, null, function* () {
      if (file.type === "image/gif") {
        return yield new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onerror = () => reject(reader.error);
          reader.onload = () => {
            resolve({
              isAnimated: reader.result ? isAnimated(reader.result) : false
            });
          };
          reader.readAsArrayBuffer(file);
        });
      }
      return {
        isAnimated: isImage(file.type) ? false : true
      };
    });
  }
  function containBoxSize(originalSize, containBoxSize2) {
    const overByXScale = originalSize.w / containBoxSize2.w;
    const overByYScale = originalSize.h / containBoxSize2.h;
    if (overByXScale <= 1 && overByYScale <= 1) {
      return originalSize;
    } else if (overByXScale > overByYScale) {
      return {
        w: originalSize.w / overByXScale,
        h: originalSize.h / overByXScale
      };
    } else {
      return {
        w: originalSize.w / overByYScale,
        h: originalSize.h / overByYScale
      };
    }
  }
  function createShapesFromFiles(app, files, position, _ignoreParent = false) {
    return __async(this, null, function* () {
      const pagePoint = new Vec2d(position.x, position.y);
      const newAssetsForFiles = /* @__PURE__ */ new Map();
      const shapePartials = yield Promise.all(
        files.map((file, i3) => __async(this, null, function* () {
          if (!file.type)
            throw new Error("No mime type");
          if (!ACCEPTED_IMG_TYPE.concat(ACCEPTED_VID_TYPE).includes(file.type)) {
            console.warn(`${file.name} not loaded - Extension not allowed.`);
            return null;
          }
          try {
            const asset = yield app.onCreateAssetFromFile(file);
            if (asset.type === "bookmark")
              return;
            if (!asset)
              throw Error("Could not create an asset");
            newAssetsForFiles.set(file, asset);
            const shapePartial = {
              id: createShapeId(),
              type: asset.type,
              x: pagePoint.x + i3,
              y: pagePoint.y,
              props: {
                w: asset.props.w,
                h: asset.props.h,
                opacity: "1"
              }
            };
            return shapePartial;
          } catch (error) {
            console.error(error);
            return null;
          }
        }))
      );
      const results = compact(shapePartials).sort((a3, b3) => a3.x - b3.x);
      if (results.length === 0)
        return;
      for (let i3 = 0; i3 < results.length; i3++) {
        const model2 = results[i3];
        if (i3 === 0) {
          model2.x -= model2.props.w / 2;
          model2.y -= model2.props.h / 2;
        } else {
          const prevModel = results[i3 - 1];
          model2.x = prevModel.x + prevModel.props.w;
          model2.y = prevModel.y;
        }
      }
      const shapeUpdates = yield Promise.all(
        files.map((file, i3) => __async(this, null, function* () {
          const shape = results[i3];
          if (!shape)
            return;
          const asset = newAssetsForFiles.get(file);
          if (!asset)
            return;
          let existing = app.getAssetById(asset.id);
          if (existing) {
            newAssetsForFiles.delete(file);
            if (shape.props) {
              shape.props.assetId = existing.id;
            }
            return shape;
          }
          existing = app.getAssetBySrc(asset.props.src);
          if (existing) {
            if (shape.props) {
              shape.props.assetId = existing.id;
            }
            return shape;
          }
          if (shape.props) {
            shape.props.assetId = asset.id;
          }
          return shape;
        }))
      );
      const filteredUpdates = shapeUpdates.filter(isNonNullish);
      app.createAssets(compact([...newAssetsForFiles.values()]));
      app.createShapes(filteredUpdates);
      app.setSelectedIds(filteredUpdates.map((s3) => s3.id));
      const { selectedIds, viewportPageBounds } = app;
      const pageBounds = Box2d.Common(compact(selectedIds.map((id) => app.getPageBoundsById(id))));
      if (pageBounds && !viewportPageBounds.contains(pageBounds)) {
        app.zoomToSelection();
      }
    });
  }
  function createEmbedShapeAtPoint(app, url, point2, props) {
    app.createShapes(
      [
        {
          id: createShapeId(),
          type: "embed",
          x: point2.x - (props.width || 450) / 2,
          y: point2.y - (props.height || 450) / 2,
          props: {
            w: props.width,
            h: props.height,
            doesResize: props.doesResize,
            url,
            opacity: "1"
          }
        }
      ],
      true
    );
  }
  function createBookmarkShapeAtPoint(app, url, point2) {
    return __async(this, null, function* () {
      const assetId = TLAsset.createCustomId(getHashForString(url));
      const existing = app.getAssetById(assetId);
      if (existing) {
        app.createShapes([
          {
            id: app.createShapeId(),
            type: "bookmark",
            x: point2.x - 150,
            y: point2.y - 160,
            props: {
              assetId: existing.id,
              url: existing.props.src,
              opacity: "1"
            }
          }
        ]);
        return;
      }
      app.batch(() => __async(this, null, function* () {
        const shapeId = createShapeId();
        app.createShapes(
          [
            {
              id: shapeId,
              type: "bookmark",
              x: point2.x,
              y: point2.y,
              props: {
                url,
                opacity: "1"
              }
            }
          ],
          true
        );
        const meta = yield app.onCreateBookmarkFromUrl(url);
        if (meta) {
          app.createAssets([
            {
              id: assetId,
              typeName: "asset",
              type: "bookmark",
              props: {
                src: url,
                description: meta.description,
                image: meta.image,
                title: meta.title
              }
            }
          ]);
          app.updateShapes([
            {
              id: shapeId,
              type: "bookmark",
              props: {
                assetId,
                opacity: "1"
              }
            }
          ]);
        }
      }));
    });
  }
  function createAssetShapeAtPoint(app, svgString, point2) {
    return __async(this, null, function* () {
      const svg = new DOMParser().parseFromString(svgString, "image/svg+xml").querySelector("svg");
      if (!svg) {
        throw new Error("No <svg/> element present");
      }
      let width = parseFloat(svg.getAttribute("width") || "0");
      let height = parseFloat(svg.getAttribute("height") || "0");
      if (!(width && height)) {
        document.body.appendChild(svg);
        const box = svg.getBoundingClientRect();
        document.body.removeChild(svg);
        width = box.width;
        height = box.height;
      }
      const asset = yield app.onCreateAssetFromFile(
        new File([svgString], "asset.svg", { type: "image/svg+xml" })
      );
      if (asset.type !== "bookmark") {
        asset.props.w = width;
        asset.props.h = height;
      }
      app.batch(() => {
        app.createAssets([asset]);
        app.createShapes(
          [
            {
              id: createShapeId(),
              type: "image",
              x: point2.x - width / 2,
              y: point2.y - height / 2,
              props: {
                assetId: asset.id,
                w: width,
                h: height,
                opacity: "1"
              }
            }
          ],
          true
        );
      });
    });
  }
  var isValidHttpURL = (url) => {
    try {
      const u3 = new URL(url);
      return u3.protocol === "http:" || u3.protocol === "https:";
    } catch (e2) {
      return false;
    }
  };
  var getValidHttpURLList = (url) => {
    const urls = url.split(/[\n\s]/);
    for (const url2 of urls) {
      try {
        const u3 = new URL(url2);
        if (!(u3.protocol === "http:" || u3.protocol === "https:")) {
          return;
        }
      } catch (e2) {
        return;
      }
    }
    return (0, import_lodash2.default)(urls);
  };
  var isSvgText = (text) => {
    return /^<svg/.test(text);
  };
  function dataUrlToFile(url, filename, mimeType) {
    return fetch(url).then(function(res) {
      return res.arrayBuffer();
    }).then(function(buf) {
      return new File([buf], filename, { type: mimeType });
    });
  }

  // ../../../packages/editor/src/lib/hooks/useCanvasEvents.ts
  function useCanvasEvents() {
    const app = useApp();
    const events = (0, import_react14.useMemo)(
      function canvasEvents() {
        let lastX, lastY;
        function onPointerDown(e2) {
          if (e2.isKilled)
            return;
          if (e2.button !== 0 && e2.button !== 1 && e2.button !== 5)
            return;
          setPointerCapture(e2.currentTarget, e2);
          app.dispatch(__spreadValues({
            type: "pointer",
            target: "canvas",
            name: "pointer_down"
          }, getPointerInfo(e2, app.getContainer())));
        }
        function onPointerMove(e2) {
          if (e2.isKilled)
            return;
          if (e2.clientX === lastX && e2.clientY === lastY)
            return;
          lastX = e2.clientX;
          lastY = e2.clientY;
          app.dispatch(__spreadValues({
            type: "pointer",
            target: "canvas",
            name: "pointer_move"
          }, getPointerInfo(e2, app.getContainer())));
        }
        function onPointerUp(e2) {
          if (e2.isKilled)
            return;
          if (e2.button !== 0 && e2.button !== 1 && e2.button !== 5)
            return;
          lastX = e2.clientX;
          lastY = e2.clientY;
          releasePointerCapture(e2.currentTarget, e2);
          app.dispatch(__spreadValues({
            type: "pointer",
            target: "canvas",
            name: "pointer_up"
          }, getPointerInfo(e2, app.getContainer())));
        }
        function onPointerEnter(e2) {
          if (e2.isKilled)
            return;
          app.dispatch(__spreadValues({
            type: "pointer",
            target: "canvas",
            name: "pointer_enter"
          }, getPointerInfo(e2, app.getContainer())));
        }
        function onPointerLeave(e2) {
          if (e2.isKilled)
            return;
          app.dispatch(__spreadValues({
            type: "pointer",
            target: "canvas",
            name: "pointer_leave"
          }, getPointerInfo(e2, app.getContainer())));
        }
        function onTouchStart(e2) {
          ;
          e2.isKilled = true;
          document.body.click();
          preventDefault(e2);
        }
        function onTouchEnd(e2) {
          ;
          e2.isKilled = true;
          if (e2.target.tagName !== "A" && e2.target.tagName !== "TEXTAREA") {
            preventDefault(e2);
          }
        }
        function onDragOver(e2) {
          preventDefault(e2);
        }
        function onDrop(e2) {
          return __async(this, null, function* () {
            var _a5, _b2;
            preventDefault(e2);
            if (!((_b2 = (_a5 = e2.dataTransfer) == null ? void 0 : _a5.files) == null ? void 0 : _b2.length))
              return;
            const files = Array.from(e2.dataTransfer.files).filter(
              (file) => !file.name.endsWith(".tldr")
            );
            yield createShapesFromFiles(app, files, app.screenToPage(e2.clientX, e2.clientY), false);
          });
        }
        return {
          onPointerDown,
          onPointerMove,
          onPointerUp,
          onPointerEnter,
          onPointerLeave,
          onDragOver,
          onDrop,
          onTouchStart,
          onTouchEnd
        };
      },
      [app]
    );
    return events;
  }

  // ../../../packages/editor/src/lib/hooks/useCoarsePointer.ts
  var import_react15 = __toESM(require_react());
  function useCoarsePointer() {
    const app = useApp();
    (0, import_react15.useEffect)(() => {
      const mql = window.matchMedia("(pointer: coarse)");
      const handler = () => {
        app.isCoarsePointer = mql.matches;
      };
      handler();
      mql.addEventListener("change", handler);
      return () => mql.removeEventListener("change", handler);
    }, [app]);
  }

  // ../../../packages/editor/src/lib/hooks/useDocumentEvents.ts
  var import_react17 = __toESM(require_react());

  // ../../../packages/editor/src/lib/hooks/useContainer.tsx
  var import_react16 = __toESM(require_react());
  var import_jsx_runtime13 = __toESM(require_jsx_runtime());
  var ContainerContext = (0, import_react16.createContext)(null);
  function ContainerProvider({
    container,
    children
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime13.jsx)(ContainerContext.Provider, { value: container, children });
  }
  function useContainer() {
    return assertExists((0, import_react16.useContext)(ContainerContext), "useContainer used outside of <Tldraw />");
  }

  // ../../../packages/editor/src/lib/hooks/useDocumentEvents.ts
  function useDocumentEvents() {
    const app = useApp();
    const container = useContainer();
    const isAppFocused = useValue("isFocused", () => app.isFocused, [app]);
    (0, import_react17.useEffect)(() => {
      if (!isAppFocused)
        return;
      const handleKeyDown = (e2) => {
        if (e2.altKey && (app.isIn("zoom") || !app.root.path.value.endsWith(".idle")) && !isFocusingInput()) {
          preventDefault(e2);
        }
        if (e2.isKilled)
          return;
        e2.isKilled = true;
        switch (e2.key) {
          case "=": {
            if (e2.metaKey || e2.ctrlKey) {
              preventDefault(e2);
              return;
            }
            break;
          }
          case "-": {
            if (e2.metaKey || e2.ctrlKey) {
              preventDefault(e2);
              return;
            }
            break;
          }
          case "0": {
            if (e2.metaKey || e2.ctrlKey) {
              preventDefault(e2);
              return;
            }
            break;
          }
          case "Tab": {
            if (isFocusingInput() || app.isMenuOpen) {
              return;
            }
            break;
          }
          case ",": {
            if (!isFocusingInput()) {
              preventDefault(e2);
              if (!app.inputs.keys.has("Comma")) {
                const { x: x3, y: y3, z: z2 } = app.inputs.currentScreenPoint;
                const {
                  pageState: { hoveredId }
                } = app;
                app.inputs.keys.add("Comma");
                const info2 = __spreadValues({
                  type: "pointer",
                  name: "pointer_down",
                  point: { x: x3, y: y3, z: z2 },
                  shiftKey: e2.shiftKey,
                  altKey: e2.altKey,
                  ctrlKey: e2.metaKey || e2.ctrlKey,
                  pointerId: 0,
                  button: 0,
                  isPen: app.isPenMode
                }, hoveredId ? {
                  target: "shape",
                  shape: app.getShapeById(hoveredId)
                } : {
                  target: "canvas"
                });
                app.dispatch(info2);
                return;
              }
            }
            break;
          }
          case "Escape": {
            if (!app.inputs.keys.has("Escape")) {
              app.inputs.keys.add("Escape");
              app.cancel();
              container.focus();
            }
            return;
          }
          default: {
            if (isFocusingInput() || app.isMenuOpen) {
              return;
            }
          }
        }
        const info = {
          type: "keyboard",
          name: app.inputs.keys.has(e2.code) ? "key_repeat" : "key_down",
          key: e2.key,
          code: e2.code,
          shiftKey: e2.shiftKey,
          altKey: e2.altKey,
          ctrlKey: e2.metaKey || e2.ctrlKey
        };
        app.dispatch(info);
      };
      const handleKeyUp = (e2) => {
        var _a5;
        if (e2.isKilled)
          return;
        e2.isKilled = true;
        if (isFocusingInput() || app.isMenuOpen) {
          return;
        }
        if (e2.key === ",") {
          if ((_a5 = document.activeElement) == null ? void 0 : _a5.ELEMENT_NODE)
            preventDefault(e2);
          if (app.inputs.keys.has(e2.code)) {
            const { x: x3, y: y3, z: z2 } = app.inputs.currentScreenPoint;
            const {
              pageState: { hoveredId }
            } = app;
            app.inputs.keys.delete(e2.code);
            const info2 = __spreadValues({
              type: "pointer",
              name: "pointer_up",
              point: { x: x3, y: y3, z: z2 },
              shiftKey: e2.shiftKey,
              altKey: e2.altKey,
              ctrlKey: e2.metaKey || e2.ctrlKey,
              pointerId: 0,
              button: 0,
              isPen: app.isPenMode
            }, hoveredId ? {
              target: "shape",
              shape: app.getShapeById(hoveredId)
            } : {
              target: "canvas"
            });
            app.dispatch(info2);
            return;
          }
        }
        const info = {
          type: "keyboard",
          name: "key_up",
          key: e2.key,
          code: e2.code,
          shiftKey: e2.shiftKey,
          altKey: e2.altKey,
          ctrlKey: e2.metaKey || e2.ctrlKey
        };
        app.dispatch(info);
      };
      function handleTouchStart(e2) {
        var _a5, _b2;
        if (container.contains(e2.target)) {
          const touchXPosition = e2.touches[0].pageX;
          const touchXRadius = e2.touches[0].radiusX || 0;
          if (touchXPosition - touchXRadius < 10 || touchXPosition + touchXRadius > app.viewportScreenBounds.width - 10) {
            if (((_a5 = e2.target) == null ? void 0 : _a5.tagName) === "BUTTON") {
              ;
              (_b2 = e2.target) == null ? void 0 : _b2.click();
            }
            preventDefault(e2);
          }
        }
      }
      const handleWheel = (e2) => {
        if (container.contains(e2.target) && (e2.ctrlKey || e2.metaKey)) {
          preventDefault(e2);
        }
      };
      function handleBlur() {
        app.complete();
      }
      function handleFocus() {
        app.updateViewportScreenBounds();
      }
      container.addEventListener("touchstart", handleTouchStart, { passive: false });
      document.addEventListener("wheel", handleWheel, { passive: false });
      document.addEventListener("gesturestart", preventDefault);
      document.addEventListener("gesturechange", preventDefault);
      document.addEventListener("gestureend", preventDefault);
      document.addEventListener("keydown", handleKeyDown);
      document.addEventListener("keyup", handleKeyUp);
      window.addEventListener("blur", handleBlur);
      window.addEventListener("focus", handleFocus);
      return () => {
        container.removeEventListener("touchstart", handleTouchStart);
        document.removeEventListener("wheel", handleWheel);
        document.removeEventListener("gesturestart", preventDefault);
        document.removeEventListener("gesturechange", preventDefault);
        document.removeEventListener("gestureend", preventDefault);
        document.removeEventListener("keydown", handleKeyDown);
        document.removeEventListener("keyup", handleKeyUp);
        window.removeEventListener("blur", handleBlur);
        window.removeEventListener("focus", handleFocus);
      };
    }, [app, container, isAppFocused]);
  }
  var INPUTS = ["input", "select", "button", "textarea"];
  function isFocusingInput() {
    const { activeElement } = document;
    if (activeElement && (activeElement.getAttribute("contenteditable") || INPUTS.indexOf(activeElement.tagName.toLowerCase()) > -1)) {
      return true;
    }
    return false;
  }

  // ../../../packages/editor/src/lib/hooks/useFixSafariDoubleTapZoomPencilEvents.ts
  var import_react18 = __toESM(require_react());
  var IGNORED_TAGS = ["textarea", "input"];
  function useFixSafariDoubleTapZoomPencilEvents(ref) {
    const app = useApp();
    (0, import_react18.useEffect)(() => {
      const elm = ref.current;
      if (!elm)
        return;
      const handleEvent = (e2) => {
        var _a5;
        if (e2 instanceof PointerEvent && e2.pointerType === "pen") {
          ;
          e2.isKilled = true;
          const { target } = e2;
          if (IGNORED_TAGS.includes((_a5 = target.tagName) == null ? void 0 : _a5.toLocaleLowerCase()) || app.isIn("select.editing_shape")) {
            return;
          }
          preventDefault(e2);
        }
      };
      elm.addEventListener("touchstart", handleEvent);
      elm.addEventListener("touchend", handleEvent);
      return () => {
        elm.removeEventListener("touchstart", handleEvent);
        elm.addEventListener("touchend", handleEvent);
      };
    }, [app, ref]);
  }

  // ../../../node_modules/@use-gesture/core/dist/maths-0ab39ae9.esm.js
  function clamp2(v3, min2, max) {
    return Math.max(min2, Math.min(v3, max));
  }
  var V = {
    toVector(v3, fallback) {
      if (v3 === void 0)
        v3 = fallback;
      return Array.isArray(v3) ? v3 : [v3, v3];
    },
    add(v1, v22) {
      return [v1[0] + v22[0], v1[1] + v22[1]];
    },
    sub(v1, v22) {
      return [v1[0] - v22[0], v1[1] - v22[1]];
    },
    addTo(v1, v22) {
      v1[0] += v22[0];
      v1[1] += v22[1];
    },
    subTo(v1, v22) {
      v1[0] -= v22[0];
      v1[1] -= v22[1];
    }
  };
  function rubberband(distance, dimension, constant) {
    if (dimension === 0 || Math.abs(dimension) === Infinity)
      return Math.pow(distance, constant * 5);
    return distance * dimension * constant / (dimension + constant * distance);
  }
  function rubberbandIfOutOfBounds(position, min2, max, constant = 0.15) {
    if (constant === 0)
      return clamp2(position, min2, max);
    if (position < min2)
      return -rubberband(min2 - position, max - min2, constant) + min2;
    if (position > max)
      return +rubberband(position - max, max - min2, constant) + max;
    return position;
  }
  function computeRubberband(bounds, [Vx, Vy], [Rx, Ry]) {
    const [[X0, X1], [Y0, Y1]] = bounds;
    return [rubberbandIfOutOfBounds(Vx, X0, X1, Rx), rubberbandIfOutOfBounds(Vy, Y0, Y1, Ry)];
  }

  // ../../../node_modules/@use-gesture/core/dist/actions-94b581a0.esm.js
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function ownKeys(object2, enumerableOnly) {
    var keys = Object.keys(object2);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object2);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = null != arguments[i3] ? arguments[i3] : {};
      i3 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var EVENT_TYPE_MAP = {
    pointer: {
      start: "down",
      change: "move",
      end: "up"
    },
    mouse: {
      start: "down",
      change: "move",
      end: "up"
    },
    touch: {
      start: "start",
      change: "move",
      end: "end"
    },
    gesture: {
      start: "start",
      change: "change",
      end: "end"
    }
  };
  function capitalize(string2) {
    if (!string2)
      return "";
    return string2[0].toUpperCase() + string2.slice(1);
  }
  var actionsWithoutCaptureSupported = ["enter", "leave"];
  function hasCapture(capture = false, actionKey) {
    return capture && !actionsWithoutCaptureSupported.includes(actionKey);
  }
  function toHandlerProp(device, action = "", capture = false) {
    const deviceProps = EVENT_TYPE_MAP[device];
    const actionKey = deviceProps ? deviceProps[action] || action : action;
    return "on" + capitalize(device) + capitalize(actionKey) + (hasCapture(capture, actionKey) ? "Capture" : "");
  }
  var pointerCaptureEvents = ["gotpointercapture", "lostpointercapture"];
  function parseProp(prop) {
    let eventKey = prop.substring(2).toLowerCase();
    const passive = !!~eventKey.indexOf("passive");
    if (passive)
      eventKey = eventKey.replace("passive", "");
    const captureKey = pointerCaptureEvents.includes(eventKey) ? "capturecapture" : "capture";
    const capture = !!~eventKey.indexOf(captureKey);
    if (capture)
      eventKey = eventKey.replace("capture", "");
    return {
      device: eventKey,
      capture,
      passive
    };
  }
  function toDomEventType(device, action = "") {
    const deviceProps = EVENT_TYPE_MAP[device];
    const actionKey = deviceProps ? deviceProps[action] || action : action;
    return device + actionKey;
  }
  function isTouch(event) {
    return "touches" in event;
  }
  function getPointerType(event) {
    if (isTouch(event))
      return "touch";
    if ("pointerType" in event)
      return event.pointerType;
    return "mouse";
  }
  function getCurrentTargetTouchList(event) {
    return Array.from(event.touches).filter((e2) => {
      var _event$currentTarget, _event$currentTarget$;
      return e2.target === event.currentTarget || ((_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 ? void 0 : (_event$currentTarget$ = _event$currentTarget.contains) === null || _event$currentTarget$ === void 0 ? void 0 : _event$currentTarget$.call(_event$currentTarget, e2.target));
    });
  }
  function distanceAngle(P1, P2) {
    try {
      const dx = P2.clientX - P1.clientX;
      const dy = P2.clientY - P1.clientY;
      const cx = (P2.clientX + P1.clientX) / 2;
      const cy = (P2.clientY + P1.clientY) / 2;
      const distance = Math.hypot(dx, dy);
      const angle = -(Math.atan2(dx, dy) * 180) / Math.PI;
      const origin = [cx, cy];
      return {
        angle,
        distance,
        origin
      };
    } catch (_unused) {
    }
    return null;
  }
  function touchIds(event) {
    return getCurrentTargetTouchList(event).map((touch) => touch.identifier);
  }
  function touchDistanceAngle(event, ids) {
    const [P1, P2] = Array.from(event.touches).filter((touch) => ids.includes(touch.identifier));
    return distanceAngle(P1, P2);
  }
  var LINE_HEIGHT = 40;
  var PAGE_HEIGHT = 800;
  function wheelValues(event) {
    let {
      deltaX,
      deltaY,
      deltaMode
    } = event;
    if (deltaMode === 1) {
      deltaX *= LINE_HEIGHT;
      deltaY *= LINE_HEIGHT;
    } else if (deltaMode === 2) {
      deltaX *= PAGE_HEIGHT;
      deltaY *= PAGE_HEIGHT;
    }
    return [deltaX, deltaY];
  }
  function getEventDetails(event) {
    const payload = {};
    if ("buttons" in event)
      payload.buttons = event.buttons;
    if ("shiftKey" in event) {
      const {
        shiftKey,
        altKey: altKey2,
        metaKey,
        ctrlKey
      } = event;
      Object.assign(payload, {
        shiftKey,
        altKey: altKey2,
        metaKey,
        ctrlKey
      });
    }
    return payload;
  }
  function call(v3, ...args) {
    if (typeof v3 === "function") {
      return v3(...args);
    } else {
      return v3;
    }
  }
  function noop() {
  }
  function chain(...fns) {
    if (fns.length === 0)
      return noop;
    if (fns.length === 1)
      return fns[0];
    return function() {
      let result;
      for (const fn of fns) {
        result = fn.apply(this, arguments) || result;
      }
      return result;
    };
  }
  function assignDefault(value, fallback) {
    return Object.assign({}, fallback, value || {});
  }
  var BEFORE_LAST_KINEMATICS_DELAY = 32;
  var Engine = class {
    constructor(ctrl, args, key) {
      this.ctrl = ctrl;
      this.args = args;
      this.key = key;
      if (!this.state) {
        this.state = {};
        this.computeValues([0, 0]);
        this.computeInitial();
        if (this.init)
          this.init();
        this.reset();
      }
    }
    get state() {
      return this.ctrl.state[this.key];
    }
    set state(state) {
      this.ctrl.state[this.key] = state;
    }
    get shared() {
      return this.ctrl.state.shared;
    }
    get eventStore() {
      return this.ctrl.gestureEventStores[this.key];
    }
    get timeoutStore() {
      return this.ctrl.gestureTimeoutStores[this.key];
    }
    get config() {
      return this.ctrl.config[this.key];
    }
    get sharedConfig() {
      return this.ctrl.config.shared;
    }
    get handler() {
      return this.ctrl.handlers[this.key];
    }
    reset() {
      const {
        state,
        shared,
        ingKey,
        args
      } = this;
      shared[ingKey] = state._active = state.active = state._blocked = state._force = false;
      state._step = [false, false];
      state.intentional = false;
      state._movement = [0, 0];
      state._distance = [0, 0];
      state._direction = [0, 0];
      state._delta = [0, 0];
      state._bounds = [[-Infinity, Infinity], [-Infinity, Infinity]];
      state.args = args;
      state.axis = void 0;
      state.memo = void 0;
      state.elapsedTime = state.timeDelta = 0;
      state.direction = [0, 0];
      state.distance = [0, 0];
      state.overflow = [0, 0];
      state._movementBound = [false, false];
      state.velocity = [0, 0];
      state.movement = [0, 0];
      state.delta = [0, 0];
      state.timeStamp = 0;
    }
    start(event) {
      const state = this.state;
      const config = this.config;
      if (!state._active) {
        this.reset();
        this.computeInitial();
        state._active = true;
        state.target = event.target;
        state.currentTarget = event.currentTarget;
        state.lastOffset = config.from ? call(config.from, state) : state.offset;
        state.offset = state.lastOffset;
        state.startTime = state.timeStamp = event.timeStamp;
      }
    }
    computeValues(values) {
      const state = this.state;
      state._values = values;
      state.values = this.config.transform(values);
    }
    computeInitial() {
      const state = this.state;
      state._initial = state._values;
      state.initial = state.values;
    }
    compute(event) {
      const {
        state,
        config,
        shared
      } = this;
      state.args = this.args;
      let dt = 0;
      if (event) {
        state.event = event;
        if (config.preventDefault && event.cancelable)
          state.event.preventDefault();
        state.type = event.type;
        shared.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size;
        shared.locked = !!document.pointerLockElement;
        Object.assign(shared, getEventDetails(event));
        shared.down = shared.pressed = shared.buttons % 2 === 1 || shared.touches > 0;
        dt = event.timeStamp - state.timeStamp;
        state.timeStamp = event.timeStamp;
        state.elapsedTime = state.timeStamp - state.startTime;
      }
      if (state._active) {
        const _absoluteDelta = state._delta.map(Math.abs);
        V.addTo(state._distance, _absoluteDelta);
      }
      if (this.axisIntent)
        this.axisIntent(event);
      const [_m0, _m1] = state._movement;
      const [t0, t1] = config.threshold;
      const {
        _step,
        values
      } = state;
      if (config.hasCustomTransform) {
        if (_step[0] === false)
          _step[0] = Math.abs(_m0) >= t0 && values[0];
        if (_step[1] === false)
          _step[1] = Math.abs(_m1) >= t1 && values[1];
      } else {
        if (_step[0] === false)
          _step[0] = Math.abs(_m0) >= t0 && Math.sign(_m0) * t0;
        if (_step[1] === false)
          _step[1] = Math.abs(_m1) >= t1 && Math.sign(_m1) * t1;
      }
      state.intentional = _step[0] !== false || _step[1] !== false;
      if (!state.intentional)
        return;
      const movement = [0, 0];
      if (config.hasCustomTransform) {
        const [v0, v1] = values;
        movement[0] = _step[0] !== false ? v0 - _step[0] : 0;
        movement[1] = _step[1] !== false ? v1 - _step[1] : 0;
      } else {
        movement[0] = _step[0] !== false ? _m0 - _step[0] : 0;
        movement[1] = _step[1] !== false ? _m1 - _step[1] : 0;
      }
      if (this.restrictToAxis && !state._blocked)
        this.restrictToAxis(movement);
      const previousOffset = state.offset;
      const gestureIsActive = state._active && !state._blocked || state.active;
      if (gestureIsActive) {
        state.first = state._active && !state.active;
        state.last = !state._active && state.active;
        state.active = shared[this.ingKey] = state._active;
        if (event) {
          if (state.first) {
            if ("bounds" in config)
              state._bounds = call(config.bounds, state);
            if (this.setup)
              this.setup();
          }
          state.movement = movement;
          this.computeOffset();
        }
      }
      const [ox, oy] = state.offset;
      const [[x0, x1], [y0, y1]] = state._bounds;
      state.overflow = [ox < x0 ? -1 : ox > x1 ? 1 : 0, oy < y0 ? -1 : oy > y1 ? 1 : 0];
      state._movementBound[0] = state.overflow[0] ? state._movementBound[0] === false ? state._movement[0] : state._movementBound[0] : false;
      state._movementBound[1] = state.overflow[1] ? state._movementBound[1] === false ? state._movement[1] : state._movementBound[1] : false;
      const rubberband2 = state._active ? config.rubberband || [0, 0] : [0, 0];
      state.offset = computeRubberband(state._bounds, state.offset, rubberband2);
      state.delta = V.sub(state.offset, previousOffset);
      this.computeMovement();
      if (gestureIsActive && (!state.last || dt > BEFORE_LAST_KINEMATICS_DELAY)) {
        state.delta = V.sub(state.offset, previousOffset);
        const absoluteDelta = state.delta.map(Math.abs);
        V.addTo(state.distance, absoluteDelta);
        state.direction = state.delta.map(Math.sign);
        state._direction = state._delta.map(Math.sign);
        if (!state.first && dt > 0) {
          state.velocity = [absoluteDelta[0] / dt, absoluteDelta[1] / dt];
          state.timeDelta = dt;
        }
      }
    }
    emit() {
      const state = this.state;
      const shared = this.shared;
      const config = this.config;
      if (!state._active)
        this.clean();
      if ((state._blocked || !state.intentional) && !state._force && !config.triggerAllEvents)
        return;
      const memo27 = this.handler(_objectSpread2(_objectSpread2(_objectSpread2({}, shared), state), {}, {
        [this.aliasKey]: state.values
      }));
      if (memo27 !== void 0)
        state.memo = memo27;
    }
    clean() {
      this.eventStore.clean();
      this.timeoutStore.clean();
    }
  };
  function selectAxis([dx, dy], threshold) {
    const absDx = Math.abs(dx);
    const absDy = Math.abs(dy);
    if (absDx > absDy && absDx > threshold) {
      return "x";
    }
    if (absDy > absDx && absDy > threshold) {
      return "y";
    }
    return void 0;
  }
  var CoordinatesEngine = class extends Engine {
    constructor(...args) {
      super(...args);
      _defineProperty(this, "aliasKey", "xy");
    }
    reset() {
      super.reset();
      this.state.axis = void 0;
    }
    init() {
      this.state.offset = [0, 0];
      this.state.lastOffset = [0, 0];
    }
    computeOffset() {
      this.state.offset = V.add(this.state.lastOffset, this.state.movement);
    }
    computeMovement() {
      this.state.movement = V.sub(this.state.offset, this.state.lastOffset);
    }
    axisIntent(event) {
      const state = this.state;
      const config = this.config;
      if (!state.axis && event) {
        const threshold = typeof config.axisThreshold === "object" ? config.axisThreshold[getPointerType(event)] : config.axisThreshold;
        state.axis = selectAxis(state._movement, threshold);
      }
      state._blocked = (config.lockDirection || !!config.axis) && !state.axis || !!config.axis && config.axis !== state.axis;
    }
    restrictToAxis(v3) {
      if (this.config.axis || this.config.lockDirection) {
        switch (this.state.axis) {
          case "x":
            v3[1] = 0;
            break;
          case "y":
            v3[0] = 0;
            break;
        }
      }
    }
  };
  var identity = (v3) => v3;
  var DEFAULT_RUBBERBAND = 0.15;
  var commonConfigResolver = {
    enabled(value = true) {
      return value;
    },
    eventOptions(value, _k, config) {
      return _objectSpread2(_objectSpread2({}, config.shared.eventOptions), value);
    },
    preventDefault(value = false) {
      return value;
    },
    triggerAllEvents(value = false) {
      return value;
    },
    rubberband(value = 0) {
      switch (value) {
        case true:
          return [DEFAULT_RUBBERBAND, DEFAULT_RUBBERBAND];
        case false:
          return [0, 0];
        default:
          return V.toVector(value);
      }
    },
    from(value) {
      if (typeof value === "function")
        return value;
      if (value != null)
        return V.toVector(value);
    },
    transform(value, _k, config) {
      const transform = value || config.shared.transform;
      this.hasCustomTransform = !!transform;
      if (false) {
        const originalTransform = transform || identity;
        return (v3) => {
          const r3 = originalTransform(v3);
          if (!isFinite(r3[0]) || !isFinite(r3[1])) {
            console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${r3[0]},${[1]}]`);
          }
          return r3;
        };
      }
      return transform || identity;
    },
    threshold(value) {
      return V.toVector(value, 0);
    }
  };
  if (false) {
    Object.assign(commonConfigResolver, {
      domTarget(value) {
        if (value !== void 0) {
          throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
        }
        return NaN;
      },
      lockDirection(value) {
        if (value !== void 0) {
          throw Error(`[@use-gesture]: \`lockDirection\` option has been merged with \`axis\`. Use it as in \`{ axis: 'lock' }\``);
        }
        return NaN;
      },
      initial(value) {
        if (value !== void 0) {
          throw Error(`[@use-gesture]: \`initial\` option has been renamed to \`from\`.`);
        }
        return NaN;
      }
    });
  }
  var DEFAULT_AXIS_THRESHOLD = 0;
  var coordinatesConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
    axis(_v, _k, {
      axis
    }) {
      this.lockDirection = axis === "lock";
      if (!this.lockDirection)
        return axis;
    },
    axisThreshold(value = DEFAULT_AXIS_THRESHOLD) {
      return value;
    },
    bounds(value = {}) {
      if (typeof value === "function") {
        return (state) => coordinatesConfigResolver.bounds(value(state));
      }
      if ("current" in value) {
        return () => value.current;
      }
      if (typeof HTMLElement === "function" && value instanceof HTMLElement) {
        return value;
      }
      const {
        left = -Infinity,
        right = Infinity,
        top = -Infinity,
        bottom = Infinity
      } = value;
      return [[left, right], [top, bottom]];
    }
  });
  var isBrowser = typeof window !== "undefined" && window.document && window.document.createElement;
  function supportsTouchEvents() {
    return isBrowser && "ontouchstart" in window;
  }
  function isTouchScreen() {
    return supportsTouchEvents() || isBrowser && window.navigator.maxTouchPoints > 1;
  }
  function supportsPointerEvents() {
    return isBrowser && "onpointerdown" in window;
  }
  function supportsPointerLock() {
    return isBrowser && "exitPointerLock" in window.document;
  }
  function supportsGestureEvents() {
    try {
      return "constructor" in GestureEvent;
    } catch (e2) {
      return false;
    }
  }
  var SUPPORT = {
    isBrowser,
    gesture: supportsGestureEvents(),
    touch: isTouchScreen(),
    touchscreen: isTouchScreen(),
    pointer: supportsPointerEvents(),
    pointerLock: supportsPointerLock()
  };
  var DEFAULT_PREVENT_SCROLL_DELAY = 250;
  var DEFAULT_DRAG_DELAY = 180;
  var DEFAULT_SWIPE_VELOCITY = 0.5;
  var DEFAULT_SWIPE_DISTANCE = 50;
  var DEFAULT_SWIPE_DURATION = 250;
  var DEFAULT_KEYBOARD_DISPLACEMENT = 10;
  var DEFAULT_DRAG_AXIS_THRESHOLD = {
    mouse: 0,
    touch: 0,
    pen: 8
  };
  var dragConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
    device(_v, _k, {
      pointer: {
        touch = false,
        lock = false,
        mouse = false
      } = {}
    }) {
      this.pointerLock = lock && SUPPORT.pointerLock;
      if (SUPPORT.touch && touch)
        return "touch";
      if (this.pointerLock)
        return "mouse";
      if (SUPPORT.pointer && !mouse)
        return "pointer";
      if (SUPPORT.touch)
        return "touch";
      return "mouse";
    },
    preventScrollAxis(value, _k, {
      preventScroll
    }) {
      this.preventScrollDelay = typeof preventScroll === "number" ? preventScroll : preventScroll || preventScroll === void 0 && value ? DEFAULT_PREVENT_SCROLL_DELAY : void 0;
      if (!SUPPORT.touchscreen || preventScroll === false)
        return void 0;
      return value ? value : preventScroll !== void 0 ? "y" : void 0;
    },
    pointerCapture(_v, _k, {
      pointer: {
        capture = true,
        buttons = 1,
        keys = true
      } = {}
    }) {
      this.pointerButtons = buttons;
      this.keys = keys;
      return !this.pointerLock && this.device === "pointer" && capture;
    },
    threshold(value, _k, {
      filterTaps = false,
      tapsThreshold = 3,
      axis = void 0
    }) {
      const threshold = V.toVector(value, filterTaps ? tapsThreshold : axis ? 1 : 0);
      this.filterTaps = filterTaps;
      this.tapsThreshold = tapsThreshold;
      return threshold;
    },
    swipe({
      velocity = DEFAULT_SWIPE_VELOCITY,
      distance = DEFAULT_SWIPE_DISTANCE,
      duration = DEFAULT_SWIPE_DURATION
    } = {}) {
      return {
        velocity: this.transform(V.toVector(velocity)),
        distance: this.transform(V.toVector(distance)),
        duration
      };
    },
    delay(value = 0) {
      switch (value) {
        case true:
          return DEFAULT_DRAG_DELAY;
        case false:
          return 0;
        default:
          return value;
      }
    },
    axisThreshold(value) {
      if (!value)
        return DEFAULT_DRAG_AXIS_THRESHOLD;
      return _objectSpread2(_objectSpread2({}, DEFAULT_DRAG_AXIS_THRESHOLD), value);
    },
    keyboardDisplacement(value = DEFAULT_KEYBOARD_DISPLACEMENT) {
      return value;
    }
  });
  if (false) {
    Object.assign(dragConfigResolver, {
      useTouch(value) {
        if (value !== void 0) {
          throw Error(`[@use-gesture]: \`useTouch\` option has been renamed to \`pointer.touch\`. Use it as in \`{ pointer: { touch: true } }\`.`);
        }
        return NaN;
      },
      experimental_preventWindowScrollY(value) {
        if (value !== void 0) {
          throw Error(`[@use-gesture]: \`experimental_preventWindowScrollY\` option has been renamed to \`preventScroll\`.`);
        }
        return NaN;
      },
      swipeVelocity(value) {
        if (value !== void 0) {
          throw Error(`[@use-gesture]: \`swipeVelocity\` option has been renamed to \`swipe.velocity\`. Use it as in \`{ swipe: { velocity: 0.5 } }\`.`);
        }
        return NaN;
      },
      swipeDistance(value) {
        if (value !== void 0) {
          throw Error(`[@use-gesture]: \`swipeDistance\` option has been renamed to \`swipe.distance\`. Use it as in \`{ swipe: { distance: 50 } }\`.`);
        }
        return NaN;
      },
      swipeDuration(value) {
        if (value !== void 0) {
          throw Error(`[@use-gesture]: \`swipeDuration\` option has been renamed to \`swipe.duration\`. Use it as in \`{ swipe: { duration: 250 } }\`.`);
        }
        return NaN;
      }
    });
  }
  function clampStateInternalMovementToBounds(state) {
    const [ox, oy] = state.overflow;
    const [dx, dy] = state._delta;
    const [dirx, diry] = state._direction;
    if (ox < 0 && dx > 0 && dirx < 0 || ox > 0 && dx < 0 && dirx > 0) {
      state._movement[0] = state._movementBound[0];
    }
    if (oy < 0 && dy > 0 && diry < 0 || oy > 0 && dy < 0 && diry > 0) {
      state._movement[1] = state._movementBound[1];
    }
  }
  var SCALE_ANGLE_RATIO_INTENT_DEG = 30;
  var PINCH_WHEEL_RATIO = 100;
  var PinchEngine = class extends Engine {
    constructor(...args) {
      super(...args);
      _defineProperty(this, "ingKey", "pinching");
      _defineProperty(this, "aliasKey", "da");
    }
    init() {
      this.state.offset = [1, 0];
      this.state.lastOffset = [1, 0];
      this.state._pointerEvents = /* @__PURE__ */ new Map();
    }
    reset() {
      super.reset();
      const state = this.state;
      state._touchIds = [];
      state.canceled = false;
      state.cancel = this.cancel.bind(this);
      state.turns = 0;
    }
    computeOffset() {
      const {
        type,
        movement,
        lastOffset
      } = this.state;
      if (type === "wheel") {
        this.state.offset = V.add(movement, lastOffset);
      } else {
        this.state.offset = [(1 + movement[0]) * lastOffset[0], movement[1] + lastOffset[1]];
      }
    }
    computeMovement() {
      const {
        offset,
        lastOffset
      } = this.state;
      this.state.movement = [offset[0] / lastOffset[0], offset[1] - lastOffset[1]];
    }
    axisIntent() {
      const state = this.state;
      const [_m0, _m1] = state._movement;
      if (!state.axis) {
        const axisMovementDifference = Math.abs(_m0) * SCALE_ANGLE_RATIO_INTENT_DEG - Math.abs(_m1);
        if (axisMovementDifference < 0)
          state.axis = "angle";
        else if (axisMovementDifference > 0)
          state.axis = "scale";
      }
    }
    restrictToAxis(v3) {
      if (this.config.lockDirection) {
        if (this.state.axis === "scale")
          v3[1] = 0;
        else if (this.state.axis === "angle")
          v3[0] = 0;
      }
    }
    cancel() {
      const state = this.state;
      if (state.canceled)
        return;
      setTimeout(() => {
        state.canceled = true;
        state._active = false;
        this.compute();
        this.emit();
      }, 0);
    }
    touchStart(event) {
      this.ctrl.setEventIds(event);
      const state = this.state;
      const ctrlTouchIds = this.ctrl.touchIds;
      if (state._active) {
        if (state._touchIds.every((id) => ctrlTouchIds.has(id)))
          return;
      }
      if (ctrlTouchIds.size < 2)
        return;
      this.start(event);
      state._touchIds = Array.from(ctrlTouchIds).slice(0, 2);
      const payload = touchDistanceAngle(event, state._touchIds);
      if (!payload)
        return;
      this.pinchStart(event, payload);
    }
    pointerStart(event) {
      if (event.buttons != null && event.buttons % 2 !== 1)
        return;
      this.ctrl.setEventIds(event);
      event.target.setPointerCapture(event.pointerId);
      const state = this.state;
      const _pointerEvents = state._pointerEvents;
      const ctrlPointerIds = this.ctrl.pointerIds;
      if (state._active) {
        if (Array.from(_pointerEvents.keys()).every((id) => ctrlPointerIds.has(id)))
          return;
      }
      if (_pointerEvents.size < 2) {
        _pointerEvents.set(event.pointerId, event);
      }
      if (state._pointerEvents.size < 2)
        return;
      this.start(event);
      const payload = distanceAngle(...Array.from(_pointerEvents.values()));
      if (!payload)
        return;
      this.pinchStart(event, payload);
    }
    pinchStart(event, payload) {
      const state = this.state;
      state.origin = payload.origin;
      this.computeValues([payload.distance, payload.angle]);
      this.computeInitial();
      this.compute(event);
      this.emit();
    }
    touchMove(event) {
      if (!this.state._active)
        return;
      const payload = touchDistanceAngle(event, this.state._touchIds);
      if (!payload)
        return;
      this.pinchMove(event, payload);
    }
    pointerMove(event) {
      const _pointerEvents = this.state._pointerEvents;
      if (_pointerEvents.has(event.pointerId)) {
        _pointerEvents.set(event.pointerId, event);
      }
      if (!this.state._active)
        return;
      const payload = distanceAngle(...Array.from(_pointerEvents.values()));
      if (!payload)
        return;
      this.pinchMove(event, payload);
    }
    pinchMove(event, payload) {
      const state = this.state;
      const prev_a = state._values[1];
      const delta_a = payload.angle - prev_a;
      let delta_turns = 0;
      if (Math.abs(delta_a) > 270)
        delta_turns += Math.sign(delta_a);
      this.computeValues([payload.distance, payload.angle - 360 * delta_turns]);
      state.origin = payload.origin;
      state.turns = delta_turns;
      state._movement = [state._values[0] / state._initial[0] - 1, state._values[1] - state._initial[1]];
      this.compute(event);
      this.emit();
    }
    touchEnd(event) {
      this.ctrl.setEventIds(event);
      if (!this.state._active)
        return;
      if (this.state._touchIds.some((id) => !this.ctrl.touchIds.has(id))) {
        this.state._active = false;
        this.compute(event);
        this.emit();
      }
    }
    pointerEnd(event) {
      const state = this.state;
      this.ctrl.setEventIds(event);
      try {
        event.target.releasePointerCapture(event.pointerId);
      } catch (_unused) {
      }
      if (state._pointerEvents.has(event.pointerId)) {
        state._pointerEvents.delete(event.pointerId);
      }
      if (!state._active)
        return;
      if (state._pointerEvents.size < 2) {
        state._active = false;
        this.compute(event);
        this.emit();
      }
    }
    gestureStart(event) {
      if (event.cancelable)
        event.preventDefault();
      const state = this.state;
      if (state._active)
        return;
      this.start(event);
      this.computeValues([event.scale, event.rotation]);
      state.origin = [event.clientX, event.clientY];
      this.compute(event);
      this.emit();
    }
    gestureMove(event) {
      if (event.cancelable)
        event.preventDefault();
      if (!this.state._active)
        return;
      const state = this.state;
      this.computeValues([event.scale, event.rotation]);
      state.origin = [event.clientX, event.clientY];
      const _previousMovement = state._movement;
      state._movement = [event.scale - 1, event.rotation];
      state._delta = V.sub(state._movement, _previousMovement);
      this.compute(event);
      this.emit();
    }
    gestureEnd(event) {
      if (!this.state._active)
        return;
      this.state._active = false;
      this.compute(event);
      this.emit();
    }
    wheel(event) {
      const modifierKey = this.config.modifierKey;
      if (modifierKey && !event[modifierKey])
        return;
      if (!this.state._active)
        this.wheelStart(event);
      else
        this.wheelChange(event);
      this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
    }
    wheelStart(event) {
      this.start(event);
      this.wheelChange(event);
    }
    wheelChange(event) {
      const isR3f = "uv" in event;
      if (!isR3f) {
        if (event.cancelable) {
          event.preventDefault();
        }
        if (false) {
          console.warn(`[@use-gesture]: To properly support zoom on trackpads, try using the \`target\` option.

This message will only appear in development mode.`);
        }
      }
      const state = this.state;
      state._delta = [-wheelValues(event)[1] / PINCH_WHEEL_RATIO * state.offset[0], 0];
      V.addTo(state._movement, state._delta);
      clampStateInternalMovementToBounds(state);
      this.state.origin = [event.clientX, event.clientY];
      this.compute(event);
      this.emit();
    }
    wheelEnd() {
      if (!this.state._active)
        return;
      this.state._active = false;
      this.compute();
      this.emit();
    }
    bind(bindFunction) {
      const device = this.config.device;
      if (!!device) {
        bindFunction(device, "start", this[device + "Start"].bind(this));
        bindFunction(device, "change", this[device + "Move"].bind(this));
        bindFunction(device, "end", this[device + "End"].bind(this));
        bindFunction(device, "cancel", this[device + "End"].bind(this));
      }
      if (this.config.pinchOnWheel) {
        bindFunction("wheel", "", this.wheel.bind(this), {
          passive: false
        });
      }
    }
  };
  var pinchConfigResolver = _objectSpread2(_objectSpread2({}, commonConfigResolver), {}, {
    device(_v, _k, {
      shared,
      pointer: {
        touch = false
      } = {}
    }) {
      const sharedConfig = shared;
      if (sharedConfig.target && !SUPPORT.touch && SUPPORT.gesture)
        return "gesture";
      if (SUPPORT.touch && touch)
        return "touch";
      if (SUPPORT.touchscreen) {
        if (SUPPORT.pointer)
          return "pointer";
        if (SUPPORT.touch)
          return "touch";
      }
    },
    bounds(_v, _k, {
      scaleBounds = {},
      angleBounds = {}
    }) {
      const _scaleBounds = (state) => {
        const D3 = assignDefault(call(scaleBounds, state), {
          min: -Infinity,
          max: Infinity
        });
        return [D3.min, D3.max];
      };
      const _angleBounds = (state) => {
        const A2 = assignDefault(call(angleBounds, state), {
          min: -Infinity,
          max: Infinity
        });
        return [A2.min, A2.max];
      };
      if (typeof scaleBounds !== "function" && typeof angleBounds !== "function")
        return [_scaleBounds(), _angleBounds()];
      return (state) => [_scaleBounds(state), _angleBounds(state)];
    },
    threshold(value, _k, config) {
      this.lockDirection = config.axis === "lock";
      const threshold = V.toVector(value, this.lockDirection ? [0.1, 3] : 0);
      return threshold;
    },
    modifierKey(value) {
      if (value === void 0)
        return "ctrlKey";
      return value;
    },
    pinchOnWheel(value = true) {
      return value;
    }
  });
  var moveConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
    mouseOnly: (value = true) => value
  });
  var WheelEngine = class extends CoordinatesEngine {
    constructor(...args) {
      super(...args);
      _defineProperty(this, "ingKey", "wheeling");
    }
    wheel(event) {
      if (!this.state._active)
        this.start(event);
      this.wheelChange(event);
      this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
    }
    wheelChange(event) {
      const state = this.state;
      state._delta = wheelValues(event);
      V.addTo(state._movement, state._delta);
      clampStateInternalMovementToBounds(state);
      this.compute(event);
      this.emit();
    }
    wheelEnd() {
      if (!this.state._active)
        return;
      this.state._active = false;
      this.compute();
      this.emit();
    }
    bind(bindFunction) {
      bindFunction("wheel", "", this.wheel.bind(this));
    }
  };
  var wheelConfigResolver = coordinatesConfigResolver;
  var hoverConfigResolver = _objectSpread2(_objectSpread2({}, coordinatesConfigResolver), {}, {
    mouseOnly: (value = true) => value
  });
  var EngineMap = /* @__PURE__ */ new Map();
  var ConfigResolverMap = /* @__PURE__ */ new Map();
  function registerAction(action) {
    EngineMap.set(action.key, action.engine);
    ConfigResolverMap.set(action.key, action.resolver);
  }
  var pinchAction = {
    key: "pinch",
    engine: PinchEngine,
    resolver: pinchConfigResolver
  };
  var wheelAction = {
    key: "wheel",
    engine: WheelEngine,
    resolver: wheelConfigResolver
  };

  // ../../../node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
  var import_react19 = __toESM(require_react());

  // ../../../node_modules/@use-gesture/core/dist/use-gesture-core.esm.js
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i3;
    for (i3 = 0; i3 < sourceKeys.length; i3++) {
      key = sourceKeys[i3];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i3;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i3 = 0; i3 < sourceSymbolKeys.length; i3++) {
        key = sourceSymbolKeys[i3];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  var sharedConfigResolver = {
    target(value) {
      if (value) {
        return () => "current" in value ? value.current : value;
      }
      return void 0;
    },
    enabled(value = true) {
      return value;
    },
    window(value = SUPPORT.isBrowser ? window : void 0) {
      return value;
    },
    eventOptions({
      passive = true,
      capture = false
    } = {}) {
      return {
        passive,
        capture
      };
    },
    transform(value) {
      return value;
    }
  };
  var _excluded = ["target", "eventOptions", "window", "enabled", "transform"];
  function resolveWith(config = {}, resolvers) {
    const result = {};
    for (const [key, resolver] of Object.entries(resolvers)) {
      switch (typeof resolver) {
        case "function":
          if (false) {
            const r3 = resolver.call(result, config[key], key, config);
            if (!Number.isNaN(r3))
              result[key] = r3;
          } else {
            result[key] = resolver.call(result, config[key], key, config);
          }
          break;
        case "object":
          result[key] = resolveWith(config[key], resolver);
          break;
        case "boolean":
          if (resolver)
            result[key] = config[key];
          break;
      }
    }
    return result;
  }
  function parse(newConfig, gestureKey, _config = {}) {
    const _ref = newConfig, {
      target,
      eventOptions,
      window: window3,
      enabled,
      transform
    } = _ref, rest = _objectWithoutProperties(_ref, _excluded);
    _config.shared = resolveWith({
      target,
      eventOptions,
      window: window3,
      enabled,
      transform
    }, sharedConfigResolver);
    if (gestureKey) {
      const resolver = ConfigResolverMap.get(gestureKey);
      _config[gestureKey] = resolveWith(_objectSpread2({
        shared: _config.shared
      }, rest), resolver);
    } else {
      for (const key in rest) {
        const resolver = ConfigResolverMap.get(key);
        if (resolver) {
          _config[key] = resolveWith(_objectSpread2({
            shared: _config.shared
          }, rest[key]), resolver);
        } else if (false) {
          if (!["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(key)) {
            if (key === "domTarget") {
              throw Error(`[@use-gesture]: \`domTarget\` option has been renamed to \`target\`.`);
            }
            console.warn(`[@use-gesture]: Unknown config key \`${key}\` was used. Please read the documentation for further information.`);
          }
        }
      }
    }
    return _config;
  }
  var EventStore = class {
    constructor(ctrl, gestureKey) {
      _defineProperty(this, "_listeners", /* @__PURE__ */ new Set());
      this._ctrl = ctrl;
      this._gestureKey = gestureKey;
    }
    add(element, device, action, handler, options) {
      const listeners = this._listeners;
      const type = toDomEventType(device, action);
      const _options = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {};
      const eventOptions = _objectSpread2(_objectSpread2({}, _options), options);
      element.addEventListener(type, handler, eventOptions);
      const remove = () => {
        element.removeEventListener(type, handler, eventOptions);
        listeners.delete(remove);
      };
      listeners.add(remove);
      return remove;
    }
    clean() {
      this._listeners.forEach((remove) => remove());
      this._listeners.clear();
    }
  };
  var TimeoutStore = class {
    constructor() {
      _defineProperty(this, "_timeouts", /* @__PURE__ */ new Map());
    }
    add(key, callback, ms = 140, ...args) {
      this.remove(key);
      this._timeouts.set(key, window.setTimeout(callback, ms, ...args));
    }
    remove(key) {
      const timeout = this._timeouts.get(key);
      if (timeout)
        window.clearTimeout(timeout);
    }
    clean() {
      this._timeouts.forEach((timeout) => void window.clearTimeout(timeout));
      this._timeouts.clear();
    }
  };
  var Controller = class {
    constructor(handlers) {
      _defineProperty(this, "gestures", /* @__PURE__ */ new Set());
      _defineProperty(this, "_targetEventStore", new EventStore(this));
      _defineProperty(this, "gestureEventStores", {});
      _defineProperty(this, "gestureTimeoutStores", {});
      _defineProperty(this, "handlers", {});
      _defineProperty(this, "config", {});
      _defineProperty(this, "pointerIds", /* @__PURE__ */ new Set());
      _defineProperty(this, "touchIds", /* @__PURE__ */ new Set());
      _defineProperty(this, "state", {
        shared: {
          shiftKey: false,
          metaKey: false,
          ctrlKey: false,
          altKey: false
        }
      });
      resolveGestures(this, handlers);
    }
    setEventIds(event) {
      if (isTouch(event)) {
        this.touchIds = new Set(touchIds(event));
        return this.touchIds;
      } else if ("pointerId" in event) {
        if (event.type === "pointerup" || event.type === "pointercancel")
          this.pointerIds.delete(event.pointerId);
        else if (event.type === "pointerdown")
          this.pointerIds.add(event.pointerId);
        return this.pointerIds;
      }
    }
    applyHandlers(handlers, nativeHandlers) {
      this.handlers = handlers;
      this.nativeHandlers = nativeHandlers;
    }
    applyConfig(config, gestureKey) {
      this.config = parse(config, gestureKey, this.config);
    }
    clean() {
      this._targetEventStore.clean();
      for (const key of this.gestures) {
        this.gestureEventStores[key].clean();
        this.gestureTimeoutStores[key].clean();
      }
    }
    effect() {
      if (this.config.shared.target)
        this.bind();
      return () => this._targetEventStore.clean();
    }
    bind(...args) {
      const sharedConfig = this.config.shared;
      const props = {};
      let target;
      if (sharedConfig.target) {
        target = sharedConfig.target();
        if (!target)
          return;
      }
      if (sharedConfig.enabled) {
        for (const gestureKey of this.gestures) {
          const gestureConfig = this.config[gestureKey];
          const bindFunction = bindToProps(props, gestureConfig.eventOptions, !!target);
          if (gestureConfig.enabled) {
            const Engine2 = EngineMap.get(gestureKey);
            new Engine2(this, args, gestureKey).bind(bindFunction);
          }
        }
        const nativeBindFunction = bindToProps(props, sharedConfig.eventOptions, !!target);
        for (const eventKey in this.nativeHandlers) {
          nativeBindFunction(eventKey, "", (event) => this.nativeHandlers[eventKey](_objectSpread2(_objectSpread2({}, this.state.shared), {}, {
            event,
            args
          })), void 0, true);
        }
      }
      for (const handlerProp in props) {
        props[handlerProp] = chain(...props[handlerProp]);
      }
      if (!target)
        return props;
      for (const handlerProp in props) {
        const {
          device,
          capture,
          passive
        } = parseProp(handlerProp);
        this._targetEventStore.add(target, device, "", props[handlerProp], {
          capture,
          passive
        });
      }
    }
  };
  function setupGesture(ctrl, gestureKey) {
    ctrl.gestures.add(gestureKey);
    ctrl.gestureEventStores[gestureKey] = new EventStore(ctrl, gestureKey);
    ctrl.gestureTimeoutStores[gestureKey] = new TimeoutStore();
  }
  function resolveGestures(ctrl, internalHandlers) {
    if (internalHandlers.drag)
      setupGesture(ctrl, "drag");
    if (internalHandlers.wheel)
      setupGesture(ctrl, "wheel");
    if (internalHandlers.scroll)
      setupGesture(ctrl, "scroll");
    if (internalHandlers.move)
      setupGesture(ctrl, "move");
    if (internalHandlers.pinch)
      setupGesture(ctrl, "pinch");
    if (internalHandlers.hover)
      setupGesture(ctrl, "hover");
  }
  var bindToProps = (props, eventOptions, withPassiveOption) => (device, action, handler, options = {}, isNative = false) => {
    var _options$capture, _options$passive;
    const capture = (_options$capture = options.capture) !== null && _options$capture !== void 0 ? _options$capture : eventOptions.capture;
    const passive = (_options$passive = options.passive) !== null && _options$passive !== void 0 ? _options$passive : eventOptions.passive;
    let handlerProp = isNative ? device : toHandlerProp(device, action, capture);
    if (withPassiveOption && passive)
      handlerProp += "Passive";
    props[handlerProp] = props[handlerProp] || [];
    props[handlerProp].push(handler);
  };
  var RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
  function sortHandlers(_handlers2) {
    const native = {};
    const handlers = {};
    const actions = /* @__PURE__ */ new Set();
    for (let key in _handlers2) {
      if (RE_NOT_NATIVE.test(key)) {
        actions.add(RegExp.lastMatch);
        handlers[key] = _handlers2[key];
      } else {
        native[key] = _handlers2[key];
      }
    }
    return [handlers, native, actions];
  }
  function registerGesture(actions, handlers, handlerKey, key, internalHandlers, config) {
    if (!actions.has(handlerKey))
      return;
    if (!EngineMap.has(key)) {
      if (false) {
        console.warn(`[@use-gesture]: You've created a custom handler that that uses the \`${key}\` gesture but isn't properly configured.

Please add \`${key}Action\` when creating your handler.`);
      }
      return;
    }
    const startKey = handlerKey + "Start";
    const endKey = handlerKey + "End";
    const fn = (state) => {
      let memo27 = void 0;
      if (state.first && startKey in handlers)
        handlers[startKey](state);
      if (handlerKey in handlers)
        memo27 = handlers[handlerKey](state);
      if (state.last && endKey in handlers)
        handlers[endKey](state);
      return memo27;
    };
    internalHandlers[key] = fn;
    config[key] = config[key] || {};
  }
  function parseMergedHandlers(mergedHandlers, mergedConfig) {
    const [handlers, nativeHandlers, actions] = sortHandlers(mergedHandlers);
    const internalHandlers = {};
    registerGesture(actions, handlers, "onDrag", "drag", internalHandlers, mergedConfig);
    registerGesture(actions, handlers, "onWheel", "wheel", internalHandlers, mergedConfig);
    registerGesture(actions, handlers, "onScroll", "scroll", internalHandlers, mergedConfig);
    registerGesture(actions, handlers, "onPinch", "pinch", internalHandlers, mergedConfig);
    registerGesture(actions, handlers, "onMove", "move", internalHandlers, mergedConfig);
    registerGesture(actions, handlers, "onHover", "hover", internalHandlers, mergedConfig);
    return {
      handlers: internalHandlers,
      config: mergedConfig,
      nativeHandlers
    };
  }

  // ../../../node_modules/@use-gesture/react/dist/use-gesture-react.esm.js
  function useRecognizers(handlers, config = {}, gestureKey, nativeHandlers) {
    const ctrl = import_react19.default.useMemo(() => new Controller(handlers), []);
    ctrl.applyHandlers(handlers, nativeHandlers);
    ctrl.applyConfig(config, gestureKey);
    import_react19.default.useEffect(ctrl.effect.bind(ctrl));
    import_react19.default.useEffect(() => {
      return ctrl.clean.bind(ctrl);
    }, []);
    if (config.target === void 0) {
      return ctrl.bind.bind(ctrl);
    }
    return void 0;
  }
  function createUseGesture(actions) {
    actions.forEach(registerAction);
    return function useGesture2(_handlers2, _config) {
      const {
        handlers,
        nativeHandlers,
        config
      } = parseMergedHandlers(_handlers2, _config || {});
      return useRecognizers(handlers, config, void 0, nativeHandlers);
    };
  }

  // ../../../packages/editor/src/lib/hooks/useGestureEvents.ts
  var import_lodash3 = __toESM(require_lodash3());
  var React10 = __toESM(require_react());

  // ../../../packages/editor/src/lib/hooks/shared.ts
  var MAX_ZOOM_STEP = 10;
  var IS_DARWIN = /Mac|iPod|iPhone|iPad/.test(
    typeof window === "undefined" ? "node" : window.navigator.platform
  );
  function normalizeWheel(event) {
    let { deltaY, deltaX } = event;
    let deltaZ = 0;
    if (event.ctrlKey || event.altKey || event.metaKey) {
      const signY = Math.sign(event.deltaY);
      const absDeltaY = Math.abs(event.deltaY);
      let dy = deltaY;
      if (absDeltaY > MAX_ZOOM_STEP) {
        dy = MAX_ZOOM_STEP * signY;
      }
      deltaZ = dy / 100;
    } else {
      if (event.shiftKey && !IS_DARWIN) {
        deltaX = deltaY;
        deltaY = 0;
      }
    }
    return { x: -deltaX, y: -deltaY, z: -deltaZ };
  }

  // ../../../packages/editor/src/lib/hooks/useGestureEvents.ts
  var useGesture = createUseGesture([wheelAction, pinchAction]);
  var lastWheelTime = void 0;
  var isWheelEndEvent = (time) => {
    if (lastWheelTime === void 0) {
      lastWheelTime = time;
      return false;
    }
    if (time - lastWheelTime > 120 && time - lastWheelTime < 160) {
      lastWheelTime = time;
      return true;
    }
    lastWheelTime = time;
    return false;
  };
  function useGestureEvents(ref) {
    const app = useApp();
    const events = React10.useMemo(() => {
      let pinchState = null;
      const onWheel = ({ event }) => {
        if (!app.isFocused) {
          return;
        }
        pinchState = null;
        if (isWheelEndEvent(Date.now())) {
          return;
        }
        if (app.editingId) {
          const shape = app.getShapeById(app.editingId);
          if (shape) {
            const util = app.getShapeUtil(shape);
            if (util.canScroll(shape)) {
              const bounds = app.getPageBoundsById(app.editingId);
              if (bounds == null ? void 0 : bounds.containsPoint(app.inputs.currentPagePoint)) {
                return;
              }
            }
          }
        }
        preventDefault(event);
        const delta = normalizeWheel(event);
        if (delta.x === 0 && delta.y === 0)
          return;
        const info = {
          type: "wheel",
          name: "wheel",
          delta,
          shiftKey: event.shiftKey,
          altKey: event.altKey,
          ctrlKey: event.metaKey || event.ctrlKey
        };
        app.dispatch(info);
      };
      let initTouchDistance = 1;
      let initZoom = 1;
      let currentZoom = 1;
      let currentTouchDistance = 0;
      const initOrigin = new Vec2d();
      const prevOrigin = new Vec2d();
      const onPinchStart = (gesture) => {
        const elm = ref.current;
        pinchState = null;
        const { event, origin, da } = gesture;
        if (event instanceof WheelEvent)
          return;
        if (!(event.target === elm || (elm == null ? void 0 : elm.contains(event.target))))
          return;
        prevOrigin.x = origin[0];
        prevOrigin.y = origin[1];
        initOrigin.x = origin[0];
        initOrigin.y = origin[1];
        initTouchDistance = da[0];
        initZoom = app.zoomLevel;
        app.dispatch({
          type: "pinch",
          name: "pinch_start",
          point: { x: origin[0], y: origin[1], z: app.zoomLevel },
          delta: { x: 0, y: 0 },
          shiftKey: event.shiftKey,
          altKey: event.altKey,
          ctrlKey: event.metaKey || event.ctrlKey
        });
      };
      const updatePinchState = (0, import_lodash3.default)((type) => {
        if (pinchState === null) {
          const touchDistance = Math.abs(currentTouchDistance - initTouchDistance);
          const originDistance = Vec2d.Dist(initOrigin, prevOrigin);
          if (type === "gesture" && touchDistance) {
            pinchState = "zooming";
          } else if (type === "touch" && touchDistance > 16) {
            pinchState = "zooming";
          } else if (originDistance > 16) {
            pinchState = "panning";
          }
        }
      }, 32);
      const onPinch = (gesture) => {
        const elm = ref.current;
        const { event, origin, offset, da } = gesture;
        if (event instanceof WheelEvent)
          return;
        if (!(event.target === elm || (elm == null ? void 0 : elm.contains(event.target))))
          return;
        const isGesture = "touches" in event ? false : true;
        currentTouchDistance = da[0];
        if (isGesture || currentTouchDistance > 64) {
          currentZoom = offset[0];
        }
        const dx = origin[0] - prevOrigin.x;
        const dy = origin[1] - prevOrigin.y;
        prevOrigin.x = origin[0];
        prevOrigin.y = origin[1];
        updatePinchState(isGesture ? "gesture" : "touch");
        switch (pinchState) {
          case "zooming": {
            app.dispatch({
              type: "pinch",
              name: "pinch",
              point: { x: origin[0], y: origin[1], z: currentZoom },
              delta: { x: dx, y: dy },
              shiftKey: event.shiftKey,
              altKey: event.altKey,
              ctrlKey: event.metaKey || event.ctrlKey
            });
            break;
          }
          case "panning": {
            app.dispatch({
              type: "pinch",
              name: "pinch",
              point: { x: origin[0], y: origin[1], z: initZoom },
              delta: { x: dx, y: dy },
              shiftKey: event.shiftKey,
              altKey: event.altKey,
              ctrlKey: event.metaKey || event.ctrlKey
            });
            break;
          }
        }
      };
      const onPinchEnd = (gesture) => {
        const elm = ref.current;
        const { event, origin, offset } = gesture;
        if (event instanceof WheelEvent)
          return;
        if (!(event.target === elm || (elm == null ? void 0 : elm.contains(event.target))))
          return;
        const scale = offset[0];
        pinchState = null;
        requestAnimationFrame(() => {
          app.dispatch({
            type: "pinch",
            name: "pinch_end",
            point: { x: origin[0], y: origin[1], z: scale },
            delta: { x: origin[0], y: origin[1] },
            shiftKey: event.shiftKey,
            altKey: event.altKey,
            ctrlKey: event.metaKey || event.ctrlKey
          });
        });
      };
      return {
        onWheel,
        onPinchStart,
        onPinchEnd,
        onPinch
      };
    }, [app, ref]);
    useGesture(events, {
      target: ref,
      eventOptions: { passive: false },
      pinch: {
        from: () => [app.zoomLevel, 0],
        // Return the camera z to use when pinch starts
        scaleBounds: () => {
          return { from: app.zoomLevel, max: 8, min: 0.05 };
        }
      }
    });
  }

  // ../../../packages/editor/src/lib/hooks/useHandleEvents.ts
  var React11 = __toESM(require_react());
  function getHandle(app, id, handleId) {
    const shape = app.getShapeById(id);
    const util = app.getShapeUtil(shape);
    const handles = util.handles(shape);
    return { shape, handle: handles.find((h3) => h3.id === handleId) };
  }
  function useHandleEvents(id, handleId) {
    const app = useApp();
    return React11.useMemo(() => {
      const onPointerDown = (e2) => {
        if (e2.isKilled)
          return;
        const target = loopToHtmlElement(e2.currentTarget);
        setPointerCapture(target, e2);
        const { shape, handle } = getHandle(app, id, handleId);
        if (!handle)
          return;
        app.dispatch(__spreadValues({
          type: "pointer",
          target: "handle",
          handle,
          shape,
          name: "pointer_down"
        }, getPointerInfo(e2, app.getContainer())));
      };
      let lastX, lastY;
      const onPointerMove = (e2) => {
        if (e2.isKilled)
          return;
        if (e2.clientX === lastX && e2.clientY === lastY)
          return;
        lastX = e2.clientX;
        lastY = e2.clientY;
        const { shape, handle } = getHandle(app, id, handleId);
        if (!handle)
          return;
        app.dispatch(__spreadValues({
          type: "pointer",
          target: "handle",
          handle,
          shape,
          name: "pointer_move"
        }, getPointerInfo(e2, app.getContainer())));
      };
      const onPointerUp = (e2) => {
        if (e2.isKilled)
          return;
        const target = loopToHtmlElement(e2.currentTarget);
        releasePointerCapture(target, e2);
        const { shape, handle } = getHandle(app, id, handleId);
        if (!handle)
          return;
        app.dispatch(__spreadValues({
          type: "pointer",
          target: "handle",
          handle,
          shape,
          name: "pointer_up"
        }, getPointerInfo(e2, app.getContainer())));
      };
      const onPointerEnter = (e2) => {
        if (e2.isKilled)
          return;
        const { shape, handle } = getHandle(app, id, handleId);
        if (!handle)
          return;
        app.dispatch(__spreadValues({
          type: "pointer",
          target: "handle",
          handle,
          shape,
          name: "pointer_enter"
        }, getPointerInfo(e2, app.getContainer())));
      };
      const onPointerLeave = (e2) => {
        if (e2.isKilled)
          return;
        const { shape, handle } = getHandle(app, id, handleId);
        if (!handle)
          return;
        app.dispatch(__spreadValues({
          type: "pointer",
          target: "handle",
          handle,
          shape,
          name: "pointer_leave"
        }, getPointerInfo(e2, app.getContainer())));
      };
      return {
        onPointerDown,
        onPointerMove,
        onPointerUp,
        onPointerEnter,
        onPointerLeave
      };
    }, [app, id, handleId]);
  }

  // ../../../packages/editor/src/lib/hooks/usePattern.tsx
  var import_react21 = __toESM(require_react());
  var import_jsx_runtime14 = __toESM(require_jsx_runtime());
  var TILE_PATTERN_SIZE = 8;
  var generateImage = (dpr, currentZoom, darkMode) => {
    return new Promise((resolve, reject) => {
      const size = TILE_PATTERN_SIZE * currentZoom * dpr;
      const canvasEl = document.createElement("canvas");
      canvasEl.width = size;
      canvasEl.height = size;
      const ctx = canvasEl.getContext("2d");
      if (!ctx)
        throw new Error("No canvas");
      ctx.fillStyle = darkMode ? "#212529" : "#f8f9fa";
      ctx.fillRect(0, 0, size, size);
      ctx.globalCompositeOperation = "destination-out";
      ctx.lineCap = "round";
      ctx.lineWidth = 1.25 * currentZoom * dpr;
      const t4 = 8 / 12;
      const s3 = (v3) => v3 * currentZoom * dpr;
      ctx.beginPath();
      ctx.moveTo(s3(t4 * 1), s3(t4 * 3));
      ctx.lineTo(s3(t4 * 3), s3(t4 * 1));
      ctx.moveTo(s3(t4 * 5), s3(t4 * 7));
      ctx.lineTo(s3(t4 * 7), s3(t4 * 5));
      ctx.moveTo(s3(t4 * 9), s3(t4 * 11));
      ctx.lineTo(s3(t4 * 11), s3(t4 * 9));
      ctx.stroke();
      canvasEl.toBlob((blob) => {
        if (!blob || debugFlags.throwToBlob.value) {
          reject();
        } else {
          resolve(blob);
        }
      });
    });
  };
  var canvasBlob = (size, fn) => {
    const canvas = document.createElement("canvas");
    canvas.width = size[0];
    canvas.height = size[1];
    fn(canvas.getContext("2d"));
    return canvas.toDataURL();
  };
  var getDefaultPatterns = () => {
    const defaultPatterns = [];
    for (let i3 = 1; i3 <= Math.ceil(MAX_ZOOM); i3++) {
      const whitePixelBlob = canvasBlob([1, 1], (ctx) => {
        ctx.fillStyle = "#e8e8e8";
        ctx.fillRect(0, 0, 1, 1);
      });
      const blackPixelBlob = canvasBlob([1, 1], (ctx) => {
        ctx.fillStyle = "#2c3036";
        ctx.fillRect(0, 0, 1, 1);
      });
      defaultPatterns.push({
        zoom: i3,
        url: whitePixelBlob,
        darkMode: false
      });
      defaultPatterns.push({
        zoom: i3,
        url: blackPixelBlob,
        darkMode: true
      });
    }
    return defaultPatterns;
  };
  var usePattern = () => {
    const app = useApp();
    const dpr = app.devicePixelRatio;
    const [isReady, setIsReady] = (0, import_react21.useState)(false);
    const defaultPatterns = (0, import_react21.useMemo)(() => getDefaultPatterns(), []);
    const [backgroundUrls, setBackgroundUrls] = (0, import_react21.useState)(defaultPatterns);
    (0, import_react21.useEffect)(() => {
      const promises = [];
      for (let i3 = 1; i3 <= Math.ceil(MAX_ZOOM); i3++) {
        promises.push(
          generateImage(dpr, i3, false).then((blob) => ({
            zoom: i3,
            url: URL.createObjectURL(blob),
            darkMode: false
          }))
        );
        promises.push(
          generateImage(dpr, i3, true).then((blob) => ({
            zoom: i3,
            url: URL.createObjectURL(blob),
            darkMode: true
          }))
        );
      }
      let isCancelled = false;
      Promise.all(promises).then((urls) => {
        if (isCancelled)
          return;
        setBackgroundUrls(urls);
        setIsReady(true);
      });
      return () => {
        isCancelled = true;
        setIsReady(false);
      };
    }, [dpr]);
    const context = /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(import_jsx_runtime14.Fragment, { children: backgroundUrls.map((item) => {
      const key = item.zoom + (item.darkMode ? "_dark" : "_light");
      return /* @__PURE__ */ (0, import_jsx_runtime14.jsx)(
        "pattern",
        {
          id: HASH_PATERN_ZOOM_NAMES[key],
          width: TILE_PATTERN_SIZE,
          height: TILE_PATTERN_SIZE,
          patternUnits: "userSpaceOnUse",
          children: /* @__PURE__ */ (0, import_jsx_runtime14.jsx)("image", { href: item.url, width: TILE_PATTERN_SIZE, height: TILE_PATTERN_SIZE })
        },
        key
      );
    }) });
    return { context, isReady };
  };
  var t = 8 / 12;
  function exportPatternSvgDefs(backgroundColor) {
    const divEl = document.createElement("div");
    divEl.innerHTML = `
		<svg>
			<defs>
				<mask id="hash_pattern_mask">
					<rect x="0" y="0" width="8" height="8" fill="white" />
					<g
						strokeLinecap="round"
						stroke="black"
					>
						<line x1="${t * 1}" y1="${t * 3}" x2="${t * 3}" y2="${t * 1}" />
						<line x1="${t * 5}" y1="${t * 7}" x2="${t * 7}" y2="${t * 5}" />
						<line x1="${t * 9}" y1="${t * 11}" x2="${t * 11}" y2="${t * 9}" />
					</g>
				</mask>
				<pattern
					id="hash_pattern"
					width="8"
					height="8"
					patternUnits="userSpaceOnUse"
				>
					<rect x="0" y="0" width="8" height="8" fill="${backgroundColor}" mask="url(#hash_pattern_mask)" />
				</pattern>
			</defs>
		</svg>
	`;
    return divEl.querySelectorAll("defs > *");
  }

  // ../../../packages/editor/src/lib/hooks/useQuickReactor.ts
  var import_react22 = __toESM(require_react());
  function useQuickReactor(name, reactFn, deps = EMPTY_ARRAY) {
    (0, import_react22.useEffect)(() => {
      const scheduler = new EffectScheduler(name, reactFn);
      scheduler.attach();
      scheduler.execute();
      return () => {
        scheduler.detach();
      };
    }, deps);
  }

  // ../../../packages/editor/src/lib/hooks/useScreenBounds.ts
  var import_lodash4 = __toESM(require_lodash3());
  var import_react23 = __toESM(require_react());
  function useScreenBounds() {
    const app = useApp();
    const container = useContainer();
    (0, import_react23.useLayoutEffect)(() => {
      const updateBounds = (0, import_lodash4.default)(
        () => {
          app.updateViewportScreenBounds();
        },
        200,
        { trailing: true }
      );
      const resizeObserver = new ResizeObserver((entries) => {
        if (entries[0].contentRect) {
          updateBounds();
        }
      });
      if (container) {
        resizeObserver.observe(container);
      }
      updateBounds();
      return () => {
        resizeObserver.disconnect();
      };
    }, [app, container]);
  }

  // ../../../packages/editor/src/lib/components/LiveCollaborators.tsx
  var import_react24 = __toESM(require_react());
  var import_jsx_runtime15 = __toESM(require_jsx_runtime());
  var useActivePresences = () => {
    const app = useApp();
    const time = useAtom("time", Date.now());
    import_react24.default.useEffect(() => {
      const interval = setInterval(() => time.set(Date.now()), 1e3 * 5);
      return () => clearInterval(interval);
    }, [time]);
    return (0, import_react24.useMemo)(
      () => app.store.query.records("user_presence", () => ({
        lastActivityTimestamp: { gt: time.value - COLLABORATOR_INACTIVITY_TIMEOUT },
        userId: { neq: app.userId }
      })),
      [app, time]
    );
  };
  var LiveCollaborators = track(function Collaborators() {
    const app = useApp();
    const { viewportPageBounds, zoomLevel } = app;
    const presences = useActivePresences();
    return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(import_jsx_runtime15.Fragment, { children: presences.value.map((userPresence) => /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
      Collaborator,
      {
        presence: userPresence,
        viewport: viewportPageBounds,
        zoom: zoomLevel
      },
      userPresence.id
    )) });
  });
  var COLLABORATOR_INACTIVITY_TIMEOUT = 1e3 * 10;
  var Collaborator = track(function Collaborator2({
    presence,
    viewport,
    zoom
  }) {
    const app = useApp();
    const {
      CollaboratorBrush,
      CollaboratorScribble,
      CollaboratorCursor,
      CollaboratorHint: CollaboratorHint2,
      CollaboratorShapeIndicator
    } = useEditorComponents();
    const { userId, color, cursor, lastUsedInstanceId } = presence;
    const pageState = (0, import_react24.useMemo)(
      () => lastUsedInstanceId ? app.store.query.record("instance_page_state", () => ({
        instanceId: { eq: lastUsedInstanceId },
        pageId: { eq: app.currentPageId }
      })) : null,
      [app, lastUsedInstanceId]
    );
    const user = (0, import_react24.useMemo)(
      () => app.store.query.record("user", () => ({
        id: { eq: userId }
      })),
      [app, userId]
    );
    if (!lastUsedInstanceId || !pageState || !user)
      return null;
    const instance = app.store.get(lastUsedInstanceId);
    if (!instance)
      return null;
    if (instance.currentPageId !== app.currentPageId)
      return null;
    if (!pageState.value)
      return null;
    if (!user.value)
      return null;
    const { brush, scribble } = instance;
    const { selectedIds } = pageState.value;
    const { name } = user.value;
    const isCursorInViewport = !(cursor.x < viewport.minX - 12 / zoom || cursor.y < viewport.minY - 16 / zoom || cursor.x > viewport.maxX - 12 / zoom || cursor.y > viewport.maxY - 16 / zoom);
    return /* @__PURE__ */ (0, import_jsx_runtime15.jsxs)(import_jsx_runtime15.Fragment, { children: [
      brush && CollaboratorBrush ? /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
        CollaboratorBrush,
        {
          className: "tl-collaborator__brush",
          brush,
          color,
          opacity: 0.1
        },
        userId + "_brush"
      ) : null,
      isCursorInViewport && CollaboratorCursor ? /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
        CollaboratorCursor,
        {
          className: "tl-collaborator__cursor",
          point: cursor,
          color,
          zoom,
          name: name !== "New User" ? name : null
        },
        userId + "_cursor"
      ) : CollaboratorHint2 ? /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
        CollaboratorHint2,
        {
          className: "tl-collaborator__cursor-hint",
          point: cursor,
          color,
          zoom,
          viewport
        },
        userId + "_cursor_hint"
      ) : null,
      scribble && CollaboratorScribble ? /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
        CollaboratorScribble,
        {
          className: "tl-collaborator__scribble",
          scribble,
          color,
          zoom,
          opacity: 0.1
        },
        userId + "_scribble"
      ) : null,
      CollaboratorShapeIndicator && selectedIds.map((shapeId) => /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(
        CollaboratorShapeIndicator,
        {
          className: "tl-collaborator__shape-indicator",
          id: shapeId,
          color,
          opacity: 0.5
        },
        userId + "_" + shapeId
      ))
    ] });
  });

  // ../../../packages/editor/src/lib/hooks/usePeerIds.ts
  var import_lodash5 = __toESM(require_lodash2());
  var import_react25 = __toESM(require_react());
  function usePeerIds() {
    const app = useApp();
    const $presences = (0, import_react25.useMemo)(() => {
      return app.store.query.records("instance_presence");
    }, [app]);
    const $userIds = useComputed(
      "userIds",
      () => (0, import_lodash5.default)($presences.value.map((p3) => p3.userId)).sort(),
      { isEqual: (a3, b3) => {
        var _a5;
        return a3.join(",") === ((_a5 = b3.join) == null ? void 0 : _a5.call(b3, ","));
      } },
      [$presences]
    );
    return useValue($userIds);
  }

  // ../../../packages/editor/src/lib/hooks/usePresence.ts
  var import_react26 = __toESM(require_react());
  function usePresence(userId) {
    const app = useApp();
    const $presences = (0, import_react26.useMemo)(() => {
      return app.store.query.records("instance_presence", () => ({
        userId: { eq: userId }
      }));
    }, [app, userId]);
    const latestPresence = useValue(
      `latestPresence:${userId}`,
      () => {
        return $presences.value.slice().sort((a3, b3) => b3.lastActivityTimestamp - a3.lastActivityTimestamp)[0];
      },
      []
    );
    return latestPresence != null ? latestPresence : null;
  }

  // ../../../packages/editor/src/lib/components/LiveCollaboratorsNext.tsx
  var import_jsx_runtime16 = __toESM(require_jsx_runtime());
  var LiveCollaboratorsNext = track(function Collaborators2() {
    const peerIds = usePeerIds();
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(import_jsx_runtime16.Fragment, { children: peerIds.map((id) => /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(Collaborator3, { userId: id }, id)) });
  });
  var Collaborator3 = track(function Collaborator4({ userId }) {
    const app = useApp();
    const { viewportPageBounds, zoomLevel } = app;
    const {
      CollaboratorBrush,
      CollaboratorScribble,
      CollaboratorCursor,
      CollaboratorHint: CollaboratorHint2,
      CollaboratorShapeIndicator
    } = useEditorComponents();
    const latestPresence = usePresence(userId);
    if (!latestPresence)
      return null;
    if (latestPresence.currentPageId !== app.currentPageId)
      return null;
    const { brush, scribble, selectedIds, userName, cursor, color } = latestPresence;
    const isCursorInViewport = !(cursor.x < viewportPageBounds.minX - 12 / zoomLevel || cursor.y < viewportPageBounds.minY - 16 / zoomLevel || cursor.x > viewportPageBounds.maxX - 12 / zoomLevel || cursor.y > viewportPageBounds.maxY - 16 / zoomLevel);
    return /* @__PURE__ */ (0, import_jsx_runtime16.jsxs)(import_jsx_runtime16.Fragment, { children: [
      brush && CollaboratorBrush ? /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(CollaboratorBrush, { brush, color }, userId + "_brush") : null,
      isCursorInViewport && CollaboratorCursor ? /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
        CollaboratorCursor,
        {
          point: cursor,
          color,
          zoom: zoomLevel,
          name: userName !== "New User" ? userName : null
        },
        userId + "_cursor"
      ) : CollaboratorHint2 ? /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
        CollaboratorHint2,
        {
          point: cursor,
          color,
          zoom: zoomLevel,
          viewport: viewportPageBounds
        },
        userId + "_cursor_hint"
      ) : null,
      scribble && CollaboratorScribble ? /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(
        CollaboratorScribble,
        {
          scribble,
          color,
          zoom: zoomLevel
        },
        userId + "_scribble"
      ) : null,
      CollaboratorShapeIndicator && selectedIds.map((shapeId) => /* @__PURE__ */ (0, import_jsx_runtime16.jsx)(CollaboratorShapeIndicator, { id: shapeId, color }, userId + "_" + shapeId))
    ] });
  });

  // ../../../packages/editor/src/lib/components/SelectionBg.tsx
  var React13 = __toESM(require_react());
  var import_jsx_runtime17 = __toESM(require_jsx_runtime());
  var SelectionBg = track(function SelectionBg2() {
    const app = useApp();
    const events = React13.useMemo(() => {
      const onPointerDown = (e2) => {
        if (e2.isKilled)
          return;
        setPointerCapture(e2.currentTarget, e2);
        const info = __spreadValues({
          type: "pointer",
          target: "selection",
          name: "pointer_down"
        }, getPointerInfo(e2, app.getContainer()));
        app.dispatch(info);
      };
      const onPointerMove = (e2) => {
        if (e2.isKilled)
          return;
        const info = __spreadValues({
          type: "pointer",
          target: "selection",
          name: "pointer_move"
        }, getPointerInfo(e2, app.getContainer()));
        app.dispatch(info);
      };
      const onPointerUp = (e2) => {
        if (e2.isKilled)
          return;
        releasePointerCapture(e2.currentTarget, e2);
        const info = __spreadValues({
          type: "pointer",
          target: "selection",
          name: "pointer_up"
        }, getPointerInfo(e2, app.getContainer()));
        app.dispatch(info);
      };
      const onPointerEnter = (e2) => {
        if (e2.isKilled)
          return;
        const info = __spreadValues({
          type: "pointer",
          target: "selection",
          name: "pointer_enter"
        }, getPointerInfo(e2, app.getContainer()));
        app.dispatch(info);
      };
      const onPointerLeave = (e2) => {
        if (e2.isKilled)
          return;
        const info = __spreadValues({
          type: "pointer",
          target: "selection",
          name: "pointer_leave"
        }, getPointerInfo(e2, app.getContainer()));
        app.dispatch(info);
      };
      return {
        onPointerDown,
        onPointerMove,
        onPointerUp,
        onPointerEnter,
        onPointerLeave
      };
    }, [app]);
    const { selectionBounds: bounds, selectedIds } = app;
    if (!bounds)
      return null;
    const shouldDisplay = app.isInAny(
      "select.idle",
      "select.brushing",
      "select.scribble_brushing",
      "select.pointing_shape",
      "select.pointing_selection",
      "text.resizing"
    );
    if (selectedIds.length === 1) {
      const shape = app.getShapeById(selectedIds[0]);
      if (!shape) {
        return null;
      }
      const util = app.getShapeUtil(shape);
      if (util.hideSelectionBoundsBg(shape)) {
        return null;
      }
    }
    const transform = Matrix2d.toCssString(
      Matrix2d.Compose(
        Matrix2d.Translate(bounds.minX, bounds.minY),
        Matrix2d.Rotate(app.selectionRotation)
      )
    );
    return /* @__PURE__ */ (0, import_jsx_runtime17.jsx)(
      "div",
      __spreadValues({
        className: "tl-selection__bg",
        draggable: false,
        style: {
          transform,
          width: toDomPrecision(Math.max(1, bounds.width)),
          height: toDomPrecision(Math.max(1, bounds.height)),
          pointerEvents: shouldDisplay ? "all" : "none",
          opacity: shouldDisplay ? 1 : 0
        }
      }, events)
    );
  });

  // ../../../packages/editor/src/lib/components/SelectionFg.tsx
  var import_classnames5 = __toESM(require_classnames());
  var import_react28 = __toESM(require_react());

  // ../../../packages/editor/src/lib/hooks/useCursor.ts
  var CORNER_SVG = `<path d='m19.7432 17.0869-4.072 4.068 2.829 2.828-8.473-.013-.013-8.47 2.841 2.842 4.075-4.068 1.414-1.415-2.844-2.842h8.486v8.484l-2.83-2.827z' fill='%23fff'/><path d='m18.6826 16.7334-4.427 4.424 1.828 1.828-5.056-.016-.014-5.054 1.842 1.841 4.428-4.422 2.474-2.475-1.844-1.843h5.073v5.071l-1.83-1.828z' fill='%23000'/>`;
  var EDGE_SVG = `<path d='m9 17.9907v.005l5.997 5.996.001-3.999h1.999 2.02v4l5.98-6.001-5.98-5.999.001 4.019-2.021.002h-2l.001-4.022zm1.411.003 3.587-3.588-.001 2.587h3.5 2.521v-2.585l3.565 3.586-3.564 3.585-.001-2.585h-2.521l-3.499-.001-.001 2.586z' fill='%23fff'/><path d='m17.4971 18.9932h2.521v2.586l3.565-3.586-3.565-3.585v2.605h-2.521-3.5v-2.607l-3.586 3.587 3.586 3.586v-2.587z' fill='%23000'/>`;
  var ROTATE_CORNER_SVG = `<g><path d="M22.4789 9.45728L25.9935 12.9942L22.4789 16.5283V14.1032C18.126 14.1502 14.6071 17.6737 14.5675 22.0283H17.05L13.513 25.543L9.97889 22.0283H12.5674C12.6071 16.5691 17.0214 12.1503 22.4789 12.1031L22.4789 9.45728Z" fill="black"/><path fill-rule="evenodd" clip-rule="evenodd" d="M21.4789 7.03223L27.4035 12.9945L21.4789 18.9521V15.1868C18.4798 15.6549 16.1113 18.0273 15.649 21.0284H19.475L13.5128 26.953L7.55519 21.0284H11.6189C12.1243 15.8155 16.2679 11.6677 21.4789 11.1559L21.4789 7.03223ZM22.4789 12.1031C17.0214 12.1503 12.6071 16.5691 12.5674 22.0284H9.97889L13.513 25.543L17.05 22.0284H14.5675C14.5705 21.6896 14.5947 21.3558 14.6386 21.0284C15.1157 17.4741 17.9266 14.6592 21.4789 14.1761C21.8063 14.1316 22.1401 14.1069 22.4789 14.1032V16.5284L25.9935 12.9942L22.4789 9.45729L22.4789 12.1031Z" fill="white"/></g>`;
  var TEXT_SVG = `<path fill="currentcolor" d='m6.94 2v-1c-1.35866267-.08246172-2.66601117.53165299-3.47 1.63-.80398883-1.09834701-2.11133733-1.71246172-3.47-1.63v1c1.30781678-.16635468 2.55544738.59885876 3 1.84v5.1h-1v1h1v4.16c-.4476345 1.2386337-1.69302129 2.002471-3 1.84v1c1.35687108.0731933 2.6600216-.5389494 3.47-1.63.8099784 1.0910506 2.11312892 1.7031933 3.47 1.63v-1c-1.28590589.133063-2.49760499-.6252793-2.94-1.84v-4.18h1v-1h-1v-5.08c.43943906-1.21710975 1.65323743-1.97676587 2.94-1.84z' transform='translate(14 9)'/>`;
  var GRABBING_SVG = `<path d='m13.5732 12.0361c.48-.178 1.427-.069 1.677.473.213.462.396 1.241.406 1.075.024-.369-.024-1.167.137-1.584.117-.304.347-.59.686-.691.285-.086.62-.116.916-.055.313.064.642.287.765.499.362.623.368 1.899.385 1.831.064-.272.07-1.229.283-1.584.141-.235.497-.445.687-.479.294-.052.656-.068.964-.008.249.049.586.344.677.487.219.344.342 1.316.379 1.658.016.141.074-.393.293-.736.406-.639 1.844-.763 1.898.639.026.654.02.624.02 1.064 0 .516-.012.828-.04 1.202-.03.399-.116 1.304-.241 1.742-.086.301-.371.978-.653 1.384 0 0-1.074 1.25-1.191 1.812-.117.563-.078.567-.102.965-.023.399.121.923.121.923s-.801.104-1.234.034c-.391-.062-.875-.84-1-1.078-.172-.328-.539-.265-.682-.023-.224.383-.709 1.07-1.05 1.113-.669.084-2.055.03-3.14.02 0 0 .185-1.011-.227-1.358-.305-.26-.83-.784-1.144-1.06l-.832-.921c-.283-.36-1.002-.929-1.243-1.985-.213-.936-.192-1.395.037-1.77.232-.381.67-.589.854-.625.208-.042.692-.039.875.062.223.123.313.159.488.391.23.307.312.456.213.121-.076-.262-.322-.595-.434-.97-.109-.361-.401-.943-.38-1.526.008-.221.103-.771.832-1.042' fill='%23fff'/><g stroke='%23000' stroke-width='.75'><path d='m13.5732 12.0361c.48-.178 1.427-.069 1.677.473.213.462.396 1.241.406 1.075.024-.369-.024-1.167.137-1.584.117-.304.347-.59.686-.691.285-.086.62-.116.916-.055.313.064.642.287.765.499.362.623.368 1.899.385 1.831.064-.272.07-1.229.283-1.584.141-.235.497-.445.687-.479.294-.052.656-.068.964-.008.249.049.586.344.677.487.219.344.342 1.316.379 1.658.016.141.074-.393.293-.736.406-.639 1.844-.763 1.898.639.026.654.02.624.02 1.064 0 .516-.012.828-.04 1.202-.03.399-.116 1.304-.241 1.742-.086.301-.371.978-.653 1.384 0 0-1.074 1.25-1.191 1.812-.117.563-.078.567-.102.965-.023.399.121.923.121.923s-.801.104-1.234.034c-.391-.062-.875-.84-1-1.078-.172-.328-.539-.265-.682-.023-.224.383-.709 1.07-1.05 1.113-.669.084-2.055.03-3.14.02 0 0 .185-1.011-.227-1.358-.305-.26-.83-.784-1.144-1.06l-.832-.921c-.283-.36-1.002-.929-1.243-1.985-.213-.936-.192-1.395.037-1.77.232-.381.67-.589.854-.625.208-.042.692-.039.875.062.223.123.313.159.488.391.23.307.312.456.213.121-.076-.262-.322-.595-.434-.97-.109-.361-.401-.943-.38-1.526.008-.221.103-.771.832-1.042z' stroke-linejoin='round'/><path d='m20.5664 19.7344v-3.459' stroke-linecap='round'/><path d='m18.5508 19.7461-.016-3.473' stroke-linecap='round'/><path d='m16.5547 16.3047.021 3.426' stroke-linecap='round'/></g>`;
  var GRAB_SVG = `<path d="m13.5557 17.5742c-.098-.375-.196-.847-.406-1.552-.167-.557-.342-.859-.47-1.233-.155-.455-.303-.721-.496-1.181-.139-.329-.364-1.048-.457-1.44-.119-.509.033-.924.244-1.206.253-.339.962-.49 1.357-.351.371.13.744.512.916.788.288.46.357.632.717 1.542.393.992.564 1.918.611 2.231l.085.452c-.001-.04-.043-1.122-.044-1.162-.035-1.029-.06-1.823-.038-2.939.002-.126.064-.587.084-.715.078-.5.305-.8.673-.979.412-.201.926-.215 1.401-.017.423.173.626.55.687 1.022.014.109.094.987.093 1.107-.013 1.025.006 1.641.015 2.174.004.231.003 1.625.017 1.469.061-.656.094-3.189.344-3.942.144-.433.405-.746.794-.929.431-.203 1.113-.07 1.404.243.285.305.446.692.482 1.153.032.405-.019.897-.02 1.245 0 .867-.021 1.324-.037 2.121-.001.038-.015.298.023.182.094-.28.188-.542.266-.745.049-.125.241-.614.359-.859.114-.234.211-.369.415-.688.2-.313.415-.448.668-.561.54-.235 1.109.112 1.301.591.086.215.009.713-.028 1.105-.061.647-.254 1.306-.352 1.648-.128.447-.274 1.235-.34 1.601-.072.394-.234 1.382-.359 1.82-.086.301-.371.978-.652 1.384 0 0-1.074 1.25-1.192 1.812-.117.563-.078.567-.101.965-.024.399.121.923.121.923s-.802.104-1.234.034c-.391-.062-.875-.841-1-1.078-.172-.328-.539-.265-.682-.023-.225.383-.709 1.07-1.051 1.113-.668.084-2.054.03-3.139.02 0 0 .185-1.011-.227-1.358-.305-.26-.83-.784-1.144-1.06l-.832-.921c-.284-.36-.629-1.093-1.243-1.985-.348-.504-1.027-1.085-1.284-1.579-.223-.425-.331-.954-.19-1.325.225-.594.675-.897 1.362-.832.519.05.848.206 1.238.537.225.19.573.534.75.748.163.195.203.276.377.509.23.307.302.459.214.121" fill="%23fff"/><g stroke="%23000" stroke-linecap="round" stroke-width=".75"><path d="m13.5557 17.5742c-.098-.375-.196-.847-.406-1.552-.167-.557-.342-.859-.47-1.233-.155-.455-.303-.721-.496-1.181-.139-.329-.364-1.048-.457-1.44-.119-.509.033-.924.244-1.206.253-.339.962-.49 1.357-.351.371.13.744.512.916.788.288.46.357.632.717 1.542.393.992.564 1.918.611 2.231l.085.452c-.001-.04-.043-1.122-.044-1.162-.035-1.029-.06-1.823-.038-2.939.002-.126.064-.587.084-.715.078-.5.305-.8.673-.979.412-.201.926-.215 1.401-.017.423.173.626.55.687 1.022.014.109.094.987.093 1.107-.013 1.025.006 1.641.015 2.174.004.231.003 1.625.017 1.469.061-.656.094-3.189.344-3.942.144-.433.405-.746.794-.929.431-.203 1.113-.07 1.404.243.285.305.446.692.482 1.153.032.405-.019.897-.02 1.245 0 .867-.021 1.324-.037 2.121-.001.038-.015.298.023.182.094-.28.188-.542.266-.745.049-.125.241-.614.359-.859.114-.234.211-.369.415-.688.2-.313.415-.448.668-.561.54-.235 1.109.112 1.301.591.086.215.009.713-.028 1.105-.061.647-.254 1.306-.352 1.648-.128.447-.274 1.235-.34 1.601-.072.394-.234 1.382-.359 1.82-.086.301-.371.978-.652 1.384 0 0-1.074 1.25-1.192 1.812-.117.563-.078.567-.101.965-.024.399.121.923.121.923s-.802.104-1.234.034c-.391-.062-.875-.841-1-1.078-.172-.328-.539-.265-.682-.023-.225.383-.709 1.07-1.051 1.113-.668.084-2.054.03-3.139.02 0 0 .185-1.011-.227-1.358-.305-.26-.83-.784-1.144-1.06l-.832-.921c-.284-.36-.629-1.093-1.243-1.985-.348-.504-1.027-1.085-1.284-1.579-.223-.425-.331-.954-.19-1.325.225-.594.675-.897 1.362-.832.519.05.848.206 1.238.537.225.19.573.534.75.748.163.195.203.276.377.509.23.307.302.459.214.121" stroke-linejoin="round"/><path d="m20.5664 21.7344v-3.459"/><path d="m18.5508 21.7461-.016-3.473"/><path d="m16.5547 18.3047.021 3.426"/></g>`;
  function getCursorCss(svg, r3, tr, f3, color) {
    const a3 = (-tr - r3) * (PI / 180);
    const s3 = Math.sin(a3);
    const c3 = Math.cos(a3);
    const dx = 1 * c3 - 1 * s3;
    const dy = 1 * s3 + 1 * c3;
    return `url("data:image/svg+xml,<svg height='32' width='32' viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg' style='color: ${color};'><defs><filter id='shadow' color-interpolation-filters='sRGB'><feDropShadow dx='${dx}' dy='${dy}' stdDeviation='1.2' flood-opacity='.5'/></filter></defs><g fill='none' transform='rotate(${r3 + tr} 16 16)${f3 ? ` scale(-1,-1) translate(0, -32)` : ""}' filter='url(%23shadow)'>` + svg.replaceAll(`"`, `'`) + '</g></svg>") 16 16, pointer';
  }
  var CURSORS = {
    none: () => "none",
    default: () => "default",
    pointer: () => "pointer",
    cross: () => "crosshair",
    move: () => "move",
    grab: (r3, f3, c3) => getCursorCss(GRAB_SVG, r3, 0, f3, c3),
    grabbing: (r3, f3, c3) => getCursorCss(GRABBING_SVG, r3, 0, f3, c3),
    text: (r3, f3, c3) => getCursorCss(TEXT_SVG, r3, 0, f3, c3),
    "resize-edge": (r3, f3, c3) => getCursorCss(EDGE_SVG, r3, 0, f3, c3),
    "resize-corner": (r3, f3, c3) => getCursorCss(CORNER_SVG, r3, 0, f3, c3),
    "ew-resize": (r3, f3, c3) => getCursorCss(EDGE_SVG, r3, 0, f3, c3),
    "ns-resize": (r3, f3, c3) => getCursorCss(EDGE_SVG, r3, 90, f3, c3),
    "nesw-resize": (r3, f3, c3) => getCursorCss(CORNER_SVG, r3, 0, f3, c3),
    "nwse-resize": (r3, f3, c3) => getCursorCss(CORNER_SVG, r3, 90, f3, c3),
    rotate: (r3, f3, c3) => getCursorCss(ROTATE_CORNER_SVG, r3, 45, f3, c3),
    "nwse-rotate": (r3, f3, c3) => getCursorCss(ROTATE_CORNER_SVG, r3, 0, f3, c3),
    "nesw-rotate": (r3, f3, c3) => getCursorCss(ROTATE_CORNER_SVG, r3, 90, f3, c3),
    "senw-rotate": (r3, f3, c3) => getCursorCss(ROTATE_CORNER_SVG, r3, 180, f3, c3),
    "swne-rotate": (r3, f3, c3) => getCursorCss(ROTATE_CORNER_SVG, r3, 270, f3, c3),
    "zoom-in": () => "zoom-in",
    "zoom-out": () => "zoom-out"
  };
  function getCursor(cursor, rotation = 0, color = "black") {
    return CURSORS[cursor](radiansToDegrees(rotation), false, color);
  }
  function useCursor() {
    const app = useApp();
    const container = useContainer();
    useQuickReactor(
      "useCursor",
      () => {
        const { type, rotation, color } = app.cursor;
        container.style.setProperty("--tl-cursor", getCursor(type, rotation, color));
      },
      [app, container]
    );
  }

  // ../../../packages/editor/src/lib/hooks/useSelectionEvents.ts
  var import_react27 = __toESM(require_react());
  function useSelectionEvents(handle) {
    const app = useApp();
    const events = (0, import_react27.useMemo)(
      function selectionEvents() {
        const onPointerDown = (e2) => {
          if (e2.isKilled)
            return;
          if (e2.button !== 0)
            return;
          const elm = loopToHtmlElement(e2.currentTarget);
          function releaseCapture() {
            elm.removeEventListener("pointerup", releaseCapture);
            releasePointerCapture(elm, e2);
          }
          setPointerCapture(elm, e2);
          elm.addEventListener("pointerup", releaseCapture);
          app.dispatch(__spreadValues({
            name: "pointer_down",
            type: "pointer",
            target: "selection",
            handle
          }, getPointerInfo(e2, app.getContainer())));
          e2.stopPropagation();
        };
        let lastX, lastY;
        function onPointerMove(e2) {
          if (e2.isKilled)
            return;
          if (e2.button !== 0)
            return;
          if (e2.clientX === lastX && e2.clientY === lastY)
            return;
          lastX = e2.clientX;
          lastY = e2.clientY;
          app.dispatch(__spreadValues({
            name: "pointer_move",
            type: "pointer",
            target: "selection",
            handle
          }, getPointerInfo(e2, app.getContainer())));
        }
        const onPointerUp = (e2) => {
          if (e2.isKilled)
            return;
          if (e2.button !== 0)
            return;
          app.dispatch(__spreadValues({
            name: "pointer_up",
            type: "pointer",
            target: "selection",
            handle
          }, getPointerInfo(e2, app.getContainer())));
        };
        return {
          onPointerDown,
          onPointerMove,
          onPointerUp
        };
      },
      [app, handle]
    );
    return events;
  }

  // ../../../packages/editor/src/lib/components/CropHandles.tsx
  var import_classnames4 = __toESM(require_classnames());
  var import_jsx_runtime18 = __toESM(require_jsx_runtime());
  function CropHandles({ size, width, height, hideAlternateHandles }) {
    const cropStrokeWidth = toDomPrecision(size / 3);
    const offset = cropStrokeWidth / 2;
    return /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)("svg", { className: "tl-overlays__item", children: [
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
        "polyline",
        {
          className: "tl-corner-crop-handle",
          points: `
						${toDomPrecision(0 - offset)},${toDomPrecision(size)} 
						${toDomPrecision(0 - offset)},${toDomPrecision(0 - offset)} 
						${toDomPrecision(size)},${toDomPrecision(0 - offset)}`,
          strokeWidth: cropStrokeWidth,
          "data-wd": "selection.crop.top_left",
          "aria-label": "top_left handle"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
        "line",
        {
          className: (0, import_classnames4.default)("tl-corner-crop-edge-handle", {
            "tl-hidden": hideAlternateHandles
          }),
          x1: toDomPrecision(width / 2 - size),
          y1: toDomPrecision(0 - offset),
          x2: toDomPrecision(width / 2 + size),
          y2: toDomPrecision(0 - offset),
          strokeWidth: cropStrokeWidth,
          "data-wd": "selection.crop.top",
          "aria-label": "top handle"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
        "polyline",
        {
          className: (0, import_classnames4.default)("tl-corner-crop-handle", {
            "tl-hidden": hideAlternateHandles
          }),
          points: `
						${toDomPrecision(width - size)},${toDomPrecision(0 - offset)} 
						${toDomPrecision(width + offset)},${toDomPrecision(0 - offset)} 
						${toDomPrecision(width + offset)},${toDomPrecision(size)}`,
          strokeWidth: cropStrokeWidth,
          "data-wd": "selection.crop.top_right",
          "aria-label": "top_right handle"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
        "line",
        {
          className: (0, import_classnames4.default)("tl-corner-crop-edge-handle", {
            "tl-hidden": hideAlternateHandles
          }),
          x1: toDomPrecision(width + offset),
          y1: toDomPrecision(height / 2 - size),
          x2: toDomPrecision(width + offset),
          y2: toDomPrecision(height / 2 + size),
          strokeWidth: cropStrokeWidth,
          "data-wd": "selection.crop.right",
          "aria-label": "right handle"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
        "polyline",
        {
          className: "tl-corner-crop-handle",
          points: `
						${toDomPrecision(width + offset)},${toDomPrecision(height - size)} 
						${toDomPrecision(width + offset)},${toDomPrecision(height + offset)}
						${toDomPrecision(width - size)},${toDomPrecision(height + offset)}`,
          strokeWidth: cropStrokeWidth,
          "data-wd": "selection.crop.bottom_right",
          "aria-label": "bottom_right handle"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
        "line",
        {
          className: (0, import_classnames4.default)("tl-corner-crop-edge-handle", {
            "tl-hidden": hideAlternateHandles
          }),
          x1: toDomPrecision(width / 2 - size),
          y1: toDomPrecision(height + offset),
          x2: toDomPrecision(width / 2 + size),
          y2: toDomPrecision(height + offset),
          strokeWidth: cropStrokeWidth,
          "data-wd": "selection.crop.bottom",
          "aria-label": "bottom handle"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
        "polyline",
        {
          className: (0, import_classnames4.default)("tl-corner-crop-handle", {
            "tl-hidden": hideAlternateHandles
          }),
          points: `
						${toDomPrecision(0 + size)},${toDomPrecision(height + offset)} 
						${toDomPrecision(0 - offset)},${toDomPrecision(height + offset)}
						${toDomPrecision(0 - offset)},${toDomPrecision(height - size)}`,
          strokeWidth: cropStrokeWidth,
          "data-wd": "selection.crop.bottom_left",
          "aria-label": "bottom_left handle"
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime18.jsx)(
        "line",
        {
          className: (0, import_classnames4.default)("tl-corner-crop-edge-handle", {
            "tl-hidden": hideAlternateHandles
          }),
          x1: toDomPrecision(0 - offset),
          y1: toDomPrecision(height / 2 - size),
          x2: toDomPrecision(0 - offset),
          y2: toDomPrecision(height / 2 + size),
          strokeWidth: cropStrokeWidth,
          "data-wd": "selection.crop.left",
          "aria-label": "left handle"
        }
      )
    ] });
  }

  // ../../../packages/editor/src/lib/components/SelectionFg.tsx
  var import_jsx_runtime19 = __toESM(require_jsx_runtime());
  var IS_FIREFOX = typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
  var SelectionFg = track(function SelectionFg2() {
    var _a5;
    const app = useApp();
    const rSvg = (0, import_react28.useRef)(null);
    const isReadonlyMode = app.isReadOnly;
    const topEvents = useSelectionEvents("top");
    const rightEvents = useSelectionEvents("right");
    const bottomEvents = useSelectionEvents("bottom");
    const leftEvents = useSelectionEvents("left");
    const topLeftEvents = useSelectionEvents("top_left");
    const topRightEvents = useSelectionEvents("top_right");
    const bottomRightEvents = useSelectionEvents("bottom_right");
    const bottomLeftEvents = useSelectionEvents("bottom_left");
    const isDefaultCursor = !app.isMenuOpen && app.cursor.type === "default";
    const isCoarsePointer = app.isCoarsePointer;
    let bounds = app.selectionBounds;
    const shapes = app.selectedShapes;
    const onlyShape = shapes.length === 1 ? shapes[0] : null;
    const expandOutlineBy = onlyShape ? app.getShapeUtil(onlyShape).expandSelectionOutlinePx(onlyShape) : 0;
    useTransform(rSvg, bounds == null ? void 0 : bounds.x, bounds == null ? void 0 : bounds.y, 1, app.selectionRotation, {
      x: -expandOutlineBy,
      y: -expandOutlineBy
    });
    if (!bounds)
      return null;
    bounds = bounds.clone().expandBy(expandOutlineBy);
    const zoom = app.zoomLevel;
    const rotation = app.selectionRotation;
    const isChangingStyles = app.isChangingStyle;
    const width = Math.max(1, bounds.width);
    const height = Math.max(1, bounds.height);
    const size = 8 / zoom;
    const isTinyX = width < size * 2;
    const isTinyY = height < size * 2;
    const isSmallX = width < size * 4;
    const isSmallY = height < size * 4;
    const isSmallCropX = width < size * 5;
    const isSmallCropY = height < size * 5;
    const mobileHandleMultiplier = isCoarsePointer ? 1.75 : 1;
    const targetSize = 6 / zoom * mobileHandleMultiplier;
    const targetSizeX = (isSmallX ? targetSize / 2 : targetSize) * (mobileHandleMultiplier * 0.75);
    const targetSizeY = (isSmallY ? targetSize / 2 : targetSize) * (mobileHandleMultiplier * 0.75);
    const showSelectionBounds = (onlyShape ? !app.getShapeUtil(onlyShape).hideSelectionBoundsFg(onlyShape) : true) && !isChangingStyles;
    let shouldDisplayBox = showSelectionBounds && app.isInAny(
      "select.idle",
      "select.brushing",
      "select.scribble_brushing",
      "select.pointing_canvas",
      "select.pointing_selection",
      "select.pointing_shape",
      "select.crop.idle",
      "select.crop.pointing_crop",
      "select.pointing_resize_handle",
      "select.pointing_crop_handle",
      "select.editing_shape"
    ) || showSelectionBounds && app.isIn("select.resizing") && onlyShape && shapes[0].type === "text";
    if (IS_FIREFOX && shouldDisplayBox) {
      if (((_a5 = app.onlySelectedShape) == null ? void 0 : _a5.type) === "embed") {
        shouldDisplayBox = false;
      }
    }
    const showCropHandles = app.isInAny("select.pointing_crop_handle", "select.crop.idle", "select.crop.pointing_crop") && !isChangingStyles && !isReadonlyMode;
    const shouldDisplayControls = app.isInAny(
      "select.idle",
      "select.pointing_selection",
      "select.pointing_shape",
      "select.crop.idle"
    ) && !isChangingStyles && !isReadonlyMode;
    const showCornerRotateHandles = !isCoarsePointer && !(isTinyX || isTinyY) && (shouldDisplayControls || showCropHandles) && (onlyShape ? !app.getShapeUtil(onlyShape).hideRotateHandle(onlyShape) : true);
    const showMobileRotateHandle = isCoarsePointer && (!isSmallX || !isSmallY) && (shouldDisplayControls || showCropHandles) && (onlyShape ? !app.getShapeUtil(onlyShape).hideRotateHandle(onlyShape) : true);
    const showResizeHandles = shouldDisplayControls && (onlyShape ? app.getShapeUtil(onlyShape).canResize(onlyShape) && !app.getShapeUtil(onlyShape).hideResizeHandles(onlyShape) : true) && !showCropHandles;
    const hideAlternateCornerHandles = isTinyX || isTinyY;
    const showOnlyOneHandle = isTinyX && isTinyY;
    const hideAlternateCropHandles = isSmallCropX || isSmallCropY;
    const showHandles = showResizeHandles || showCropHandles;
    const hideRotateCornerHandles = !showCornerRotateHandles;
    const hideMobileRotateHandle = !shouldDisplayControls || !showMobileRotateHandle;
    const hideTopLeftCorner = !shouldDisplayControls || !showHandles;
    const hideTopRightCorner = !shouldDisplayControls || !showHandles || hideAlternateCornerHandles;
    const hideBottomLeftCorner = !shouldDisplayControls || !showHandles || hideAlternateCornerHandles;
    const hideBottomRightCorner = !shouldDisplayControls || !showHandles || showOnlyOneHandle && !showCropHandles;
    let hideEdgeTargetsDueToCoarsePointer = isCoarsePointer;
    if (hideEdgeTargetsDueToCoarsePointer && shapes.every((shape) => app.getShapeUtil(shape).isAspectRatioLocked(shape))) {
      hideEdgeTargetsDueToCoarsePointer = false;
    }
    let hideEdgeTargets = true;
    if (showCropHandles) {
      hideEdgeTargets = hideAlternateCropHandles;
    } else if (showResizeHandles) {
      hideEdgeTargets = hideAlternateCornerHandles || showOnlyOneHandle || hideEdgeTargetsDueToCoarsePointer;
    }
    const textHandleHeight = Math.min(24 / zoom, height - targetSizeY * 3);
    const showTextResizeHandles = shouldDisplayControls && isCoarsePointer && (onlyShape == null ? void 0 : onlyShape.type) === "text" && textHandleHeight * zoom >= 4;
    return /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)("svg", { ref: rSvg, className: "tl-overlays__item tl-selection__fg", "data-wd": "selection-foreground", children: [
      shouldDisplayBox && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
        "rect",
        {
          className: (0, import_classnames5.default)("tl-selection__fg__outline"),
          width: toDomPrecision(width),
          height: toDomPrecision(height)
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
        RotateCornerHandle,
        {
          "data-wd": "selection.rotate.top-left",
          cx: 0,
          cy: 0,
          targetSize,
          corner: "top_left_rotate",
          cursor: isDefaultCursor ? getCursor("nwse-rotate", rotation) : void 0,
          isHidden: hideRotateCornerHandles
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
        RotateCornerHandle,
        {
          "data-wd": "selection.rotate.top-right",
          cx: width + targetSize * 3,
          cy: 0,
          targetSize,
          corner: "top_right_rotate",
          cursor: isDefaultCursor ? getCursor("nesw-rotate", rotation) : void 0,
          isHidden: hideRotateCornerHandles
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
        RotateCornerHandle,
        {
          "data-wd": "selection.rotate.bottom-left",
          cx: 0,
          cy: height + targetSize * 3,
          targetSize,
          corner: "bottom_left_rotate",
          cursor: isDefaultCursor ? getCursor("swne-rotate", rotation) : void 0,
          isHidden: hideRotateCornerHandles
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
        RotateCornerHandle,
        {
          "data-wd": "selection.rotate.bottom-right",
          cx: width + targetSize * 3,
          cy: height + targetSize * 3,
          targetSize,
          corner: "bottom_right_rotate",
          cursor: isDefaultCursor ? getCursor("senw-rotate", rotation) : void 0,
          isHidden: hideRotateCornerHandles
        }
      ),
      " ",
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
        MobileRotateHandle,
        {
          "data-wd": "selection.rotate.mobile",
          cx: isSmallX ? -targetSize * 1.5 : width / 2,
          cy: isSmallX ? height / 2 : -targetSize * 1.5,
          size,
          isHidden: hideMobileRotateHandle
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
        "rect",
        __spreadValues({
          className: (0, import_classnames5.default)("tl-transparent", {
            "tl-hidden": hideEdgeTargets
          }),
          "data-wd": "selection.resize.top",
          "aria-label": "top target",
          pointerEvents: "all",
          x: 0,
          y: toDomPrecision(0 - (isSmallY ? targetSizeY * 2 : targetSizeY)),
          width: toDomPrecision(Math.max(1, width)),
          height: toDomPrecision(Math.max(1, targetSizeY * 2)),
          style: isDefaultCursor ? { cursor: getCursor("ns-resize", rotation) } : void 0
        }, topEvents)
      ),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
        "rect",
        __spreadValues({
          className: (0, import_classnames5.default)("tl-transparent", {
            "tl-hidden": hideEdgeTargets
          }),
          "data-wd": "selection.resize.right",
          "aria-label": "right target",
          pointerEvents: "all",
          x: toDomPrecision(width - (isSmallX ? 0 : targetSizeX)),
          y: 0,
          height: toDomPrecision(Math.max(1, height)),
          width: toDomPrecision(Math.max(1, targetSizeX * 2)),
          style: isDefaultCursor ? { cursor: getCursor("ew-resize", rotation) } : void 0
        }, rightEvents)
      ),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
        "rect",
        __spreadValues({
          className: (0, import_classnames5.default)("tl-transparent", {
            "tl-hidden": hideEdgeTargets
          }),
          "data-wd": "selection.resize.bottom",
          "aria-label": "bottom target",
          pointerEvents: "all",
          x: 0,
          y: toDomPrecision(height - (isSmallY ? 0 : targetSizeY)),
          width: toDomPrecision(Math.max(1, width)),
          height: toDomPrecision(Math.max(1, targetSizeY * 2)),
          style: isDefaultCursor ? { cursor: getCursor("ns-resize", rotation) } : void 0
        }, bottomEvents)
      ),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
        "rect",
        __spreadValues({
          className: (0, import_classnames5.default)("tl-transparent", {
            "tl-hidden": hideEdgeTargets
          }),
          "data-wd": "selection.resize.left",
          "aria-label": "left target",
          pointerEvents: "all",
          x: toDomPrecision(0 - (isSmallX ? targetSizeX * 2 : targetSizeX)),
          y: 0,
          height: toDomPrecision(Math.max(1, height)),
          width: toDomPrecision(Math.max(1, targetSizeX * 2)),
          style: isDefaultCursor ? { cursor: getCursor("ew-resize", rotation) } : void 0
        }, leftEvents)
      ),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
        "rect",
        __spreadValues({
          className: (0, import_classnames5.default)("tl-transparent", {
            "tl-hidden": hideTopLeftCorner
          }),
          "data-wd": "selection.target.top-left",
          "aria-label": "top-left target",
          pointerEvents: "all",
          x: toDomPrecision(0 - (isSmallX ? targetSizeX * 2 : targetSizeX * 1.5)),
          y: toDomPrecision(0 - (isSmallY ? targetSizeY * 2 : targetSizeY * 1.5)),
          width: toDomPrecision(targetSizeX * 3),
          height: toDomPrecision(targetSizeY * 3),
          style: isDefaultCursor ? { cursor: getCursor("nwse-resize", rotation) } : void 0
        }, topLeftEvents)
      ),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
        "rect",
        __spreadValues({
          className: (0, import_classnames5.default)("tl-transparent", {
            "tl-hidden": hideTopRightCorner
          }),
          "data-wd": "selection.target.top-right",
          "aria-label": "top-right target",
          pointerEvents: "all",
          x: toDomPrecision(width - (isSmallX ? 0 : targetSizeX * 1.5)),
          y: toDomPrecision(0 - (isSmallY ? targetSizeY * 2 : targetSizeY * 1.5)),
          width: toDomPrecision(targetSizeX * 3),
          height: toDomPrecision(targetSizeY * 3),
          style: isDefaultCursor ? { cursor: getCursor("nesw-resize", rotation) } : void 0
        }, topRightEvents)
      ),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
        "rect",
        __spreadValues({
          className: (0, import_classnames5.default)("tl-transparent", {
            "tl-hidden": hideBottomRightCorner
          }),
          "data-wd": "selection.target.bottom-right",
          "aria-label": "bottom-right target",
          pointerEvents: "all",
          x: toDomPrecision(width - (isSmallX ? targetSizeX : targetSizeX * 1.5)),
          y: toDomPrecision(height - (isSmallY ? targetSizeY : targetSizeY * 1.5)),
          width: toDomPrecision(targetSizeX * 3),
          height: toDomPrecision(targetSizeY * 3),
          style: isDefaultCursor ? { cursor: getCursor("nwse-resize", rotation) } : void 0
        }, bottomRightEvents)
      ),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
        "rect",
        __spreadValues({
          className: (0, import_classnames5.default)("tl-transparent", {
            "tl-hidden": hideBottomLeftCorner
          }),
          "data-wd": "selection.target.bottom-left",
          "aria-label": "bottom-left target",
          pointerEvents: "all",
          x: toDomPrecision(0 - (isSmallX ? targetSizeX * 3 : targetSizeX * 1.5)),
          y: toDomPrecision(height - (isSmallY ? 0 : targetSizeY * 1.5)),
          width: toDomPrecision(targetSizeX * 3),
          height: toDomPrecision(targetSizeY * 3),
          style: isDefaultCursor ? { cursor: getCursor("nesw-resize", rotation) } : void 0
        }, bottomLeftEvents)
      ),
      showResizeHandles && /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)(import_jsx_runtime19.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
          "rect",
          {
            "data-wd": "selection.resize.top-left",
            className: (0, import_classnames5.default)("tl-corner-handle", {
              "tl-hidden": hideTopLeftCorner
            }),
            "aria-label": "top_left handle",
            x: toDomPrecision(0 - size / 2),
            y: toDomPrecision(0 - size / 2),
            width: toDomPrecision(size),
            height: toDomPrecision(size)
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
          "rect",
          {
            "data-wd": "selection.resize.top-right",
            className: (0, import_classnames5.default)("tl-corner-handle", {
              "tl-hidden": hideTopRightCorner
            }),
            "aria-label": "top_right handle",
            x: toDomPrecision(width - size / 2),
            y: toDomPrecision(0 - size / 2),
            width: toDomPrecision(size),
            height: toDomPrecision(size)
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
          "rect",
          {
            "data-wd": "selection.resize.bottom-right",
            className: (0, import_classnames5.default)("tl-corner-handle", {
              "tl-hidden": hideBottomRightCorner
            }),
            "aria-label": "bottom_right handle",
            x: toDomPrecision(width - size / 2),
            y: toDomPrecision(height - size / 2),
            width: toDomPrecision(size),
            height: toDomPrecision(size)
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
          "rect",
          {
            "data-wd": "selection.resize.bottom-left",
            className: (0, import_classnames5.default)("tl-corner-handle", {
              "tl-hidden": hideBottomLeftCorner
            }),
            "aria-label": "bottom_left handle",
            x: toDomPrecision(0 - size / 2),
            y: toDomPrecision(height - size / 2),
            width: toDomPrecision(size),
            height: toDomPrecision(size)
          }
        )
      ] }),
      showTextResizeHandles && /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)(import_jsx_runtime19.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
          "rect",
          {
            "data-wd": "selection.text-resize.left.handle",
            className: "tl-text-handle",
            "aria-label": "bottom_left handle",
            x: toDomPrecision(0 - size / 4),
            y: toDomPrecision(height / 2 - textHandleHeight / 2),
            rx: size / 4,
            width: toDomPrecision(size / 2),
            height: toDomPrecision(textHandleHeight)
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
          "rect",
          {
            "data-wd": "selection.text-resize.right.handle",
            className: "tl-text-handle",
            "aria-label": "bottom_left handle",
            rx: size / 4,
            x: toDomPrecision(width - size / 4),
            y: toDomPrecision(height / 2 - textHandleHeight / 2),
            width: toDomPrecision(size / 2),
            height: toDomPrecision(textHandleHeight)
          }
        )
      ] }),
      showCropHandles && /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
        CropHandles,
        __spreadValues({}, {
          size,
          width,
          height,
          hideAlternateHandles: hideAlternateCropHandles
        })
      )
    ] });
  });
  var RotateCornerHandle = function RotateCornerHandle2({
    cx,
    cy,
    targetSize,
    corner,
    cursor,
    isHidden,
    "data-wd": dataWd
  }) {
    const events = useSelectionEvents(corner);
    return /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
      "rect",
      __spreadValues({
        className: (0, import_classnames5.default)("tl-transparent", "tl-rotate-corner", { "tl-hidden": isHidden }),
        "data-wd": dataWd,
        "aria-label": `${corner} target`,
        pointerEvents: "all",
        x: toDomPrecision(cx - targetSize * 3),
        y: toDomPrecision(cy - targetSize * 3),
        width: toDomPrecision(Math.max(1, targetSize * 3)),
        height: toDomPrecision(Math.max(1, targetSize * 3)),
        cursor
      }, events)
    );
  };
  var SQUARE_ROOT_PI = Math.sqrt(Math.PI);
  var MobileRotateHandle = function RotateHandle({
    cx,
    cy,
    size,
    isHidden,
    "data-wd": dataWd
  }) {
    const events = useSelectionEvents("mobile_rotate");
    return /* @__PURE__ */ (0, import_jsx_runtime19.jsxs)("g", { children: [
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
        "circle",
        __spreadValues({
          "data-wd": dataWd,
          pointerEvents: "all",
          className: (0, import_classnames5.default)("tl-transparent", "tl-mobile-rotate__bg", { "tl-hidden": isHidden }),
          cx,
          cy
        }, events)
      ),
      /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(
        "circle",
        {
          className: (0, import_classnames5.default)("tl-mobile-rotate__fg", { "tl-hidden": isHidden }),
          cx,
          cy,
          r: size / SQUARE_ROOT_PI
        }
      )
    ] });
  };

  // ../../../packages/editor/src/lib/components/Shape.tsx
  var React16 = __toESM(require_react());

  // ../../../packages/editor/src/lib/hooks/useShapeEvents.ts
  var import_react29 = __toESM(require_react());
  var pointerEventHandler = (app, shapeId, name, capturedPointerIdLookup) => {
    return (e2) => {
      if (name !== "pointer_move" && app.pageState.editingId === shapeId)
        e2.isKilled = true;
      if (e2.isKilled)
        return;
      let pointerInfo = getPointerInfo(e2, app.getContainer());
      switch (name) {
        case "pointer_down": {
          if (e2.button !== 0 && e2.button !== 1 && e2.button !== 2)
            return;
          setPointerCapture(e2.currentTarget, e2);
          if (e2.button === 0) {
            capturedPointerIdLookup.add(`pointer_down:${e2.pointerId}:0`);
          }
          break;
        }
        case "pointer_up": {
          const key = `pointer_down:${e2.pointerId}:0`;
          if (capturedPointerIdLookup.has(key)) {
            pointerInfo = __spreadProps(__spreadValues({}, pointerInfo), {
              button: 0
            });
            capturedPointerIdLookup.delete(key);
          }
          releasePointerCapture(e2.currentTarget, e2);
          break;
        }
      }
      const shape = app.getShapeById(shapeId);
      if (!shape) {
        console.error("Shape not found", shapeId);
        return;
      }
      app.dispatch(__spreadValues({
        type: "pointer",
        target: "shape",
        shape,
        name
      }, pointerInfo));
    };
  };
  function useShapeEvents(id) {
    const app = useApp();
    return import_react29.default.useMemo(() => {
      const capturedPointerIdLookup = /* @__PURE__ */ new Set();
      function onTouchStart(e2) {
        ;
        e2.isKilled = true;
        preventDefault(e2);
      }
      function onTouchEnd(e2) {
        ;
        e2.isKilled = true;
        preventDefault(e2);
      }
      const handlePointerMove = pointerEventHandler(app, id, "pointer_move", capturedPointerIdLookup);
      let lastX, lastY;
      function onPointerMove(e2) {
        if (e2.isKilled)
          return;
        if (e2.clientX === lastX && e2.clientY === lastY)
          return;
        lastX = e2.clientX;
        lastY = e2.clientY;
        return handlePointerMove(e2);
      }
      return {
        onPointerDown: pointerEventHandler(app, id, "pointer_down", capturedPointerIdLookup),
        onPointerUp: pointerEventHandler(app, id, "pointer_up", capturedPointerIdLookup),
        onPointerEnter: pointerEventHandler(app, id, "pointer_enter", capturedPointerIdLookup),
        onPointerLeave: pointerEventHandler(app, id, "pointer_leave", capturedPointerIdLookup),
        onPointerMove,
        onTouchStart,
        onTouchEnd
      };
    }, [app, id]);
  }

  // ../../../packages/editor/src/lib/components/ErrorBoundary.tsx
  var React15 = __toESM(require_react());
  var import_jsx_runtime20 = __toESM(require_jsx_runtime());
  var initialState = { error: null };
  var ErrorBoundary = class extends React15.Component {
    constructor() {
      super(...arguments);
      __publicField(this, "state", initialState);
    }
    static getDerivedStateFromError(error) {
      return { error };
    }
    componentDidCatch(error) {
      var _a5, _b2;
      (_b2 = (_a5 = this.props).onError) == null ? void 0 : _b2.call(_a5, error);
    }
    render() {
      const { error } = this.state;
      if (error !== null) {
        return this.props.fallback(error);
      }
      return this.props.children;
    }
  };
  function OptionalErrorBoundary(_a5) {
    var _b2 = _a5, {
      children,
      fallback
    } = _b2, props = __objRest(_b2, [
      "children",
      "fallback"
    ]);
    if (fallback === null) {
      return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(import_jsx_runtime20.Fragment, { children });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(ErrorBoundary, __spreadProps(__spreadValues({ fallback }, props), { children }));
  }

  // ../../../packages/editor/src/lib/components/Shape.tsx
  var import_jsx_runtime21 = __toESM(require_jsx_runtime());
  var Shape = track(function Shape2({
    id,
    index: index2,
    opacity,
    isCulled
  }) {
    const app = useApp();
    const { ShapeErrorFallback } = useEditorComponents();
    const events = useShapeEvents(id);
    const rContainer = React16.useRef(null);
    useQuickReactor(
      "set shape container transform position",
      () => {
        const elm = rContainer.current;
        if (!elm)
          return;
        const shape2 = app.getShapeById(id);
        const pageTransform = app.getPageTransformById(id);
        if (!shape2 || !pageTransform)
          return null;
        const transform = Matrix2d.toCssString(pageTransform);
        elm.style.setProperty("transform", transform);
      },
      [app]
    );
    useQuickReactor(
      "set shape container clip path / color",
      () => {
        const elm = rContainer.current;
        const shape2 = app.getShapeById(id);
        if (!elm)
          return;
        if (!shape2)
          return null;
        const clipPath = app.getClipPathById(id);
        elm.style.setProperty("clip-path", clipPath != null ? clipPath : "none");
        if ("color" in shape2.props) {
          elm.style.setProperty("color", app.getCssColor(shape2.props.color));
        }
      },
      [app]
    );
    useQuickReactor(
      "set shape height and width",
      () => {
        const elm = rContainer.current;
        const shape2 = app.getShapeById(id);
        if (!elm)
          return;
        if (!shape2)
          return null;
        const util2 = app.getShapeUtil(shape2);
        const bounds = util2.bounds(shape2);
        elm.style.setProperty("width", Math.ceil(bounds.width) + "px");
        elm.style.setProperty("height", Math.ceil(bounds.height) + "px");
      },
      [app]
    );
    React16.useLayoutEffect(() => {
      const elm = rContainer.current;
      if (!elm)
        return;
      elm.style.setProperty("opacity", opacity + "");
      elm.style.setProperty("z-index", index2 + "");
    }, [opacity, index2]);
    const shape = app.getShapeById(id);
    if (!shape)
      return null;
    const util = app.getShapeUtil(shape);
    return /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
      "div",
      {
        ref: rContainer,
        className: "tl-shape",
        "data-shape-type": shape.type,
        draggable: false,
        onPointerDown: events.onPointerDown,
        onPointerMove: events.onPointerMove,
        onPointerUp: events.onPointerUp,
        onPointerEnter: events.onPointerEnter,
        onPointerLeave: events.onPointerLeave,
        children: isCulled && util.canUnmount(shape) ? /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(CulledShape, { shape, util }) : /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
          OptionalErrorBoundary,
          {
            fallback: ShapeErrorFallback ? (error) => /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(ShapeErrorFallback, { error }) : null,
            onError: (error) => app.annotateError(error, { origin: "react.shape", willCrashApp: false }),
            children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(InnerShape, { shape, util })
          }
        )
      },
      id
    );
  });
  var InnerShape = React16.memo(
    function InnerShape2({ shape, util }) {
      return useStateTracking("InnerShape:" + util.type, () => util.render(shape));
    },
    (prev, next) => prev.shape.props === next.shape.props
  );
  var CulledShape = React16.memo(
    function CulledShap({ shape, util }) {
      const bounds = util.bounds(shape);
      return /* @__PURE__ */ (0, import_jsx_runtime21.jsx)(
        "div",
        {
          className: "tl-shape__culled",
          style: {
            transform: `translate(${bounds.minX}px, ${bounds.minY}px)`,
            width: bounds.width,
            height: bounds.height
          }
        }
      );
    },
    () => true
  );

  // ../../../packages/editor/src/lib/components/ShapeIndicator.tsx
  var import_classnames6 = __toESM(require_classnames());
  var React17 = __toESM(require_react());
  var import_jsx_runtime22 = __toESM(require_jsx_runtime());
  var ShapeWithPropsEquality = class {
    constructor(shape) {
      this.shape = shape;
    }
    equals(other) {
      var _a5, _b2;
      return ((_a5 = this.shape) == null ? void 0 : _a5.props) === ((_b2 = other == null ? void 0 : other.shape) == null ? void 0 : _b2.props);
    }
  };
  var EvenInnererIndicator = ({ shape, util }) => {
    return useStateTracking("Indicator:" + shape.type, () => util.indicator(shape));
  };
  var InnerIndicator = ({ app, id }) => {
    const shape = useValue("shape", () => new ShapeWithPropsEquality(app.store.get(id)), [app, id]);
    const { ShapeIndicatorErrorFallback } = useEditorComponents();
    if (!shape.shape)
      return null;
    return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
      OptionalErrorBoundary,
      {
        fallback: ShapeIndicatorErrorFallback ? (error) => /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(ShapeIndicatorErrorFallback, { error }) : null,
        onError: (error) => app.annotateError(error, { origin: "react.shapeIndicator", willCrashApp: false }),
        children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
          EvenInnererIndicator,
          {
            shape: shape.shape,
            util: app.getShapeUtil(shape.shape)
          },
          shape.shape.id
        )
      }
    );
  };
  var _ShapeIndicator = ({ id, className, color, opacity }) => {
    const app = useApp();
    const transform = useValue(
      "transform",
      () => {
        const pageTransform = app.getPageTransformById(id);
        if (!pageTransform)
          return "";
        return pageTransform.toCssString();
      },
      [app, id]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)("svg", { className: (0, import_classnames6.default)("tl-overlays__item", className), children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(
      "g",
      {
        className: "tl-shape-indicator",
        transform,
        stroke: color != null ? color : "var(--color-selected)",
        opacity,
        children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(InnerIndicator, { app, id })
      }
    ) });
  };
  var ShapeIndicator = React17.memo(_ShapeIndicator);

  // ../../../packages/editor/src/lib/components/Canvas.tsx
  var import_jsx_runtime23 = __toESM(require_jsx_runtime());
  var Canvas = track(function Canvas2({
    onDropOverride
  }) {
    const app = useApp();
    const { Background, SvgDefs } = useEditorComponents();
    const rCanvas = React18.useRef(null);
    const rHtmlLayer = React18.useRef(null);
    useScreenBounds();
    useDocumentEvents();
    useCoarsePointer();
    useGestureEvents(rCanvas);
    useFixSafariDoubleTapZoomPencilEvents(rCanvas);
    useQuickReactor(
      "position layers",
      () => {
        const htmlElm = rHtmlLayer.current;
        if (!htmlElm)
          return;
        const { x: x3, y: y3, z: z2 } = app.camera;
        const offset = z2 >= 1 ? modulate(z2, [1, 8], [0.125, 0.5], true) : modulate(z2, [0.1, 1], [-2, 0.125], true);
        htmlElm.style.setProperty(
          "transform",
          `scale(${toDomPrecision(z2)}) translate(${toDomPrecision(x3 + offset)}px,${toDomPrecision(
            y3 + offset
          )}px)`
        );
      },
      [app]
    );
    const { context: patternContext, isReady: patternIsReady } = usePattern();
    const events = useCanvasEvents();
    if (onDropOverride) {
      events.onDrop = onDropOverride(events.onDrop);
    }
    React18.useEffect(() => {
      if (patternIsReady && app.isSafari) {
        const htmlElm = rHtmlLayer.current;
        if (htmlElm) {
          requestAnimationFrame(() => {
            htmlElm.style.display = "none";
            requestAnimationFrame(() => {
              htmlElm.style.display = "";
            });
          });
        }
      }
    }, [app, patternIsReady]);
    React18.useEffect(() => {
      var _a5;
      (_a5 = rCanvas.current) == null ? void 0 : _a5.focus();
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("div", __spreadProps(__spreadValues({ ref: rCanvas, draggable: false, className: "tl-canvas", "data-wd": "canvas" }, events), { children: [
      Background && /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(Background, {}),
      /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(GridWrapper, {}),
      /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(UiLogger, {}),
      /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("div", { ref: rHtmlLayer, className: "tl-html-layer", draggable: false, children: [
        /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("svg", { className: "tl-svg-context", children: /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("defs", { children: [
          patternContext,
          Cursor && /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(Cursor, {}),
          /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(CollaboratorHint, {}),
          /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(ArrowheadDot, {}),
          /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(ArrowheadCross, {}),
          SvgDefs && /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(SvgDefs, {})
        ] }) }),
        /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(SelectionBg, {}),
        /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { className: "tl-shapes", children: /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(ShapesToDisplay, {}) }),
        /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("div", { className: "tl-overlays", children: [
          /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(HandlesWrapper, {}),
          /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(BrushWrapper, {}),
          /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(ScribbleWrapper, {}),
          /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(ZoomBrushWrapper, {}),
          /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(SelectedIdIndicators, {}),
          /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(HoveredShapeIndicator, {}),
          /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(HintedShapeIndicator, {}),
          /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(SnapLinesWrapper, {}),
          /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(SelectionFg, {}),
          debugFlags.newLiveCollaborators.value ? /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(LiveCollaboratorsNext, {}) : /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(LiveCollaborators, {})
        ] })
      ] })
    ] }));
  });
  var GridWrapper = track(function GridWrapper2() {
    const app = useApp();
    const { Grid } = useEditorComponents();
    const { x: x3, y: y3, z: z2 } = app.camera;
    const isGridMode = app.isGridMode;
    if (!(Grid && isGridMode))
      return null;
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(Grid, { x: x3, y: y3, z: z2, size: app.gridSize });
  });
  var ScribbleWrapper = track(function ScribbleWrapper2() {
    const app = useApp();
    const scribble = app.scribble;
    const zoom = app.zoomLevel;
    const { Scribble } = useEditorComponents();
    if (!(Scribble && scribble))
      return null;
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(Scribble, { className: "tl-user-scribble", scribble, zoom });
  });
  var BrushWrapper = track(function BrushWrapper2() {
    const app = useApp();
    const { brush } = app;
    const { Brush } = useEditorComponents();
    if (!(Brush && brush && app.isIn("select.brushing")))
      return null;
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(Brush, { className: "tl-user-brush", brush });
  });
  var ZoomBrushWrapper = track(function Zoom() {
    const app = useApp();
    const { zoomBrush } = app;
    const { ZoomBrush } = useEditorComponents();
    if (!(ZoomBrush && zoomBrush && app.isIn("zoom")))
      return null;
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(ZoomBrush, { className: "tl-user-brush", brush: zoomBrush });
  });
  var SnapLinesWrapper = track(function SnapLines() {
    const app = useApp();
    const {
      snaps: { lines },
      zoomLevel
    } = app;
    const { SnapLine } = useEditorComponents();
    if (!(SnapLine && lines.length > 0))
      return null;
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(import_jsx_runtime23.Fragment, { children: lines.map((line) => /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(SnapLine, { className: "tl-user-snapline", line, zoom: zoomLevel }, line.id)) });
  });
  var MIN_HANDLE_DISTANCE = 48;
  var HandlesWrapper = track(function HandlesWrapper2() {
    var _a5;
    const app = useApp();
    const zoom = app.zoomLevel;
    const isChangingStyle = app.isChangingStyle;
    const onlySelectedShape = app.onlySelectedShape;
    const shouldDisplayHandles = app.isInAny("select.idle", "select.pointing_handle") && !isChangingStyle && !app.isReadOnly;
    if (!(onlySelectedShape && shouldDisplayHandles))
      return null;
    const util = app.getShapeUtil(onlySelectedShape);
    const handles = (_a5 = util.handles) == null ? void 0 : _a5.call(util, onlySelectedShape);
    if (!handles)
      return null;
    const transform = app.getPageTransform(onlySelectedShape);
    if (!transform)
      return null;
    const handlesToDisplay = [];
    for (let i3 = 0, handle = handles[i3]; i3 < handles.length; i3++, handle = handles[i3]) {
      if (handle.type !== "vertex") {
        const prev = handles[i3 - 1];
        const next = handles[i3 + 1];
        if (prev && next) {
          if (Math.hypot(prev.y - next.y, prev.x - next.x) < MIN_HANDLE_DISTANCE / zoom) {
            continue;
          }
        }
      }
      handlesToDisplay.push(handle);
    }
    handlesToDisplay.sort((a3) => a3.type === "vertex" ? 1 : -1);
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("svg", { className: "tl-user-handles tl-overlays__item", children: /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("g", { transform: Matrix2d.toCssString(transform), children: handlesToDisplay.map((handle) => {
      return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(HandleWrapper, { shapeId: onlySelectedShape.id, handle }, handle.id);
    }) }) });
  });
  var HandleWrapper = ({ shapeId, handle }) => {
    const events = useHandleEvents(shapeId, handle.id);
    const { Handle } = useEditorComponents();
    if (!Handle)
      return null;
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("g", __spreadProps(__spreadValues({ "aria-label": "handle", transform: `translate(${handle.x}, ${handle.y})` }, events), { children: /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(Handle, { shapeId, handle }) }));
  };
  var ShapesToDisplay = track(function ShapesToDisplay2() {
    const app = useApp();
    const { renderingShapes } = app;
    const debugSvg = debugFlags.debugSvg.value;
    if (debugSvg) {
      return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(import_jsx_runtime23.Fragment, { children: renderingShapes.map((result) => /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)(React18.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(Shape, __spreadValues({}, result)),
        /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(DebugSvgCopy, { id: result.id })
      ] }, result.id + "_fragment")) });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(import_jsx_runtime23.Fragment, { children: renderingShapes.map((result) => /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(Shape, __spreadValues({}, result), result.id + "_shape")) });
  });
  var SelectedIdIndicators = track(function SelectedIdIndicators2() {
    const app = useApp();
    const shouldDisplay = app.isInAny(
      "select.idle",
      "select.brushing",
      "select.scribble_brushing",
      "select.pointing_shape",
      "select.pointing_selection",
      "select.pointing_handle"
    ) && !app.isChangingStyle;
    if (!shouldDisplay)
      return null;
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(import_jsx_runtime23.Fragment, { children: app.selectedIds.map((id) => /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(ShapeIndicator, { className: "tl-user-indicator__selected", id }, id + "_indicator")) });
  });
  var HoveredShapeIndicator = function HoveredShapeIndicator2() {
    const app = useApp();
    const displayingHoveredId = useValue(
      "hovered id and should display",
      () => app.isInAny("select.idle", "select.editing_shape") ? app.pageState.hoveredId : null,
      [app]
    );
    if (!displayingHoveredId)
      return null;
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(ShapeIndicator, { className: "tl-user-indicator__hovered", id: displayingHoveredId });
  };
  var HintedShapeIndicator = track(function HintedShapeIndicator2() {
    const app = useApp();
    const ids = dedupe(app.hintingIds);
    if (!ids.length)
      return null;
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(import_jsx_runtime23.Fragment, { children: ids.map((id) => /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(ShapeIndicator, { className: "tl-user-indicator__hint", id }, id + "_hinting")) });
  });
  function Cursor() {
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("g", { id: "cursor", children: [
      /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("g", { fill: "rgba(0,0,0,.2)", transform: "translate(-11,-11)", children: [
        /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }),
        /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("g", { fill: "white", transform: "translate(-12,-12)", children: [
        /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }),
        /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("g", { fill: "currentColor", transform: "translate(-12,-12)", children: [
        /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("path", { d: "m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z" }),
        /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("path", { d: "m13 10.814v11.188l2.969-2.866.428-.139h4.768z" })
      ] })
    ] });
  }
  function CollaboratorHint() {
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("path", { id: "cursor_hint", fill: "currentColor", d: "M -2,-5 2,0 -2,5 Z" });
  }
  function ArrowheadDot() {
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("marker", { id: "arrowhead-dot", className: "tl-arrow-hint", refX: "3.0", refY: "3.0", orient: "0", children: /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("circle", { cx: "3", cy: "3", r: "2", strokeDasharray: "100%" }) });
  }
  function ArrowheadCross() {
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)("marker", { id: "arrowhead-cross", className: "tl-arrow-hint", refX: "3.0", refY: "3.0", orient: "auto", children: [
      /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("line", { x1: "1.5", y1: "1.5", x2: "4.5", y2: "4.5", strokeDasharray: "100%" }),
      /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("line", { x1: "1.5", y1: "4.5", x2: "4.5", y2: "1.5", strokeDasharray: "100%" })
    ] });
  }
  var DebugSvgCopy = track(function DupSvg({ id }) {
    const app = useApp();
    const shape = app.getShapeById(id);
    const [html, setHtml] = React18.useState("");
    const isInRoot = (shape == null ? void 0 : shape.parentId) === app.currentPageId;
    React18.useEffect(() => {
      if (!isInRoot)
        return;
      let latest = null;
      const unsubscribe = react("shape to svg", () => __async(this, null, function* () {
        const renderId = Math.random();
        latest = renderId;
        const bb = app.getPageBoundsById(id);
        const el = yield app.getSvg([id], { padding: 0 });
        if (el && bb && latest === renderId) {
          el.style.setProperty("overflow", "visible");
          el.setAttribute("preserveAspectRatio", "xMidYMin slice");
          el.style.setProperty("transform", `translate(${bb.x}px, ${bb.y + bb.h + 12}px)`);
          el.style.setProperty("border", "1px solid black");
          setHtml(el == null ? void 0 : el.outerHTML);
        }
      }));
      return () => {
        latest = null;
        unsubscribe();
      };
    }, [app, id, isInRoot]);
    if (!isInRoot)
      return null;
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { style: { paddingTop: 12, position: "absolute" }, children: /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { style: { display: "flex" }, dangerouslySetInnerHTML: { __html: html } }) });
  });
  var UiLogger = () => {
    const logMessages = useValue(debugFlags.logMessages);
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { className: "debug__ui-logger", children: logMessages.map((message, messageIndex) => {
      const text = typeof message === "string" ? message : JSON.stringify(message);
      return /* @__PURE__ */ (0, import_jsx_runtime23.jsx)("div", { className: "debug__ui-logger__line", children: text }, messageIndex);
    }) });
  };

  // ../../../packages/editor/src/lib/components/DefaultErrorFallback.tsx
  var import_jsx_runtime24 = __toESM(require_jsx_runtime());
  var BASE_ERROR_URL = "https://github.com/tldraw/tldraw/issues/new";
  function noop2() {
  }
  var DefaultErrorFallback = ({ error, app }) => {
    const containerRef = (0, import_react30.useRef)(null);
    const [shouldShowError, setShouldShowError] = (0, import_react30.useState)(false);
    const [didCopy, setDidCopy] = (0, import_react30.useState)(false);
    const [shouldShowResetConfirmation, setShouldShowResetConfirmation] = (0, import_react30.useState)(false);
    const errorMessage = error instanceof Error ? error.message : String(error);
    const errorStack = error instanceof Error ? error.stack : null;
    const isDarkModeFromApp = useValue(
      "isDarkMode",
      () => {
        try {
          if (app) {
            return app.userDocumentSettings.isDarkMode;
          }
        } catch (e2) {
        }
        return null;
      },
      [app]
    );
    const [isDarkMode, setIsDarkMode] = (0, import_react30.useState)(null);
    (0, import_react30.useLayoutEffect)(() => {
      var _a5;
      if (isDarkModeFromApp !== null) {
        setIsDarkMode(isDarkModeFromApp);
      }
      let parent = (_a5 = containerRef.current) == null ? void 0 : _a5.parentElement;
      let foundParentThemeClass = false;
      while (parent) {
        if (parent.classList.contains("tl-theme__dark") || parent.classList.contains("tl-theme__light")) {
          foundParentThemeClass = true;
          break;
        }
        parent = parent.parentElement;
      }
      if (foundParentThemeClass) {
        setIsDarkMode(null);
        return;
      }
      setIsDarkMode(window.matchMedia("(prefetl-color-scheme: dark)").matches);
    }, [isDarkModeFromApp]);
    (0, import_react30.useEffect)(() => {
      if (didCopy) {
        const timeout = setTimeout(() => {
          setDidCopy(false);
        }, 2e3);
        return () => clearTimeout(timeout);
      }
    }, [didCopy]);
    const copyError = () => {
      const textarea = document.createElement("textarea");
      textarea.value = errorStack != null ? errorStack : errorMessage;
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand("copy");
      textarea.remove();
      setDidCopy(true);
    };
    const refresh = () => {
      refreshPage();
    };
    const resetLocalState = () => __async(void 0, null, function* () {
      hardResetApp();
    });
    const url = new URL(BASE_ERROR_URL);
    url.searchParams.set("title", errorMessage);
    url.searchParams.set("labels", `bug`);
    url.searchParams.set(
      "body",
      `Hey, I ran into an error while using tldraw:

\`\`\`js
${errorStack != null ? errorStack : errorMessage}
\`\`\`

My browser: ${navigator.userAgent}`
    );
    return /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)(
      "div",
      {
        ref: containerRef,
        className: (0, import_classnames7.default)(
          "tl-container tl-error-boundary",
          // error-boundary is sometimes used outside of the theme
          // container, so we need to provide it with a theme for our
          // styles to work correctly
          isDarkMode === null ? "" : isDarkMode ? "tl-theme__dark" : "tl-theme__light"
        ),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("div", { className: "tl-error-boundary__overlay" }),
          app && // opportunistically attempt to render the canvas to reassure
          // the user that their document is still there. there's a good
          // chance this won't work (ie the error that we're currently
          // notifying the user about originates in the canvas) so it's
          // not a big deal if it doesn't work - in that case we just have
          // a plain grey background.
          /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(ErrorBoundary, { onError: noop2, fallback: () => null, children: /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(AppContext.Provider, { value: app, children: /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("div", { className: "tl-overlay tl-error-boundary__canvas", children: /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(Canvas, {}) }) }) }),
          /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
            "div",
            {
              className: (0, import_classnames7.default)("tl-modal", "tl-error-boundary__content", {
                "tl-error-boundary__content__expanded": shouldShowError && !shouldShowResetConfirmation
              }),
              children: shouldShowResetConfirmation ? /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [
                /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("h2", { children: "Are you sure?" }),
                /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("p", { children: "Resetting your data will delete your drawing and cannot be undone." }),
                /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)("div", { className: "tl-error-boundary__content__actions", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("button", { onClick: () => setShouldShowResetConfirmation(false), children: "Cancel" }),
                  /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("button", { className: "tl-error-boundary__reset", onClick: resetLocalState, children: "Reset data" })
                ] })
              ] }) : /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)(import_jsx_runtime24.Fragment, { children: [
                /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("h2", { children: "Something's gone wrong." }),
                /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)("p", { children: [
                  "Sorry, we encountered an error. Please refresh the page to continue. If you keep seeing this error, you can ",
                  /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("a", { href: url.toString(), children: "create a GitHub issue" }),
                  " or",
                  " ",
                  /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("a", { href: "https://discord.gg/Cq6cPsTfNy", children: "ask for help on Discord" }),
                  "."
                ] }),
                shouldShowError && /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)("div", { className: "tl-error-boundary__content__error", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("pre", { children: /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("code", { children: errorStack != null ? errorStack : errorMessage }) }),
                  /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("button", { onClick: copyError, children: didCopy ? "Copied!" : "Copy" })
                ] }),
                /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)("div", { className: "tl-error-boundary__content__actions", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("button", { onClick: () => setShouldShowError(!shouldShowError), children: shouldShowError ? "Hide details" : "Show details" }),
                  /* @__PURE__ */ (0, import_jsx_runtime24.jsxs)("div", { className: "tl-error-boundary__content__actions__group", children: [
                    /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(
                      "button",
                      {
                        className: "tl-error-boundary__reset",
                        onClick: () => setShouldShowResetConfirmation(true),
                        children: "Reset data"
                      }
                    ),
                    /* @__PURE__ */ (0, import_jsx_runtime24.jsx)("button", { className: "tl-error-boundary__refresh", onClick: refresh, children: "Refresh Page" })
                  ] })
                ] })
              ] })
            }
          )
        ]
      }
    );
  };

  // ../../../packages/editor/src/lib/components/DefaultGrid.tsx
  var import_jsx_runtime25 = __toESM(require_jsx_runtime());
  var DefaultGrid = ({ x: x3, y: y3, z: z2, size }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime25.jsxs)("svg", { className: "tl-grid", version: "1.1", xmlns: "http://www.w3.org/2000/svg", children: [
      /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("defs", { children: GRID_STEPS.map(({ min: min2, mid, step }, i3) => {
        const s3 = step * size * z2;
        const xo = 0.5 + x3 * z2;
        const yo = 0.5 + y3 * z2;
        const gxo = xo > 0 ? xo % s3 : s3 + xo % s3;
        const gyo = yo > 0 ? yo % s3 : s3 + yo % s3;
        const opacity = z2 < mid ? modulate(z2, [min2, mid], [0, 1]) : 1;
        return /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(
          "pattern",
          {
            id: `grid-${step}`,
            width: s3,
            height: s3,
            patternUnits: "userSpaceOnUse",
            children: /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("circle", { className: "tl-grid-dot", cx: gxo, cy: gyo, r: 1, opacity })
          },
          `grid-pattern-${i3}`
        );
      }) }),
      GRID_STEPS.map(({ step }, i3) => /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("rect", { width: "100%", height: "100%", fill: `url(#grid-${step})` }, `grid-rect-${i3}`))
    ] });
  };

  // ../../../packages/editor/src/lib/components/DefaultHandle.tsx
  var import_classnames8 = __toESM(require_classnames());
  var import_jsx_runtime26 = __toESM(require_jsx_runtime());
  var DefaultHandle = ({ handle, className }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime26.jsxs)(
      "g",
      {
        className: (0, import_classnames8.default)(
          "tl-handle",
          { "tl-handle__hint": handle.type !== "vertex" },
          className
        ),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("circle", { className: "tl-handle__bg" }),
          /* @__PURE__ */ (0, import_jsx_runtime26.jsx)("circle", { className: "tl-handle__fg" })
        ]
      }
    );
  };

  // ../../../packages/editor/src/lib/components/DefaultScribble.tsx
  var import_classnames9 = __toESM(require_classnames());
  var import_jsx_runtime27 = __toESM(require_jsx_runtime());
  var DefaultScribble = ({
    scribble,
    zoom,
    color,
    opacity,
    className
  }) => {
    const d3 = getSvgPathFromStroke(
      getStroke(scribble.points, {
        size: scribble.size / zoom,
        start: { taper: true, easing: EASINGS.linear },
        last: scribble.state === "stopping",
        simulatePressure: false
      })
    );
    return /* @__PURE__ */ (0, import_jsx_runtime27.jsx)("svg", { className: className ? (0, import_classnames9.default)("tl-overlays__item", className) : className, children: /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(
      "path",
      {
        className: "tl-scribble",
        d: d3,
        fill: color != null ? color : `var(--color-${scribble.color})`,
        opacity: opacity != null ? opacity : scribble.opacity
      }
    ) });
  };

  // ../../../packages/editor/src/lib/components/DefaultShapeErrorFallback.tsx
  var import_jsx_runtime28 = __toESM(require_jsx_runtime());
  var DefaultShapeErrorFallback = () => {
    return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)("div", { className: "tl-shape-error-boundary" });
  };

  // ../../../packages/editor/src/lib/components/DefaultShapeIndicatorErrorFallback.tsx
  var import_jsx_runtime29 = __toESM(require_jsx_runtime());
  var DefaultShapeIndicatorErrorFallback = () => {
    return /* @__PURE__ */ (0, import_jsx_runtime29.jsx)("circle", { cx: 4, cy: 4, r: 8, strokeWidth: "1", stroke: "red" });
  };

  // ../../../packages/editor/src/lib/components/DefaultSnapLine.tsx
  var import_classnames10 = __toESM(require_classnames());
  var React19 = __toESM(require_react());
  var import_jsx_runtime30 = __toESM(require_jsx_runtime());
  function PointsSnapLine({ points: points2, zoom }) {
    const l3 = 2.5 / zoom;
    const minX = points2.reduce((acc, p3) => Math.min(acc, p3.x), Infinity);
    const maxX = points2.reduce((acc, p3) => Math.max(acc, p3.x), -Infinity);
    const minY = points2.reduce((acc, p3) => Math.min(acc, p3.y), Infinity);
    const maxY = points2.reduce((acc, p3) => Math.max(acc, p3.y), -Infinity);
    const useNWtoSEdireciton = points2.some((p3) => p3.x === minX && p3.y === minY);
    let firstX, firstY, secondX, secondY;
    if (useNWtoSEdireciton) {
      firstX = minX;
      firstY = minY;
      secondX = maxX;
      secondY = maxY;
    } else {
      firstX = minX;
      firstY = maxY;
      secondX = maxX;
      secondY = minY;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)("g", { className: "tl-snap-line", children: [
      /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("line", { x1: firstX, y1: firstY, x2: secondX, y2: secondY }),
      points2.map((p3, i3) => /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("g", { transform: `translate(${p3.x},${p3.y})`, children: /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
        "path",
        {
          className: "tl-snap-point",
          d: `M ${-l3},${-l3} L ${l3},${l3} M ${-l3},${l3} L ${l3},${-l3}`
        }
      ) }, i3))
    ] });
  }
  function GapsSnapLine({ gaps, direction, zoom }) {
    const l3 = 3.5 / zoom;
    let edgeIntersection = [-Infinity, Infinity];
    let nextEdgeIntersection = null;
    const horizontal = direction === "horizontal";
    for (const gap of gaps) {
      nextEdgeIntersection = rangeIntersection(
        edgeIntersection[0],
        edgeIntersection[1],
        horizontal ? gap.startEdge[0].y : gap.startEdge[0].x,
        horizontal ? gap.startEdge[1].y : gap.startEdge[1].x
      );
      if (nextEdgeIntersection) {
        edgeIntersection = nextEdgeIntersection;
      } else {
        continue;
      }
      nextEdgeIntersection = rangeIntersection(
        edgeIntersection[0],
        edgeIntersection[1],
        horizontal ? gap.endEdge[0].y : gap.endEdge[0].x,
        horizontal ? gap.endEdge[1].y : gap.endEdge[1].x
      );
      if (nextEdgeIntersection) {
        edgeIntersection = nextEdgeIntersection;
      } else {
        continue;
      }
    }
    if (edgeIntersection === null) {
      return null;
    }
    const midPoint = (edgeIntersection[0] + edgeIntersection[1]) / 2;
    return /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("g", { className: "tl-snap-line", children: gaps.map(({ startEdge, endEdge }, i3) => /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(React19.Fragment, { children: horizontal ? (
      // horizontal gap
      /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)(import_jsx_runtime30.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
          "line",
          {
            x1: startEdge[0].x,
            y1: midPoint - 2 * l3,
            x2: startEdge[1].x,
            y2: midPoint + 2 * l3
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
          "line",
          {
            x1: endEdge[0].x,
            y1: midPoint - 2 * l3,
            x2: endEdge[1].x,
            y2: midPoint + 2 * l3
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("line", { x1: startEdge[0].x, y1: midPoint, x2: endEdge[0].x, y2: midPoint }),
        /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
          "line",
          {
            x1: (startEdge[0].x + endEdge[0].x) / 2,
            y1: midPoint - l3,
            x2: (startEdge[0].x + endEdge[0].x) / 2,
            y2: midPoint + l3
          }
        )
      ] })
    ) : (
      // vertical gap
      /* @__PURE__ */ (0, import_jsx_runtime30.jsxs)(import_jsx_runtime30.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
          "line",
          {
            x1: midPoint - 2 * l3,
            y1: startEdge[0].y,
            x2: midPoint + 2 * l3,
            y2: startEdge[1].y
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
          "line",
          {
            x1: midPoint - 2 * l3,
            y1: endEdge[0].y,
            x2: midPoint + 2 * l3,
            y2: endEdge[1].y
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("line", { x1: midPoint, y1: startEdge[0].y, x2: midPoint, y2: endEdge[0].y }),
        /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(
          "line",
          {
            x1: midPoint - l3,
            y1: (startEdge[0].y + endEdge[0].y) / 2,
            x2: midPoint + l3,
            y2: (startEdge[0].y + endEdge[0].y) / 2
          }
        )
      ] })
    ) }, i3)) });
  }
  var DefaultSnapLine = ({ className, line, zoom }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime30.jsx)("svg", { className: (0, import_classnames10.default)("tl-overlays__item", className), children: line.type === "points" ? /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(PointsSnapLine, __spreadProps(__spreadValues({}, line), { zoom })) : line.type === "gaps" ? /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(GapsSnapLine, __spreadProps(__spreadValues({}, line), { zoom })) : null });
  };

  // ../../../packages/editor/src/lib/components/DefaultSpinner.tsx
  var import_jsx_runtime31 = __toESM(require_jsx_runtime());
  var DefaultSpinner = () => {
    return /* @__PURE__ */ (0, import_jsx_runtime31.jsx)("svg", { width: 16, height: 16, viewBox: "0 0 16 16", children: /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)("g", { strokeWidth: 2, fill: "none", fillRule: "evenodd", children: [
      /* @__PURE__ */ (0, import_jsx_runtime31.jsx)("circle", { strokeOpacity: 0.25, cx: 8, cy: 8, r: 7, stroke: "black" }),
      /* @__PURE__ */ (0, import_jsx_runtime31.jsx)("path", { strokeLinecap: "round", d: "M15 8c0-4.5-4.5-7-7-7", stroke: "black", children: /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(
        "animateTransform",
        {
          attributeName: "transform",
          type: "rotate",
          from: "0 8 8",
          to: "360 8 8",
          dur: "1s",
          repeatCount: "indefinite"
        }
      ) })
    ] }) });
  };

  // ../../../packages/editor/src/lib/components/DefaultSvgDefs.tsx
  var DefaultSvgDefs = () => {
    return null;
  };

  // ../../../packages/editor/src/lib/hooks/useEditorComponents.tsx
  var import_jsx_runtime32 = __toESM(require_jsx_runtime());
  var EditorComponentsContext = (0, import_react31.createContext)({});
  function EditorComponentsProvider({ overrides, children }) {
    return /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(
      EditorComponentsContext.Provider,
      {
        value: __spreadValues({
          Background: DefaultBackground,
          SvgDefs: DefaultSvgDefs,
          Brush: DefaultBrush,
          ZoomBrush: DefaultBrush,
          CollaboratorBrush: DefaultBrush,
          Cursor: DefaultCursor,
          CollaboratorCursor: DefaultCursor,
          CollaboratorHint: DefaultCollaboratorHint,
          CollaboratorShapeIndicator: ShapeIndicator,
          Grid: DefaultGrid,
          Scribble: DefaultScribble,
          SnapLine: DefaultSnapLine,
          Handle: DefaultHandle,
          CollaboratorScribble: DefaultScribble,
          ErrorFallback: DefaultErrorFallback,
          ShapeErrorFallback: DefaultShapeErrorFallback,
          ShapeIndicatorErrorFallback: DefaultShapeIndicatorErrorFallback,
          Spinner: DefaultSpinner
        }, overrides),
        children
      }
    );
  }
  function useEditorComponents() {
    return (0, import_react31.useContext)(EditorComponentsContext);
  }

  // ../../../packages/editor/src/lib/hooks/useIsEditing.ts
  function useIsEditing(shapeId) {
    const app = useApp();
    return useValue("isEditing", () => app.editingId === shapeId, [app, shapeId]);
  }

  // ../../../node_modules/escape-string-regexp/index.js
  function escapeStringRegexp(string2) {
    if (typeof string2 !== "string") {
      throw new TypeError("Expected a string");
    }
    return string2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
  }

  // ../../../packages/editor/src/lib/utils/embeds.ts
  function matchEmbedUrl(url) {
    const host = new URL(url).host.replace("www.", "");
    for (const localEmbedDef of EMBED_DEFINITIONS) {
      if (checkHostnames(localEmbedDef.hostnames, host)) {
        const originalUrl = localEmbedDef.fromEmbedUrl(url);
        if (originalUrl) {
          return {
            definition: localEmbedDef,
            url: originalUrl,
            embedUrl: url
          };
        }
      }
    }
  }
  var globlikeRegExp = (input) => {
    return input.split("*").map((str) => escapeStringRegexp(str)).join(".+");
  };
  var checkHostnames = (hostnames, targetHostname) => {
    return !!hostnames.find((hostname) => {
      const re = new RegExp(globlikeRegExp(hostname));
      return targetHostname.match(re);
    });
  };
  function matchUrl(url) {
    const host = new URL(url).host.replace("www.", "");
    for (const localEmbedDef of EMBED_DEFINITIONS) {
      if (checkHostnames(localEmbedDef.hostnames, host)) {
        const embedUrl = localEmbedDef.toEmbedUrl(url);
        if (embedUrl) {
          return {
            definition: localEmbedDef,
            embedUrl,
            url
          };
        }
      }
    }
  }
  function getEmbedInfoUnsafely(inputUrl) {
    var _a5;
    const result = (_a5 = matchUrl(inputUrl)) != null ? _a5 : matchEmbedUrl(inputUrl);
    return result;
  }
  function getEmbedInfo(inputUrl) {
    try {
      return getEmbedInfoUnsafely(inputUrl);
    } catch (e2) {
      console.error(e2);
    }
    return void 0;
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLEmbedUtil/TLEmbedUtil.tsx
  var import_jsx_runtime33 = __toESM(require_jsx_runtime());
  var getSandboxPermissions = (permissions) => {
    return Object.entries(permissions).filter(([_perm, isEnabled]) => isEnabled).map(([perm]) => perm).join(" ");
  };
  var TLEmbedUtil = class extends TLBoxUtil {
    constructor() {
      super(...arguments);
      __publicField(this, "canUnmount", () => false);
      __publicField(this, "canResize", (shape) => {
        var _a5;
        const result = getEmbedInfo(shape.props.url);
        return !!((_a5 = result == null ? void 0 : result.definition) == null ? void 0 : _a5.doesResize);
      });
      __publicField(this, "hideSelectionBoundsBg", (shape) => !this.canResize(shape));
      __publicField(this, "hideSelectionBoundsFg", (shape) => !this.canResize(shape));
      __publicField(this, "canEdit", () => true);
      __publicField(this, "isAspectRatioLocked", (shape) => {
        var _a5;
        const embedInfo = getEmbedInfo(shape.props.url);
        return (_a5 = embedInfo == null ? void 0 : embedInfo.definition.isAspectRatioLocked) != null ? _a5 : false;
      });
      __publicField(this, "onResize", (shape, info) => {
        var _a5, _b2;
        const isAspectRatioLocked = this.isAspectRatioLocked(shape);
        const embedInfo = getEmbedInfo(shape.props.url);
        let minWidth = (_a5 = embedInfo == null ? void 0 : embedInfo.definition.minWidth) != null ? _a5 : 200;
        let minHeight = (_b2 = embedInfo == null ? void 0 : embedInfo.definition.minHeight) != null ? _b2 : 200;
        if (isAspectRatioLocked) {
          const aspectRatio = shape.props.w / shape.props.h;
          if (aspectRatio > 1) {
            minWidth *= aspectRatio;
          } else {
            minHeight /= aspectRatio;
          }
        }
        return resizeBox(shape, info, { minWidth, minHeight });
      });
    }
    defaultProps() {
      return {
        opacity: "1",
        w: 300,
        h: 300,
        url: "",
        doesResize: true
      };
    }
    render(shape) {
      var _a5, _b2;
      const { w: w3, h: h3, url } = shape.props;
      const isEditing = useIsEditing(shape.id);
      const embedInfo = (0, import_react32.useMemo)(() => getEmbedInfoUnsafely(url), [url]);
      const { Spinner: Spinner2 } = useEditorComponents();
      const isHoveringWhileEditingSameShape = useValue(
        "is hovering",
        () => {
          const { editingId, hoveredId } = this.app.pageState;
          if (editingId && hoveredId !== editingId) {
            const editingShape = this.app.getShapeById(editingId);
            if (editingShape && editingShape.type === "embed") {
              return true;
            }
          }
          return false;
        },
        []
      );
      const pageRotation = this.app.getPageRotation(shape);
      const isInteractive = isEditing || isHoveringWhileEditingSameShape;
      if ((embedInfo == null ? void 0 : embedInfo.definition.type) === "github_gist") {
        const idFromGistUrl = embedInfo.url.split("/").pop();
        if (idFromGistUrl) {
          return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(HTMLContainer, { className: "tl-embed-container", id: shape.id, children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
            Gist,
            {
              id: idFromGistUrl,
              width: toDomPrecision(w3),
              height: toDomPrecision(h3),
              isInteractive,
              pageRotation
            }
          ) });
        }
      }
      const sandbox = getSandboxPermissions(__spreadValues(__spreadValues({}, tlEmbedShapePermissionDefaults), (_a5 = embedInfo == null ? void 0 : embedInfo.definition.overridePermissions) != null ? _a5 : {}));
      return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(HTMLContainer, { className: "tl-embed-container", id: shape.id, children: (embedInfo == null ? void 0 : embedInfo.definition) ? /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
        "iframe",
        {
          className: `tl-embed tl-embed-${shape.id}`,
          sandbox,
          src: embedInfo.embedUrl,
          width: toDomPrecision(w3),
          height: toDomPrecision(h3),
          draggable: false,
          frameBorder: "0",
          referrerPolicy: "no-referrer-when-downgrade",
          style: {
            border: 0,
            pointerEvents: isInteractive ? "auto" : "none",
            // Fix for safari <https://stackoverflow.com/a/49150908>
            zIndex: isInteractive ? "" : "-1",
            boxShadow: rotateBoxShadow(pageRotation, ROTATING_SHADOWS),
            borderRadius: (_b2 = embedInfo == null ? void 0 : embedInfo.definition.overrideOutlineRadius) != null ? _b2 : 8,
            background: embedInfo == null ? void 0 : embedInfo.definition.backgroundColor
          }
        }
      ) : Spinner2 ? /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("g", { transform: `translate(${(w3 - 38) / 2}, ${(h3 - 38) / 2})`, children: /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(Spinner2, {}) }) : null });
    }
    indicator(shape) {
      var _a5, _b2;
      const embedInfo = (0, import_react32.useMemo)(() => getEmbedInfo(shape.props.url), [shape.props.url]);
      return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
        "rect",
        {
          width: toDomPrecision(shape.props.w),
          height: toDomPrecision(shape.props.h),
          rx: (_a5 = embedInfo == null ? void 0 : embedInfo.definition.overrideOutlineRadius) != null ? _a5 : 8,
          ry: (_b2 = embedInfo == null ? void 0 : embedInfo.definition.overrideOutlineRadius) != null ? _b2 : 8
        }
      );
    }
  };
  __publicField(TLEmbedUtil, "type", "embed");
  function Gist({
    id,
    file,
    isInteractive,
    width,
    height,
    style,
    pageRotation
  }) {
    const rIframe = React20.useRef(null);
    const fileArg = file ? `?file=${file}` : "";
    const gistLink = `https://gist.github.com/${id}.js${fileArg}`;
    return /* @__PURE__ */ (0, import_jsx_runtime33.jsx)(
      "iframe",
      {
        ref: rIframe,
        className: "tl-embed",
        draggable: false,
        width: toDomPrecision(width),
        height: toDomPrecision(height),
        frameBorder: "0",
        scrolling: "no",
        seamless: true,
        referrerPolicy: "no-referrer-when-downgrade",
        style: __spreadProps(__spreadValues({}, style), {
          pointerEvents: isInteractive ? "all" : "none",
          // Fix for safari <https://stackoverflow.com/a/49150908>
          zIndex: isInteractive ? "" : "-1",
          boxShadow: rotateBoxShadow(pageRotation, ROTATING_SHADOWS)
        }),
        srcDoc: `
			<html>
				<head>
					<base target="_blank">
				</head>
				<body>
					<script src=${gistLink}><\/script>
					<style type="text/css">
						* { margin: 0px; }
						table { height: 100%; background-color: red; }
						.gist { background-color: none; height: 100%;  }
						.gist .gist-file { height: calc(100vh - 2px); padding: 0px; display: grid; grid-template-rows: 1fr auto; }
					</style>
				</body>
			</html>`
      }
    );
  }
  var TLEmbedShapeDef = defineShape({
    type: "embed",
    getShapeUtil: () => TLEmbedUtil,
    validator: embedShapeTypeValidator,
    migrations: embedShapeMigrations
  });

  // ../../../packages/editor/src/lib/app/shapeutils/TLFrameUtil/components/FrameHeading.tsx
  var import_react34 = __toESM(require_react());

  // ../../../packages/editor/src/lib/app/shapeutils/TLFrameUtil/components/FrameLabelInput.tsx
  var import_react33 = __toESM(require_react());
  var import_jsx_runtime34 = __toESM(require_jsx_runtime());
  var FrameLabelInput = (0, import_react33.forwardRef)(({ id, name, isEditing }, ref) => {
    const app = useApp();
    const handleKeyDown = (0, import_react33.useCallback)(
      (e2) => {
        if (e2.key === "Enter") {
          e2.stopPropagation();
          e2.currentTarget.blur();
          app.setEditingId(null);
        }
      },
      [app]
    );
    const handleBlur = (0, import_react33.useCallback)(
      (e2) => {
        const shape = app.getShapeById(id);
        if (!shape)
          return;
        const name2 = shape.props.name;
        const value = e2.currentTarget.value.trim();
        if (name2 === value)
          return;
        app.updateShapes(
          [
            {
              id,
              type: "frame",
              props: { name: value }
            }
          ],
          true
        );
      },
      [id, app]
    );
    const handleChange = (0, import_react33.useCallback)(
      (e2) => {
        const shape = app.getShapeById(id);
        if (!shape)
          return;
        const name2 = shape.props.name;
        const value = e2.currentTarget.value;
        if (name2 === value)
          return;
        app.updateShapes(
          [
            {
              id,
              type: "frame",
              props: { name: value }
            }
          ],
          true
        );
      },
      [id, app]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime34.jsxs)("div", { className: `tl-frame-label ${isEditing ? "tl-frame-label__editing" : ""}`, children: [
      /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(
        "input",
        {
          className: "tl-frame-name-input",
          ref,
          style: { display: isEditing ? void 0 : "none" },
          value: name,
          autoFocus: true,
          onKeyDown: handleKeyDown,
          onBlur: handleBlur,
          onChange: handleChange
        }
      ),
      defaultEmptyAs(name, "Frame") + String.fromCharCode(8203)
    ] });
  });

  // ../../../packages/editor/src/lib/app/shapeutils/TLFrameUtil/components/FrameHeading.tsx
  var import_jsx_runtime35 = __toESM(require_jsx_runtime());
  var FrameHeading = function FrameHeading2({
    id,
    name,
    width,
    height
  }) {
    const app = useApp();
    const pageRotation = canolicalizeRotation(app.getPageRotationById(id));
    const isEditing = useIsEditing(id);
    const rInput = (0, import_react34.useRef)(null);
    (0, import_react34.useEffect)(() => {
      const el = rInput.current;
      if (el && isEditing) {
        el.focus();
        el.select();
        requestAnimationFrame(() => {
          if (document.activeElement !== el) {
            el.focus();
            el.select();
          }
        });
      }
    }, [rInput, isEditing]);
    const offsetRotation = pageRotation + Math.PI / 4;
    const scaledRotation = (offsetRotation * (2 / Math.PI) + 4) % 4;
    const labelSide = ["top", "left", "bottom", "right"][Math.floor(scaledRotation)];
    let labelTranslate;
    switch (labelSide) {
      case "top":
        labelTranslate = ``;
        break;
      case "right":
        labelTranslate = `translate(${toDomPrecision(width)}px, 0px) rotate(90deg)`;
        break;
      case "bottom":
        labelTranslate = `translate(${toDomPrecision(width)}px, ${toDomPrecision(
          height
        )}px) rotate(180deg)`;
        break;
      case "left":
        labelTranslate = `translate(0px, ${toDomPrecision(height)}px) rotate(270deg)`;
        break;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(
      "div",
      {
        className: "tl-frame-heading",
        style: {
          overflow: isEditing ? "visible" : "hidden",
          maxWidth: `calc(var(--tl-zoom) * ${labelSide === "top" || labelSide === "bottom" ? Math.ceil(width) : Math.ceil(height)}px + var(--space-5))`,
          bottom: Math.ceil(height),
          transform: `${labelTranslate} scale(var(--tl-scale)) translateX(calc(-1 * var(--space-3))`
        },
        children: /* @__PURE__ */ (0, import_jsx_runtime35.jsx)("div", { className: "tl-frame-heading-hit-area", children: /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(FrameLabelInput, { ref: rInput, id, name, isEditing }) })
      }
    );
  };

  // ../../../packages/editor/src/lib/app/shapeutils/TLFrameUtil/TLFrameUtil.tsx
  var import_jsx_runtime36 = __toESM(require_jsx_runtime());
  var TLFrameUtil = class extends TLBoxUtil {
    constructor() {
      super(...arguments);
      __publicField(this, "canBind", () => true);
      __publicField(this, "canEdit", () => true);
      __publicField(this, "canReceiveNewChildrenOfType", (_type) => {
        return true;
      });
      __publicField(this, "canDropShapes", (_shape, _shapes) => {
        return true;
      });
      __publicField(this, "onDragShapesOver", (frame2, shapes) => {
        if (!shapes.every((child) => child.parentId === frame2.id)) {
          this.app.reparentShapesById(
            shapes.map((shape) => shape.id),
            frame2.id
          );
          return { shouldHint: true };
        }
        return { shouldHint: false };
      });
      __publicField(this, "onDragShapesOut", (_shape, shapes) => {
        const parentId = this.app.getShapeById(_shape.parentId);
        const isInGroup = (parentId == null ? void 0 : parentId.type) === "group";
        if (isInGroup) {
          this.app.reparentShapesById(
            shapes.map((shape) => shape.id),
            parentId.id
          );
        } else {
          this.app.reparentShapesById(
            shapes.map((shape) => shape.id),
            this.app.currentPageId
          );
        }
      });
      __publicField(this, "onResizeEnd", (shape) => {
        const bounds = this.app.getPageBounds(shape);
        const children = this.app.getSortedChildIds(shape.id);
        const shapesToReparent = [];
        for (const childId of children) {
          const childBounds = this.app.getPageBoundsById(childId);
          if (!bounds.includes(childBounds)) {
            shapesToReparent.push(childId);
          }
        }
        if (shapesToReparent.length > 0) {
          this.app.reparentShapesById(shapesToReparent, this.app.currentPageId);
        }
      });
    }
    defaultProps() {
      return { opacity: "1", w: 160 * 2, h: 90 * 2, name: "" };
    }
    render(shape) {
      const bounds = this.bounds(shape);
      return /* @__PURE__ */ (0, import_jsx_runtime36.jsxs)(import_jsx_runtime36.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime36.jsxs)(SVGContainer, { children: [
          /* @__PURE__ */ (0, import_jsx_runtime36.jsx)("rect", { className: "tl-hitarea-stroke", width: bounds.width, height: bounds.height }),
          /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(
            "rect",
            {
              className: "tl-frame__body",
              width: bounds.width,
              height: bounds.height,
              fill: "none"
            }
          )
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(
          FrameHeading,
          {
            id: shape.id,
            name: shape.props.name,
            width: bounds.width,
            height: bounds.height
          }
        )
      ] });
    }
    toSvg(shape, font, colors) {
      const g3 = document.createElementNS("http://www.w3.org/2000/svg", "g");
      const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      rect.setAttribute("width", shape.props.w.toString());
      rect.setAttribute("height", shape.props.h.toString());
      rect.setAttribute("fill", colors.solid);
      rect.setAttribute("opacity", shape.props.opacity);
      rect.setAttribute("stroke", colors.fill.black);
      rect.setAttribute("stroke-width", "1");
      rect.setAttribute("rx", "1");
      rect.setAttribute("ry", "1");
      g3.appendChild(rect);
      const pageRotation = canolicalizeRotation(this.app.getPageRotationById(shape.id));
      const offsetRotation = pageRotation + Math.PI / 4;
      const scaledRotation = (offsetRotation * (2 / Math.PI) + 4) % 4;
      const labelSide = ["top", "left", "bottom", "right"][Math.floor(scaledRotation)];
      let labelTranslate;
      switch (labelSide) {
        case "top":
          labelTranslate = ``;
          break;
        case "right":
          labelTranslate = `translate(${toDomPrecision(shape.props.w)}px, 0px) rotate(90deg)`;
          break;
        case "bottom":
          labelTranslate = `translate(${toDomPrecision(shape.props.w)}px, ${toDomPrecision(
            shape.props.h
          )}px) rotate(180deg)`;
          break;
        case "left":
          labelTranslate = `translate(0px, ${toDomPrecision(shape.props.h)}px) rotate(270deg)`;
          break;
        default:
          labelTranslate = ``;
      }
      const opts = {
        fontSize: 12,
        fontFamily: "Inter, sans-serif",
        textAlign: "start",
        width: shape.props.w + 16,
        height: 30,
        padding: 8,
        lineHeight: 1,
        fontStyle: "normal",
        fontWeight: "normal"
      };
      let textContent = defaultEmptyAs(shape.props.name, "Frame") + String.fromCharCode(8203);
      const lines = this.app.textMeasure.getTextLines(__spreadValues({
        text: textContent,
        wrap: true
      }, opts));
      textContent = lines.length > 1 ? lines[0] + "\u2026" : lines[0];
      const size = this.app.textMeasure.measureText({
        fontSize: 12,
        fontFamily: "Inter, sans-serif",
        lineHeight: 1,
        fontStyle: "normal",
        fontWeight: "normal",
        text: textContent,
        width: "fit-content",
        maxWidth: "unset",
        padding: "0px"
      });
      const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
      text.setAttribute("x", "0");
      text.setAttribute("y", -(8 + size.h / 2) + "px");
      text.setAttribute("font-family", '"Inter", sans-serif');
      text.setAttribute("font-size", "12px");
      text.setAttribute("font-weight", "400");
      text.style.setProperty("transform", labelTranslate);
      text.textContent = textContent;
      const textBg = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      textBg.setAttribute("x", " -4px");
      textBg.setAttribute("y", -(16 + size.h) + "px");
      textBg.setAttribute("width", size.w + 8 + "px");
      textBg.setAttribute("height", size.h + 8 + "px");
      textBg.setAttribute("rx", 4 + "px");
      textBg.setAttribute("ry", 4 + "px");
      textBg.setAttribute("fill", colors.background);
      g3.appendChild(textBg);
      g3.appendChild(text);
      return g3;
    }
    indicator(shape) {
      const bounds = this.bounds(shape);
      return /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(
        "rect",
        {
          width: toDomPrecision(bounds.width),
          height: toDomPrecision(bounds.height),
          className: `tl-frame-indicator`
        }
      );
    }
  };
  __publicField(TLFrameUtil, "type", "frame");
  var TLFrameShapeDef = defineShape({
    type: "frame",
    getShapeUtil: () => TLFrameUtil,
    validator: frameShapeTypeValidator,
    migrations: frameShapeMigrations
  });

  // ../../../packages/editor/src/lib/app/shapeutils/shared/TextLabel.tsx
  var import_react35 = __toESM(require_react());
  var import_jsx_runtime37 = __toESM(require_jsx_runtime());
  var TextLabel = import_react35.default.memo(function TextLabel2({
    id,
    type,
    text,
    size,
    labelColor,
    font,
    align,
    wrap: wrap2
  }) {
    const {
      rInput,
      isEmpty,
      isEditing,
      isEditableFromHover,
      handleFocus,
      handleChange,
      handleKeyDown,
      handleBlur
    } = useEditableText(id, type, text);
    const isInteractive = isEditing || isEditableFromHover;
    return /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
      "div",
      {
        className: "tl-text-label",
        "data-font": font,
        "data-align": align,
        "data-hastext": !isEmpty,
        "data-isediting": isEditing,
        "data-textwrap": !!wrap2,
        children: /* @__PURE__ */ (0, import_jsx_runtime37.jsxs)(
          "div",
          {
            className: "tl-text-label__inner",
            style: {
              fontSize: LABEL_FONT_SIZES[size],
              lineHeight: LABEL_FONT_SIZES[size] * TEXT_PROPS.lineHeight + "px",
              minHeight: isEmpty ? LABEL_FONT_SIZES[size] * TEXT_PROPS.lineHeight + 32 : 0,
              minWidth: isEmpty ? 33 : 0,
              color: labelColor
            },
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime37.jsx)("div", { className: "tl-text tl-text-content", dir: "ltr", children: TextHelpers.normalizeTextForDom(text) }),
              isInteractive ? (
                // Consider replacing with content-editable
                /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(
                  "textarea",
                  {
                    ref: rInput,
                    className: "tl-text tl-text-input",
                    name: "text",
                    tabIndex: -1,
                    autoComplete: "false",
                    autoCapitalize: "false",
                    autoCorrect: "false",
                    autoSave: "false",
                    autoFocus: isEditing,
                    placeholder: "",
                    spellCheck: "true",
                    wrap: "off",
                    dir: "auto",
                    datatype: "wysiwyg",
                    defaultValue: text,
                    onFocus: handleFocus,
                    onChange: handleChange,
                    onKeyDown: handleKeyDown,
                    onBlur: handleBlur,
                    onContextMenu: stopEventPropagation
                  }
                )
              ) : null
            ]
          }
        )
      }
    );
  });

  // ../../../packages/editor/src/lib/app/shapeutils/TLGeoUtil/components/DashStyleEllipse.tsx
  var React22 = __toESM(require_react());
  var import_jsx_runtime38 = __toESM(require_jsx_runtime());
  var DashStyleEllipse = React22.memo(function DashStyleEllipse2({
    w: w3,
    h: h3,
    strokeWidth: sw,
    dash,
    color,
    fill
  }) {
    const cx = w3 / 2;
    const cy = h3 / 2;
    const rx = Math.max(0, cx - sw / 2);
    const ry = Math.max(0, cy - sw / 2);
    const perimeter = perimeterOfEllipse(rx, ry);
    const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
      perimeter < 64 ? perimeter * 2 : perimeter,
      sw,
      {
        style: dash,
        snap: 4,
        closed: true
      }
    );
    const d3 = `M${cx - rx},${cy}a${rx},${ry},0,1,1,${rx * 2},0a${rx},${ry},0,1,1,-${rx * 2},0`;
    return /* @__PURE__ */ (0, import_jsx_runtime38.jsxs)(import_jsx_runtime38.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(ShapeFill, { d: d3, color, fill }),
      /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(
        "path",
        {
          d: d3,
          strokeWidth: sw,
          width: toDomPrecision(w3),
          height: toDomPrecision(h3),
          fill: "none",
          stroke: "currentColor",
          strokeDasharray,
          strokeDashoffset,
          pointerEvents: "all"
        }
      )
    ] });
  });
  function DashStyleEllipseSvg({
    w: w3,
    h: h3,
    strokeWidth: sw,
    dash,
    color,
    colors,
    fill
  }) {
    const cx = w3 / 2;
    const cy = h3 / 2;
    const rx = Math.max(0, cx - sw / 2);
    const ry = Math.max(0, cy - sw / 2);
    const perimeter = perimeterOfEllipse(rx, ry);
    const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
      perimeter < 64 ? perimeter * 2 : perimeter,
      sw,
      {
        style: dash,
        snap: 4,
        closed: true
      }
    );
    const d3 = `M${cx - rx},${cy}a${rx},${ry},0,1,1,${rx * 2},0a${rx},${ry},0,1,1,-${rx * 2},0`;
    const strokeElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
    strokeElement.setAttribute("d", d3);
    strokeElement.setAttribute("stroke-width", sw.toString());
    strokeElement.setAttribute("width", w3.toString());
    strokeElement.setAttribute("height", h3.toString());
    strokeElement.setAttribute("fill", "none");
    strokeElement.setAttribute("stroke", colors.fill[color]);
    strokeElement.setAttribute("stroke-dasharray", strokeDasharray);
    strokeElement.setAttribute("stroke-dashoffset", strokeDashoffset);
    const fillElement = getShapeFillSvg({
      d: d3,
      fill,
      color,
      colors
    });
    return getSvgWithShapeFill(strokeElement, fillElement);
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLGeoUtil/components/DashStyleOval.tsx
  var React23 = __toESM(require_react());

  // ../../../packages/editor/src/lib/app/shapeutils/TLGeoUtil/helpers.ts
  function getOvalSolidPath(w3, h3) {
    if (h3 > w3) {
      const offset2 = w3 / 2;
      return `
    M0,${offset2}
    a${offset2},${offset2},0,1,1,${offset2 * 2},0
    L${w3},${h3 - offset2}
    a${offset2},${offset2},0,1,1,-${offset2 * 2},0
    Z`;
    }
    const offset = h3 / 2;
    return `
    M${offset},0
    L${w3 - offset},0
    a${offset},${offset},0,1,1,0,${offset * 2}
    L${offset},${h3}
    a${offset},${offset},0,1,1,0,${-offset * 2}
    Z`;
  }
  function getOvalPerimeter(h3, w3) {
    if (h3 > w3) {
      const offset2 = w3 / 2;
      return perimeterOfEllipse(offset2, offset2) + (h3 - offset2 * 2) * 2;
    }
    const offset = h3 / 2;
    return perimeterOfEllipse(offset, offset) + (w3 - offset * 2) * 2;
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLGeoUtil/components/DashStyleOval.tsx
  var import_jsx_runtime39 = __toESM(require_jsx_runtime());
  var DashStyleOval = React23.memo(function DashStyleOval2({
    w: w3,
    h: h3,
    strokeWidth: sw,
    dash,
    color,
    fill
  }) {
    const d3 = getOvalSolidPath(w3, h3);
    const perimeter = getOvalPerimeter(w3, h3);
    const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
      perimeter < 64 ? perimeter * 2 : perimeter,
      sw,
      {
        style: dash,
        snap: 4,
        start: "outset",
        end: "outset",
        closed: true
      }
    );
    return /* @__PURE__ */ (0, import_jsx_runtime39.jsxs)(import_jsx_runtime39.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(ShapeFill, { d: d3, color, fill }),
      /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(
        "path",
        {
          d: d3,
          strokeWidth: sw,
          width: toDomPrecision(w3),
          height: toDomPrecision(h3),
          fill: "none",
          stroke: "currentColor",
          strokeDasharray,
          strokeDashoffset,
          pointerEvents: "all"
        }
      )
    ] });
  });
  function DashStyleOvalSvg({
    w: w3,
    h: h3,
    strokeWidth: sw,
    dash,
    color,
    colors,
    fill
  }) {
    const d3 = getOvalSolidPath(w3, h3);
    const perimeter = getOvalPerimeter(w3, h3);
    const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
      perimeter < 64 ? perimeter * 2 : perimeter,
      sw,
      {
        style: dash,
        snap: 4,
        closed: true
      }
    );
    const strokeElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
    strokeElement.setAttribute("d", d3);
    strokeElement.setAttribute("stroke-width", sw.toString());
    strokeElement.setAttribute("width", w3.toString());
    strokeElement.setAttribute("height", h3.toString());
    strokeElement.setAttribute("fill", "none");
    strokeElement.setAttribute("stroke", colors.fill[color]);
    strokeElement.setAttribute("stroke-dasharray", strokeDasharray);
    strokeElement.setAttribute("stroke-dashoffset", strokeDashoffset);
    const fillElement = getShapeFillSvg({
      d: d3,
      fill,
      color,
      colors
    });
    return getSvgWithShapeFill(strokeElement, fillElement);
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLGeoUtil/components/DashStylePolygon.tsx
  var React24 = __toESM(require_react());
  var import_jsx_runtime40 = __toESM(require_jsx_runtime());
  var DashStylePolygon = React24.memo(function DashStylePolygon2({
    dash,
    fill,
    color,
    strokeWidth,
    outline,
    lines
  }) {
    const innerPath = "M" + outline[0] + "L" + outline.slice(1) + "Z";
    return /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)(import_jsx_runtime40.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(ShapeFill, { d: innerPath, fill, color }),
      lines && lines.map((l3, i3) => /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(
        "path",
        {
          className: "tl-hitarea-stroke",
          fill: "none",
          d: `M${l3[0].x},${l3[0].y}L${l3[1].x},${l3[1].y}`
        },
        `line_bg_${i3}`
      )),
      /* @__PURE__ */ (0, import_jsx_runtime40.jsxs)("g", { strokeWidth, stroke: "currentColor", fill: "none", pointerEvents: "all", children: [
        Array.from(Array(outline.length)).map((_, i3) => {
          const A2 = outline[i3];
          const B = outline[(i3 + 1) % outline.length];
          const dist = Vec2d.Dist(A2, B);
          const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(dist, strokeWidth, {
            style: dash,
            start: "outset",
            end: "outset"
          });
          return /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(
            "line",
            {
              x1: A2.x,
              y1: A2.y,
              x2: B.x,
              y2: B.y,
              strokeDasharray,
              strokeDashoffset
            },
            i3
          );
        }),
        lines && lines.map(([A2, B], i3) => {
          const dist = Vec2d.Dist(A2, B);
          const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(dist, strokeWidth, {
            style: dash,
            start: "skip",
            end: "outset",
            snap: dash === "dotted" ? 4 : void 0
          });
          return /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(
            "path",
            {
              d: `M${A2.x},${A2.y}L${B.x},${B.y}`,
              stroke: "currentColor",
              strokeWidth,
              fill: "none",
              strokeDasharray,
              strokeDashoffset
            },
            `line_fg_${i3}`
          );
        })
      ] })
    ] });
  });
  function DashStylePolygonSvg({
    dash,
    fill,
    color,
    colors,
    strokeWidth,
    outline,
    lines
  }) {
    const strokeElement = document.createElementNS("http://www.w3.org/2000/svg", "g");
    strokeElement.setAttribute("stroke-width", strokeWidth.toString());
    strokeElement.setAttribute("stroke", colors.fill[color]);
    strokeElement.setAttribute("fill", "none");
    Array.from(Array(outline.length)).forEach((_, i3) => {
      const A2 = outline[i3];
      const B = outline[(i3 + 1) % outline.length];
      const dist = Vec2d.Dist(A2, B);
      const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(dist, strokeWidth, {
        style: dash
      });
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", A2.x.toString());
      line.setAttribute("y1", A2.y.toString());
      line.setAttribute("x2", B.x.toString());
      line.setAttribute("y2", B.y.toString());
      line.setAttribute("stroke-dasharray", strokeDasharray.toString());
      line.setAttribute("stroke-dashoffset", strokeDashoffset.toString());
      strokeElement.appendChild(line);
    });
    if (lines) {
      for (const [A2, B] of lines) {
        const dist = Vec2d.Dist(A2, B);
        const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(dist, strokeWidth, {
          style: dash,
          start: "skip",
          end: "skip",
          snap: dash === "dotted" ? 4 : 2
        });
        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", A2.x.toString());
        line.setAttribute("y1", A2.y.toString());
        line.setAttribute("x2", B.x.toString());
        line.setAttribute("y2", B.y.toString());
        line.setAttribute("stroke-dasharray", strokeDasharray.toString());
        line.setAttribute("stroke-dashoffset", strokeDashoffset.toString());
        strokeElement.appendChild(line);
      }
    }
    const fillElement = getShapeFillSvg({
      d: "M" + outline[0] + "L" + outline.slice(1) + "Z",
      fill,
      color,
      colors
    });
    return getSvgWithShapeFill(strokeElement, fillElement);
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLGeoUtil/components/DrawStyleEllipse.tsx
  var React25 = __toESM(require_react());
  var import_jsx_runtime41 = __toESM(require_jsx_runtime());
  var DrawStyleEllipse = React25.memo(function DrawStyleEllipse2({
    id,
    w: w3,
    h: h3,
    strokeWidth: sw,
    fill,
    color
  }) {
    const innerPath = getEllipseIndicatorPath(id, w3, h3, sw);
    const outerPath = getEllipsePath(id, w3, h3, sw);
    return /* @__PURE__ */ (0, import_jsx_runtime41.jsxs)(import_jsx_runtime41.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(ShapeFill, { d: innerPath, color, fill }),
      /* @__PURE__ */ (0, import_jsx_runtime41.jsx)("path", { d: outerPath, fill: "currentColor", strokeWidth: 0, pointerEvents: "all" })
    ] });
  });
  function DrawStyleEllipseSvg({
    id,
    w: w3,
    h: h3,
    strokeWidth: sw,
    fill,
    color,
    colors
  }) {
    const strokeElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
    strokeElement.setAttribute("d", getEllipsePath(id, w3, h3, sw));
    strokeElement.setAttribute("fill", colors.fill[color]);
    const fillElement = getShapeFillSvg({
      d: getEllipseIndicatorPath(id, w3, h3, sw),
      fill,
      color,
      colors
    });
    return getSvgWithShapeFill(strokeElement, fillElement);
  }
  function getEllipseStrokeOptions(strokeWidth) {
    return {
      size: 1 + strokeWidth,
      thinning: 0.25,
      end: { taper: strokeWidth },
      start: { taper: strokeWidth },
      streamline: 0,
      smoothing: 1,
      simulatePressure: false
    };
  }
  function getEllipseStrokePoints(id, width, height, strokeWidth) {
    const getRandom = rng(id);
    const rx = width / 2;
    const ry = height / 2;
    const perimeter = perimeterOfEllipse(rx, ry);
    const points2 = [];
    const start = PI2 * getRandom();
    const length = PI2 + TAU / 2 + Math.abs(getRandom()) * TAU;
    const count = Math.max(16, perimeter / 10);
    for (let i3 = 0; i3 < count; i3++) {
      const t4 = i3 / (count - 1);
      const r3 = start + t4 * length;
      const c3 = Math.cos(r3);
      const s3 = Math.sin(r3);
      points2.push(
        new Vec2d(
          rx * c3 + width * 0.5 + 0.05 * getRandom(),
          ry * s3 + height / 2 + 0.05 * getRandom(),
          Math.min(
            1,
            0.5 + Math.abs(0.5 - (getRandom() > 0 ? EASINGS.easeInOutSine(t4) : EASINGS.easeInExpo(t4))) / 2
          )
        )
      );
    }
    return getStrokePoints(points2, getEllipseStrokeOptions(strokeWidth));
  }
  function getEllipsePath(id, width, height, strokeWidth) {
    const options = getEllipseStrokeOptions(strokeWidth);
    return getSvgPathFromStroke(
      getStrokeOutlinePoints(
        setStrokePointRadii(getEllipseStrokePoints(id, width, height, strokeWidth), options),
        options
      )
    );
  }
  function getEllipseIndicatorPath(id, width, height, strokeWidth) {
    return getSvgPathFromStrokePoints(getEllipseStrokePoints(id, width, height, strokeWidth));
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLGeoUtil/components/DrawStylePolygon.tsx
  var React26 = __toESM(require_react());
  var import_jsx_runtime42 = __toESM(require_jsx_runtime());
  var DrawStylePolygon = React26.memo(function DrawStylePolygon2({
    id,
    outline,
    lines,
    fill,
    color,
    strokeWidth
  }) {
    const polygonPoints = getRoundedPolygonPoints(id, outline, strokeWidth / 3, strokeWidth * 2, 2);
    let strokePathData = getRoundedInkyPolygonPath(polygonPoints);
    if (lines) {
      for (const [A2, B] of lines) {
        strokePathData += `M${A2.x},${A2.y}L${B.x},${B.y}`;
      }
    }
    const innerPolygonPoints = getRoundedPolygonPoints(id, outline, 0, strokeWidth * 2, 1);
    const innerPathData = getRoundedInkyPolygonPath(innerPolygonPoints);
    return /* @__PURE__ */ (0, import_jsx_runtime42.jsxs)(import_jsx_runtime42.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(ShapeFill, { d: innerPathData, fill, color }),
      /* @__PURE__ */ (0, import_jsx_runtime42.jsx)("path", { d: strokePathData, stroke: "currentColor", strokeWidth, fill: "none" })
    ] });
  });
  function DrawStylePolygonSvg({
    id,
    outline,
    lines,
    fill,
    color,
    colors,
    strokeWidth
  }) {
    const polygonPoints = getRoundedPolygonPoints(id, outline, strokeWidth / 3, strokeWidth * 2, 2);
    let strokePathData = getRoundedInkyPolygonPath(polygonPoints);
    if (lines) {
      for (const [A2, B] of lines) {
        strokePathData += `M${A2.x},${A2.y}L${B.x},${B.y}`;
      }
    }
    const innerPolygonPoints = getRoundedPolygonPoints(id, outline, 0, strokeWidth * 2, 1);
    const innerPathData = getRoundedInkyPolygonPath(innerPolygonPoints);
    const strokeElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
    strokeElement.setAttribute("d", strokePathData);
    strokeElement.setAttribute("fill", "none");
    strokeElement.setAttribute("stroke", colors.fill[color]);
    strokeElement.setAttribute("stroke-width", strokeWidth.toString());
    const fillElement = getShapeFillSvg({
      d: innerPathData,
      fill,
      color,
      colors
    });
    return getSvgWithShapeFill(strokeElement, fillElement);
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLGeoUtil/components/SolidStyleEllipse.tsx
  var React27 = __toESM(require_react());
  var import_jsx_runtime43 = __toESM(require_jsx_runtime());
  var SolidStyleEllipse = React27.memo(function SolidStyleEllipse2({
    w: w3,
    h: h3,
    strokeWidth: sw,
    fill,
    color
  }) {
    const cx = w3 / 2;
    const cy = h3 / 2;
    const rx = Math.max(0, cx);
    const ry = Math.max(0, cy);
    const d3 = `M${cx - rx},${cy}a${rx},${ry},0,1,1,${rx * 2},0a${rx},${ry},0,1,1,-${rx * 2},0`;
    return /* @__PURE__ */ (0, import_jsx_runtime43.jsxs)(import_jsx_runtime43.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(ShapeFill, { d: d3, color, fill }),
      /* @__PURE__ */ (0, import_jsx_runtime43.jsx)("path", { d: d3, stroke: `var(--palette-${color})`, strokeWidth: sw, fill: "none" })
    ] });
  });
  function SolidStyleEllipseSvg({
    w: w3,
    h: h3,
    strokeWidth: sw,
    fill,
    color,
    colors
  }) {
    const cx = w3 / 2;
    const cy = h3 / 2;
    const rx = Math.max(0, cx);
    const ry = Math.max(0, cy);
    const d3 = `M${cx - rx},${cy}a${rx},${ry},0,1,1,${rx * 2},0a${rx},${ry},0,1,1,-${rx * 2},0`;
    const strokeElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
    strokeElement.setAttribute("d", d3);
    strokeElement.setAttribute("stroke-width", sw.toString());
    strokeElement.setAttribute("width", w3.toString());
    strokeElement.setAttribute("height", h3.toString());
    strokeElement.setAttribute("fill", "none");
    strokeElement.setAttribute("stroke", colors.fill[color]);
    const fillElement = getShapeFillSvg({
      d: d3,
      fill,
      color,
      colors
    });
    return getSvgWithShapeFill(strokeElement, fillElement);
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLGeoUtil/components/SolidStyleOval.tsx
  var React28 = __toESM(require_react());
  var import_jsx_runtime44 = __toESM(require_jsx_runtime());
  var SolidStyleOval = React28.memo(function SolidStyleOval2({
    w: w3,
    h: h3,
    strokeWidth: sw,
    fill,
    color
  }) {
    const d3 = getOvalIndicatorPath(w3, h3);
    return /* @__PURE__ */ (0, import_jsx_runtime44.jsxs)(import_jsx_runtime44.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(ShapeFill, { d: d3, color, fill }),
      /* @__PURE__ */ (0, import_jsx_runtime44.jsx)("path", { d: d3, stroke: `var(--palette-${color})`, strokeWidth: sw, fill: "none" })
    ] });
  });
  function SolidStyleOvalSvg({
    w: w3,
    h: h3,
    strokeWidth: sw,
    fill,
    color,
    colors
  }) {
    const d3 = getOvalIndicatorPath(w3, h3);
    const strokeElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
    strokeElement.setAttribute("d", d3);
    strokeElement.setAttribute("stroke-width", sw.toString());
    strokeElement.setAttribute("width", w3.toString());
    strokeElement.setAttribute("height", h3.toString());
    strokeElement.setAttribute("fill", "none");
    strokeElement.setAttribute("stroke", colors.fill[color]);
    const fillElement = getShapeFillSvg({
      d: d3,
      fill,
      color,
      colors
    });
    return getSvgWithShapeFill(strokeElement, fillElement);
  }
  function getOvalIndicatorPath(w3, h3) {
    let d3;
    if (h3 > w3) {
      const offset = w3 / 2;
      d3 = `
    M0,${offset}
    a${offset},${offset},0,1,1,${offset * 2},0
    L${w3},${h3 - offset}
    a${offset},${offset},0,1,1,-${offset * 2},0
    Z`;
    } else {
      const offset = h3 / 2;
      d3 = `
    M${offset},0
    L${w3 - offset},0
    a${offset},${offset},0,1,1,0,${offset * 2}
    L${offset},${h3}
    a${offset},${offset},0,1,1,0,${-offset * 2}
    Z`;
    }
    return d3;
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLGeoUtil/components/SolidStylePolygon.tsx
  var React29 = __toESM(require_react());
  var import_jsx_runtime45 = __toESM(require_jsx_runtime());
  var SolidStylePolygon = React29.memo(function SolidStylePolygon2({
    outline,
    lines,
    fill,
    color,
    strokeWidth
  }) {
    let path = "M" + outline[0] + "L" + outline.slice(1) + "Z";
    if (lines) {
      for (const [A2, B] of lines) {
        path += `M${A2.x},${A2.y}L${B.x},${B.y}`;
      }
    }
    return /* @__PURE__ */ (0, import_jsx_runtime45.jsxs)(import_jsx_runtime45.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime45.jsx)(ShapeFill, { d: path, fill, color }),
      /* @__PURE__ */ (0, import_jsx_runtime45.jsx)("path", { d: path, stroke: `var(--palette-${color}`, strokeWidth, fill: "none" })
    ] });
  });
  function SolidStylePolygonSvg({
    outline,
    lines,
    fill,
    color,
    strokeWidth,
    colors
  }) {
    const pathData = "M" + outline[0] + "L" + outline.slice(1) + "Z";
    const fillPathData = pathData;
    let strokePathData = pathData;
    if (lines) {
      for (const [A2, B] of lines) {
        strokePathData += `M${A2.x},${A2.y}L${B.x},${B.y}`;
      }
    }
    const strokeElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
    strokeElement.setAttribute("d", strokePathData);
    strokeElement.setAttribute("stroke-width", strokeWidth.toString());
    strokeElement.setAttribute("stroke", colors.fill[color]);
    strokeElement.setAttribute("fill", "none");
    const fillElement = getShapeFillSvg({
      d: fillPathData,
      fill,
      color,
      colors
    });
    return getSvgWithShapeFill(strokeElement, fillElement);
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLGeoUtil/TLGeoUtil.tsx
  var import_jsx_runtime46 = __toESM(require_jsx_runtime());
  var LABEL_PADDING = 16;
  var MIN_SIZE_WITH_LABEL = 17 * 3;
  var TLGeoUtil = class extends TLBoxUtil {
    constructor() {
      super(...arguments);
      __publicField(this, "canEdit", () => true);
      __publicField(this, "onEditEnd", (shape) => {
        const {
          id,
          type,
          props: { text }
        } = shape;
        if (text.trimEnd() !== shape.props.text) {
          this.app.updateShapes([
            {
              id,
              type,
              props: {
                text: text.trimEnd()
              }
            }
          ]);
        }
      });
      __publicField(this, "onResize", (shape, { initialBounds, handle, newPoint, scaleX, scaleY }) => {
        let w3 = initialBounds.width * scaleX;
        let h3 = initialBounds.height * scaleY;
        let overShrinkX = 0;
        let overShrinkY = 0;
        if (shape.props.text.trim()) {
          let newW = Math.max(Math.abs(w3), MIN_SIZE_WITH_LABEL);
          let newH = Math.max(Math.abs(h3), MIN_SIZE_WITH_LABEL);
          if (newW < MIN_SIZE_WITH_LABEL && newH === MIN_SIZE_WITH_LABEL) {
            newW = MIN_SIZE_WITH_LABEL;
          }
          if (newW === MIN_SIZE_WITH_LABEL && newH < MIN_SIZE_WITH_LABEL) {
            newH = MIN_SIZE_WITH_LABEL;
          }
          const labelSize = getLabelSize(this.app, __spreadProps(__spreadValues({}, shape), {
            props: __spreadProps(__spreadValues({}, shape.props), {
              w: newW,
              h: newH
            })
          }));
          const nextW = Math.max(Math.abs(w3), labelSize.w) * Math.sign(w3);
          const nextH = Math.max(Math.abs(h3), labelSize.h) * Math.sign(h3);
          overShrinkX = Math.abs(nextW) - Math.abs(w3);
          overShrinkY = Math.abs(nextH) - Math.abs(h3);
          w3 = nextW;
          h3 = nextH;
        }
        const offset = new Vec2d(0, 0);
        if (scaleX < 0) {
          offset.x += w3;
        }
        if (handle === "left" || handle === "top_left" || handle === "bottom_left") {
          offset.x += scaleX < 0 ? overShrinkX : -overShrinkX;
        }
        if (scaleY < 0) {
          offset.y += h3;
        }
        if (handle === "top" || handle === "top_left" || handle === "top_right") {
          offset.y += scaleY < 0 ? overShrinkY : -overShrinkY;
        }
        const { x: x3, y: y3 } = offset.rot(shape.rotation).add(newPoint);
        return {
          x: x3,
          y: y3,
          props: {
            w: Math.max(Math.abs(w3), 1),
            h: Math.max(Math.abs(h3), 1),
            growY: 0
          }
        };
      });
      __publicField(this, "onBeforeCreate", (shape) => {
        if (!shape.props.text) {
          if (shape.props.growY) {
            return __spreadProps(__spreadValues({}, shape), {
              props: __spreadProps(__spreadValues({}, shape.props), {
                growY: 0
              })
            });
          } else {
            return;
          }
        }
        const prevHeight = shape.props.h;
        const nextHeight = getLabelSize(this.app, shape).h;
        let growY = null;
        if (nextHeight > prevHeight) {
          growY = nextHeight - prevHeight;
        } else {
          if (shape.props.growY) {
            growY = 0;
          }
        }
        if (growY !== null) {
          return __spreadProps(__spreadValues({}, shape), {
            props: __spreadProps(__spreadValues({}, shape.props), {
              growY
            })
          });
        }
      });
      __publicField(this, "onBeforeUpdate", (prev, next) => {
        const prevText = prev.props.text.trimEnd();
        const nextText = next.props.text.trimEnd();
        if (prevText === nextText && prev.props.font === next.props.font && prev.props.size === next.props.size) {
          return;
        }
        if (prevText && !nextText) {
          return __spreadProps(__spreadValues({}, next), {
            props: __spreadProps(__spreadValues({}, next.props), {
              growY: 0
            })
          });
        }
        const prevWidth = prev.props.w;
        const prevHeight = prev.props.h;
        const nextSize = getLabelSize(this.app, next);
        const nextWidth = nextSize.w;
        const nextHeight = nextSize.h;
        if (!prevText && nextText && nextText.length === 1) {
          let w3 = Math.max(prevWidth, nextWidth);
          let h3 = Math.max(prevHeight, nextHeight);
          if (prev.props.w < MIN_SIZE_WITH_LABEL && prev.props.h < MIN_SIZE_WITH_LABEL) {
            w3 = Math.max(w3, MIN_SIZE_WITH_LABEL);
            h3 = Math.max(h3, MIN_SIZE_WITH_LABEL);
            w3 = Math.max(w3, h3);
            h3 = Math.max(w3, h3);
          }
          return __spreadProps(__spreadValues({}, next), {
            props: __spreadProps(__spreadValues({}, next.props), {
              w: w3,
              h: h3,
              growY: 0
            })
          });
        }
        let growY = null;
        if (nextHeight > prevHeight) {
          growY = nextHeight - prevHeight;
        } else {
          if (prev.props.growY) {
            growY = 0;
          }
        }
        if (growY !== null) {
          return __spreadProps(__spreadValues({}, next), {
            props: __spreadProps(__spreadValues({}, next.props), {
              growY,
              w: Math.max(next.props.w, nextWidth)
            })
          });
        }
        if (nextWidth > prev.props.w) {
          return __spreadProps(__spreadValues({}, next), {
            props: __spreadProps(__spreadValues({}, next.props), {
              w: nextWidth
            })
          });
        }
      });
      __publicField(this, "onDoubleClick", (shape) => {
        if (this.app.inputs.altKey) {
          switch (shape.props.geo) {
            case "rectangle": {
              return __spreadProps(__spreadValues({}, shape), {
                props: {
                  geo: "check-box"
                }
              });
            }
            case "check-box": {
              return __spreadProps(__spreadValues({}, shape), {
                props: {
                  geo: "rectangle"
                }
              });
            }
          }
        }
        return;
      });
    }
    defaultProps() {
      return {
        w: 100,
        h: 100,
        geo: "rectangle",
        color: "black",
        labelColor: "black",
        fill: "none",
        dash: "draw",
        size: "m",
        opacity: "1",
        font: "draw",
        text: "",
        align: "middle",
        growY: 0,
        url: ""
      };
    }
    hitTestLineSegment(shape, A2, B) {
      const outline = this.outline(shape);
      for (let i3 = 0; i3 < outline.length; i3++) {
        const C2 = outline[i3];
        const D3 = outline[(i3 + 1) % outline.length];
        if (linesIntersect(A2, B, C2, D3))
          return true;
      }
      const lines = getLines(shape.props, 0);
      if (lines !== void 0) {
        for (const [C2, D3] of lines) {
          if (linesIntersect(A2, B, C2, D3))
            return true;
        }
      }
      return false;
    }
    hitTestPoint(shape, point2) {
      const outline = this.outline(shape);
      if (shape.props.fill === "none") {
        const zoomLevel = this.app.zoomLevel;
        const offsetDist = this.app.getStrokeWidth(shape.props.size) / zoomLevel;
        for (let i3 = 0; i3 < outline.length; i3++) {
          const C2 = outline[i3];
          const D3 = outline[(i3 + 1) % outline.length];
          if (Vec2d.DistanceToLineSegment(C2, D3, point2) < offsetDist)
            return true;
        }
        const lines = getLines(shape.props, 1);
        if (lines !== void 0) {
          for (const [C2, D3] of lines) {
            if (Vec2d.DistanceToLineSegment(C2, D3, point2) < offsetDist)
              return true;
          }
        }
        return false;
      }
      return pointInPolygon(point2, outline);
    }
    getBounds(shape) {
      return new Box2d(0, 0, shape.props.w, shape.props.h + shape.props.growY);
    }
    getCenter(shape) {
      return new Vec2d(shape.props.w / 2, (shape.props.h + shape.props.growY) / 2);
    }
    getOutline(shape) {
      const w3 = Math.max(1, shape.props.w);
      const h3 = Math.max(1, shape.props.h + shape.props.growY);
      const cx = w3 / 2;
      const cy = h3 / 2;
      switch (shape.props.geo) {
        case "triangle": {
          return [new Vec2d(cx, 0), new Vec2d(w3, h3), new Vec2d(0, h3)];
        }
        case "diamond": {
          return [new Vec2d(cx, 0), new Vec2d(w3, cy), new Vec2d(cx, h3), new Vec2d(0, cy)];
        }
        case "pentagon": {
          return getPolygonVertices(w3, h3, 5);
        }
        case "hexagon": {
          return getPolygonVertices(w3, h3, 6);
        }
        case "octagon": {
          return getPolygonVertices(w3, h3, 8);
        }
        case "ellipse": {
          const q = Math.pow(cx - cy, 2) / Math.pow(cx + cy, 2);
          const p3 = PI * (cx + cy) * (1 + 3 * q / (10 + Math.sqrt(4 - 3 * q)));
          let len = Math.max(4, Math.ceil(p3 / 10));
          len = Math.ceil(len / 4) * 4;
          const step = PI2 / len;
          const a3 = Math.cos(step);
          const b3 = Math.sin(step);
          let sin = 0;
          let cos = 1;
          let ts = 0;
          let tc = 1;
          const points2 = Array(len);
          for (let i3 = 0; i3 < len; i3++) {
            points2[i3] = new Vec2d(cx + cx * cos, cy + cy * sin);
            ts = b3 * cos + a3 * sin;
            tc = a3 * cos - b3 * sin;
            sin = ts;
            cos = tc;
          }
          return points2;
        }
        case "oval": {
          const len = 10;
          const points2 = Array(len * 2);
          if (h3 > w3) {
            for (let i3 = 0; i3 < len; i3++) {
              const t1 = -PI + PI * i3 / (len - 2);
              const t22 = PI * i3 / (len - 2);
              points2[i3] = new Vec2d(cx + cx * Math.cos(t1), cx + cx * Math.sin(t1));
              points2[i3 + len] = new Vec2d(cx + cx * Math.cos(t22), h3 - cx + cx * Math.sin(t22));
            }
          } else {
            for (let i3 = 0; i3 < len; i3++) {
              const t1 = -TAU + PI * i3 / (len - 2);
              const t22 = TAU + PI * -i3 / (len - 2);
              points2[i3] = new Vec2d(w3 - cy + cy * Math.cos(t1), h3 - cy + cy * Math.sin(t1));
              points2[i3 + len] = new Vec2d(cy - cy * Math.cos(t22), h3 - cy + cy * Math.sin(t22));
            }
          }
          return points2;
        }
        case "star": {
          const sides = 5;
          const step = PI2 / sides / 2;
          const rightMostIndex = Math.floor(sides / 4) * 2;
          const leftMostIndex = sides * 2 - rightMostIndex;
          const topMostIndex = 0;
          const bottomMostIndex = Math.floor(sides / 2) * 2;
          const maxX = Math.cos(-TAU + rightMostIndex * step) * w3 / 2;
          const minX = Math.cos(-TAU + leftMostIndex * step) * w3 / 2;
          const minY = Math.sin(-TAU + topMostIndex * step) * h3 / 2;
          const maxY = Math.sin(-TAU + bottomMostIndex * step) * h3 / 2;
          const diffX = w3 - Math.abs(maxX - minX);
          const diffY = h3 - Math.abs(maxY - minY);
          const offsetX = w3 / 2 + minX - (w3 / 2 - maxX);
          const offsetY = h3 / 2 + minY - (h3 / 2 - maxY);
          const ratio = 1;
          const cx2 = (w3 - offsetX) / 2;
          const cy2 = (h3 - offsetY) / 2;
          const ox = (w3 + diffX) / 2;
          const oy = (h3 + diffY) / 2;
          const ix = ox * ratio / 2;
          const iy = oy * ratio / 2;
          return Array.from(Array(sides * 2)).map((_, i3) => {
            const theta = -TAU + i3 * step;
            return new Vec2d(
              cx2 + (i3 % 2 ? ix : ox) * Math.cos(theta),
              cy2 + (i3 % 2 ? iy : oy) * Math.sin(theta)
            );
          });
        }
        case "rhombus": {
          const offset = Math.min(w3 * 0.38, h3 * 0.38);
          return [new Vec2d(offset, 0), new Vec2d(w3, 0), new Vec2d(w3 - offset, h3), new Vec2d(0, h3)];
        }
        case "rhombus-2": {
          const offset = Math.min(w3 * 0.38, h3 * 0.38);
          return [new Vec2d(0, 0), new Vec2d(w3 - offset, 0), new Vec2d(w3, h3), new Vec2d(offset, h3)];
        }
        case "trapezoid": {
          const offset = Math.min(w3 * 0.38, h3 * 0.38);
          return [new Vec2d(offset, 0), new Vec2d(w3 - offset, 0), new Vec2d(w3, h3), new Vec2d(0, h3)];
        }
        case "arrow-right": {
          const ox = Math.min(w3, h3) * 0.38;
          const oy = h3 * 0.16;
          return [
            new Vec2d(0, oy),
            new Vec2d(w3 - ox, oy),
            new Vec2d(w3 - ox, 0),
            new Vec2d(w3, h3 / 2),
            new Vec2d(w3 - ox, h3),
            new Vec2d(w3 - ox, h3 - oy),
            new Vec2d(0, h3 - oy)
          ];
        }
        case "arrow-left": {
          const ox = Math.min(w3, h3) * 0.38;
          const oy = h3 * 0.16;
          return [
            new Vec2d(ox, 0),
            new Vec2d(ox, oy),
            new Vec2d(w3, oy),
            new Vec2d(w3, h3 - oy),
            new Vec2d(ox, h3 - oy),
            new Vec2d(ox, h3),
            new Vec2d(0, h3 / 2)
          ];
        }
        case "arrow-up": {
          const ox = w3 * 0.16;
          const oy = Math.min(w3, h3) * 0.38;
          return [
            new Vec2d(w3 / 2, 0),
            new Vec2d(w3, oy),
            new Vec2d(w3 - ox, oy),
            new Vec2d(w3 - ox, h3),
            new Vec2d(ox, h3),
            new Vec2d(ox, oy),
            new Vec2d(0, oy)
          ];
        }
        case "arrow-down": {
          const ox = w3 * 0.16;
          const oy = Math.min(w3, h3) * 0.38;
          return [
            new Vec2d(ox, 0),
            new Vec2d(w3 - ox, 0),
            new Vec2d(w3 - ox, h3 - oy),
            new Vec2d(w3, h3 - oy),
            new Vec2d(w3 / 2, h3),
            new Vec2d(0, h3 - oy),
            new Vec2d(ox, h3 - oy)
          ];
        }
        case "check-box":
        case "x-box":
        case "rectangle": {
          return [new Vec2d(0, 0), new Vec2d(w3, 0), new Vec2d(w3, h3), new Vec2d(0, h3)];
        }
      }
    }
    render(shape) {
      const { id, type, props } = shape;
      const forceSolid = useForceSolid();
      const strokeWidth = this.app.getStrokeWidth(props.size);
      const { w: w3, color, labelColor, fill, dash, growY, font, align, size, text } = props;
      const getShape = () => {
        const h3 = props.h + growY;
        switch (props.geo) {
          case "ellipse": {
            if (dash === "solid" || dash === "draw" && forceSolid) {
              return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(SolidStyleEllipse, { strokeWidth, w: w3, h: h3, color, fill });
            } else if (dash === "dashed" || dash === "dotted") {
              return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
                DashStyleEllipse,
                {
                  id,
                  strokeWidth,
                  w: w3,
                  h: h3,
                  dash: dash === "dashed" ? dash : size === "s" && forceSolid ? "dashed" : dash,
                  color,
                  fill
                }
              );
            } else if (dash === "draw") {
              return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(SolidStyleEllipse, { strokeWidth, w: w3, h: h3, color, fill });
            }
            break;
          }
          case "oval": {
            if (dash === "solid" || dash === "draw" && forceSolid) {
              return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(SolidStyleOval, { strokeWidth, w: w3, h: h3, color, fill });
            } else if (dash === "dashed" || dash === "dotted") {
              return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
                DashStyleOval,
                {
                  id,
                  strokeWidth,
                  w: w3,
                  h: h3,
                  dash: dash === "dashed" ? dash : size === "s" && forceSolid ? "dashed" : dash,
                  color,
                  fill
                }
              );
            } else if (dash === "draw") {
              return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(SolidStyleOval, { strokeWidth, w: w3, h: h3, color, fill });
            }
            break;
          }
          default: {
            const outline = this.outline(shape);
            const lines = getLines(shape.props, strokeWidth);
            if (dash === "solid" || dash === "draw" && forceSolid) {
              return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
                SolidStylePolygon,
                {
                  fill,
                  color,
                  strokeWidth,
                  outline,
                  lines
                }
              );
            } else if (dash === "dashed" || dash === "dotted") {
              return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
                DashStylePolygon,
                {
                  dash: dash === "dashed" ? dash : size === "s" && forceSolid ? "dashed" : dash,
                  fill,
                  color,
                  strokeWidth,
                  outline,
                  lines
                }
              );
            } else if (dash === "draw") {
              return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
                DrawStylePolygon,
                {
                  id,
                  fill,
                  color,
                  strokeWidth,
                  outline,
                  lines
                }
              );
            }
          }
        }
      };
      return /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(import_jsx_runtime46.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(SVGContainer, { id, children: getShape() }),
        /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(
          TextLabel,
          {
            id,
            type,
            font,
            fill,
            size,
            align,
            text,
            labelColor: this.app.getCssColor(labelColor),
            wrap: true
          }
        ),
        "url" in shape.props && shape.props.url && /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(HyperlinkButton, { url: shape.props.url, zoomLevel: this.app.zoomLevel })
      ] });
    }
    indicator(shape) {
      const { id, props } = shape;
      const { w: w3, h: h3, growY, size } = props;
      const forceSolid = useForceSolid();
      const strokeWidth = this.app.getStrokeWidth(size);
      switch (props.geo) {
        case "ellipse": {
          if (props.dash === "draw" && !forceSolid) {
            return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("path", { d: getEllipseIndicatorPath(id, w3, h3 + growY, strokeWidth) });
          }
          return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("ellipse", { cx: w3 / 2, cy: (h3 + growY) / 2, rx: w3 / 2, ry: (h3 + growY) / 2 });
        }
        case "oval": {
          return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("path", { d: getOvalIndicatorPath(w3, h3 + growY) });
        }
        default: {
          const outline = this.outline(shape);
          let path;
          if (props.dash === "draw" && !forceSolid) {
            const polygonPoints = getRoundedPolygonPoints(id, outline, 0, strokeWidth * 2, 1);
            path = getRoundedInkyPolygonPath(polygonPoints);
          } else {
            path = "M" + outline[0] + "L" + outline.slice(1) + "Z";
          }
          const lines = getLines(shape.props, strokeWidth);
          if (lines) {
            for (const [A2, B] of lines) {
              path += `M${A2.x},${A2.y}L${B.x},${B.y}`;
            }
          }
          return /* @__PURE__ */ (0, import_jsx_runtime46.jsx)("path", { d: path });
        }
      }
    }
    toSvg(shape, font, colors) {
      const { id, props } = shape;
      const strokeWidth = this.app.getStrokeWidth(props.size);
      let svgElm;
      switch (props.geo) {
        case "ellipse": {
          switch (props.dash) {
            case "draw":
              svgElm = DrawStyleEllipseSvg({
                id,
                w: props.w,
                h: props.h,
                color: props.color,
                fill: props.fill,
                strokeWidth,
                colors
              });
              break;
            case "solid":
              svgElm = SolidStyleEllipseSvg({
                strokeWidth,
                w: props.w,
                h: props.h,
                color: props.color,
                fill: props.fill,
                colors
              });
              break;
            default:
              svgElm = DashStyleEllipseSvg({
                id,
                strokeWidth,
                w: props.w,
                h: props.h,
                dash: props.dash,
                color: props.color,
                fill: props.fill,
                colors
              });
              break;
          }
          break;
        }
        case "oval": {
          switch (props.dash) {
            case "draw":
              svgElm = DashStyleOvalSvg({
                id,
                strokeWidth,
                w: props.w,
                h: props.h,
                dash: props.dash,
                color: props.color,
                fill: props.fill,
                colors
              });
              break;
            case "solid":
              svgElm = SolidStyleOvalSvg({
                strokeWidth,
                w: props.w,
                h: props.h,
                color: props.color,
                fill: props.fill,
                colors
              });
              break;
            default:
              svgElm = DashStyleOvalSvg({
                id,
                strokeWidth,
                w: props.w,
                h: props.h,
                dash: props.dash,
                color: props.color,
                fill: props.fill,
                colors
              });
          }
          break;
        }
        default: {
          const outline = this.outline(shape);
          const lines = getLines(shape.props, strokeWidth);
          switch (props.dash) {
            case "draw":
              svgElm = DrawStylePolygonSvg({
                id,
                fill: props.fill,
                color: props.color,
                strokeWidth,
                outline,
                lines,
                colors
              });
              break;
            case "solid":
              svgElm = SolidStylePolygonSvg({
                fill: props.fill,
                color: props.color,
                strokeWidth,
                outline,
                lines,
                colors
              });
              break;
            default:
              svgElm = DashStylePolygonSvg({
                dash: props.dash,
                fill: props.fill,
                color: props.color,
                strokeWidth,
                outline,
                lines,
                colors
              });
              break;
          }
          break;
        }
      }
      if (props.text) {
        const bounds = this.bounds(shape);
        const opts = {
          fontSize: LABEL_FONT_SIZES[shape.props.size],
          fontFamily: font,
          textAlign: shape.props.align,
          padding: 16,
          lineHeight: TEXT_PROPS.lineHeight,
          fontStyle: "normal",
          fontWeight: "normal",
          width: Math.ceil(bounds.width),
          height: Math.ceil(bounds.height)
        };
        const lines = this.app.textMeasure.getTextLines(__spreadValues({
          text: props.text,
          wrap: true
        }, opts));
        const groupEl = document.createElementNS("http://www.w3.org/2000/svg", "g");
        const labelSize = getLabelSize(this.app, shape);
        const textBgEl = getTextSvgElement(this.app, __spreadProps(__spreadValues({}, opts), {
          lines,
          strokeWidth: 2,
          stroke: colors.background,
          fill: colors.background,
          width: labelSize.w
        }));
        textBgEl.setAttribute("transform", `translate(${(bounds.width - labelSize.w) / 2}, 0)`);
        const textElm = textBgEl.cloneNode(true);
        textElm.setAttribute("fill", colors.fill[shape.props.labelColor]);
        textElm.setAttribute("stroke", "none");
        groupEl.append(textBgEl);
        groupEl.append(textElm);
        if (svgElm.nodeName === "g") {
          svgElm.appendChild(groupEl);
          return svgElm;
        } else {
          const g3 = document.createElementNS("http://www.w3.org/2000/svg", "g");
          g3.appendChild(svgElm);
          g3.appendChild(groupEl);
          return g3;
        }
      }
      return svgElm;
    }
  };
  __publicField(TLGeoUtil, "type", "geo");
  function getLabelSize(app, shape) {
    const text = shape.props.text.trimEnd();
    if (!text) {
      return { w: 0, h: 0 };
    }
    const minSize = app.textMeasure.measureText(__spreadProps(__spreadValues({}, TEXT_PROPS), {
      text: "w",
      fontFamily: FONT_FAMILIES[shape.props.font],
      fontSize: LABEL_FONT_SIZES[shape.props.size],
      width: "fit-content",
      maxWidth: "100px"
    }));
    const sizes = {
      s: 2,
      m: 3.5,
      l: 5,
      xl: 10
    };
    const size = app.textMeasure.measureText(__spreadProps(__spreadValues({}, TEXT_PROPS), {
      text,
      fontFamily: FONT_FAMILIES[shape.props.font],
      fontSize: LABEL_FONT_SIZES[shape.props.size],
      width: "fit-content",
      minWidth: minSize.w + "px",
      maxWidth: Math.max(
        // Guard because a DOM nodes can't be less 0
        0,
        // A 'w' width that we're setting as the min-width
        Math.ceil(minSize.w + sizes[shape.props.size]),
        // The actual text size
        Math.ceil(shape.props.w - LABEL_PADDING * 2)
      ) + "px"
    }));
    return {
      w: size.w + LABEL_PADDING * 2,
      h: size.h + LABEL_PADDING * 2
    };
  }
  function getLines(props, sw) {
    switch (props.geo) {
      case "x-box": {
        return getXBoxLines(props.w, props.h, sw, props.dash);
      }
      case "check-box": {
        return getCheckBoxLines(props.w, props.h);
      }
      default: {
        return void 0;
      }
    }
  }
  function getXBoxLines(w3, h3, sw, dash) {
    const inset = dash === "draw" ? 0.62 : 0;
    if (dash === "dashed") {
      return [
        [new Vec2d(0, 0), new Vec2d(w3 / 2, h3 / 2)],
        [new Vec2d(w3, h3), new Vec2d(w3 / 2, h3 / 2)],
        [new Vec2d(0, h3), new Vec2d(w3 / 2, h3 / 2)],
        [new Vec2d(w3, 0), new Vec2d(w3 / 2, h3 / 2)]
      ];
    }
    return [
      [new Vec2d(sw * inset, sw * inset), new Vec2d(w3 - sw * inset, h3 - sw * inset)],
      [new Vec2d(sw * inset, h3 - sw * inset), new Vec2d(w3 - sw * inset, sw * inset)]
    ];
  }
  function getCheckBoxLines(w3, h3) {
    const size = Math.min(w3, h3) * 0.82;
    const ox = (w3 - size) / 2;
    const oy = (h3 - size) / 2;
    return [
      [new Vec2d(ox + size * 0.25, oy + size * 0.52), new Vec2d(ox + size * 0.45, oy + size * 0.82)],
      [new Vec2d(ox + size * 0.45, oy + size * 0.82), new Vec2d(ox + size * 0.82, oy + size * 0.22)]
    ];
  }
  var TLGeoShapeDef = defineShape({
    type: "geo",
    getShapeUtil: () => TLGeoUtil,
    validator: geoShapeTypeValidator,
    migrations: geoShapeMigrations
  });

  // ../../../packages/editor/src/lib/app/shapeutils/shared/DashedOutlineBox.tsx
  var import_jsx_runtime47 = __toESM(require_jsx_runtime());
  function DashedOutlineBox({
    bounds,
    zoomLevel,
    className
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime47.jsx)("g", { className, pointerEvents: "none", strokeLinecap: "round", strokeLinejoin: "round", children: bounds.sides.map((side, i3) => {
      const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
        side[0].dist(side[1]),
        1 / zoomLevel,
        {
          style: "dashed",
          lengthRatio: 4
        }
      );
      return /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(
        "line",
        {
          x1: side[0].x,
          y1: side[0].y,
          x2: side[1].x,
          y2: side[1].y,
          strokeDasharray,
          strokeDashoffset
        },
        i3
      );
    }) });
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLGroupUtil/TLGroupUtil.tsx
  var import_jsx_runtime48 = __toESM(require_jsx_runtime());
  var TLGroupUtil = class extends TLShapeUtil {
    constructor() {
      super(...arguments);
      __publicField(this, "hideSelectionBoundsBg", () => false);
      __publicField(this, "hideSelectionBoundsFg", () => true);
      __publicField(this, "canBind", () => false);
      __publicField(this, "onChildrenChange", (group) => {
        const children = this.app.getSortedChildIds(group.id);
        if (children.length === 0) {
          if (this.app.pageState.focusLayerId === group.id) {
            this.app.popFocusLayer();
          }
          this.app.deleteShapes([group.id]);
          return;
        } else if (children.length === 1) {
          if (this.app.pageState.focusLayerId === group.id) {
            this.app.popFocusLayer();
          }
          this.app.reparentShapesById(children, group.parentId);
          this.app.deleteShapes([group.id]);
          return;
        }
      });
    }
    defaultProps() {
      return { opacity: "1" };
    }
    getBounds(shape) {
      const children = this.app.getSortedChildIds(shape.id);
      if (children.length === 0) {
        return new Box2d();
      }
      const allChildPoints = children.flatMap((childId) => {
        const shape2 = this.app.getShapeById(childId);
        return this.app.getOutlineById(childId).map((point2) => Matrix2d.applyToPoint(this.app.getTransform(shape2), point2));
      });
      return Box2d.FromPoints(allChildPoints);
    }
    getCenter(shape) {
      return this.bounds(shape).center;
    }
    getOutline(shape) {
      return this.bounds(shape).corners;
    }
    render(shape) {
      const {
        erasingIdsSet,
        pageState: { hintingIds, focusLayerId },
        zoomLevel
      } = this.app;
      const isErasing = erasingIdsSet.has(shape.id);
      const isHintingOtherGroup = hintingIds.length > 0 && hintingIds.some((id) => {
        var _a5;
        return id !== shape.id && ((_a5 = this.app.getShapeById(id)) == null ? void 0 : _a5.type) === "group";
      });
      if (
        // always show the outline while we're erasing the group
        !isErasing && // show the outline while the group is focused unless something outside of the group is being hinted
        // this happens dropping shapes from a group onto some outside group
        (shape.id !== focusLayerId || isHintingOtherGroup)
      ) {
        return null;
      }
      const bounds = this.bounds(shape);
      return /* @__PURE__ */ (0, import_jsx_runtime48.jsx)(SVGContainer, { id: shape.id, children: /* @__PURE__ */ (0, import_jsx_runtime48.jsx)(DashedOutlineBox, { className: "tl-group", bounds, zoomLevel }) });
    }
    indicator(shape) {
      const {
        camera: { z: zoomLevel }
      } = this.app;
      const bounds = this.bounds(shape);
      return /* @__PURE__ */ (0, import_jsx_runtime48.jsx)(DashedOutlineBox, { className: "", bounds, zoomLevel });
    }
  };
  __publicField(TLGroupUtil, "type", "group");
  var TLGroupShapeDef = defineShape({
    type: "group",
    getShapeUtil: () => TLGroupUtil,
    validator: groupShapeTypeValidator,
    migrations: groupShapeMigrations
  });

  // ../../../packages/editor/src/lib/app/shapeutils/TLImageUtil/TLImageUtil.tsx
  var import_react36 = __toESM(require_react());

  // ../../../packages/editor/src/lib/hooks/useIsCropping.ts
  function useIsCropping(shapeId) {
    const app = useApp();
    return useValue("isCropping", () => app.croppingId === shapeId, [app, shapeId]);
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLImageUtil/TLImageUtil.tsx
  var import_jsx_runtime49 = __toESM(require_jsx_runtime());
  var loadImage = (url) => __async(void 0, null, function* () {
    return new Promise((resolve, reject) => {
      const image = new Image();
      image.onload = () => resolve(image);
      image.onerror = () => reject(new Error("Failed to load image"));
      image.crossOrigin = "anonymous";
      image.src = url;
    });
  });
  var getStateFrame = (url) => __async(void 0, null, function* () {
    const image = yield loadImage(url);
    const canvas = document.createElement("canvas");
    canvas.width = image.width;
    canvas.height = image.height;
    const ctx = canvas.getContext("2d");
    if (!ctx)
      return;
    ctx.drawImage(image, 0, 0);
    return canvas.toDataURL();
  });
  function getDataURIFromURL(url) {
    return __async(this, null, function* () {
      const response = yield fetch(url);
      const blob = yield response.blob();
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    });
  }
  var TLImageUtil = class extends TLBoxUtil {
    constructor() {
      super(...arguments);
      __publicField(this, "isAspectRatioLocked", () => true);
      __publicField(this, "canCrop", () => true);
      __publicField(this, "onDoubleClick", (shape) => {
        const asset = shape.props.assetId ? this.app.getAssetById(shape.props.assetId) : void 0;
        if (!asset)
          return;
        const canPlay = asset.props.src && "mimeType" in asset.props && asset.props.mimeType === "image/gif";
        if (!canPlay)
          return;
        this.app.updateShapes([
          {
            type: "image",
            id: shape.id,
            props: {
              playing: !shape.props.playing
            }
          }
        ]);
      });
      __publicField(this, "onDoubleClickEdge", (shape) => {
        const props = shape.props;
        if (!props)
          return;
        if (this.app.croppingId !== shape.id) {
          return;
        }
        const crop = deepCopy(props.crop) || {
          topLeft: { x: 0, y: 0 },
          bottomRight: { x: 1, y: 1 }
        };
        const w3 = 1 / (crop.bottomRight.x - crop.topLeft.x) * shape.props.w;
        const h3 = 1 / (crop.bottomRight.y - crop.topLeft.y) * shape.props.h;
        const pointDelta = new Vec2d(crop.topLeft.x * w3, crop.topLeft.y * h3).rot(shape.rotation);
        const partial = {
          id: shape.id,
          type: shape.type,
          x: shape.x - pointDelta.x,
          y: shape.y - pointDelta.y,
          props: {
            crop: {
              topLeft: { x: 0, y: 0 },
              bottomRight: { x: 1, y: 1 }
            },
            w: w3,
            h: h3
          }
        };
        this.app.updateShapes([partial]);
      });
    }
    defaultProps() {
      return {
        opacity: "1",
        w: 100,
        h: 100,
        assetId: null,
        playing: true,
        url: "",
        crop: null
      };
    }
    render(shape) {
      var _a5, _b2;
      const containerStyle = getContainerStyle(shape);
      const isCropping = useIsCropping(shape.id);
      const prefersReducedMotion = usePrefersReducedMotion();
      const [staticFrameSrc, setStaticFrameSrc] = (0, import_react36.useState)("");
      const { Spinner: Spinner2 } = useEditorComponents();
      const { w: w3, h: h3 } = shape.props;
      const asset = shape.props.assetId ? this.app.getAssetById(shape.props.assetId) : void 0;
      if ((asset == null ? void 0 : asset.type) === "bookmark") {
        throw Error("Bookmark assets can't be rendered as images");
      }
      const isSelected = useValue(
        "onlySelectedShape",
        () => {
          var _a6;
          return shape.id === ((_a6 = this.app.onlySelectedShape) == null ? void 0 : _a6.id);
        },
        [this.app]
      );
      const showCropPreview = isSelected && isCropping && this.app.isInAny("select.crop", "select.cropping", "select.pointing_crop_handle");
      const reduceMotion = prefersReducedMotion && (((_a5 = asset == null ? void 0 : asset.props.mimeType) == null ? void 0 : _a5.includes("video")) || ((_b2 = asset == null ? void 0 : asset.props.mimeType) == null ? void 0 : _b2.includes("gif")));
      (0, import_react36.useEffect)(() => {
        if ((asset == null ? void 0 : asset.props.src) && "mimeType" in asset.props && (asset == null ? void 0 : asset.props.mimeType) === "image/gif") {
          let cancelled = false;
          const run = () => __async(this, null, function* () {
            const newStaticFrame = yield getStateFrame(asset.props.src);
            if (cancelled)
              return;
            if (newStaticFrame) {
              setStaticFrameSrc(newStaticFrame);
            }
          });
          run();
          return () => {
            cancelled = true;
          };
        }
      }, [prefersReducedMotion, asset == null ? void 0 : asset.props]);
      return /* @__PURE__ */ (0, import_jsx_runtime49.jsxs)(import_jsx_runtime49.Fragment, { children: [
        (asset == null ? void 0 : asset.props.src) && showCropPreview && /* @__PURE__ */ (0, import_jsx_runtime49.jsx)("div", { style: containerStyle, children: /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(
          "div",
          {
            className: `tl-image tl-image-${shape.id}-crop`,
            style: {
              opacity: 0.1,
              backgroundImage: `url(${!shape.props.playing || reduceMotion ? staticFrameSrc : asset.props.src})`
            },
            draggable: false
          }
        ) }),
        /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(HTMLContainer, { id: shape.id, style: { overflow: "hidden" }, children: /* @__PURE__ */ (0, import_jsx_runtime49.jsxs)("div", { className: "tl-image-container", style: containerStyle, children: [
          (asset == null ? void 0 : asset.props.src) ? /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(
            "div",
            {
              className: `tl-image tl-image-${shape.id}`,
              style: {
                backgroundImage: `url(${!shape.props.playing || reduceMotion ? staticFrameSrc : asset.props.src})`
              },
              draggable: false
            }
          ) : Spinner2 ? /* @__PURE__ */ (0, import_jsx_runtime49.jsx)("g", { transform: `translate(${(w3 - 38) / 2}, ${(h3 - 38) / 2})`, children: /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(Spinner2, {}) }) : null,
          (asset == null ? void 0 : asset.props.isAnimated) && !shape.props.playing && /* @__PURE__ */ (0, import_jsx_runtime49.jsx)("div", { className: "tl-image__tg", children: "GIF" })
        ] }) }),
        "url" in shape.props && shape.props.url && /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(HyperlinkButton, { url: shape.props.url, zoomLevel: this.app.zoomLevel })
      ] });
    }
    indicator(shape) {
      const isCropping = useIsCropping(shape.id);
      if (isCropping) {
        return null;
      }
      return /* @__PURE__ */ (0, import_jsx_runtime49.jsx)("rect", { width: toDomPrecision(shape.props.w), height: toDomPrecision(shape.props.h) });
    }
    toSvg(shape) {
      return __async(this, null, function* () {
        const g3 = document.createElementNS("http://www.w3.org/2000/svg", "g");
        const asset = shape.props.assetId ? this.app.getAssetById(shape.props.assetId) : null;
        let src = (asset == null ? void 0 : asset.props.src) || "";
        if (src && src.startsWith("http")) {
          src = (yield getDataURIFromURL(src)) || "";
        }
        const image = document.createElementNS("http://www.w3.org/2000/svg", "image");
        image.setAttributeNS("http://www.w3.org/1999/xlink", "href", src);
        const containerStyle = getContainerStyle(shape);
        const crop = shape.props.crop;
        if (containerStyle && crop) {
          const { transform, width, height } = containerStyle;
          const points2 = [
            new Vec2d(crop.topLeft.x * width, crop.topLeft.y * height),
            new Vec2d(crop.bottomRight.x * width, crop.topLeft.y * height),
            new Vec2d(crop.bottomRight.x * width, crop.bottomRight.y * height),
            new Vec2d(crop.topLeft.x * width, crop.bottomRight.y * height)
          ];
          const innerElement = document.createElementNS("http://www.w3.org/2000/svg", "g");
          innerElement.style.clipPath = `polygon(${points2.map((p3) => `${p3.x}px ${p3.y}px`).join(",")})`;
          image.setAttribute("width", width.toString());
          image.setAttribute("height", height.toString());
          image.style.transform = transform;
          innerElement.appendChild(image);
          g3.appendChild(innerElement);
        } else {
          image.setAttribute("width", shape.props.w.toString());
          image.setAttribute("height", shape.props.h.toString());
          g3.appendChild(image);
        }
        return g3;
      });
    }
  };
  __publicField(TLImageUtil, "type", "image");
  var TLImageShapeDef = defineShape({
    type: "image",
    getShapeUtil: () => TLImageUtil,
    validator: imageShapeTypeValidator,
    migrations: imageShapeMigrations
  });
  function getContainerStyle(shape) {
    const crop = shape.props.crop;
    const topLeft = crop == null ? void 0 : crop.topLeft;
    if (!topLeft)
      return;
    const w3 = 1 / (crop.bottomRight.x - crop.topLeft.x) * shape.props.w;
    const h3 = 1 / (crop.bottomRight.y - crop.topLeft.y) * shape.props.h;
    const offsetX = -topLeft.x * w3;
    const offsetY = -topLeft.y * h3;
    return {
      transform: `translate(${offsetX}px, ${offsetY}px)`,
      width: w3,
      height: h3
    };
  }

  // ../../../packages/editor/src/lib/utils/reordering/dgreensp/dgreensp.ts
  var DIGITS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  var INTEGER_ZERO = "a0";
  var SMALLEST_INTEGER = "A00000000000000000000000000";
  function getIntegerLength(head) {
    if (head >= "a" && head <= "z") {
      return head.charCodeAt(0) - "a".charCodeAt(0) + 2;
    } else if (head >= "A" && head <= "Z") {
      return "Z".charCodeAt(0) - head.charCodeAt(0) + 2;
    } else {
      throw new Error("Invalid index key head: " + head);
    }
  }
  function validateInteger(int) {
    if (int.length !== getIntegerLength(int.charAt(0))) {
      throw new Error("invalid integer part of index key: " + int);
    }
  }
  function isNotUndefined(n3) {
    if (n3 === void 0)
      throw Error("n is undefined");
  }
  function incrementInteger(x3) {
    validateInteger(x3);
    const [head, ...digs] = x3.split("");
    let carry = true;
    for (let i3 = digs.length - 1; carry && i3 >= 0; i3--) {
      const d3 = DIGITS.indexOf(digs[i3]) + 1;
      if (d3 === DIGITS.length) {
        digs[i3] = "0";
      } else {
        digs[i3] = DIGITS.charAt(d3);
        carry = false;
      }
    }
    if (carry) {
      if (head === "Z")
        return "a0";
      if (head === "z")
        return void 0;
      const h3 = String.fromCharCode(head.charCodeAt(0) + 1);
      if (h3 > "a") {
        digs.push("0");
      } else {
        digs.pop();
      }
      return h3 + digs.join("");
    } else {
      return head + digs.join("");
    }
  }
  function decrementInteger(x3) {
    validateInteger(x3);
    const [head, ...digs] = x3.split("");
    let borrow = true;
    for (let i3 = digs.length - 1; borrow && i3 >= 0; i3--) {
      const d3 = DIGITS.indexOf(digs[i3]) - 1;
      if (d3 === -1) {
        digs[i3] = DIGITS.slice(-1);
      } else {
        digs[i3] = DIGITS.charAt(d3);
        borrow = false;
      }
    }
    if (borrow) {
      if (head === "a")
        return "Z" + DIGITS.slice(-1);
      if (head === "A")
        return void 0;
      const h3 = String.fromCharCode(head.charCodeAt(0) - 1);
      if (h3 < "Z") {
        digs.push(DIGITS.slice(-1));
      } else {
        digs.pop();
      }
      return h3 + digs.join("");
    } else {
      return head + digs.join("");
    }
  }
  function midpoint(a3, b3) {
    if (b3 !== void 0 && a3 >= b3) {
      throw new Error(a3 + " >= " + b3);
    }
    if (a3.slice(-1) === "0" || b3 && b3.slice(-1) === "0") {
      throw new Error("trailing zero");
    }
    if (b3) {
      let n3 = 0;
      while ((a3.charAt(n3) || "0") === b3.charAt(n3)) {
        n3++;
      }
      if (n3 > 0) {
        return b3.slice(0, n3) + midpoint(a3.slice(n3), b3.slice(n3));
      }
    }
    const digitA = a3 ? DIGITS.indexOf(a3.charAt(0)) : 0;
    const digitB = b3 !== void 0 ? DIGITS.indexOf(b3.charAt(0)) : DIGITS.length;
    if (digitB - digitA > 1) {
      const midDigit = Math.round(0.5 * (digitA + digitB));
      return DIGITS.charAt(midDigit);
    } else {
      if (b3 && b3.length > 1) {
        return b3.slice(0, 1);
      } else {
        return DIGITS.charAt(digitA) + midpoint(a3.slice(1), void 0);
      }
    }
  }
  function getIntegerPart(index2) {
    const integerPartLength = getIntegerLength(index2.charAt(0));
    if (integerPartLength > index2.length) {
      throw new Error("invalid index: " + index2);
    }
    return index2.slice(0, integerPartLength);
  }
  function validateOrder(index2) {
    if (index2 === SMALLEST_INTEGER) {
      throw new Error("invalid index: " + index2);
    }
    const i3 = getIntegerPart(index2);
    const f3 = index2.slice(i3.length);
    if (f3.slice(-1) === "0") {
      throw new Error("invalid index: " + index2);
    }
  }
  function generateKeyBetween(a3, b3) {
    if (a3 !== void 0)
      validateOrder(a3);
    if (b3 !== void 0)
      validateOrder(b3);
    if (a3 !== void 0 && b3 !== void 0 && a3 >= b3) {
      throw new Error(a3 + " >= " + b3);
    }
    if (a3 === void 0 && b3 === void 0) {
      return INTEGER_ZERO;
    }
    if (a3 === void 0) {
      if (b3 === void 0)
        throw Error("b is undefined");
      const ib2 = getIntegerPart(b3);
      const fb2 = b3.slice(ib2.length);
      if (ib2 === SMALLEST_INTEGER) {
        return ib2 + midpoint("", fb2);
      }
      if (ib2 < b3) {
        return ib2;
      }
      const ibl = decrementInteger(ib2);
      isNotUndefined(ibl);
      return ibl;
    }
    if (b3 === void 0) {
      const ia2 = getIntegerPart(a3);
      const fa2 = a3.slice(ia2.length);
      const i4 = incrementInteger(ia2);
      return i4 === void 0 ? ia2 + midpoint(fa2, void 0) : i4;
    }
    const ia = getIntegerPart(a3);
    const fa = a3.slice(ia.length);
    const ib = getIntegerPart(b3);
    const fb = b3.slice(ib.length);
    if (ia === ib) {
      return ia + midpoint(fa, fb);
    }
    const i3 = incrementInteger(ia);
    isNotUndefined(i3);
    return i3 < b3 ? i3 : ia + midpoint(fa, void 0);
  }
  function generateNKeysBetween(a3, b3, n3) {
    if (n3 === 0)
      return [];
    if (n3 === 1)
      return [generateKeyBetween(a3, b3)];
    if (b3 === void 0) {
      let c4 = generateKeyBetween(a3, b3);
      const result = [c4];
      for (let i3 = 0; i3 < n3 - 1; i3++) {
        c4 = generateKeyBetween(c4, b3);
        result.push(c4);
      }
      return result;
    }
    if (a3 === void 0) {
      let c4 = generateKeyBetween(a3, b3);
      const result = [c4];
      for (let i3 = 0; i3 < n3 - 1; i3++) {
        c4 = generateKeyBetween(a3, c4);
        result.push(c4);
      }
      result.reverse();
      return result;
    }
    const mid = Math.floor(n3 / 2);
    const c3 = generateKeyBetween(a3, b3);
    return [...generateNKeysBetween(a3, c3, mid), c3, ...generateNKeysBetween(c3, b3, n3 - mid - 1)];
  }

  // ../../../packages/editor/src/lib/utils/reordering/reordering.ts
  function getIndicesBetween(below, above, n3) {
    return generateNKeysBetween(below, above, n3);
  }
  function getIndicesAbove(below, n3) {
    return generateNKeysBetween(below, void 0, n3);
  }
  function getIndexBetween(below, above) {
    return generateNKeysBetween(below, above, 1)[0];
  }
  function getIndexAbove(below) {
    return generateNKeysBetween(below, void 0, 1)[0];
  }
  function getIndexBelow(above) {
    return generateNKeysBetween(void 0, above, 1)[0];
  }
  function getIndices(n3) {
    return ["a1", ...generateNKeysBetween("a1", void 0, n3)];
  }
  function sortByIndex2(a3, b3) {
    if (a3.index < b3.index) {
      return -1;
    } else if (a3.index > b3.index) {
      return 1;
    }
    return 0;
  }
  function sortById(a3, b3) {
    if (a3.id < b3.id) {
      return -1;
    } else if (a3.id > b3.id) {
      return 1;
    }
    return 0;
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLLineUtil/components/getLinePath.ts
  function getLinePoints(spline) {
    const { segments } = spline;
    const allPoints = [];
    for (let j = 0, k2 = segments.length; j < k2; j++) {
      const segment = segments[j];
      const lut = segment.lut;
      const n3 = lut.length - 1;
      if (j > 0) {
        allPoints.push(Vec2d.Lrp(lut[0], lut[1], 0.25));
      } else {
        allPoints.push(lut[0]);
      }
      for (let i3 = 1; i3 < n3; i3++) {
        allPoints.push(lut[i3]);
      }
      if (j < k2 - 1) {
        allPoints.push(Vec2d.Lrp(lut[n3 - 1], lut[n3], 0.75));
      } else {
        allPoints.push(lut[n3]);
      }
    }
    return allPoints;
  }
  function getLineDrawFreehandOptions(strokeWidth) {
    return {
      size: strokeWidth,
      thinning: 0.4,
      streamline: 0,
      smoothing: 0.5,
      simulatePressure: true,
      last: true
    };
  }
  function getLineStrokePoints(shape, spline, strokeWidth) {
    const points2 = getLinePoints(spline);
    const options = getLineDrawFreehandOptions(strokeWidth);
    return getStrokePoints(points2, options);
  }
  function getLineDrawStrokeOutlinePoints(shape, spline, strokeWidth) {
    const options = getLineDrawFreehandOptions(strokeWidth);
    return getStrokeOutlinePoints(
      setStrokePointRadii(getLineStrokePoints(shape, spline, strokeWidth), options),
      options
    );
  }
  function getLineDrawPath(shape, spline, strokeWidth) {
    const stroke = getLineDrawStrokeOutlinePoints(shape, spline, strokeWidth);
    return getSvgPathFromStroke(stroke);
  }
  function getLineIndicatorPath(shape, spline, strokeWidth) {
    if (shape.props.dash === "draw") {
      const strokePoints = getLineStrokePoints(shape, spline, strokeWidth);
      return getSvgPathFromStrokePoints(strokePoints);
    }
    return spline.path;
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLLineUtil/components/getLineSvg.ts
  function getDrawLineShapeSvg({
    shape,
    strokeWidth,
    spline,
    color
  }) {
    const pfPath = getLineDrawPath(shape, spline, strokeWidth);
    const p3 = document.createElementNS("http://www.w3.org/2000/svg", "path");
    p3.setAttribute("stroke-width", "0");
    p3.setAttribute("stroke", "none");
    p3.setAttribute("fill", color);
    p3.setAttribute("d", pfPath);
    return p3;
  }
  function getDashedLineShapeSvg({
    dash,
    strokeWidth,
    spline,
    color
  }) {
    const { segments } = spline;
    const g3 = document.createElementNS("http://www.w3.org/2000/svg", "g");
    g3.setAttribute("stroke", color);
    g3.setAttribute("stroke-width", strokeWidth.toString());
    segments.forEach((segment, i3) => {
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(segment.length, strokeWidth, {
        style: dash,
        start: i3 > 0 ? "outset" : "none",
        end: i3 < segments.length - 1 ? "outset" : "none"
      });
      path.setAttribute("stroke-dasharray", strokeDasharray.toString());
      path.setAttribute("stroke-dashoffset", strokeDashoffset.toString());
      path.setAttribute("d", segment.path);
      path.setAttribute("fill", "none");
      g3.appendChild(path);
    });
    return g3;
  }
  function getSolidLineShapeSvg({
    strokeWidth,
    spline,
    color
  }) {
    const { path } = spline;
    const p3 = document.createElementNS("http://www.w3.org/2000/svg", "path");
    p3.setAttribute("stroke-width", strokeWidth.toString());
    p3.setAttribute("stroke", color);
    p3.setAttribute("fill", "none");
    p3.setAttribute("d", path);
    return p3;
  }
  function getLineSvg(shape, spline, color, strokeWidth) {
    switch (shape.props.dash) {
      case "draw":
        return getDrawLineShapeSvg({
          shape,
          strokeWidth,
          spline,
          color
        });
      case "solid":
        return getSolidLineShapeSvg({
          strokeWidth,
          spline,
          color
        });
      default:
        return getDashedLineShapeSvg({
          strokeWidth,
          spline,
          dash: shape.props.dash,
          color
        });
    }
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLLineUtil/TLLineUtil.tsx
  var import_jsx_runtime50 = __toESM(require_jsx_runtime());
  var splinesCache = new WeakMapCache();
  var handlesCache = new WeakMapCache();
  var TLLineUtil = class extends TLShapeUtil {
    constructor() {
      super(...arguments);
      __publicField(this, "hideResizeHandles", () => true);
      __publicField(this, "hideRotateHandle", () => true);
      __publicField(this, "hideSelectionBoundsBg", () => true);
      __publicField(this, "hideSelectionBoundsFg", () => true);
      __publicField(this, "isClosed", () => false);
      //   Events
      __publicField(this, "onResize", (shape, info) => {
        const { scaleX, scaleY } = info;
        const handles = deepCopy(shape.props.handles);
        Object.values(shape.props.handles).forEach(({ id, x: x3, y: y3 }) => {
          handles[id].x = x3 * scaleX;
          handles[id].y = y3 * scaleY;
        });
        return {
          props: {
            handles
          }
        };
      });
      __publicField(this, "onHandleChange", (shape, { handle }) => {
        const next = deepCopy(shape);
        switch (handle.id) {
          case "start":
          case "end": {
            next.props.handles[handle.id] = __spreadProps(__spreadValues({}, next.props.handles[handle.id]), {
              x: handle.x,
              y: handle.y
            });
            break;
          }
          default: {
            const id = "handle:" + handle.index;
            const existing = shape.props.handles[id];
            if (existing) {
              next.props.handles[id] = __spreadProps(__spreadValues({}, existing), {
                x: handle.x,
                y: handle.y
              });
            } else {
              next.props.handles[id] = {
                id,
                type: "vertex",
                canBind: false,
                index: handle.index,
                x: handle.x,
                y: handle.y
              };
            }
            break;
          }
        }
        return next;
      });
    }
    defaultProps() {
      return {
        opacity: "1",
        dash: "draw",
        size: "m",
        color: "black",
        spline: "line",
        handles: {
          start: {
            id: "start",
            type: "vertex",
            canBind: false,
            index: "a1",
            x: 0,
            y: 0
          },
          end: {
            id: "end",
            type: "vertex",
            canBind: false,
            index: "a2",
            x: 0,
            y: 0
          }
        }
      };
    }
    getBounds(shape) {
      const spline = getSplineForLineShape(shape);
      return spline.bounds;
    }
    getCenter(shape) {
      return this.bounds(shape).center;
    }
    getHandles(shape) {
      return handlesCache.get(shape.props, () => {
        const handles = shape.props.handles;
        const spline = getSplineForLineShape(shape);
        const sortedHandles = Object.values(handles).sort(sortByIndex2);
        const results = sortedHandles.slice();
        for (let i3 = 0; i3 < spline.segments.length; i3++) {
          const segment = spline.segments[i3];
          const point2 = segment.getPoint(0.5);
          const index2 = getIndexBetween(sortedHandles[i3].index, sortedHandles[i3 + 1].index);
          results.push({
            id: `mid-${i3}`,
            type: "create",
            index: index2,
            x: point2.x,
            y: point2.y
          });
        }
        return results.sort(sortByIndex2);
      });
    }
    getOutline(shape) {
      return getLinePoints(getSplineForLineShape(shape));
    }
    hitTestPoint(shape, point2) {
      const zoomLevel = this.app.zoomLevel;
      const offsetDist = this.app.getStrokeWidth(shape.props.size) / zoomLevel;
      return pointNearToPolyline(point2, this.outline(shape), offsetDist);
    }
    hitTestLineSegment(shape, A2, B) {
      return intersectLineSegmentPolyline(A2, B, this.outline(shape)) !== null;
    }
    render(shape) {
      const forceSolid = useForceSolid();
      const spline = getSplineForLineShape(shape);
      const strokeWidth = this.app.getStrokeWidth(shape.props.size);
      const { dash, color } = shape.props;
      if (shape.props.spline === "line") {
        if (dash === "solid") {
          const outline = spline.points;
          const pathData = "M" + outline[0] + "L" + outline.slice(1);
          return /* @__PURE__ */ (0, import_jsx_runtime50.jsxs)(SVGContainer, { id: shape.id, children: [
            /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(ShapeFill, { d: pathData, fill: "none", color }),
            /* @__PURE__ */ (0, import_jsx_runtime50.jsx)("path", { d: pathData, stroke: "currentColor", strokeWidth, fill: "none" })
          ] });
        }
        if (dash === "dashed" || dash === "dotted") {
          const outline = spline.points;
          const pathData = "M" + outline[0] + "L" + outline.slice(1);
          return /* @__PURE__ */ (0, import_jsx_runtime50.jsxs)(SVGContainer, { id: shape.id, children: [
            /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(ShapeFill, { d: pathData, fill: "none", color }),
            /* @__PURE__ */ (0, import_jsx_runtime50.jsx)("g", { stroke: "currentColor", strokeWidth, children: spline.segments.map((segment, i3) => {
              const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
                segment.length,
                strokeWidth,
                {
                  style: dash,
                  start: i3 > 0 ? "outset" : "none",
                  end: i3 < spline.segments.length - 1 ? "outset" : "none"
                }
              );
              return /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(
                "path",
                {
                  strokeDasharray,
                  strokeDashoffset,
                  d: segment.path,
                  fill: "none"
                },
                i3
              );
            }) })
          ] });
        }
        if (dash === "draw") {
          const outline = spline.points;
          const [innerPathData, outerPathData] = getDrawLinePathData(shape.id, outline, strokeWidth);
          return /* @__PURE__ */ (0, import_jsx_runtime50.jsxs)(SVGContainer, { id: shape.id, children: [
            /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(ShapeFill, { d: innerPathData, fill: "none", color }),
            /* @__PURE__ */ (0, import_jsx_runtime50.jsx)("path", { d: outerPathData, stroke: "currentColor", strokeWidth, fill: "none" })
          ] });
        }
      }
      if (shape.props.spline === "cubic") {
        const splinePath = spline.path;
        if (dash === "solid" || dash === "draw" && forceSolid) {
          return /* @__PURE__ */ (0, import_jsx_runtime50.jsxs)(SVGContainer, { id: shape.id, children: [
            /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(ShapeFill, { d: splinePath, fill: "none", color }),
            /* @__PURE__ */ (0, import_jsx_runtime50.jsx)("path", { strokeWidth, stroke: "currentColor", fill: "none", d: splinePath })
          ] });
        }
        if (dash === "dashed" || dash === "dotted") {
          return /* @__PURE__ */ (0, import_jsx_runtime50.jsxs)(SVGContainer, { id: shape.id, children: [
            /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(ShapeFill, { d: splinePath, fill: "none", color }),
            /* @__PURE__ */ (0, import_jsx_runtime50.jsx)("g", { stroke: "currentColor", strokeWidth, children: spline.segments.map((segment, i3) => {
              const { strokeDasharray, strokeDashoffset } = getPerfectDashProps(
                segment.length,
                strokeWidth,
                {
                  style: dash,
                  start: i3 > 0 ? "outset" : "none",
                  end: i3 < spline.segments.length - 1 ? "outset" : "none"
                }
              );
              return /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(
                "path",
                {
                  strokeDasharray,
                  strokeDashoffset,
                  d: segment.path,
                  fill: "none"
                },
                i3
              );
            }) })
          ] });
        }
        if (dash === "draw") {
          return /* @__PURE__ */ (0, import_jsx_runtime50.jsxs)(SVGContainer, { id: shape.id, children: [
            /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(ShapeFill, { d: splinePath, fill: "none", color }),
            /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(
              "path",
              {
                d: getLineDrawPath(shape, spline, strokeWidth),
                strokeWidth: 1,
                stroke: "currentColor",
                fill: "currentColor"
              }
            )
          ] });
        }
      }
    }
    indicator(shape) {
      const strokeWidth = this.app.getStrokeWidth(shape.props.size);
      const spline = getSplineForLineShape(shape);
      const { dash } = shape.props;
      let path;
      if (shape.props.spline === "line") {
        const outline = spline.points;
        if (dash === "solid" || dash === "dotted" || dash === "dashed") {
          path = "M" + outline[0] + "L" + outline.slice(1);
        } else {
          const [innerPathData] = getDrawLinePathData(shape.id, outline, strokeWidth);
          path = innerPathData;
        }
      } else {
        path = getLineIndicatorPath(shape, spline, strokeWidth);
      }
      return /* @__PURE__ */ (0, import_jsx_runtime50.jsx)("path", { d: path });
    }
    toSvg(shape, _font, colors) {
      const { color: _color, size } = shape.props;
      const color = colors.fill[_color];
      const spline = getSplineForLineShape(shape);
      return getLineSvg(shape, spline, color, this.app.getStrokeWidth(size));
    }
  };
  __publicField(TLLineUtil, "type", "line");
  var TLLineShapeDef = defineShape({
    type: "line",
    getShapeUtil: () => TLLineUtil,
    validator: lineShapeTypeValidator,
    migrations: lineShapeMigrations
  });
  function getSplineForLineShape(shape) {
    return splinesCache.get(shape.props, () => {
      const { spline, handles } = shape.props;
      const handlePoints = Object.values(handles).sort(sortByIndex2).map(Vec2d.From);
      switch (spline) {
        case "cubic": {
          return new CubicSpline2d(handlePoints, handlePoints.length === 2 ? 2 : 1.2, 20);
        }
        case "line": {
          return new Polyline2d(handlePoints);
        }
      }
    });
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLNoteUtil/TLNoteUtil.tsx
  var import_jsx_runtime51 = __toESM(require_jsx_runtime());
  var NOTE_SIZE = 200;
  var TLNoteUtil = class extends TLShapeUtil {
    constructor() {
      super(...arguments);
      __publicField(this, "canEdit", () => true);
      __publicField(this, "hideResizeHandles", () => true);
      __publicField(this, "hideSelectionBoundsBg", () => true);
      __publicField(this, "hideSelectionBoundsFg", () => true);
      __publicField(this, "onBeforeCreate", (next) => {
        return getGrowY(this.app, next, next.props.growY);
      });
      __publicField(this, "onBeforeUpdate", (prev, next) => {
        if (prev.props.text === next.props.text && prev.props.font === next.props.font && prev.props.size === next.props.size) {
          return;
        }
        return getGrowY(this.app, next, prev.props.growY);
      });
      __publicField(this, "onEditEnd", (shape) => {
        const {
          id,
          type,
          props: { text }
        } = shape;
        if (text.trimEnd() !== shape.props.text) {
          this.app.updateShapes([
            {
              id,
              type,
              props: {
                text: text.trimEnd()
              }
            }
          ]);
        }
      });
    }
    defaultProps() {
      return {
        opacity: "1",
        color: "black",
        size: "m",
        text: "",
        font: "draw",
        align: "middle",
        growY: 0,
        url: ""
      };
    }
    getHeight(shape) {
      return NOTE_SIZE + shape.props.growY;
    }
    getBounds(shape) {
      const height = this.getHeight(shape);
      return new Box2d(0, 0, NOTE_SIZE, height);
    }
    getOutline(shape) {
      return this.bounds(shape).corners;
    }
    getCenter(_shape) {
      return new Vec2d(NOTE_SIZE / 2, this.getHeight(_shape) / 2);
    }
    render(shape) {
      const {
        id,
        type,
        props: { color, font, size, align, text }
      } = shape;
      const adjustedColor = color === "black" ? "yellow" : color;
      return /* @__PURE__ */ (0, import_jsx_runtime51.jsxs)(import_jsx_runtime51.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(
          "div",
          {
            style: {
              position: "absolute",
              width: NOTE_SIZE,
              height: this.getHeight(shape)
            },
            children: /* @__PURE__ */ (0, import_jsx_runtime51.jsxs)(
              "div",
              {
                className: "tl-note__container tl-hitarea-fill",
                style: {
                  color: `var(--palette-${adjustedColor})`,
                  backgroundColor: `var(--palette-${adjustedColor})`
                },
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime51.jsx)("div", { className: "tl-note__scrim" }),
                  /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(
                    TextLabel,
                    {
                      id,
                      type,
                      font,
                      size,
                      align,
                      text,
                      labelColor: "inherit",
                      wrap: true
                    }
                  )
                ]
              }
            )
          }
        ),
        "url" in shape.props && shape.props.url && /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(HyperlinkButton, { url: shape.props.url, zoomLevel: this.app.zoomLevel })
      ] });
    }
    indicator(shape) {
      return /* @__PURE__ */ (0, import_jsx_runtime51.jsx)(
        "rect",
        {
          rx: "7",
          width: toDomPrecision(NOTE_SIZE),
          height: toDomPrecision(this.getHeight(shape))
        }
      );
    }
    toSvg(shape, font, colors) {
      const bounds = this.bounds(shape);
      const g3 = document.createElementNS("http://www.w3.org/2000/svg", "g");
      const adjustedColor = shape.props.color === "black" ? "yellow" : shape.props.color;
      const rect1 = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      rect1.setAttribute("rx", "10");
      rect1.setAttribute("width", NOTE_SIZE.toString());
      rect1.setAttribute("height", bounds.height.toString());
      rect1.setAttribute("fill", colors.fill[adjustedColor]);
      rect1.setAttribute("stroke", colors.fill[adjustedColor]);
      rect1.setAttribute("stroke-width", "1");
      g3.appendChild(rect1);
      const rect2 = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      rect2.setAttribute("rx", "10");
      rect2.setAttribute("width", NOTE_SIZE.toString());
      rect2.setAttribute("height", bounds.height.toString());
      rect2.setAttribute("fill", colors.background);
      rect2.setAttribute("opacity", ".28");
      g3.appendChild(rect2);
      const PADDING = 17;
      const opts = {
        fontSize: LABEL_FONT_SIZES[shape.props.size],
        fontFamily: font,
        textAlign: shape.props.align,
        width: bounds.width - PADDING * 2,
        height: bounds.height - PADDING * 2,
        padding: 0,
        lineHeight: TEXT_PROPS.lineHeight,
        fontStyle: "normal",
        fontWeight: "normal"
      };
      const lines = this.app.textMeasure.getTextLines(__spreadValues({
        text: shape.props.text,
        wrap: true
      }, opts));
      const maxWidth = lines.reduce((max, line) => {
        return Math.max(
          max,
          this.app.textMeasure.measureText(__spreadProps(__spreadValues({}, TEXT_PROPS), {
            text: line.trim(),
            fontFamily: opts.fontFamily,
            fontSize: opts.fontSize,
            width: "fit-content",
            padding: `0px`
          })).w
        );
      }, 0);
      if (shape.props.align === "start") {
        opts.padding = (bounds.width - maxWidth) / 2;
      } else if (shape.props.align === "end") {
        opts.padding = -(bounds.width - maxWidth) / 2;
      } else {
        opts.padding = PADDING;
      }
      opts.width = bounds.width;
      const textElm = getTextSvgElement(this.app, __spreadValues({
        lines
      }, opts));
      textElm.setAttribute("fill", colors.text);
      textElm.setAttribute("transform", `translate(0 ${PADDING})`);
      g3.appendChild(textElm);
      return g3;
    }
  };
  __publicField(TLNoteUtil, "type", "note");
  var TLNoteShapeDef = defineShape({
    getShapeUtil: () => TLNoteUtil,
    type: "note",
    validator: noteShapeTypeValidator,
    migrations: noteShapeMigrations
  });
  function getGrowY(app, shape, prevGrowY = 0) {
    const PADDING = 17;
    const nextTextSize = app.textMeasure.measureText(__spreadProps(__spreadValues({}, TEXT_PROPS), {
      text: shape.props.text,
      fontFamily: FONT_FAMILIES[shape.props.font],
      fontSize: LABEL_FONT_SIZES[shape.props.size],
      width: NOTE_SIZE - PADDING * 2 + "px"
    }));
    const nextHeight = nextTextSize.h + PADDING * 2;
    let growY = null;
    if (nextHeight > NOTE_SIZE) {
      growY = nextHeight - NOTE_SIZE;
    } else {
      if (prevGrowY) {
        growY = 0;
      }
    }
    if (growY !== null) {
      return __spreadProps(__spreadValues({}, shape), {
        props: __spreadProps(__spreadValues({}, shape.props), {
          growY
        })
      });
    }
  }

  // ../../../packages/editor/src/lib/app/shapeutils/shared/resizeScaled.ts
  function resizeScaled(shape, {
    initialBounds,
    scaleX,
    scaleY,
    newPoint
  }) {
    const scaleDelta = Math.max(0.01, Math.min(Math.abs(scaleX), Math.abs(scaleY)));
    const offset = new Vec2d(0, 0);
    if (scaleX < 0) {
      offset.x = -(initialBounds.width * scaleDelta);
    }
    if (scaleY < 0) {
      offset.y = -(initialBounds.height * scaleDelta);
    }
    const { x: x3, y: y3 } = Vec2d.Add(newPoint, offset.rot(shape.rotation));
    return {
      x: x3,
      y: y3,
      props: {
        scale: scaleDelta * shape.props.scale
      }
    };
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLTextUtil/TLTextUtil.tsx
  var import_jsx_runtime52 = __toESM(require_jsx_runtime());
  var sizeCache = new WeakMapCache();
  var TLTextUtil = class extends TLShapeUtil {
    constructor() {
      super(...arguments);
      __publicField(this, "canEdit", () => true);
      __publicField(this, "isAspectRatioLocked", () => true);
      __publicField(this, "onResize", (shape, info) => {
        const { initialBounds, initialShape, scaleX, handle } = info;
        if (info.mode === "scale_shape" || handle !== "right" && handle !== "left") {
          return resizeScaled(shape, info);
        } else {
          const prevWidth = initialBounds.width;
          let nextWidth = prevWidth * scaleX;
          const offset = new Vec2d(0, 0);
          nextWidth = Math.max(1, Math.abs(nextWidth));
          if (handle === "left") {
            offset.x = prevWidth - nextWidth;
            if (scaleX < 0) {
              offset.x += nextWidth;
            }
          } else {
            if (scaleX < 0) {
              offset.x -= nextWidth;
            }
          }
          const { x: x3, y: y3 } = offset.rot(shape.rotation).add(initialShape);
          return {
            x: x3,
            y: y3,
            props: {
              w: nextWidth / initialShape.props.scale,
              autoSize: false
            }
          };
        }
      });
      __publicField(this, "onBeforeCreate", (shape) => {
        if (!shape.props.autoSize)
          return;
        if (shape.props.text.trim())
          return;
        const bounds = this.getMinDimensions(shape);
        return __spreadProps(__spreadValues({}, shape), {
          x: shape.x - bounds.width / 2,
          y: shape.y - bounds.height / 2
        });
      });
      __publicField(this, "onEditEnd", (shape) => {
        const {
          id,
          type,
          props: { text }
        } = shape;
        const trimmedText = shape.props.text.trimEnd();
        if (trimmedText.length === 0) {
          this.app.deleteShapes([shape.id]);
        } else {
          if (trimmedText !== shape.props.text) {
            this.app.updateShapes([
              {
                id,
                type,
                props: {
                  text: text.trimEnd()
                }
              }
            ]);
          }
        }
      });
      __publicField(this, "onBeforeUpdate", (prev, next) => {
        if (!next.props.autoSize)
          return;
        const styleDidChange = prev.props.size !== next.props.size || prev.props.align !== next.props.align || prev.props.font !== next.props.font || prev.props.scale !== 1 && next.props.scale === 1;
        const textDidChange = prev.props.text !== next.props.text;
        if (!styleDidChange && !textDidChange)
          return;
        const boundsA = this.getMinDimensions(prev);
        const boundsB = getTextSize(this.app, next.props);
        const wA = boundsA.width * prev.props.scale;
        const hA = boundsA.height * prev.props.scale;
        const wB = boundsB.width * next.props.scale;
        const hB = boundsB.height * next.props.scale;
        let delta;
        switch (next.props.align) {
          case "middle": {
            delta = new Vec2d((wB - wA) / 2, textDidChange ? 0 : (hB - hA) / 2);
            break;
          }
          case "end": {
            delta = new Vec2d(wB - wA, textDidChange ? 0 : (hB - hA) / 2);
            break;
          }
          default: {
            if (textDidChange)
              break;
            delta = new Vec2d(0, (hB - hA) / 2);
            break;
          }
        }
        if (delta) {
          delta.rot(next.rotation);
          const { x: x3, y: y3 } = next;
          return __spreadProps(__spreadValues({}, next), {
            x: x3 - delta.x,
            y: y3 - delta.y,
            props: __spreadProps(__spreadValues({}, next.props), { w: wB })
          });
        } else {
          return __spreadProps(__spreadValues({}, next), {
            props: __spreadProps(__spreadValues({}, next.props), { w: wB })
          });
        }
      });
      __publicField(this, "onDoubleClickEdge", (shape) => {
        if (!shape.props.autoSize) {
          return {
            id: shape.id,
            type: shape.type,
            props: {
              autoSize: true
            }
          };
        }
        if (shape.props.scale !== 1) {
          return {
            id: shape.id,
            type: shape.type,
            props: {
              scale: 1
            }
          };
        }
      });
    }
    defaultProps() {
      return {
        opacity: "1",
        color: "black",
        size: "m",
        w: 8,
        text: "",
        font: "draw",
        align: "middle",
        autoSize: true,
        scale: 1
      };
    }
    // @computed
    // private get minDimensionsCache() {
    // 	return this.app.store.createSelectedComputedCache<
    // 		TLTextShape['props'],
    // 		{ width: number; height: number },
    // 		TLTextShape
    // 	>(
    // 		'text measure cache',
    // 		(shape) => {
    // 			return shape.props
    // 		},
    // 		(props) => getTextSize(this.app, props)
    // 	)
    // }
    getMinDimensions(shape) {
      return sizeCache.get(shape.props, (props) => getTextSize(this.app, props));
    }
    getBounds(shape) {
      const { scale } = shape.props;
      const { width, height } = this.getMinDimensions(shape);
      return new Box2d(0, 0, width * scale, height * scale);
    }
    getOutline(shape) {
      const bounds = this.bounds(shape);
      return [
        new Vec2d(0, 0),
        new Vec2d(bounds.width, 0),
        new Vec2d(bounds.width, bounds.height),
        new Vec2d(0, bounds.height)
      ];
    }
    getCenter(shape) {
      const bounds = this.bounds(shape);
      return new Vec2d(bounds.width / 2, bounds.height / 2);
    }
    render(shape) {
      const {
        id,
        type,
        props: { text }
      } = shape;
      const { width, height } = this.getMinDimensions(shape);
      const {
        rInput,
        isEmpty,
        isEditing,
        isEditableFromHover,
        handleFocus,
        handleChange,
        handleKeyDown,
        handleBlur
      } = useEditableText(id, type, text);
      return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(HTMLContainer, { id: shape.id, children: /* @__PURE__ */ (0, import_jsx_runtime52.jsxs)(
        "div",
        {
          className: "tl-text-shape__wrapper tl-text-shadow",
          "data-font": shape.props.font,
          "data-align": shape.props.align,
          "data-hastext": !isEmpty,
          "data-isediting": isEditing || isEditableFromHover,
          "data-textwrap": true,
          style: {
            fontSize: FONT_SIZES[shape.props.size],
            lineHeight: FONT_SIZES[shape.props.size] * TEXT_PROPS.lineHeight + "px",
            transform: `scale(${shape.props.scale})`,
            transformOrigin: "top left",
            width: Math.max(1, width),
            height: Math.max(FONT_SIZES[shape.props.size] * TEXT_PROPS.lineHeight, height)
          },
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime52.jsx)("div", { className: "tl-text tl-text-content", dir: "ltr", children: text }),
            isEditing || isEditableFromHover ? /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(
              "textarea",
              {
                ref: rInput,
                className: "tl-text tl-text-input",
                name: "text",
                tabIndex: -1,
                autoComplete: "false",
                autoCapitalize: "false",
                autoCorrect: "false",
                autoSave: "false",
                autoFocus: isEditing,
                placeholder: "",
                spellCheck: "true",
                wrap: "off",
                dir: "ltr",
                datatype: "wysiwyg",
                defaultValue: text,
                onFocus: handleFocus,
                onChange: handleChange,
                onKeyDown: handleKeyDown,
                onBlur: handleBlur,
                onTouchEnd: stopEventPropagation,
                onContextMenu: stopEventPropagation
              }
            ) : null
          ]
        }
      ) });
    }
    indicator(shape) {
      const bounds = this.bounds(shape);
      return /* @__PURE__ */ (0, import_jsx_runtime52.jsx)("rect", { width: toDomPrecision(bounds.width), height: toDomPrecision(bounds.height) });
    }
    toSvg(shape, font, colors) {
      var _a5, _b2;
      const bounds = this.bounds(shape);
      const text = shape.props.text;
      const width = bounds.width / ((_a5 = shape.props.scale) != null ? _a5 : 1);
      const height = bounds.height / ((_b2 = shape.props.scale) != null ? _b2 : 1);
      const opts = {
        fontSize: FONT_SIZES[shape.props.size],
        fontFamily: font,
        textAlign: shape.props.align,
        width,
        height,
        padding: 0,
        // no padding?
        lineHeight: TEXT_PROPS.lineHeight,
        fontStyle: "normal",
        fontWeight: "normal"
      };
      const lines = this.app.textMeasure.getTextLines(__spreadValues({
        text,
        wrap: true
      }, opts));
      const color = colors.fill[shape.props.color];
      const groupEl = document.createElementNS("http://www.w3.org/2000/svg", "g");
      const textBgEl = getTextSvgElement(this.app, __spreadProps(__spreadValues({
        lines
      }, opts), {
        stroke: colors.background,
        strokeWidth: 2,
        fill: colors.background,
        padding: 0
      }));
      const textElm = textBgEl.cloneNode(true);
      textElm.setAttribute("fill", color);
      textElm.setAttribute("stroke", "none");
      groupEl.append(textBgEl);
      groupEl.append(textElm);
      return groupEl;
    }
  };
  __publicField(TLTextUtil, "type", "text");
  var TLTextShapeDef = defineShape({
    type: "text",
    getShapeUtil: () => TLTextUtil,
    validator: textShapeTypeValidator,
    migrations: textShapeMigrations
  });
  function getTextSize(app, props) {
    const { font, text, autoSize, size, w: w3 } = props;
    const minWidth = 16;
    const fontSize = FONT_SIZES[size];
    const cw = autoSize ? "fit-content" : (
      // `measureText` floors the number so we need to do the same here to avoid issues.
      Math.floor(Math.max(minWidth, w3)) + "px"
    );
    const result = app.textMeasure.measureText(__spreadProps(__spreadValues({}, TEXT_PROPS), {
      text,
      fontFamily: FONT_FAMILIES[font],
      fontSize,
      width: cw
    }));
    if (autoSize) {
      result.w += 1;
    }
    return {
      width: Math.max(minWidth, result.w),
      height: Math.max(fontSize, result.h)
    };
  }

  // ../../../packages/editor/src/lib/app/shapeutils/TLVideoUtil/TLVideoUtil.tsx
  var React30 = __toESM(require_react());
  var import_jsx_runtime53 = __toESM(require_jsx_runtime());
  var TLVideoUtil = class extends TLBoxUtil {
    constructor() {
      super(...arguments);
      __publicField(this, "canEdit", () => true);
      __publicField(this, "isAspectRatioLocked", () => true);
    }
    defaultProps() {
      return {
        opacity: "1",
        w: 100,
        h: 100,
        assetId: null,
        time: 0,
        playing: true,
        url: ""
      };
    }
    render(shape) {
      return /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(TLVideoUtilComponent, { shape, videoUtil: this });
    }
    indicator(shape) {
      return /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("rect", { width: toDomPrecision(shape.props.w), height: toDomPrecision(shape.props.h) });
    }
    toSvg(shape) {
      const g3 = document.createElementNS("http://www.w3.org/2000/svg", "g");
      const image = document.createElementNS("http://www.w3.org/2000/svg", "image");
      image.setAttributeNS("http://www.w3.org/1999/xlink", "href", serializeVideo(shape.id));
      image.setAttribute("width", shape.props.w.toString());
      image.setAttribute("height", shape.props.h.toString());
      g3.appendChild(image);
      return g3;
    }
  };
  __publicField(TLVideoUtil, "type", "video");
  var TLVideoShapeDef = defineShape({
    type: "video",
    getShapeUtil: () => TLVideoUtil,
    validator: videoShapeTypeValidator,
    migrations: videoShapeMigrations
  });
  function serializeVideo(id) {
    const splitId = id.split(":")[1];
    const video = document.querySelector(`.tl-video-shape-${splitId}`);
    if (video) {
      const canvas = document.createElement("canvas");
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      canvas.getContext("2d").drawImage(video, 0, 0);
      return canvas.toDataURL("image/png");
    } else
      throw new Error("Video with id " + splitId + " not found");
  }
  var TLVideoUtilComponent = track(function TLVideoUtilComponent2(props) {
    const { Spinner: Spinner2 } = useEditorComponents();
    const { shape, videoUtil } = props;
    const showControls = videoUtil.app.getBounds(shape).w * videoUtil.app.zoomLevel >= 110;
    const asset = shape.props.assetId ? videoUtil.app.getAssetById(shape.props.assetId) : null;
    const { w: w3, h: h3, time, playing } = shape.props;
    const isEditing = useIsEditing(shape.id);
    const prefersReducedMotion = usePrefersReducedMotion();
    const rVideo = React30.useRef(null);
    const handlePlay = React30.useCallback(
      (e2) => {
        const video = e2.currentTarget;
        videoUtil.app.updateShapes([
          {
            type: "video",
            id: shape.id,
            props: {
              playing: true,
              time: video.currentTime
            }
          }
        ]);
      },
      [shape.id, videoUtil.app]
    );
    const handlePause = React30.useCallback(
      (e2) => {
        const video = e2.currentTarget;
        videoUtil.app.updateShapes([
          {
            type: "video",
            id: shape.id,
            props: {
              playing: false,
              time: video.currentTime
            }
          }
        ]);
      },
      [shape.id, videoUtil.app]
    );
    const handleSetCurrentTime = React30.useCallback(
      (e2) => {
        const video = e2.currentTarget;
        if (isEditing) {
          videoUtil.app.updateShapes([
            {
              type: "video",
              id: shape.id,
              props: {
                time: video.currentTime
              }
            }
          ]);
        }
      },
      [isEditing, shape.id, videoUtil.app]
    );
    const [isLoaded, setIsLoaded] = React30.useState(false);
    const handleLoadedData = React30.useCallback(
      (e2) => {
        const video = e2.currentTarget;
        if (time !== video.currentTime) {
          video.currentTime = time;
        }
        if (!playing) {
          video.pause();
        }
        setIsLoaded(true);
      },
      [playing, time]
    );
    React30.useEffect(() => {
      const video = rVideo.current;
      if (!video)
        return;
      if (isLoaded && !isEditing && time !== video.currentTime) {
        video.currentTime = time;
      }
    }, [isEditing, isLoaded, time]);
    React30.useEffect(() => {
      if (prefersReducedMotion) {
        const video = rVideo.current;
        video.pause();
        video.currentTime = 0;
      }
    }, [rVideo, prefersReducedMotion]);
    return /* @__PURE__ */ (0, import_jsx_runtime53.jsxs)(import_jsx_runtime53.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(HTMLContainer, { id: shape.id, children: /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("div", { className: "tl-counter-scaled", children: (asset == null ? void 0 : asset.props.src) ? /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(
        "video",
        {
          ref: rVideo,
          className: `tl-video tl-video-shape-${shape.id.split(":")[1]} tl-hitarea-stroke`,
          width: "100%",
          height: "100%",
          draggable: false,
          playsInline: true,
          autoPlay: true,
          muted: true,
          loop: true,
          disableRemotePlayback: true,
          disablePictureInPicture: true,
          controls: isEditing && showControls,
          onPlay: handlePlay,
          onPause: handlePause,
          onTimeUpdate: handleSetCurrentTime,
          onLoadedData: handleLoadedData,
          hidden: !isLoaded,
          children: /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("source", { src: asset.props.src })
        }
      ) : Spinner2 ? /* @__PURE__ */ (0, import_jsx_runtime53.jsx)("g", { transform: `translate(${(w3 - 38) / 2}, ${(h3 - 38) / 2})`, children: /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(Spinner2, {}) }) : null }) }),
      "url" in shape.props && shape.props.url && /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(HyperlinkButton, { url: shape.props.url, zoomLevel: videoUtil.app.zoomLevel })
    ] });
  });

  // ../../../packages/editor/src/lib/config/TldrawEditorConfig.tsx
  var _TldrawEditorConfig = class {
    constructor(args) {
      __publicField(this, "storeSchema");
      __publicField(this, "shapes");
      __publicField(this, "TLShape");
      __publicField(this, "tools");
      const { shapes = [], tools = [], allowUnknownShapes = false, derivePresenceState } = args;
      this.tools = tools;
      this.shapes = [
        TLArrowShapeDef,
        TLBookmarkShapeDef,
        TLDrawShapeDef,
        TLEmbedShapeDef,
        TLFrameShapeDef,
        TLGeoShapeDef,
        TLGroupShapeDef,
        TLImageShapeDef,
        TLLineShapeDef,
        TLNoteShapeDef,
        TLTextShapeDef,
        TLVideoShapeDef,
        ...shapes
      ];
      this.storeSchema = createTLSchema({
        allowUnknownShapes,
        customShapeDefs: shapes,
        derivePresenceState
      });
      this.TLShape = this.storeSchema.types.shape;
    }
    createStore(config) {
      var _a5, _b2;
      let initialData = config.initialData;
      if (initialData) {
        initialData = CLIENT_FIXUP_SCRIPT(initialData);
      }
      return new Store({
        schema: this.storeSchema,
        initialData,
        props: {
          userId: (_a5 = config == null ? void 0 : config.userId) != null ? _a5 : TLUser.createId(),
          instanceId: (_b2 = config == null ? void 0 : config.instanceId) != null ? _b2 : TLInstance.createId(),
          documentId: TLDOCUMENT_ID
        }
      });
    }
  };
  var TldrawEditorConfig = _TldrawEditorConfig;
  __publicField(TldrawEditorConfig, "default", new _TldrawEditorConfig({}));

  // ../../../packages/editor/src/lib/utils/data.ts
  function uniqueId() {
    return nanoid();
  }
  function fileToBase64(file) {
    return new Promise((resolve, reject) => {
      if (file) {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result);
        reader.onerror = (error) => reject(error);
        reader.onabort = (error) => reject(error);
      }
    });
  }
  function getIncrementedName(name, others) {
    var _a5;
    let result = name;
    const set = new Set(others);
    while (set.has(result)) {
      result = ((_a5 = /^.*(\d+)$/.exec(result)) == null ? void 0 : _a5[1]) ? result.replace(/(\d+)(?=\D?)$/, (m3) => {
        return (+m3 + 1).toString();
      }) : `${result} 1`;
    }
    return result;
  }

  // ../../../packages/editor/src/lib/utils/props-for-next-shape.ts
  function setPropsForNextShape(previousProps, newProps) {
    let nextProps = null;
    for (const [prop, value] of Object.entries(newProps)) {
      if (!TL_STYLE_TYPES.has(prop))
        continue;
      if (!nextProps)
        nextProps = __spreadValues({}, previousProps);
      nextProps[prop] = value;
    }
    return nextProps != null ? nextProps : previousProps;
  }

  // ../../../packages/editor/src/lib/utils/rotation.ts
  function getRotationSnapshot({ app }) {
    const {
      selectionRotation,
      selectionPageCenter,
      inputs: { originPagePoint },
      selectedShapes
    } = app;
    return {
      selectionPageCenter,
      initialCursorAngle: selectionPageCenter.angle(originPagePoint),
      initialSelectionRotation: selectionRotation,
      shapeSnapshots: selectedShapes.map((shape) => ({
        shape: structuredClone(shape),
        initialPagePoint: app.getPagePointById(shape.id)
      }))
    };
  }
  function applyRotationToSnapshotShapes({
    delta,
    app,
    snapshot,
    stage
  }) {
    const { selectionPageCenter, shapeSnapshots } = snapshot;
    app.updateShapes(
      shapeSnapshots.map(({ shape, initialPagePoint }) => {
        const parentTransform = isShapeId(shape.parentId) ? app.getPageTransformById(shape.parentId) : Matrix2d.Identity();
        const newPagePoint = Vec2d.RotWith(initialPagePoint, selectionPageCenter, delta);
        const newLocalPoint = Matrix2d.applyToPoint(
          // use the current parent transform in case it has moved/resized since the start
          // (e.g. if rotating a shape at the edge of a group)
          Matrix2d.Inverse(parentTransform),
          newPagePoint
        );
        const newRotation = canolicalizeRotation(shape.rotation + delta);
        return {
          id: shape.id,
          type: shape.type,
          x: newLocalPoint.x,
          y: newLocalPoint.y,
          rotation: newRotation
        };
      })
    );
    const changes = [];
    shapeSnapshots.forEach(({ shape }) => {
      var _a5, _b2, _c;
      const current = app.getShapeById(shape.id);
      if (!current)
        return;
      const util = app.getShapeUtil(shape);
      if (stage === "start" || stage === "one-off") {
        const changeStart = (_a5 = util.onRotateStart) == null ? void 0 : _a5.call(util, shape);
        if (changeStart)
          changes.push(changeStart);
      }
      const changeUpdate = (_b2 = util.onRotate) == null ? void 0 : _b2.call(util, shape, current);
      if (changeUpdate)
        changes.push(changeUpdate);
      if (stage === "end" || stage === "one-off") {
        const changeEnd = (_c = util.onRotateEnd) == null ? void 0 : _c.call(util, shape, current);
        if (changeEnd)
          changes.push(changeEnd);
      }
    });
    if (changes.length > 0) {
      app.updateShapes(changes);
    }
  }

  // ../../../packages/editor/src/lib/app/derivations/arrowBindingsIndex.ts
  var arrowBindingsIndex = (store) => {
    const shapeHistory = store.query.filterHistory("shape");
    const arrowQuery = store.query.records("shape", () => ({ type: { eq: "arrow" } }));
    function fromScratch() {
      const allArrows = arrowQuery.value;
      const bindings2Arrows = {};
      for (const arrow2 of allArrows) {
        const { start, end } = arrow2.props;
        if (start.type === "binding") {
          const arrows = bindings2Arrows[start.boundShapeId];
          if (arrows)
            arrows.push({ arrowId: arrow2.id, handleId: "start" });
          else
            bindings2Arrows[start.boundShapeId] = [{ arrowId: arrow2.id, handleId: "start" }];
        }
        if (end.type === "binding") {
          const arrows = bindings2Arrows[end.boundShapeId];
          if (arrows)
            arrows.push({ arrowId: arrow2.id, handleId: "end" });
          else
            bindings2Arrows[end.boundShapeId] = [{ arrowId: arrow2.id, handleId: "end" }];
        }
      }
      return bindings2Arrows;
    }
    return computed("arrowBindingsIndex", (_lastValue, lastComputedEpoch) => {
      if (isUninitialized(_lastValue)) {
        return fromScratch();
      }
      const lastValue = _lastValue;
      const diff = shapeHistory.getDiffSince(lastComputedEpoch);
      if (diff === RESET_VALUE) {
        return fromScratch();
      }
      let nextValue = void 0;
      function ensureNewArray(boundShapeId) {
        if (!nextValue) {
          nextValue = __spreadValues({}, lastValue);
        }
        if (!nextValue[boundShapeId]) {
          nextValue[boundShapeId] = [];
        } else if (nextValue[boundShapeId] === lastValue[boundShapeId]) {
          nextValue[boundShapeId] = [...nextValue[boundShapeId]];
        }
      }
      function removingBinding(boundShapeId, arrowId, handleId) {
        ensureNewArray(boundShapeId);
        nextValue[boundShapeId] = nextValue[boundShapeId].filter(
          (binding) => binding.arrowId !== arrowId || binding.handleId !== handleId
        );
        if (nextValue[boundShapeId].length === 0) {
          delete nextValue[boundShapeId];
        }
      }
      function addBinding(boundShapeId, arrowId, handleId) {
        ensureNewArray(boundShapeId);
        nextValue[boundShapeId].push({ arrowId, handleId });
      }
      for (const changes of diff) {
        for (const newShape of Object.values(changes.added)) {
          if (TLArrowShapeDef.is(newShape)) {
            const { start, end } = newShape.props;
            if (start.type === "binding") {
              addBinding(start.boundShapeId, newShape.id, "start");
            }
            if (end.type === "binding") {
              addBinding(end.boundShapeId, newShape.id, "end");
            }
          }
        }
        for (const [prev, next] of Object.values(changes.updated)) {
          if (!TLArrowShapeDef.is(prev) || !TLArrowShapeDef.is(next))
            continue;
          for (const handle of ["start", "end"]) {
            const prevTerminal = prev.props[handle];
            const nextTerminal = next.props[handle];
            if (prevTerminal.type === "binding" && nextTerminal.type === "point") {
              removingBinding(prevTerminal.boundShapeId, prev.id, handle);
            } else if (prevTerminal.type === "point" && nextTerminal.type === "binding") {
              addBinding(nextTerminal.boundShapeId, next.id, handle);
            } else if (prevTerminal.type === "binding" && nextTerminal.type === "binding" && prevTerminal.boundShapeId !== nextTerminal.boundShapeId) {
              removingBinding(prevTerminal.boundShapeId, prev.id, handle);
              addBinding(nextTerminal.boundShapeId, next.id, handle);
            }
          }
        }
        for (const prev of Object.values(changes.removed)) {
          if (TLArrowShapeDef.is(prev)) {
            const { start, end } = prev.props;
            if (start.type === "binding") {
              removingBinding(start.boundShapeId, prev.id, "start");
            }
            if (end.type === "binding") {
              removingBinding(end.boundShapeId, prev.id, "end");
            }
          }
        }
      }
      return nextValue != null ? nextValue : lastValue;
    });
  };

  // ../../../packages/editor/src/lib/app/derivations/parentsToChildrenWithIndexes.ts
  var parentsToChildrenWithIndexes = (store) => {
    const shapeIds = store.query.ids("shape");
    function fromScratch() {
      const result = {};
      shapeIds.value.forEach((id) => {
        const shape = store.get(id);
        if (!result[shape.parentId]) {
          result[shape.parentId] = [];
        }
        result[shape.parentId].push([id, shape.index]);
      });
      Object.values(result).forEach((arr) => arr.sort((a3, b3) => a3[1] < b3[1] ? -1 : 1));
      return result;
    }
    return computed(
      "parentsToChildrenWithIndexes",
      (lastValue, lastComputedEpoch) => {
        if (isUninitialized(lastValue)) {
          return fromScratch();
        }
        const diff = store.history.getDiffSince(lastComputedEpoch);
        if (diff === RESET_VALUE) {
          return fromScratch();
        }
        if (diff.length === 0)
          return lastValue;
        let newValue = null;
        const ensureNewArray = (parentId) => {
          if (!newValue) {
            newValue = __spreadValues({}, lastValue);
          }
          if (!newValue[parentId]) {
            newValue[parentId] = [];
          } else if (newValue[parentId] === lastValue[parentId]) {
            newValue[parentId] = [...newValue[parentId]];
          }
        };
        const toSort = /* @__PURE__ */ new Set();
        let changes;
        for (let i3 = 0, n3 = diff.length; i3 < n3; i3++) {
          changes = diff[i3];
          for (const record of Object.values(changes.added)) {
            if (!isShape(record))
              continue;
            ensureNewArray(record.parentId);
            newValue[record.parentId].push([record.id, record.index]);
            toSort.add(newValue[record.parentId]);
          }
          for (const [from, to] of Object.values(changes.updated)) {
            if (!isShape(to))
              continue;
            if (!isShape(from))
              continue;
            if (from.parentId !== to.parentId) {
              ensureNewArray(from.parentId);
              ensureNewArray(to.parentId);
              newValue[from.parentId].splice(
                newValue[from.parentId].findIndex((i4) => i4[0] === to.id),
                1
              );
              newValue[to.parentId].push([to.id, to.index]);
              toSort.add(newValue[to.parentId]);
            } else if (from.index !== to.index) {
              ensureNewArray(to.parentId);
              const idx = newValue[to.parentId].findIndex((i4) => i4[0] === to.id);
              newValue[to.parentId][idx] = [to.id, to.index];
              toSort.add(newValue[to.parentId]);
            }
          }
          for (const record of Object.values(changes.removed)) {
            if (!isShape(record))
              continue;
            ensureNewArray(record.parentId);
            newValue[record.parentId].splice(
              newValue[record.parentId].findIndex((i4) => i4[0] === record.id),
              1
            );
          }
        }
        for (const arr of toSort) {
          arr.sort((a3, b3) => a3[1] < b3[1] ? -1 : 1);
        }
        return newValue != null ? newValue : lastValue;
      }
    );
  };

  // ../../../packages/editor/src/lib/app/derivations/shapeIdsInCurrentPage.ts
  var isShapeInPage = (store, pageId, shape) => {
    while (!TLPage.isId(shape.parentId)) {
      const parent = store.get(shape.parentId);
      if (!parent)
        return false;
      shape = parent;
    }
    return shape.parentId === pageId;
  };
  var shapeIdsInCurrentPage = (store, getCurrentPageId) => {
    const shapesIndex = store.query.ids("shape");
    let lastPageId = null;
    function fromScratch() {
      const currentPageId = getCurrentPageId();
      lastPageId = currentPageId;
      return new Set(
        [...shapesIndex.value].filter((id) => isShapeInPage(store, currentPageId, store.get(id)))
      );
    }
    return computed("_shapeIdsInCurrentPage", (prevValue, lastComputedEpoch) => {
      if (isUninitialized(prevValue)) {
        return fromScratch();
      }
      const currentPageId = getCurrentPageId();
      if (currentPageId !== lastPageId) {
        return fromScratch();
      }
      const diff = store.history.getDiffSince(lastComputedEpoch);
      if (diff === RESET_VALUE) {
        return fromScratch();
      }
      const builder = new IncrementalSetConstructor(
        prevValue
      );
      for (const changes of diff) {
        for (const record of Object.values(changes.added)) {
          if (isShape(record) && isShapeInPage(store, currentPageId, record)) {
            builder.add(record.id);
          }
        }
        for (const [_from, to] of Object.values(changes.updated)) {
          if (isShape(to)) {
            if (isShapeInPage(store, currentPageId, to)) {
              builder.add(to.id);
            } else {
              builder.remove(to.id);
            }
          }
        }
        for (const id of Object.keys(changes.removed)) {
          if (isShapeId(id)) {
            builder.remove(id);
          }
        }
      }
      const result = builder.get();
      if (!result) {
        return prevValue;
      }
      return withDiff(result.value, result.diff);
    });
  };

  // ../../../packages/editor/src/lib/app/managers/ActiveAreaManager.ts
  var DEFAULT_OFFSETS = {
    top: 10,
    left: 10,
    bottom: 10,
    right: 10
  };
  function getActiveAreaScreenSpace(app) {
    const containerEl = app.getContainer();
    const el = containerEl.querySelector('*[data-tldraw-area="active-drawing"]');
    const out = __spreadProps(__spreadValues({}, DEFAULT_OFFSETS), {
      width: 0,
      height: 0
    });
    if (el && containerEl) {
      const cBbbox = containerEl.getBoundingClientRect();
      const bbox = el.getBoundingClientRect();
      out.top = bbox.top;
      out.left = bbox.left;
      out.bottom = cBbbox.height - bbox.bottom;
      out.right = cBbbox.width - bbox.right;
    }
    out.width = app.viewportScreenBounds.width - out.left - out.right;
    out.height = app.viewportScreenBounds.height - out.top - out.bottom;
    return out;
  }
  function getActiveAreaPageSpace(app) {
    const out = getActiveAreaScreenSpace(app);
    const z2 = app.zoomLevel;
    out.left /= z2;
    out.right /= z2;
    out.top /= z2;
    out.bottom /= z2;
    out.width /= z2;
    out.height /= z2;
    return out;
  }
  var ActiveAreaManager = class {
    constructor(app) {
      this.app = app;
      __publicField(this, "offsets", atom("activeAreaOffsets", DEFAULT_OFFSETS));
      __publicField(this, "updateOffsets", () => {
        const offsets = getActiveAreaPageSpace(this.app);
        this.offsets.set(offsets);
      });
      // Clear the listener
      __publicField(this, "dispose", () => {
        window.addEventListener("resize", this.updateOffsets);
      });
      window.addEventListener("resize", this.updateOffsets);
      this.app.disposables.add(this.dispose);
    }
  };

  // ../../../packages/editor/src/lib/app/managers/CameraManager.ts
  var CAMERA_SETTLE_TIMEOUT = 12;
  var CameraManager = class {
    constructor(app) {
      this.app = app;
      __publicField(this, "state", atom("camera state", "idle"));
      __publicField(this, "timeoutRemaining", 0);
      __publicField(this, "decay", (elapsed) => {
        this.timeoutRemaining -= elapsed;
        if (this.timeoutRemaining <= 0) {
          this.state.set("idle");
          this.app.off("tick", this.decay);
          this.app.updateCullingBounds();
        }
      });
      __publicField(this, "tick", () => {
        this.timeoutRemaining = CAMERA_SETTLE_TIMEOUT;
        if (this.state.__unsafe__getWithoutCapture() === "idle") {
          this.state.set("moving");
          this.app.on("tick", this.decay);
        }
      });
    }
  };

  // ../../../packages/editor/src/lib/app/managers/ClickManager.ts
  var MAX_CLICK_DISTANCE = 40;
  var ClickManager = class {
    constructor(app) {
      this.app = app;
      __publicField(this, "_clickId", "");
      __publicField(this, "_clickTimeout");
      __publicField(this, "_clickScreenPoint");
      __publicField(this, "_previousScreenPoint");
      __publicField(this, "_getClickTimeout", (state, id = uniqueId()) => {
        this._clickId = id;
        clearTimeout(this._clickTimeout);
        this._clickTimeout = setTimeout(
          () => {
            if (this._clickState === state && this._clickId === id) {
              switch (this._clickState) {
                case "pendingTriple": {
                  this.app.dispatch(__spreadProps(__spreadValues({}, this.lastPointerInfo), {
                    type: "click",
                    name: "double_click",
                    phase: "settle"
                  }));
                  break;
                }
                case "pendingQuadruple": {
                  this.app.dispatch(__spreadProps(__spreadValues({}, this.lastPointerInfo), {
                    type: "click",
                    name: "triple_click",
                    phase: "settle"
                  }));
                  break;
                }
                case "pendingOverflow": {
                  this.app.dispatch(__spreadProps(__spreadValues({}, this.lastPointerInfo), {
                    type: "click",
                    name: "quadruple_click",
                    phase: "settle"
                  }));
                  break;
                }
                default: {
                }
              }
              this._clickState = "idle";
            }
          },
          state === "idle" || state === "pendingDouble" ? DOUBLE_CLICK_DURATION : MULTI_CLICK_DURATION
        );
      });
      /**
       * The current click state.
       *
       * @internal
       */
      __publicField(this, "_clickState", "idle");
      __publicField(this, "lastPointerInfo", {});
      /**
       * Start the double click timeout.
       *
       * @param info - The event info.
       */
      __publicField(this, "transformPointerDownEvent", (info) => {
        if (!this._clickState)
          return info;
        this._clickScreenPoint = Vec2d.From(info.point);
        if (this._previousScreenPoint && this._previousScreenPoint.dist(this._clickScreenPoint) > MAX_CLICK_DISTANCE) {
          this._clickState = "idle";
        }
        this._previousScreenPoint = this._clickScreenPoint;
        this.lastPointerInfo = info;
        switch (this._clickState) {
          case "idle": {
            this._clickState = "pendingDouble";
            this._clickTimeout = this._getClickTimeout(this._clickState);
            return info;
          }
          case "pendingDouble": {
            this._clickState = "pendingTriple";
            this._clickTimeout = this._getClickTimeout(this._clickState);
            return __spreadProps(__spreadValues({}, info), {
              type: "click",
              name: "double_click",
              phase: "down"
            });
          }
          case "pendingTriple": {
            this._clickState = "pendingQuadruple";
            this._clickTimeout = this._getClickTimeout(this._clickState);
            return __spreadProps(__spreadValues({}, info), {
              type: "click",
              name: "triple_click",
              phase: "down"
            });
          }
          case "pendingQuadruple": {
            this._clickState = "pendingOverflow";
            this._clickTimeout = this._getClickTimeout(this._clickState);
            return __spreadProps(__spreadValues({}, info), {
              type: "click",
              name: "quadruple_click",
              phase: "down"
            });
          }
          case "pendingOverflow": {
            this._clickState = "overflow";
            this._clickTimeout = this._getClickTimeout(this._clickState);
            return info;
          }
          default: {
            this._clickTimeout = this._getClickTimeout(this._clickState);
            return info;
          }
        }
      });
      /**
       * Emit click_up events on pointer up.
       *
       * @param info - The event info.
       */
      __publicField(this, "transformPointerUpEvent", (info) => {
        if (!this._clickState)
          return info;
        this._clickScreenPoint = Vec2d.From(info.point);
        switch (this._clickState) {
          case "pendingTriple": {
            return __spreadProps(__spreadValues({}, this.lastPointerInfo), {
              type: "click",
              name: "double_click",
              phase: "up"
            });
          }
          case "pendingQuadruple": {
            return __spreadProps(__spreadValues({}, this.lastPointerInfo), {
              type: "click",
              name: "triple_click",
              phase: "up"
            });
          }
          case "pendingOverflow": {
            return __spreadProps(__spreadValues({}, this.lastPointerInfo), {
              type: "click",
              name: "quadruple_click",
              phase: "up"
            });
          }
          default: {
            return info;
          }
        }
      });
      /**
       * Cancel the double click timeout.
       *
       * @internal
       */
      __publicField(this, "cancelDoubleClickTimeout", () => {
        this._clickTimeout = clearTimeout(this._clickTimeout);
        this._clickState = "idle";
      });
      /**
       * Handle a move event, possibly cancelling the click timeout.
       *
       * @internal
       */
      __publicField(this, "handleMove", () => {
        if (this._clickState !== "idle" && this._clickScreenPoint && this._clickScreenPoint.dist(this.app.inputs.currentScreenPoint) > (this.app.isCoarsePointer ? COARSE_DRAG_DISTANCE : DRAG_DISTANCE)) {
          this.cancelDoubleClickTimeout();
        }
      });
    }
    /**
     * The current click state.
     *
     * @public
     */
    get clickState() {
      return this._clickState;
    }
  };

  // ../../../packages/editor/src/lib/app/managers/DprManager.ts
  var DprManager = class {
    constructor(app) {
      this.app = app;
      __publicField(this, "_currentMM");
      __publicField(this, "dpr", atom(
        "devicePixelRatio",
        typeof window === "undefined" ? 1 : window.devicePixelRatio
      ));
      // Update the device pixel ratio atom
      __publicField(this, "updateDevicePixelRatio", () => {
        this.dpr.set(window.devicePixelRatio);
        this.rebind();
      });
      // Clear the listener
      __publicField(this, "dispose", () => {
        var _a5;
        (_a5 = this._currentMM) == null ? void 0 : _a5.removeEventListener("change", this.updateDevicePixelRatio);
      });
      this.rebind();
      this.app.disposables.add(this.dispose);
    }
    // Set a listener to update the dpr when the device pixel ratio changes
    rebind() {
      var _a5;
      this.dispose();
      this._currentMM = this.getMedia();
      (_a5 = this._currentMM) == null ? void 0 : _a5.addEventListener("change", this.updateDevicePixelRatio);
    }
    // Get the media query list for the device pixel ratio
    getMedia() {
      if (window.matchMedia) {
        return matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
      }
    }
  };

  // ../../../packages/editor/src/lib/app/managers/Stack.ts
  function stack2(items) {
    if (items) {
      let result = EMPTY_STACK_ITEM;
      while (items.length) {
        result = result.push(items.pop());
      }
      return result;
    }
    return EMPTY_STACK_ITEM;
  }
  var EmptyStackItem = class {
    constructor() {
      __publicField(this, "length", 0);
      __publicField(this, "head", null);
      __publicField(this, "tail", this);
    }
    push(head) {
      return new StackItem(head, this);
    }
    toArray() {
      return EMPTY_ARRAY;
    }
    [Symbol.iterator]() {
      return {
        next() {
          return { value: void 0, done: true };
        }
      };
    }
  };
  var EMPTY_STACK_ITEM = new EmptyStackItem();
  var StackItem = class {
    constructor(head, tail) {
      this.head = head;
      this.tail = tail;
      __publicField(this, "length");
      this.length = tail.length + 1;
    }
    push(head) {
      return new StackItem(head, this);
    }
    toArray() {
      return Array.from(this);
    }
    [Symbol.iterator]() {
      let stack3 = this;
      return {
        next() {
          if (stack3.length) {
            const value = stack3.head;
            stack3 = stack3.tail;
            return { value, done: false };
          } else {
            return { value: void 0, done: true };
          }
        }
      };
    }
  };

  // ../../../packages/editor/src/lib/app/managers/HistoryManager.ts
  var HistoryManager = class {
    // A flag for whether the user is in a batch operation
    constructor(ctx, onBatchComplete, annotateError2) {
      this.ctx = ctx;
      this.onBatchComplete = onBatchComplete;
      this.annotateError = annotateError2;
      __publicField(this, "_undos", atom("HistoryManager.undos", stack2()));
      // Updated by each action that includes and undo
      __publicField(this, "_redos", atom("HistoryManager.redos", stack2()));
      // Updated when a user undoes
      __publicField(this, "_batchDepth", 0);
      __publicField(this, "_commands", {});
      __publicField(this, "createCommand", (name, constructor, handle) => {
        if (this._commands[name]) {
          throw new Error(`Duplicate command: ${name}`);
        }
        this._commands[name] = handle;
        const exec = (...args) => {
          if (!this._batchDepth) {
            this.batch(() => exec(...args));
            return this.ctx;
          }
          const result = constructor(...args);
          if (!result) {
            return this.ctx;
          }
          const { data, ephemeral, squashing, preservesRedoStack } = result;
          this.ignoringUpdates((undos, redos) => {
            handle.do(data);
            return { undos, redos };
          });
          if (!ephemeral) {
            const prev = this._undos.value.head;
            if (squashing && prev && prev.type === "command" && prev.name === name && prev.preservesRedoStack === preservesRedoStack) {
              this._undos.update(
                (undos) => undos.tail.push(__spreadProps(__spreadValues({}, prev), {
                  id: uniqueId(),
                  data: devFreeze(handle.squash(prev.data, data))
                }))
              );
            } else {
              this._undos.update(
                (undos) => undos.push({
                  type: "command",
                  name,
                  data: devFreeze(data),
                  id: uniqueId(),
                  preservesRedoStack
                })
              );
            }
            if (!result.preservesRedoStack) {
              this._redos.set(stack2());
            }
            this.ctx.emit("change-history", { reason: "push" });
          }
          return this.ctx;
        };
        return exec;
      });
      __publicField(this, "batch", (fn) => {
        try {
          this._batchDepth++;
          if (this._batchDepth === 1) {
            transact(() => {
              var _a5, _b2;
              const mostRecentActionId = (_a5 = this._undos.value.head) == null ? void 0 : _a5.id;
              fn();
              if (mostRecentActionId !== ((_b2 = this._undos.value.head) == null ? void 0 : _b2.id)) {
                this.onBatchComplete();
              }
            });
          } else {
            fn();
          }
        } catch (error) {
          this.annotateError(error);
          throw error;
        } finally {
          this._batchDepth--;
        }
        return this;
      });
      __publicField(this, "ignoringUpdates", (fn) => {
        let undos = this._undos.value;
        let redos = this._redos.value;
        this._undos.set(stack2());
        this._redos.set(stack2());
        try {
          ;
          ({ undos, redos } = transact(() => fn(undos, redos)));
        } finally {
          this._undos.set(undos);
          this._redos.set(redos);
        }
      });
      // History
      __publicField(this, "_undo", ({
        pushToRedoStack,
        toMark = void 0
      }) => {
        this.ignoringUpdates((undos, redos) => {
          var _a5;
          if (undos.length === 0) {
            return { undos, redos };
          }
          while (((_a5 = undos.head) == null ? void 0 : _a5.type) === "STOP") {
            const mark = undos.head;
            undos = undos.tail;
            if (pushToRedoStack) {
              redos = redos.push(mark);
            }
            if (mark.id === toMark) {
              this.ctx.emit(
                "change-history",
                pushToRedoStack ? { reason: "undo" } : { reason: "bail", markId: toMark }
              );
              return { undos, redos };
            }
          }
          if (undos.length === 0) {
            this.ctx.emit(
              "change-history",
              pushToRedoStack ? { reason: "undo" } : { reason: "bail", markId: toMark }
            );
            return { undos, redos };
          }
          while (undos.head) {
            const command = undos.head;
            undos = undos.tail;
            if (pushToRedoStack) {
              redos = redos.push(command);
            }
            if (command.type === "STOP") {
              if (command.onUndo && (!toMark || command.id === toMark)) {
                this.ctx.emit(
                  "change-history",
                  pushToRedoStack ? { reason: "undo" } : { reason: "bail", markId: toMark }
                );
                return { undos, redos };
              }
            } else {
              const handler = this._commands[command.name];
              handler.undo(command.data);
            }
          }
          this.ctx.emit(
            "change-history",
            pushToRedoStack ? { reason: "undo" } : { reason: "bail", markId: toMark }
          );
          return { undos, redos };
        });
        return this;
      });
      __publicField(this, "undo", () => {
        this._undo({ pushToRedoStack: true });
        return this;
      });
      __publicField(this, "redo", () => {
        this.ignoringUpdates((undos, redos) => {
          var _a5;
          if (redos.length === 0) {
            return { undos, redos };
          }
          while (((_a5 = redos.head) == null ? void 0 : _a5.type) === "STOP") {
            undos = undos.push(redos.head);
            redos = redos.tail;
          }
          if (redos.length === 0) {
            this.ctx.emit("change-history", { reason: "redo" });
            return { undos, redos };
          }
          while (redos.head) {
            const command = redos.head;
            undos = undos.push(redos.head);
            redos = redos.tail;
            if (command.type === "STOP") {
              if (command.onRedo) {
                break;
              }
            } else {
              const handler = this._commands[command.name];
              if (handler.redo) {
                handler.redo(command.data);
              } else {
                handler.do(command.data);
              }
            }
          }
          this.ctx.emit("change-history", { reason: "redo" });
          return { undos, redos };
        });
        return this;
      });
      __publicField(this, "bail", () => {
        this._undo({ pushToRedoStack: false });
        return this;
      });
      __publicField(this, "bailToMark", (id) => {
        this._undo({ pushToRedoStack: false, toMark: id });
        return this;
      });
      __publicField(this, "mark", (id = uniqueId(), onUndo = true, onRedo = true) => {
        const mostRecent = this._undos.value.head;
        if (mostRecent && mostRecent.type === "STOP") {
          if (mostRecent.id === id && mostRecent.onUndo === onUndo && mostRecent.onRedo === onRedo) {
            return mostRecent.id;
          }
        }
        this._undos.update((undos) => undos.push({ type: "STOP", id, onUndo, onRedo }));
        this.ctx.emit("mark-history", { id });
        return id;
      });
    }
    get numUndos() {
      return this._undos.value.length;
    }
    get numRedos() {
      return this._redos.value.length;
    }
    clear() {
      this._undos.set(stack2());
      this._redos.set(stack2());
    }
  };

  // ../../../packages/editor/src/lib/app/managers/SnapManager.ts
  var round = (x3) => {
    const decimalPlacesTolerance = 8;
    return Math.round(x3 * __pow(10, decimalPlacesTolerance)) / __pow(10, decimalPlacesTolerance);
  };
  function findAdjacentGaps(gaps, shapeId, gapLength, direction, intersection) {
    const matches = gaps.filter(
      (gap) => (direction === "forward" ? gap.startNode.id === shapeId : gap.endNode.id === shapeId) && round(gap.length) === round(gapLength) && rangeIntersection(
        gap.breadthIntersection[0],
        gap.breadthIntersection[1],
        intersection[0],
        intersection[1]
      )
    );
    if (matches.length === 0)
      return [];
    const nextNodes = /* @__PURE__ */ new Set();
    for (const match of matches) {
      const node = direction === "forward" ? match.endNode.id : match.startNode.id;
      if (!nextNodes.has(node)) {
        nextNodes.add(node);
        matches.push(
          ...findAdjacentGaps(
            gaps,
            node,
            gapLength,
            direction,
            rangeIntersection(
              match.breadthIntersection[0],
              match.breadthIntersection[1],
              intersection[0],
              intersection[1]
            )
          )
        );
      }
    }
    return matches;
  }
  function dedupeGapSnaps(snaps) {
    snaps.sort((a3, b3) => b3.gaps.length - a3.gaps.length);
    for (let i3 = snaps.length - 1; i3 > 0; i3--) {
      const snap = snaps[i3];
      for (let j = i3 - 1; j >= 0; j--) {
        const otherSnap = snaps[j];
        if (otherSnap.direction === snap.direction && snap.gaps.every(
          (gap) => otherSnap.gaps.some(
            (otherGap) => round(gap.startEdge[0].x) === round(otherGap.startEdge[0].x) && round(gap.startEdge[0].y) === round(otherGap.startEdge[0].y) && round(gap.startEdge[1].x) === round(otherGap.startEdge[1].x) && round(gap.startEdge[1].y) === round(otherGap.startEdge[1].y)
          ) && otherSnap.gaps.some(
            (otherGap) => round(gap.endEdge[0].x) === round(otherGap.endEdge[0].x) && round(gap.endEdge[0].y) === round(otherGap.endEdge[0].y) && round(gap.endEdge[1].x) === round(otherGap.endEdge[1].x) && round(gap.endEdge[1].y) === round(otherGap.endEdge[1].y)
          )
        )) {
          snaps.splice(i3, 1);
          break;
        }
      }
    }
  }
  var SnapManager = class {
    constructor(app) {
      this.app = app;
      __publicField(this, "_snapLines", atom("snapLines", void 0));
    }
    get lines() {
      var _a5;
      return (_a5 = this._snapLines.value) != null ? _a5 : EMPTY_ARRAY;
    }
    clear() {
      if (this.lines.length) {
        this._snapLines.set(void 0);
      }
    }
    setLines(lines) {
      this._snapLines.set(lines);
    }
    get snapPointsCache() {
      return this.app.store.createComputedCache("snapPoints", (shape) => {
        const pageTransfrorm = this.app.getPageTransformById(shape.id);
        if (!pageTransfrorm)
          return void 0;
        const util = this.app.getShapeUtil(shape);
        const snapPoints = util.snapPoints(shape);
        return snapPoints.map((point2, i3) => {
          const { x: x3, y: y3 } = Matrix2d.applyToPoint(pageTransfrorm, point2);
          return { x: x3, y: y3, id: `${shape.id}:${i3}` };
        });
      });
    }
    get snapThreshold() {
      return 8 / this.app.zoomLevel;
    }
    get visibleShapesNotInSelection() {
      const selectedIds = this.app.selectedIds;
      const result = /* @__PURE__ */ new Set();
      const processParent = (parentId) => {
        const children = this.app.getSortedChildIds(parentId);
        for (const id of children) {
          const shape = this.app.getShapeById(id);
          if (!shape)
            continue;
          if (shape.type === "arrow")
            continue;
          if (selectedIds.includes(id))
            continue;
          if (!this.app.isShapeInViewport(shape.id))
            continue;
          if (shape.type === "group") {
            processParent(id);
            continue;
          }
          result.add({ id: shape.id, pageBounds: this.app.getPageBoundsById(shape.id) });
          if (shape.type !== "frame") {
            processParent(id);
          }
        }
      };
      const commonFrameAncestor = this.app.findCommonAncestor(
        compact(selectedIds.map((id) => this.app.getShapeById(id))),
        (parent) => parent.type === "frame"
      );
      processParent(commonFrameAncestor != null ? commonFrameAncestor : this.app.currentPageId);
      return result;
    }
    get visibleSnapPointsNotInSelection() {
      const result = [];
      for (const shape of this.visibleShapesNotInSelection) {
        const snapPoints = this.snapPointsCache.get(shape.id);
        if (snapPoints) {
          result.push(...snapPoints);
        }
      }
      return result;
    }
    get visibleGaps() {
      const horizontal = [];
      const vertical = [];
      const sortedShapesHorizontal = [...this.visibleShapesNotInSelection].sort((a3, b3) => {
        return a3.pageBounds.minX - b3.pageBounds.minX;
      });
      for (let i3 = 0; i3 < sortedShapesHorizontal.length; i3++) {
        const startNode = sortedShapesHorizontal[i3];
        for (let j = i3 + 1; j < sortedShapesHorizontal.length; j++) {
          const endNode = sortedShapesHorizontal[j];
          if (
            // is there space between the boxes
            startNode.pageBounds.maxX < endNode.pageBounds.minX && // and they overlap in the y axis
            rangesOverlap(
              startNode.pageBounds.minY,
              startNode.pageBounds.maxY,
              endNode.pageBounds.minY,
              endNode.pageBounds.maxY
            )
          ) {
            horizontal.push({
              startNode,
              endNode,
              startEdge: [
                new Vec2d(startNode.pageBounds.maxX, startNode.pageBounds.minY),
                new Vec2d(startNode.pageBounds.maxX, startNode.pageBounds.maxY)
              ],
              endEdge: [
                new Vec2d(endNode.pageBounds.minX, endNode.pageBounds.minY),
                new Vec2d(endNode.pageBounds.minX, endNode.pageBounds.maxY)
              ],
              length: endNode.pageBounds.minX - startNode.pageBounds.maxX,
              breadthIntersection: rangeIntersection(
                startNode.pageBounds.minY,
                startNode.pageBounds.maxY,
                endNode.pageBounds.minY,
                endNode.pageBounds.maxY
              )
            });
          }
        }
      }
      const sortedShapesVertical = sortedShapesHorizontal.slice(0).sort((a3, b3) => {
        return a3.pageBounds.minY - b3.pageBounds.minY;
      });
      for (let i3 = 0; i3 < sortedShapesVertical.length; i3++) {
        const startNode = sortedShapesVertical[i3];
        for (let j = i3 + 1; j < sortedShapesVertical.length; j++) {
          const endNode = sortedShapesVertical[j];
          if (
            // is there space between the boxes
            startNode.pageBounds.maxY < endNode.pageBounds.minY && // do they overlap in the x axis
            rangesOverlap(
              startNode.pageBounds.minX,
              startNode.pageBounds.maxX,
              endNode.pageBounds.minX,
              endNode.pageBounds.maxX
            )
          ) {
            vertical.push({
              startNode,
              endNode,
              startEdge: [
                new Vec2d(startNode.pageBounds.minX, startNode.pageBounds.maxY),
                new Vec2d(startNode.pageBounds.maxX, startNode.pageBounds.maxY)
              ],
              endEdge: [
                new Vec2d(endNode.pageBounds.minX, endNode.pageBounds.minY),
                new Vec2d(endNode.pageBounds.maxX, endNode.pageBounds.minY)
              ],
              length: endNode.pageBounds.minY - startNode.pageBounds.maxY,
              breadthIntersection: rangeIntersection(
                startNode.pageBounds.minX,
                startNode.pageBounds.maxX,
                endNode.pageBounds.minX,
                endNode.pageBounds.maxX
              )
            });
          }
        }
      }
      return { horizontal, vertical };
    }
    snapTranslate({
      lockedAxis,
      initialSelectionPageBounds,
      initialSelectionSnapPoints,
      dragDelta
    }) {
      var _a5, _b2, _c, _d;
      const isXLocked = lockedAxis === "x";
      const isYLocked = lockedAxis === "y";
      const selectionPageBounds = initialSelectionPageBounds.clone().translate(dragDelta);
      const selectionSnapPoints = initialSelectionSnapPoints.map(({ x: x3, y: y3 }, i3) => ({
        id: "selection:" + i3,
        x: x3 + dragDelta.x,
        y: y3 + dragDelta.y
      }));
      const otherNodeSnapPoints = this.visibleSnapPointsNotInSelection;
      const nearestSnapsX = [];
      const nearestSnapsY = [];
      const minOffset = new Vec2d(this.snapThreshold, this.snapThreshold);
      this.findPointSnaps({
        minOffset,
        nearestSnapsX,
        nearestSnapsY,
        otherNodeSnapPoints,
        selectionSnapPoints
      });
      this.findGapSnaps({ selectionPageBounds, nearestSnapsX, nearestSnapsY, minOffset });
      const nudge = new Vec2d(
        isXLocked ? 0 : (_b2 = (_a5 = nearestSnapsX[0]) == null ? void 0 : _a5.nudge) != null ? _b2 : 0,
        isYLocked ? 0 : (_d = (_c = nearestSnapsY[0]) == null ? void 0 : _c.nudge) != null ? _d : 0
      );
      minOffset.x = 0;
      minOffset.y = 0;
      nearestSnapsX.length = 0;
      nearestSnapsY.length = 0;
      selectionSnapPoints.forEach((s3) => {
        s3.x += nudge.x;
        s3.y += nudge.y;
      });
      selectionPageBounds.translate(nudge);
      this.findPointSnaps({
        minOffset,
        nearestSnapsX,
        nearestSnapsY,
        otherNodeSnapPoints,
        selectionSnapPoints
      });
      this.findGapSnaps({
        selectionPageBounds,
        nearestSnapsX,
        nearestSnapsY,
        minOffset
      });
      const pointSnaps = this.getPointSnapLines({
        nearestSnapsX,
        nearestSnapsY
      });
      const gapSnaps = this.getGapSnapLines({
        selectionPageBounds,
        nearestSnapsX,
        nearestSnapsY
      });
      this._snapLines.set([...gapSnaps, ...pointSnaps]);
      return { nudge };
    }
    // for a handle of a line:
    // - find the nearest snap point
    // - return the nudge vector to snap to that point
    // note: this happens within page space
    snapLineHandleTranslate({
      lineId,
      handleId,
      handlePoint
    }) {
      const line = this.app.getShapeById(lineId);
      if (!line) {
        return { nudge: new Vec2d(0, 0) };
      }
      const util = this.app.getShapeUtilByDef(TLLineShapeDef);
      const handles = util.handles(line).sort(sortByIndex2);
      if (handles.length < 3)
        return { nudge: new Vec2d(0, 0) };
      const handleNumber = handles.findIndex((h3) => h3.id === handleId);
      const handle = handles[handleNumber];
      const segmentNumber = handle.type === "vertex" ? handleNumber / 2 : (handleNumber + 1) / 2;
      const spline = getSplineForLineShape(line);
      const ignoreCount = 1;
      const pageTransform = this.app.getPageTransform(line);
      const pageHeadSegments = spline.segments.slice(0, Math.max(0, segmentNumber - ignoreCount)).map((s3) => Matrix2d.applyToPoints(pageTransform, s3.lut));
      const pageTailSegments = spline.segments.slice(segmentNumber + ignoreCount).map((s3) => Matrix2d.applyToPoints(pageTransform, s3.lut));
      return this.snapHandleTranslate({
        handlePoint,
        additionalOutlines: [...pageHeadSegments, ...pageTailSegments]
      });
    }
    // for a handle:
    // - find the nearest snap point from all non-selected shapes
    // - return the nudge vector to snap to that point
    // note: this happens within page space
    snapHandleTranslate({
      handlePoint,
      additionalOutlines = []
    }) {
      var _a5, _b2;
      const visibleShapesNotInSelection = this.visibleShapesNotInSelection;
      const pageOutlines = [];
      for (const visibleShape of visibleShapesNotInSelection) {
        const shape = this.app.getShapeById(visibleShape.id);
        if (shape.type === "text" || shape.type === "icon") {
          continue;
        }
        const outline = deepCopy(this.app.getOutlineById(visibleShape.id));
        const isClosed = (_b2 = (_a5 = this.app.getShapeUtil(shape)).isClosed) == null ? void 0 : _b2.call(_a5, shape);
        if (isClosed) {
          outline.push(outline[0]);
        }
        pageOutlines.push(Matrix2d.applyToPoints(this.app.getPageTransformById(shape.id), outline));
      }
      let minDistance = this.snapThreshold;
      let nearestPoint = null;
      for (const outline of [...pageOutlines, ...additionalOutlines]) {
        for (let i3 = 0; i3 < outline.length - 1; i3++) {
          const C2 = outline[i3];
          const D3 = outline[i3 + 1];
          const distance = Vec2d.DistanceToLineSegment(C2, D3, handlePoint);
          if (isNaN(distance))
            continue;
          if (distance < minDistance) {
            minDistance = distance;
            nearestPoint = Vec2d.NearestPointOnLineSegment(C2, D3, handlePoint);
          }
        }
      }
      if (nearestPoint) {
        const snapLines = [];
        snapLines.push({
          id: uniqueId(),
          type: "points",
          points: [nearestPoint]
        });
        this._snapLines.set(snapLines);
        return {
          nudge: Vec2d.Sub(nearestPoint, handlePoint)
        };
      }
      return { nudge: new Vec2d(0, 0) };
    }
    snapResize({
      initialSelectionPageBounds,
      dragDelta,
      handle: originalHandle,
      isAspectRatioLocked,
      isResizingFromCenter
    }) {
      var _a5, _b2, _c, _d;
      const {
        box: unsnappedResizedPageBounds,
        scaleX,
        scaleY
      } = Box2d.Resize(
        initialSelectionPageBounds,
        originalHandle,
        isResizingFromCenter ? dragDelta.x * 2 : dragDelta.x,
        isResizingFromCenter ? dragDelta.y * 2 : dragDelta.y,
        isAspectRatioLocked
      );
      let handle = originalHandle;
      if (scaleX < 0) {
        handle = flipSelectionHandleX(handle);
      }
      if (scaleY < 0) {
        handle = flipSelectionHandleY(handle);
      }
      if (isResizingFromCenter) {
        unsnappedResizedPageBounds.center = initialSelectionPageBounds.center;
      }
      const isXLocked = handle === "top" || handle === "bottom";
      const isYLocked = handle === "left" || handle === "right";
      const selectionSnapPoints = getResizeSnapPointsForHandle(handle, unsnappedResizedPageBounds);
      const otherNodeSnapPoints = this.visibleSnapPointsNotInSelection;
      const nearestSnapsX = [];
      const nearestSnapsY = [];
      const minOffset = new Vec2d(this.snapThreshold, this.snapThreshold);
      this.findPointSnaps({
        minOffset,
        nearestSnapsX,
        nearestSnapsY,
        otherNodeSnapPoints,
        selectionSnapPoints
      });
      const nudge = new Vec2d(
        isXLocked ? 0 : (_b2 = (_a5 = nearestSnapsX[0]) == null ? void 0 : _a5.nudge) != null ? _b2 : 0,
        isYLocked ? 0 : (_d = (_c = nearestSnapsY[0]) == null ? void 0 : _c.nudge) != null ? _d : 0
      );
      if (isAspectRatioLocked && isSelectionCorner(handle) && nudge.len() !== 0) {
        const primaryNudgeAxis = nearestSnapsX.length && nearestSnapsY.length ? Math.abs(nudge.x) < Math.abs(nudge.y) ? "x" : "y" : nearestSnapsX.length ? "x" : "y";
        const ratio = initialSelectionPageBounds.aspectRatio;
        if (primaryNudgeAxis === "x") {
          nearestSnapsY.length = 0;
          nudge.y = nudge.x / ratio;
          if (handle === "bottom_left" || handle === "top_right") {
            nudge.y = -nudge.y;
          }
        } else {
          nearestSnapsX.length = 0;
          nudge.x = nudge.y * ratio;
          if (handle === "bottom_left" || handle === "top_right") {
            nudge.x = -nudge.x;
          }
        }
      }
      const snappedDelta = Vec2d.Add(dragDelta, nudge);
      const { box: snappedResizedPageBounds } = Box2d.Resize(
        initialSelectionPageBounds,
        originalHandle,
        isResizingFromCenter ? snappedDelta.x * 2 : snappedDelta.x,
        isResizingFromCenter ? snappedDelta.y * 2 : snappedDelta.y,
        isAspectRatioLocked
      );
      if (isResizingFromCenter) {
        snappedResizedPageBounds.center = initialSelectionPageBounds.center;
      }
      const snappedSelectionPoints = getResizeSnapPointsForHandle("any", snappedResizedPageBounds);
      nearestSnapsX.length = 0;
      nearestSnapsY.length = 0;
      minOffset.x = 0;
      minOffset.y = 0;
      this.findPointSnaps({
        minOffset,
        nearestSnapsX,
        nearestSnapsY,
        otherNodeSnapPoints,
        selectionSnapPoints: snappedSelectionPoints
      });
      const pointSnaps = this.getPointSnapLines({
        nearestSnapsX,
        nearestSnapsY
      });
      this._snapLines.set([...pointSnaps]);
      return { nudge };
    }
    findPointSnaps({
      selectionSnapPoints,
      otherNodeSnapPoints,
      minOffset,
      nearestSnapsX,
      nearestSnapsY
    }) {
      for (const thisSnapPoint of selectionSnapPoints) {
        for (const otherSnapPoint of otherNodeSnapPoints) {
          const offset = Vec2d.Sub(thisSnapPoint, otherSnapPoint);
          const offsetX = Math.abs(offset.x);
          const offsetY = Math.abs(offset.y);
          if (round(offsetX) <= round(minOffset.x)) {
            if (round(offsetX) < round(minOffset.x)) {
              nearestSnapsX.length = 0;
            }
            nearestSnapsX.push({
              type: "points",
              points: { thisPoint: thisSnapPoint, otherPoint: otherSnapPoint },
              nudge: otherSnapPoint.x - thisSnapPoint.x
            });
            minOffset.x = offsetX;
          }
          if (round(offsetY) <= round(minOffset.y)) {
            if (round(offsetY) < round(minOffset.y)) {
              nearestSnapsY.length = 0;
            }
            nearestSnapsY.push({
              type: "points",
              points: { thisPoint: thisSnapPoint, otherPoint: otherSnapPoint },
              nudge: otherSnapPoint.y - thisSnapPoint.y
            });
            minOffset.y = offsetY;
          }
        }
      }
    }
    findGapSnaps({
      selectionPageBounds,
      minOffset,
      nearestSnapsX,
      nearestSnapsY
    }) {
      for (const gap of this.visibleGaps.horizontal) {
        if (!rangesOverlap(
          gap.breadthIntersection[0],
          gap.breadthIntersection[1],
          selectionPageBounds.minY,
          selectionPageBounds.maxY
        )) {
          continue;
        }
        const gapMidX = gap.startEdge[0].x + gap.length / 2;
        const centerNudge = gapMidX - selectionPageBounds.center.x;
        const gapIsLargerThanSelection = gap.length > selectionPageBounds.width;
        if (gapIsLargerThanSelection && round(Math.abs(centerNudge)) <= round(minOffset.x)) {
          if (round(Math.abs(centerNudge)) < round(minOffset.x)) {
            nearestSnapsX.length = 0;
          }
          minOffset.x = Math.abs(centerNudge);
          const snap = {
            type: "gap_center",
            gap,
            nudge: centerNudge
          };
          const otherCenterSnap = nearestSnapsX.find(({ type }) => type === "gap_center");
          const gapBreadthsOverlap = otherCenterSnap && rangeIntersection(
            gap.breadthIntersection[0],
            gap.breadthIntersection[1],
            otherCenterSnap.gap.breadthIntersection[0],
            otherCenterSnap.gap.breadthIntersection[1]
          );
          if (otherCenterSnap && otherCenterSnap.gap.length > gap.length && gapBreadthsOverlap) {
            nearestSnapsX[nearestSnapsX.indexOf(otherCenterSnap)] = snap;
          } else if (!otherCenterSnap || !gapBreadthsOverlap) {
            nearestSnapsX.push(snap);
          }
        }
        const duplicationLeftX = gap.startNode.pageBounds.minX - gap.length;
        const selectionRightX = selectionPageBounds.maxX;
        const duplicationLeftNudge = duplicationLeftX - selectionRightX;
        if (round(Math.abs(duplicationLeftNudge)) <= round(minOffset.x)) {
          if (round(Math.abs(duplicationLeftNudge)) < round(minOffset.x)) {
            nearestSnapsX.length = 0;
          }
          minOffset.x = Math.abs(duplicationLeftNudge);
          nearestSnapsX.push({
            type: "gap_duplicate",
            gap,
            protrusionDirection: "left",
            nudge: duplicationLeftNudge
          });
        }
        const duplicationRightX = gap.endNode.pageBounds.maxX + gap.length;
        const selectionLeftX = selectionPageBounds.minX;
        const duplicationRightNudge = duplicationRightX - selectionLeftX;
        if (round(Math.abs(duplicationRightNudge)) <= round(minOffset.x)) {
          if (round(Math.abs(duplicationRightNudge)) < round(minOffset.x)) {
            nearestSnapsX.length = 0;
          }
          minOffset.x = Math.abs(duplicationRightNudge);
          nearestSnapsX.push({
            type: "gap_duplicate",
            gap,
            protrusionDirection: "right",
            nudge: duplicationRightNudge
          });
        }
      }
      for (const gap of this.visibleGaps.vertical) {
        if (!rangesOverlap(
          gap.breadthIntersection[0],
          gap.breadthIntersection[1],
          selectionPageBounds.minX,
          selectionPageBounds.maxX
        )) {
          continue;
        }
        const gapMidY = gap.startEdge[0].y + gap.length / 2;
        const centerNudge = gapMidY - selectionPageBounds.center.y;
        const gapIsLargerThanSelection = gap.length > selectionPageBounds.height;
        if (gapIsLargerThanSelection && round(Math.abs(centerNudge)) <= round(minOffset.y)) {
          if (round(Math.abs(centerNudge)) < round(minOffset.y)) {
            nearestSnapsY.length = 0;
          }
          minOffset.y = Math.abs(centerNudge);
          const snap = {
            type: "gap_center",
            gap,
            nudge: centerNudge
          };
          const otherCenterSnap = nearestSnapsY.find(({ type }) => type === "gap_center");
          const gapBreadthsOverlap = otherCenterSnap && rangesOverlap(
            otherCenterSnap.gap.breadthIntersection[0],
            otherCenterSnap.gap.breadthIntersection[1],
            gap.breadthIntersection[0],
            gap.breadthIntersection[1]
          );
          if (otherCenterSnap && otherCenterSnap.gap.length > gap.length && gapBreadthsOverlap) {
            nearestSnapsY[nearestSnapsY.indexOf(otherCenterSnap)] = snap;
          } else if (!otherCenterSnap || !gapBreadthsOverlap) {
            nearestSnapsY.push(snap);
          }
          continue;
        }
        const duplicationTopY = gap.startNode.pageBounds.minY - gap.length;
        const selectionBottomY = selectionPageBounds.maxY;
        const duplicationTopNudge = duplicationTopY - selectionBottomY;
        if (round(Math.abs(duplicationTopNudge)) <= round(minOffset.y)) {
          if (round(Math.abs(duplicationTopNudge)) < round(minOffset.y)) {
            nearestSnapsY.length = 0;
          }
          minOffset.y = Math.abs(duplicationTopNudge);
          nearestSnapsY.push({
            type: "gap_duplicate",
            gap,
            protrusionDirection: "top",
            nudge: duplicationTopNudge
          });
        }
        const duplicationBottomY = gap.endNode.pageBounds.maxY + gap.length;
        const selectionTopY = selectionPageBounds.minY;
        const duplicationBottomNudge = duplicationBottomY - selectionTopY;
        if (round(Math.abs(duplicationBottomNudge)) <= round(minOffset.y)) {
          if (round(Math.abs(duplicationBottomNudge)) < round(minOffset.y)) {
            nearestSnapsY.length = 0;
          }
          minOffset.y = Math.abs(duplicationBottomNudge);
          nearestSnapsY.push({
            type: "gap_duplicate",
            gap,
            protrusionDirection: "bottom",
            nudge: duplicationBottomNudge
          });
        }
      }
    }
    getPointSnapLines({
      nearestSnapsX,
      nearestSnapsY
    }) {
      const snapGroupsX = {};
      const snapGroupsY = {};
      const result = [];
      if (nearestSnapsX.length > 0) {
        for (const snap of nearestSnapsX) {
          if (snap.type === "points") {
            const key = round(snap.points.otherPoint.x);
            if (!snapGroupsX[key]) {
              snapGroupsX[key] = [];
            }
            snapGroupsX[key].push(snap.points);
          }
        }
      }
      if (nearestSnapsY.length > 0) {
        for (const snap of nearestSnapsY) {
          if (snap.type === "points") {
            const key = round(snap.points.otherPoint.y);
            if (!snapGroupsY[key]) {
              snapGroupsY[key] = [];
            }
            snapGroupsY[key].push(snap.points);
          }
        }
      }
      for (const [_, snapGroup] of Object.entries(snapGroupsX).concat(Object.entries(snapGroupsY))) {
        result.push({
          id: uniqueId(),
          type: "points",
          points: dedupe(
            snapGroup.map((snap) => Vec2d.From(snap.otherPoint)).concat(snapGroup.map((snap) => Vec2d.From(snap.thisPoint))),
            (a3, b3) => a3.equals(b3)
          )
        });
      }
      return result;
    }
    getGapSnapLines({
      selectionPageBounds,
      nearestSnapsX,
      nearestSnapsY
    }) {
      const selectionSides = {
        top: selectionPageBounds.sides[0],
        right: selectionPageBounds.sides[1],
        // need bottom and left to be sorted asc, which .sides is not.
        bottom: [selectionPageBounds.corners[3], selectionPageBounds.corners[2]],
        left: [selectionPageBounds.corners[0], selectionPageBounds.corners[3]]
      };
      const result = [];
      if (nearestSnapsX.length > 0) {
        for (const snap of nearestSnapsX) {
          if (snap.type === "gap_center") {
            const newGapsLength = (snap.gap.length - selectionPageBounds.width) / 2;
            const gapBreadthIntersection = rangeIntersection(
              snap.gap.breadthIntersection[0],
              snap.gap.breadthIntersection[1],
              selectionPageBounds.minY,
              selectionPageBounds.maxY
            );
            result.push({
              type: "gaps",
              direction: "horizontal",
              id: uniqueId(),
              gaps: [
                ...findAdjacentGaps(
                  this.visibleGaps.horizontal,
                  snap.gap.startNode.id,
                  newGapsLength,
                  "backward",
                  gapBreadthIntersection
                ),
                {
                  startEdge: snap.gap.startEdge,
                  endEdge: selectionSides.left
                },
                {
                  startEdge: selectionSides.right,
                  endEdge: snap.gap.endEdge
                },
                ...findAdjacentGaps(
                  this.visibleGaps.horizontal,
                  snap.gap.endNode.id,
                  newGapsLength,
                  "forward",
                  gapBreadthIntersection
                )
              ]
            });
          }
          if (snap.type === "gap_duplicate") {
            const gapBreadthIntersection = rangeIntersection(
              snap.gap.breadthIntersection[0],
              snap.gap.breadthIntersection[1],
              selectionPageBounds.minY,
              selectionPageBounds.maxY
            );
            result.push({
              type: "gaps",
              direction: "horizontal",
              id: uniqueId(),
              gaps: snap.protrusionDirection === "left" ? [
                {
                  startEdge: selectionSides.right,
                  endEdge: [
                    Vec2d.Add(snap.gap.startEdge[0], {
                      x: -snap.gap.startNode.pageBounds.width,
                      y: 0
                    }),
                    Vec2d.Add(snap.gap.startEdge[1], {
                      x: -snap.gap.startNode.pageBounds.width,
                      y: 0
                    })
                  ]
                },
                {
                  startEdge: snap.gap.startEdge,
                  endEdge: snap.gap.endEdge
                },
                ...findAdjacentGaps(
                  this.visibleGaps.horizontal,
                  snap.gap.endNode.id,
                  snap.gap.length,
                  "forward",
                  gapBreadthIntersection
                )
              ] : [
                ...findAdjacentGaps(
                  this.visibleGaps.horizontal,
                  snap.gap.startNode.id,
                  snap.gap.length,
                  "backward",
                  gapBreadthIntersection
                ),
                {
                  startEdge: snap.gap.startEdge,
                  endEdge: snap.gap.endEdge
                },
                {
                  startEdge: [
                    Vec2d.Add(snap.gap.endEdge[0], {
                      x: snap.gap.endNode.pageBounds.width,
                      y: 0
                    }),
                    Vec2d.Add(snap.gap.endEdge[1], {
                      x: snap.gap.endNode.pageBounds.width,
                      y: 0
                    })
                  ],
                  endEdge: selectionSides.left
                }
              ]
            });
          }
        }
      }
      if (nearestSnapsY.length > 0) {
        for (const snap of nearestSnapsY) {
          if (snap.type === "gap_center") {
            const newGapsLength = (snap.gap.length - selectionPageBounds.height) / 2;
            const gapBreadthIntersection = rangeIntersection(
              snap.gap.breadthIntersection[0],
              snap.gap.breadthIntersection[1],
              selectionPageBounds.minX,
              selectionPageBounds.maxX
            );
            result.push({
              type: "gaps",
              direction: "vertical",
              id: uniqueId(),
              gaps: [
                ...findAdjacentGaps(
                  this.visibleGaps.vertical,
                  snap.gap.startNode.id,
                  newGapsLength,
                  "backward",
                  gapBreadthIntersection
                ),
                {
                  startEdge: snap.gap.startEdge,
                  endEdge: selectionSides.top
                },
                {
                  startEdge: selectionSides.bottom,
                  endEdge: snap.gap.endEdge
                },
                ...findAdjacentGaps(
                  this.visibleGaps.vertical,
                  snap.gap.endNode.id,
                  newGapsLength,
                  "forward",
                  gapBreadthIntersection
                )
              ]
            });
          }
          if (snap.type === "gap_duplicate") {
            const gapBreadthIntersection = rangeIntersection(
              snap.gap.breadthIntersection[0],
              snap.gap.breadthIntersection[1],
              selectionPageBounds.minX,
              selectionPageBounds.maxX
            );
            result.push({
              type: "gaps",
              direction: "vertical",
              id: uniqueId(),
              gaps: snap.protrusionDirection === "top" ? [
                {
                  startEdge: selectionSides.bottom,
                  endEdge: [
                    Vec2d.Add(snap.gap.startEdge[0], {
                      x: 0,
                      y: -snap.gap.startNode.pageBounds.height
                    }),
                    Vec2d.Add(snap.gap.startEdge[1], {
                      x: 0,
                      y: -snap.gap.startNode.pageBounds.height
                    })
                  ]
                },
                {
                  startEdge: snap.gap.startEdge,
                  endEdge: snap.gap.endEdge
                },
                ...findAdjacentGaps(
                  this.visibleGaps.vertical,
                  snap.gap.endNode.id,
                  snap.gap.length,
                  "forward",
                  gapBreadthIntersection
                )
              ] : [
                ...findAdjacentGaps(
                  this.visibleGaps.vertical,
                  snap.gap.startNode.id,
                  snap.gap.length,
                  "backward",
                  gapBreadthIntersection
                ),
                {
                  startEdge: snap.gap.startEdge,
                  endEdge: snap.gap.endEdge
                },
                {
                  startEdge: [
                    Vec2d.Add(snap.gap.endEdge[0], {
                      x: 0,
                      y: snap.gap.endNode.pageBounds.height
                    }),
                    Vec2d.Add(snap.gap.endEdge[1], {
                      x: 0,
                      y: snap.gap.endNode.pageBounds.height
                    })
                  ],
                  endEdge: selectionSides.top
                }
              ]
            });
          }
        }
      }
      dedupeGapSnaps(result);
      return result;
    }
  };
  __decorateClass([
    computed
  ], SnapManager.prototype, "snapPointsCache", 1);
  __decorateClass([
    computed
  ], SnapManager.prototype, "visibleShapesNotInSelection", 1);
  __decorateClass([
    computed
  ], SnapManager.prototype, "visibleSnapPointsNotInSelection", 1);
  __decorateClass([
    computed
  ], SnapManager.prototype, "visibleGaps", 1);
  function getResizeSnapPointsForHandle(handle, selectionPageBounds) {
    const { minX, maxX, minY, maxY } = selectionPageBounds;
    const result = [];
    switch (handle) {
      case "top":
      case "left":
      case "top_left":
      case "any":
        result.push({
          id: "top_left",
          handle: "top_left",
          x: minX,
          y: minY
        });
    }
    switch (handle) {
      case "top":
      case "right":
      case "top_right":
      case "any":
        result.push({
          id: "top_right",
          handle: "top_right",
          x: maxX,
          y: minY
        });
    }
    switch (handle) {
      case "bottom":
      case "right":
      case "bottom_right":
      case "any":
        result.push({
          id: "bottom_right",
          handle: "bottom_right",
          x: maxX,
          y: maxY
        });
    }
    switch (handle) {
      case "bottom":
      case "left":
      case "bottom_left":
      case "any":
        result.push({
          id: "bottom_left",
          handle: "bottom_left",
          x: minX,
          y: maxY
        });
    }
    return result;
  }

  // ../../../packages/editor/src/lib/app/managers/TextManager.ts
  var textAlignmentsForLtr = {
    start: "left",
    middle: "center",
    end: "right"
  };
  var TextManager = class {
    constructor(app) {
      this.app = app;
      __publicField(this, "measureText", (opts) => {
        var _a5;
        const elm = this.getTextElement();
        elm.setAttribute("dir", "ltr");
        elm.style.setProperty("font-family", opts.fontFamily);
        elm.style.setProperty("font-style", opts.fontStyle);
        elm.style.setProperty("font-weight", opts.fontWeight);
        elm.style.setProperty("font-size", opts.fontSize + "px");
        elm.style.setProperty("line-height", opts.lineHeight * opts.fontSize + "px");
        elm.style.setProperty("width", opts.width);
        elm.style.setProperty("min-width", (_a5 = opts.minWidth) != null ? _a5 : null);
        elm.style.setProperty("max-width", opts.maxWidth);
        elm.style.setProperty("padding", opts.padding);
        elm.textContent = TextHelpers.normalizeTextForDom(opts.text);
        const rect = elm.getBoundingClientRect();
        return {
          x: 0,
          y: 0,
          w: rect.width,
          h: rect.height
        };
      });
    }
    getTextElement() {
      const oldElm = document.querySelector(".tl-text-measure");
      oldElm == null ? void 0 : oldElm.remove();
      const elm = document.createElement("div");
      this.app.getContainer().appendChild(elm);
      elm.id = `__textMeasure_${uniqueId()}`;
      elm.classList.add("tl-text");
      elm.classList.add("tl-text-measure");
      elm.tabIndex = -1;
      return elm;
    }
    getTextLines(opts) {
      const elm = this.getTextElement();
      elm.style.setProperty("width", opts.width - opts.padding * 2 + "px");
      elm.style.setProperty("height", "min-content");
      elm.style.setProperty("dir", "ltr");
      elm.style.setProperty("font-size", opts.fontSize + "px");
      elm.style.setProperty("font-family", opts.fontFamily);
      elm.style.setProperty("font-weight", opts.fontWeight);
      elm.style.setProperty("line-height", opts.lineHeight * opts.fontSize + "px");
      elm.style.setProperty("text-align", textAlignmentsForLtr[opts.textAlign]);
      const words = opts.text.replace(/ {2}/g, "	").split(/( |\t|\n)/).filter(Boolean).map((str) => str === "	" ? INDENT : str);
      const lines = [];
      let currentLine = [];
      elm.textContent = "";
      let prevHeight = elm.offsetHeight;
      let prevTextContent = elm.textContent;
      for (let i3 = 0, n3 = words.length; i3 < n3; i3++) {
        const word = words[i3];
        elm.textContent += word;
        const newHeight = elm.offsetHeight;
        if (newHeight <= prevHeight) {
          currentLine.push(word);
          prevTextContent = elm.textContent;
          continue;
        }
        if (word === "\n") {
          currentLine = [];
          lines.push(currentLine);
          prevTextContent = elm.textContent;
          continue;
        }
        const afterTextContent = elm.textContent;
        elm.textContent = prevTextContent;
        elm.textContent += "\n";
        const chars = [...word];
        elm.textContent += chars[0];
        prevHeight = elm.offsetHeight;
        let currentSubLine = [chars[0]];
        const subLines = [currentSubLine];
        for (let i4 = 1; i4 < chars.length; i4++) {
          const char = chars[i4];
          elm.textContent += char;
          const newHeight2 = elm.offsetHeight;
          if (newHeight2 > prevHeight) {
            currentSubLine = [char];
            subLines.push(currentSubLine);
            prevHeight = newHeight2;
          } else {
            currentSubLine.push(char);
          }
        }
        const joinedSubLines = subLines.map((b3) => [b3.join("")]);
        lines.push(...joinedSubLines);
        currentLine = lines[lines.length - 1];
        elm.textContent = afterTextContent;
        prevHeight = elm.offsetHeight;
        prevTextContent = elm.textContent;
      }
      elm.remove();
      const result = lines.map((line) => line.join("").trimEnd());
      return result;
    }
  };

  // ../../../packages/editor/src/lib/app/managers/TickManager.ts
  var TickManager = class {
    constructor(app) {
      this.app = app;
      __publicField(this, "raf");
      __publicField(this, "isPaused", true);
      __publicField(this, "last", 0);
      __publicField(this, "t", 0);
      __publicField(this, "start", () => {
        this.isPaused = false;
        cancelAnimationFrame(this.raf);
        this.raf = requestAnimationFrame(this.tick);
        this.last = Date.now();
      });
      __publicField(this, "tick", () => {
        if (this.isPaused) {
          return;
        }
        const now = Date.now();
        const elapsed = now - this.last;
        this.last = now;
        this.t += elapsed;
        if (this.t < 16) {
          this.raf = requestAnimationFrame(this.tick);
          return;
        }
        this.t -= 16;
        this.updatePointerVelocity(elapsed);
        this.app.emit("tick", elapsed);
        this.raf = requestAnimationFrame(this.tick);
      });
      // Clear the listener
      __publicField(this, "dispose", () => {
        this.isPaused = true;
        cancelAnimationFrame(this.raf);
      });
      __publicField(this, "prevPoint", new Vec2d());
      __publicField(this, "updatePointerVelocity", (elapsed) => {
        const {
          prevPoint,
          app: {
            inputs: { currentScreenPoint, pointerVelocity }
          }
        } = this;
        if (elapsed === 0)
          return;
        const delta = Vec2d.Sub(currentScreenPoint, prevPoint);
        this.prevPoint = currentScreenPoint.clone();
        const length = delta.len();
        const direction = length ? delta.div(length) : new Vec2d(0, 0);
        const next = pointerVelocity.clone().lrp(direction.mul(length / elapsed), 0.5);
        if (Math.abs(next.x) < 0.01)
          next.x = 0;
        if (Math.abs(next.y) < 0.01)
          next.y = 0;
        if (!pointerVelocity.equals(next)) {
          this.app.inputs.pointerVelocity = next;
        }
      });
      this.app.disposables.add(this.dispose);
      this.start();
    }
  };

  // ../../../packages/editor/src/lib/app/types/event-types.ts
  var EVENT_NAME_MAP = {
    wheel: "onWheel",
    pointer_enter: "onPointerEnter",
    pointer_leave: "onPointerLeave",
    pointer_down: "onPointerDown",
    pointer_move: "onPointerMove",
    pointer_up: "onPointerUp",
    right_click: "onRightClick",
    middle_click: "onMiddleClick",
    key_down: "onKeyDown",
    key_up: "onKeyUp",
    key_repeat: "onKeyRepeat",
    cancel: "onCancel",
    complete: "onComplete",
    interrupt: "onInterrupt",
    double_click: "onDoubleClick",
    triple_click: "onTripleClick",
    quadruple_click: "onQuadrupleClick"
  };

  // ../../../packages/editor/src/lib/app/statechart/StateNode.ts
  var StateNode = class {
    constructor(app, parent) {
      this.app = app;
      __publicField(this, "path");
      __publicField(this, "id");
      __publicField(this, "current");
      __publicField(this, "type");
      __publicField(this, "styles", []);
      __publicField(this, "initial");
      __publicField(this, "children");
      __publicField(this, "parent");
      __publicField(this, "isActive", false);
      __publicField(this, "onWheel");
      __publicField(this, "onPointerEnter");
      __publicField(this, "onPointerLeave");
      __publicField(this, "onPointerDown");
      __publicField(this, "onPointerMove");
      __publicField(this, "onPointerUp");
      __publicField(this, "onDoubleClick");
      __publicField(this, "onTripleClick");
      __publicField(this, "onQuadrupleClick");
      __publicField(this, "onRightClick");
      __publicField(this, "onMiddleClick");
      __publicField(this, "onKeyDown");
      __publicField(this, "onKeyUp");
      __publicField(this, "onKeyRepeat");
      __publicField(this, "onCancel");
      __publicField(this, "onComplete");
      __publicField(this, "onInterrupt");
      __publicField(this, "onEnter");
      __publicField(this, "onExit");
      const { id, children, initial } = this.constructor;
      this.id = id;
      this.current = atom("toolState" + this.id, void 0);
      this.path = computed("toolPath" + this.id, () => {
        const current = this.current.value;
        return this.id + (current ? `.${current.path.value}` : "");
      });
      this.parent = parent != null ? parent : {};
      if (this.parent) {
        if (children && initial) {
          this.type = "branch";
          this.initial = initial;
          this.children = Object.fromEntries(
            children().map((Ctor) => [Ctor.id, new Ctor(this.app, this)])
          );
          this.current.set(this.children[this.initial]);
        } else {
          this.type = "leaf";
        }
      } else {
        this.type = "root";
        if (children && initial) {
          this.initial = initial;
          this.children = Object.fromEntries(
            children().map((Ctor) => [Ctor.id, new Ctor(this.app, this)])
          );
          this.current.set(this.children[this.initial]);
        }
      }
    }
    transition(id, info) {
      var _a5;
      const path = id.split(".");
      let currState = this;
      for (let i3 = 0; i3 < path.length; i3++) {
        const id2 = path[i3];
        const prevChildState = currState.current.value;
        const nextChildState = (_a5 = currState.children) == null ? void 0 : _a5[id2];
        if (!nextChildState) {
          throw Error(`${currState.id} - no child state exists with the id ${id2}.`);
        }
        if ((prevChildState == null ? void 0 : prevChildState.id) !== nextChildState.id) {
          prevChildState == null ? void 0 : prevChildState.exit(info, id2);
          currState.current.set(nextChildState);
          nextChildState.enter(info, (prevChildState == null ? void 0 : prevChildState.id) || "initial");
          if (!nextChildState.isActive)
            break;
        }
        currState = nextChildState;
      }
      return this;
    }
    handleEvent(info) {
      var _a5;
      const cbName = EVENT_NAME_MAP[info.name];
      const x3 = this.current.value;
      (_a5 = this[cbName]) == null ? void 0 : _a5.call(this, info);
      if (this.current.value === x3 && this.isActive) {
        x3 == null ? void 0 : x3.handleEvent(info);
      }
    }
    enter(info, from) {
      var _a5;
      this.isActive = true;
      (_a5 = this.onEnter) == null ? void 0 : _a5.call(this, info, from);
      if (this.children && this.initial && this.isActive) {
        const initial = this.children[this.initial];
        this.current.set(initial);
        initial.enter(info, from);
      }
    }
    exit(info, from) {
      var _a5, _b2;
      this.isActive = false;
      (_a5 = this.onExit) == null ? void 0 : _a5.call(this, info, from);
      if (!this.isActive) {
        (_b2 = this.current.value) == null ? void 0 : _b2.exit(info, from);
      }
    }
  };
  __publicField(StateNode, "id");
  __publicField(StateNode, "initial");
  __publicField(StateNode, "children");

  // ../../../packages/editor/src/lib/app/statechart/TLArrowTool/children/Idle.ts
  var Idle = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "onPointerDown", (info) => {
        this.parent.transition("pointing", info);
      });
      __publicField(this, "onEnter", () => {
        this.app.setCursor({ type: "cross" });
      });
      __publicField(this, "onCancel", () => {
        this.app.setSelectedTool("select");
      });
    }
  };
  __publicField(Idle, "id", "idle");

  // ../../../packages/editor/src/lib/app/statechart/TLArrowTool/children/Pointing.ts
  var Pointing = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "shapeType", "");
      __publicField(this, "shape");
      __publicField(this, "preciseTimeout", -1);
      __publicField(this, "didTimeout", false);
      __publicField(this, "onEnter", () => {
        var _a5, _b2, _c;
        const {
          inputs: { currentPagePoint }
        } = this.app;
        this.didTimeout = false;
        this.shapeType = this.parent.shapeType;
        this.app.mark("creating");
        const id = createShapeId();
        this.app.createShapes([
          {
            id,
            type: this.shapeType,
            x: currentPagePoint.x,
            y: currentPagePoint.y
          }
        ]);
        const util = this.app.getShapeUtilByDef(TLArrowShapeDef);
        const shape = this.app.getShapeById(id);
        if (!shape)
          return;
        const handles = (_a5 = util.handles) == null ? void 0 : _a5.call(util, shape);
        if (handles) {
          const point2 = this.app.getPointInShapeSpace(shape, currentPagePoint);
          const change = (_b2 = util.onHandleChange) == null ? void 0 : _b2.call(util, shape, {
            handle: __spreadProps(__spreadValues({}, handles[0]), { x: point2.x, y: point2.y }),
            isPrecise: true
          });
          if (change) {
            const startTerminal = (_c = change.props) == null ? void 0 : _c.start;
            if ((startTerminal == null ? void 0 : startTerminal.type) === "binding") {
              this.app.setHintingIds([startTerminal.boundShapeId]);
            }
            this.app.updateShapes([change], true);
          }
        }
        this.app.select(id);
        this.shape = this.app.getShapeById(id);
        this.startPreciseTimeout();
      });
      __publicField(this, "onExit", () => {
        this.clearPreciseTimeout();
      });
      __publicField(this, "onPointerMove", () => {
        var _a5, _b2;
        if (!this.shape)
          return;
        if (this.app.inputs.isDragging) {
          const util = this.app.getShapeUtil(this.shape);
          const handles = (_a5 = util.handles) == null ? void 0 : _a5.call(util, this.shape);
          if (!handles) {
            this.app.bailToMark("creating");
            throw Error("No handles found");
          }
          if (!this.didTimeout) {
            const util2 = this.app.getShapeUtilByDef(TLArrowShapeDef);
            const shape = this.app.getShapeById(this.shape.id);
            if (!shape)
              return;
            const handles2 = util2.handles(shape);
            if (handles2) {
              const { x: x3, y: y3 } = this.app.getPointInShapeSpace(shape, this.app.inputs.originPagePoint);
              const change = (_b2 = util2.onHandleChange) == null ? void 0 : _b2.call(util2, shape, {
                handle: __spreadProps(__spreadValues({}, handles2[0]), {
                  x: x3,
                  y: y3
                }),
                isPrecise: false
              });
              if (change) {
                this.app.updateShapes([change], true);
              }
            }
          }
          this.app.setSelectedTool("select.dragging_handle", {
            shape: this.shape,
            handle: handles.find((h3) => h3.id === "end"),
            isCreating: true,
            onInteractionEnd: "arrow"
          });
        }
      });
      __publicField(this, "onPointerUp", () => {
        this.cancel();
      });
      __publicField(this, "onCancel", () => {
        this.cancel();
      });
      __publicField(this, "onComplete", () => {
        this.cancel();
      });
      __publicField(this, "onInterrupt", () => {
        this.cancel();
      });
    }
    startPreciseTimeout() {
      this.preciseTimeout = window.setTimeout(() => {
        if (!this.isActive)
          return;
        if (!this.shape)
          return;
        this.didTimeout = true;
      }, 300);
    }
    clearPreciseTimeout() {
      clearTimeout(this.preciseTimeout);
    }
    cancel() {
      this.app.bailToMark("creating");
      this.app.setHintingIds([]);
      this.parent.transition("idle", {});
    }
  };
  __publicField(Pointing, "id", "pointing");

  // ../../../packages/editor/src/lib/app/statechart/TLArrowTool/TLArrowTool.ts
  var TLArrowTool = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "shapeType", "arrow");
      __publicField(this, "styles", [
        "color",
        "opacity",
        "dash",
        "size",
        "arrowheadStart",
        "arrowheadEnd",
        "font",
        "fill"
      ]);
    }
  };
  __publicField(TLArrowTool, "id", "arrow");
  __publicField(TLArrowTool, "initial", "idle");
  __publicField(TLArrowTool, "children", () => [Idle, Pointing]);

  // ../../../packages/editor/src/lib/app/statechart/TLDrawTool/children/Drawing.ts
  var Drawing = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "info", {});
      __publicField(this, "initialShape");
      __publicField(this, "util", this.app.getShapeUtilByDef(TLDrawShapeDef));
      __publicField(this, "isPen", false);
      __publicField(this, "segmentMode", "free");
      __publicField(this, "didJustShiftClickToExtendPreviousShapeLine", false);
      __publicField(this, "pagePointWhereCurrentSegmentChanged", {});
      __publicField(this, "pagePointWhereNextSegmentChanged", null);
      __publicField(this, "lastRecordedPoint", {});
      __publicField(this, "mergeNextPoint", false);
      __publicField(this, "currentLineLength", 0);
      __publicField(this, "canDraw", false);
      __publicField(this, "onEnter", (info) => {
        this.info = info;
        this.canDraw = !this.app.isMenuOpen;
        this.lastRecordedPoint = this.app.inputs.currentPagePoint.clone();
        if (this.canDraw) {
          this.startShape();
        }
      });
      __publicField(this, "onPointerMove", () => {
        const {
          app: { inputs }
        } = this;
        if (this.isPen !== inputs.isPen) {
          this.cancel();
        }
        if (!this.canDraw && inputs.isDragging) {
          this.startShape();
          this.canDraw = true;
        }
        if (this.canDraw) {
          if (inputs.isPen) {
            if (Vec2d.Dist(inputs.currentPagePoint, this.lastRecordedPoint) >= 1 / this.app.zoomLevel) {
              this.lastRecordedPoint = inputs.currentPagePoint.clone();
              this.mergeNextPoint = false;
            } else {
              this.mergeNextPoint = true;
            }
          } else {
            this.mergeNextPoint = false;
          }
          this.updateShapes();
        }
      });
      __publicField(this, "onKeyDown", (info) => {
        if (info.key === "Shift") {
          switch (this.segmentMode) {
            case "free": {
              this.segmentMode = "starting_straight";
              this.pagePointWhereNextSegmentChanged = this.app.inputs.currentPagePoint.clone();
              break;
            }
            case "starting_free": {
              this.segmentMode = "starting_straight";
            }
          }
        }
        this.updateShapes();
      });
      __publicField(this, "onKeyUp", (info) => {
        if (info.key === "Shift") {
          this.app.snaps.clear();
          switch (this.segmentMode) {
            case "straight": {
              this.segmentMode = "starting_free";
              this.pagePointWhereNextSegmentChanged = this.app.inputs.currentPagePoint.clone();
              break;
            }
            case "starting_straight": {
              this.pagePointWhereNextSegmentChanged = null;
              this.segmentMode = "free";
              break;
            }
          }
        }
        this.updateShapes();
      });
      __publicField(this, "onExit", () => {
        this.app.snaps.clear();
        this.pagePointWhereCurrentSegmentChanged = this.app.inputs.currentPagePoint.clone();
      });
      __publicField(this, "onPointerUp", () => {
        this.complete();
      });
      __publicField(this, "onCancel", () => {
        this.cancel();
      });
      __publicField(this, "onComplete", () => {
        this.complete();
      });
      __publicField(this, "onInterrupt", () => {
        if (this.app.inputs.isDragging) {
          return;
        }
        this.app.bail();
        this.cancel();
      });
    }
    getIsClosed(segments, size) {
      const strokeWidth = this.app.getStrokeWidth(size);
      const firstPoint = segments[0].points[0];
      const lastSegment = segments[segments.length - 1];
      const lastPoint = lastSegment.points[lastSegment.points.length - 1];
      return this.currentLineLength > strokeWidth * 4 && Vec2d.Dist(firstPoint, lastPoint) < strokeWidth * 2;
    }
    startShape() {
      const {
        inputs: { originPagePoint, isPen }
      } = this.app;
      this.app.mark("draw create start");
      this.isPen = isPen;
      const pressure = this.isPen ? this.info.point.z * 1.25 : 0.5;
      this.segmentMode = this.app.inputs.shiftKey ? "straight" : "free";
      this.didJustShiftClickToExtendPreviousShapeLine = false;
      this.lastRecordedPoint = originPagePoint.clone();
      if (this.initialShape) {
        const shape = this.app.getShapeById(this.initialShape.id);
        if (shape && this.segmentMode === "straight") {
          this.didJustShiftClickToExtendPreviousShapeLine = true;
          const prevSegment = last(shape.props.segments);
          if (!prevSegment)
            throw Error("Expected a previous segment!");
          const prevPoint = last(prevSegment.points);
          if (!prevPoint)
            throw Error("Expected a previous point!");
          const { x: x3, y: y3 } = this.app.getPointInShapeSpace(shape, originPagePoint).toFixed();
          const pressure2 = this.isPen ? this.info.point.z * 1.25 : 0.5;
          const newSegment = {
            type: this.segmentMode,
            points: [
              {
                x: prevPoint.x,
                y: prevPoint.y,
                z: +pressure2.toFixed(2)
              },
              {
                x: x3,
                y: y3,
                z: +pressure2.toFixed(2)
              }
            ]
          };
          const prevPointPageSpace = Matrix2d.applyToPoint(
            this.app.getPageTransformById(shape.id),
            prevPoint
          );
          this.pagePointWhereCurrentSegmentChanged = prevPointPageSpace;
          this.pagePointWhereNextSegmentChanged = null;
          const segments = [...shape.props.segments, newSegment];
          this.currentLineLength = this.getLineLength(segments);
          this.app.updateShapes([
            {
              id: shape.id,
              type: "draw",
              props: {
                segments,
                isClosed: this.getIsClosed(segments, shape.props.size)
              }
            }
          ]);
          return;
        }
      }
      this.pagePointWhereCurrentSegmentChanged = originPagePoint.clone();
      const id = createShapeId();
      this.app.createShapes([
        {
          id,
          type: "draw",
          x: originPagePoint.x,
          y: originPagePoint.y,
          props: {
            isPen: this.isPen,
            segments: [
              {
                type: this.segmentMode,
                points: [
                  {
                    x: 0,
                    y: 0,
                    z: +pressure.toFixed(2)
                  }
                ]
              }
            ]
          }
        }
      ]);
      this.currentLineLength = 0;
      this.initialShape = this.app.getShapeById(id);
    }
    updateShapes() {
      const { inputs } = this.app;
      const { initialShape } = this;
      if (!initialShape)
        return;
      const {
        id,
        props: { size }
      } = initialShape;
      const shape = this.app.getShapeById(id);
      if (!shape)
        return;
      const { segments } = shape.props;
      const { x: x3, y: y3, z: z2 } = this.app.getPointInShapeSpace(shape, inputs.currentPagePoint).toFixed();
      const newPoint = { x: x3, y: y3, z: this.isPen ? +(z2 * 1.25).toFixed(2) : 0.5 };
      switch (this.segmentMode) {
        case "starting_straight": {
          const { pagePointWhereNextSegmentChanged } = this;
          if (pagePointWhereNextSegmentChanged === null) {
            throw Error("We should have a point where the segment changed");
          }
          const hasMovedFarEnough = Vec2d.Dist(pagePointWhereNextSegmentChanged, inputs.currentPagePoint) > DRAG_DISTANCE;
          if (hasMovedFarEnough) {
            this.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged.clone();
            this.pagePointWhereNextSegmentChanged = null;
            this.segmentMode = "straight";
            const prevSegment = last(segments);
            if (!prevSegment)
              throw Error("Expected a previous segment!");
            const prevLastPoint = last(prevSegment.points);
            if (!prevLastPoint)
              throw Error("Expected a previous last point!");
            let newSegment;
            const newLastPoint = this.app.getPointInShapeSpace(shape, this.pagePointWhereCurrentSegmentChanged).toFixed().toJson();
            if (prevSegment.type === "straight") {
              this.currentLineLength += Vec2d.Dist(prevLastPoint, newLastPoint);
              newSegment = {
                type: "straight",
                points: [__spreadValues({}, prevLastPoint), newLastPoint]
              };
              const transform = this.app.getPageTransform(shape);
              this.pagePointWhereCurrentSegmentChanged = Matrix2d.applyToPoint(
                transform,
                prevLastPoint
              );
            } else {
              newSegment = {
                type: "straight",
                points: [newLastPoint, newPoint]
              };
            }
            this.app.updateShapes(
              [
                {
                  id,
                  type: "draw",
                  props: {
                    segments: [...segments, newSegment],
                    isClosed: this.getIsClosed(segments, size)
                  }
                }
              ],
              true
            );
          }
          break;
        }
        case "starting_free": {
          const { pagePointWhereNextSegmentChanged } = this;
          if (pagePointWhereNextSegmentChanged === null) {
            throw Error("We should have a point where the segment changed");
          }
          const hasMovedFarEnough = Vec2d.Dist(pagePointWhereNextSegmentChanged, inputs.currentPagePoint) > DRAG_DISTANCE;
          if (hasMovedFarEnough) {
            this.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged.clone();
            this.pagePointWhereNextSegmentChanged = null;
            this.segmentMode = "free";
            const newSegments = segments.slice();
            const prevStraightSegment = newSegments[newSegments.length - 1];
            const prevPoint = last(prevStraightSegment.points);
            if (!prevPoint) {
              throw Error("No previous point!");
            }
            const newFreeSegment = {
              type: "free",
              points: [
                ...Vec2d.PointsBetween(prevPoint, newPoint, 6).map((p3) => p3.toFixed().toJson())
              ]
            };
            this.currentLineLength = this.getLineLength(segments);
            this.app.updateShapes(
              [
                {
                  id,
                  type: "draw",
                  props: {
                    segments: [...newSegments, newFreeSegment],
                    isClosed: this.getIsClosed(segments, size)
                  }
                }
              ],
              true
            );
          }
          break;
        }
        case "straight": {
          const newSegments = segments.slice();
          const newSegment = newSegments[newSegments.length - 1];
          const { pagePointWhereCurrentSegmentChanged } = this;
          const { currentPagePoint, ctrlKey } = this.app.inputs;
          if (!pagePointWhereCurrentSegmentChanged)
            throw Error("We should have a point where the segment changed");
          let pagePoint;
          let shouldSnapToAngle = false;
          if (this.didJustShiftClickToExtendPreviousShapeLine) {
            if (this.app.inputs.isDragging) {
              shouldSnapToAngle = !ctrlKey;
              this.didJustShiftClickToExtendPreviousShapeLine = false;
            } else {
            }
          } else {
            shouldSnapToAngle = !ctrlKey;
          }
          let newPoint2 = this.app.getPointInShapeSpace(shape, currentPagePoint).toFixed().toJson();
          let didSnap = false;
          let snapSegment = void 0;
          const shouldSnap = this.app.userDocumentSettings.isSnapMode ? !ctrlKey : ctrlKey;
          if (shouldSnap) {
            if (newSegments.length > 2) {
              let nearestPoint = void 0;
              let minDistance = 8 / this.app.zoomLevel;
              for (let i3 = 0, n3 = segments.length - 2; i3 < n3; i3++) {
                const segment = segments[i3];
                if (!segment)
                  break;
                if (segment.type === "free")
                  continue;
                const first = segment.points[0];
                const lastPoint = last(segment.points);
                if (!(first && lastPoint))
                  continue;
                const nearestPointOnSegment = Vec2d.NearestPointOnLineSegment(
                  first,
                  lastPoint,
                  newPoint2
                );
                const distance = Vec2d.Dist(nearestPointOnSegment, newPoint2);
                if (distance < minDistance) {
                  nearestPoint = nearestPointOnSegment.toFixed().toJson();
                  minDistance = distance;
                  snapSegment = segment;
                  break;
                }
              }
              if (nearestPoint) {
                didSnap = true;
                newPoint2 = nearestPoint;
              }
            }
          }
          if (didSnap && snapSegment) {
            const transform = this.app.getPageTransform(shape);
            const first = snapSegment.points[0];
            const lastPoint = last(snapSegment.points);
            if (!lastPoint)
              throw Error("Expected a last point!");
            const A2 = Matrix2d.applyToPoint(transform, first);
            const B = Matrix2d.applyToPoint(transform, lastPoint);
            const snappedPoint = Matrix2d.applyToPoint(transform, newPoint2);
            this.app.snaps.setLines([
              {
                id: uniqueId(),
                type: "points",
                points: [A2, snappedPoint, B]
              }
            ]);
          } else {
            this.app.snaps.clear();
            if (shouldSnapToAngle) {
              const currentAngle = Vec2d.Angle(pagePointWhereCurrentSegmentChanged, currentPagePoint);
              const snappedAngle = snapAngle(currentAngle, 24);
              const angleDiff = snappedAngle - currentAngle;
              pagePoint = Vec2d.RotWith(
                currentPagePoint,
                pagePointWhereCurrentSegmentChanged,
                angleDiff
              );
            } else {
              pagePoint = currentPagePoint;
            }
            newPoint2 = this.app.getPointInShapeSpace(shape, pagePoint).toFixed().toJson();
          }
          this.currentLineLength += Vec2d.Dist(newSegment.points[0], newPoint2);
          newSegments[newSegments.length - 1] = __spreadProps(__spreadValues({}, newSegment), {
            type: "straight",
            points: [newSegment.points[0], newPoint2]
          });
          this.app.updateShapes(
            [
              {
                id,
                type: "draw",
                props: {
                  segments: newSegments,
                  isClosed: this.getIsClosed(segments, size)
                }
              }
            ],
            true
          );
          break;
        }
        case "free": {
          const newSegments = segments.slice();
          const newSegment = newSegments[newSegments.length - 1];
          const newPoints = [...newSegment.points];
          if (newPoints.length && this.mergeNextPoint) {
            const { z: z3 } = newPoints[newPoints.length - 1];
            newPoints[newPoints.length - 1] = {
              x: newPoint.x,
              y: newPoint.y,
              z: z3 ? Math.max(z3, newPoint.z) : newPoint.z
            };
          } else {
            this.currentLineLength += Vec2d.Dist(newPoints[newPoints.length - 1], newPoint);
            newPoints.push(newPoint);
          }
          newSegments[newSegments.length - 1] = __spreadProps(__spreadValues({}, newSegment), {
            points: newPoints
          });
          this.app.updateShapes(
            [
              {
                id,
                type: "draw",
                props: {
                  segments: newSegments,
                  isClosed: this.getIsClosed(segments, size)
                }
              }
            ],
            true
          );
          if (newPoints.length > 500) {
            this.app.updateShapes([{ id, type: "draw", props: { isComplete: true } }]);
            const { currentPagePoint } = this.app.inputs;
            const newShapeId = this.app.createShapeId();
            this.app.createShapes([
              {
                id: newShapeId,
                type: "draw",
                x: currentPagePoint.x,
                y: currentPagePoint.y,
                props: {
                  isPen: this.isPen,
                  segments: [
                    {
                      type: "free",
                      points: [{ x: 0, y: 0, z: this.isPen ? +(z2 * 1.25).toFixed() : 0.5 }]
                    }
                  ]
                }
              }
            ]);
            this.initialShape = structuredClone(this.app.getShapeById(newShapeId));
            this.mergeNextPoint = false;
            this.lastRecordedPoint = this.app.inputs.currentPagePoint.clone();
            this.currentLineLength = 0;
          }
          break;
        }
      }
    }
    getLineLength(segments) {
      let length = 0;
      for (const segment of segments) {
        for (let i3 = 0; i3 < segment.points.length - 1; i3++) {
          const A2 = segment.points[i3];
          const B = segment.points[i3 + 1];
          length += Vec2d.Sub(B, A2).len2();
        }
      }
      return Math.sqrt(length);
    }
    complete() {
      if (!this.canDraw) {
        this.cancel();
        return;
      }
      const { initialShape } = this;
      if (!initialShape)
        return;
      this.app.updateShapes([
        { id: initialShape.id, type: initialShape.type, props: { isComplete: true } }
      ]);
      this.parent.transition("idle", {});
    }
    cancel() {
      this.parent.transition("idle", this.info);
    }
  };
  __publicField(Drawing, "id", "drawing");

  // ../../../packages/editor/src/lib/app/statechart/TLDrawTool/children/Idle.ts
  var Idle2 = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "onPointerDown", (info) => {
        this.parent.transition("drawing", info);
      });
      __publicField(this, "onEnter", () => {
        this.app.setCursor({ type: "cross" });
      });
      __publicField(this, "onCancel", () => {
        this.app.setSelectedTool("select");
      });
    }
  };
  __publicField(Idle2, "id", "idle");

  // ../../../packages/editor/src/lib/app/statechart/TLDrawTool/TLDrawTool.ts
  var TLDrawTool = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "styles", ["color", "opacity", "dash", "fill", "size"]);
      __publicField(this, "onExit", () => {
        const drawingState = this.children["drawing"];
        drawingState.initialShape = void 0;
      });
    }
  };
  __publicField(TLDrawTool, "id", "draw");
  __publicField(TLDrawTool, "initial", "idle");
  __publicField(TLDrawTool, "children", () => [Idle2, Drawing]);

  // ../../../packages/editor/src/lib/app/managers/ScribbleManager.ts
  var ScribbleManager = class {
    constructor(opts) {
      // Scribble properties
      __publicField(this, "state");
      __publicField(this, "points");
      __publicField(this, "size");
      __publicField(this, "color");
      __publicField(this, "opacity");
      // Callbacks
      __publicField(this, "onUpdate");
      __publicField(this, "onComplete");
      // Internal state
      __publicField(this, "prev", null);
      __publicField(this, "next", null);
      __publicField(this, "resume", () => {
        this.state = "active";
      });
      __publicField(this, "pause", () => {
        this.state = "starting";
      });
      /**
       * Start stopping the scribble. The scribble won't be removed until its last point is cleared.
       *
       * @public
       */
      __publicField(this, "stop", () => {
        this.state = "stopping";
      });
      /**
       * Set the scribble's next point.
       *
       * @param point - The point to add.
       * @public
       */
      __publicField(this, "addPoint", (x3, y3) => {
        const { prev } = this;
        const point2 = { x: x3, y: y3, z: 0.5 };
        if (prev && Vec2d.Dist(prev, point2) < 1)
          return;
        this.next = point2;
      });
      __publicField(this, "timeoutMs", 0);
      __publicField(this, "tick", (elapsed) => {
        this.timeoutMs += elapsed;
        if (this.timeoutMs >= 16) {
          this.timeoutMs = 0;
        }
        const { timeoutMs, state, prev, next, points: points2 } = this;
        switch (state) {
          case "active": {
            if (next && next !== prev) {
              this.prev = next;
              points2.push(next);
              if (points2.length > 8) {
                points2.shift();
              }
              this.updateScribble();
            } else {
              if (timeoutMs === 0 && points2.length > 1) {
                points2.shift();
                this.updateScribble();
              }
            }
            break;
          }
          case "stopping": {
            if (timeoutMs === 0) {
              if (points2.length === 1) {
                this.state = "paused";
                this.onComplete();
                return;
              }
              this.size *= 0.9;
              points2.shift();
              this.updateScribble();
            }
            break;
          }
          case "paused": {
            break;
          }
        }
      });
      const { size = 20, color = "accent", opacity = 0.8, onComplete, onUpdate } = opts;
      this.onUpdate = onUpdate;
      this.onComplete = onComplete;
      this.size = size;
      this.color = color;
      this.opacity = opacity;
      this.points = [];
      this.state = "starting";
      this.prev = null;
      this.next = null;
      this.resume();
    }
    /**
     * Get the current TLScribble object from the scribble manager.
     *
     * @public
     */
    getScribble() {
      return {
        state: this.state,
        size: this.size,
        color: this.color,
        opacity: this.opacity,
        points: [...this.points]
      };
    }
    updateScribble() {
      this.onUpdate(this.getScribble());
    }
  };

  // ../../../packages/editor/src/lib/app/statechart/TLEraserTool/children/Erasing.ts
  var Erasing = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "info", {});
      __publicField(this, "scribble", {});
      __publicField(this, "markId", "");
      __publicField(this, "excludedShapeIds", /* @__PURE__ */ new Set());
      __publicField(this, "onEnter", (info) => {
        this.markId = this.app.mark("erase scribble begin");
        this.info = info;
        const { originPagePoint } = this.app.inputs;
        this.excludedShapeIds = new Set(
          this.app.shapesArray.filter(
            (shape) => (shape.type === "frame" || shape.type === "group") && this.app.isPointInShape(originPagePoint, shape)
          ).map((shape) => shape.id)
        );
        this.startScribble();
        this.update();
      });
      __publicField(this, "startScribble", () => {
        this.scribble = new ScribbleManager({
          onUpdate: this.onScribbleUpdate,
          onComplete: this.onScribbleComplete,
          color: "muted-1",
          size: 12
        });
        this.app.on("tick", this.scribble.tick);
      });
      __publicField(this, "pushPointToScribble", () => {
        const { x: x3, y: y3 } = this.app.inputs.currentPagePoint;
        this.scribble.addPoint(x3, y3);
      });
      __publicField(this, "onScribbleUpdate", (scribble) => {
        this.app.setScribble(scribble);
      });
      __publicField(this, "onScribbleComplete", () => {
        this.app.off("tick", this.scribble.tick);
        this.app.setScribble(null);
      });
      __publicField(this, "onExit", () => {
        this.scribble.stop();
      });
      __publicField(this, "onPointerMove", () => {
        this.update();
      });
      __publicField(this, "onPointerUp", () => {
        this.complete();
      });
      __publicField(this, "onCancel", () => {
        this.cancel();
      });
      __publicField(this, "onComplete", () => {
        this.complete();
      });
    }
    update() {
      const {
        shapesArray,
        erasingIdsSet,
        inputs: { currentPagePoint, previousPagePoint }
      } = this.app;
      const { excludedShapeIds } = this;
      this.pushPointToScribble();
      const erasing = new Set(erasingIdsSet);
      for (const shape of shapesArray) {
        if (shape.type === "group")
          continue;
        const pageMask = this.app.getPageMaskById(shape.id);
        if (pageMask && !pointInPolygon(currentPagePoint, pageMask)) {
          continue;
        }
        const util = this.app.getShapeUtil(shape);
        const A2 = this.app.getPointInShapeSpace(shape, previousPagePoint);
        const B = this.app.getPointInShapeSpace(shape, currentPagePoint);
        if (util.hitTestLineSegment(shape, A2, B)) {
          erasing.add(this.app.getOutermostSelectableShape(shape).id);
        }
      }
      this.app.setErasingIds([...erasing].filter((id) => !excludedShapeIds.has(id)));
    }
    complete() {
      this.app.deleteShapes(this.app.pageState.erasingIds);
      this.app.setErasingIds([]);
      this.parent.transition("idle", {});
    }
    cancel() {
      this.app.setErasingIds([]);
      this.app.bailToMark(this.markId);
      this.parent.transition("idle", this.info);
    }
  };
  __publicField(Erasing, "id", "erasing");

  // ../../../packages/editor/src/lib/app/statechart/TLEraserTool/children/Idle.ts
  var Idle3 = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "onPointerDown", (info) => {
        this.parent.transition("pointing", info);
      });
    }
  };
  __publicField(Idle3, "id", "idle");

  // ../../../packages/editor/src/lib/app/statechart/TLEraserTool/children/Pointing.ts
  var Pointing2 = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "onEnter", () => {
        const { inputs } = this.app;
        const erasing = /* @__PURE__ */ new Set();
        const initialSize = erasing.size;
        for (const shape of [...this.app.sortedShapesArray].reverse()) {
          if (this.app.isPointInShape(inputs.currentPagePoint, shape)) {
            if (shape.type === "group")
              continue;
            const hitShape = this.app.getOutermostSelectableShape(shape);
            if (hitShape.type === "frame" && erasing.size > initialSize)
              break;
            erasing.add(hitShape.id);
          }
        }
        this.app.setErasingIds([...erasing]);
      });
      __publicField(this, "onPointerMove", (info) => {
        if (this.app.inputs.isDragging) {
          this.parent.transition("erasing", info);
        }
      });
      __publicField(this, "onPointerUp", () => {
        this.complete();
      });
      __publicField(this, "onCancel", () => {
        this.cancel();
      });
      __publicField(this, "onComplete", () => {
        this.complete();
      });
      __publicField(this, "onInterrupt", () => {
        this.cancel();
      });
    }
    complete() {
      const { erasingIds } = this.app;
      if (erasingIds.length) {
        this.app.mark("erase end");
        this.app.deleteShapes(erasingIds);
      }
      this.app.setErasingIds([]);
      this.parent.transition("idle", {});
    }
    cancel() {
      this.app.setErasingIds([]);
      this.parent.transition("idle", {});
    }
  };
  __publicField(Pointing2, "id", "pointing");

  // ../../../packages/editor/src/lib/app/statechart/TLEraserTool/TLEraserTool.ts
  var TLEraserTool = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "onEnter", () => {
        this.app.setCursor({ type: "cross" });
      });
    }
  };
  __publicField(TLEraserTool, "id", "eraser");
  __publicField(TLEraserTool, "initial", "idle");
  __publicField(TLEraserTool, "children", () => [Idle3, Pointing2, Erasing]);

  // ../../../packages/editor/src/lib/app/statechart/TLBoxTool/children/Idle.ts
  var Idle4 = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "onPointerDown", (info) => {
        this.parent.transition("pointing", info);
      });
      __publicField(this, "onEnter", () => {
        this.app.setCursor({ type: "cross" });
      });
      __publicField(this, "onCancel", () => {
        this.app.setSelectedTool("select");
      });
    }
  };
  __publicField(Idle4, "id", "idle");

  // ../../../packages/editor/src/lib/app/statechart/TLBoxTool/children/Pointing.ts
  var Pointing3 = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "markId", "creating");
      __publicField(this, "wasFocusedOnEnter", false);
      __publicField(this, "onEnter", () => {
        const { isMenuOpen } = this.app;
        this.wasFocusedOnEnter = !isMenuOpen;
      });
      __publicField(this, "onPointerMove", (info) => {
        if (this.app.inputs.isDragging) {
          const { originPagePoint } = this.app.inputs;
          const shapeType = this.parent.shapeType;
          const id = createShapeId();
          this.app.mark(this.markId);
          this.app.createShapes([
            {
              id,
              type: shapeType,
              x: originPagePoint.x,
              y: originPagePoint.y,
              props: {
                w: 1,
                h: 1
              }
            }
          ]);
          this.app.setSelectedIds([id]);
          this.app.setSelectedTool("select.resizing", __spreadProps(__spreadValues({}, info), {
            target: "selection",
            handle: "bottom_right",
            isCreating: true,
            creationCursorOffset: { x: 1, y: 1 },
            onInteractionEnd: this.parent.id
          }));
        }
      });
      __publicField(this, "onPointerUp", () => {
        this.complete();
      });
      __publicField(this, "onCancel", () => {
        this.cancel();
      });
      __publicField(this, "onComplete", () => {
        this.complete();
      });
      __publicField(this, "onInterrupt", () => {
        this.cancel();
      });
    }
    complete() {
      const { originPagePoint } = this.app.inputs;
      if (!this.wasFocusedOnEnter) {
        return;
      }
      this.app.mark(this.markId);
      const shapeType = this.parent.shapeType;
      const id = createShapeId();
      this.app.mark(this.markId);
      this.app.createShapes([
        {
          id,
          type: shapeType,
          x: originPagePoint.x,
          y: originPagePoint.y
        }
      ]);
      const shape = this.app.getShapeById(id);
      const { w: w3, h: h3 } = this.app.getShapeUtil(shape).defaultProps();
      const delta = this.app.getDeltaInParentSpace(shape, new Vec2d(w3 / 2, h3 / 2));
      this.app.updateShapes([
        {
          id,
          type: shapeType,
          x: shape.x - delta.x,
          y: shape.y - delta.y
        }
      ]);
      this.app.setSelectedIds([id]);
      if (this.app.instanceState.isToolLocked) {
        this.parent.transition("idle", {});
      } else {
        this.app.setSelectedTool("select.idle");
      }
    }
    cancel() {
      this.parent.transition("idle", {});
    }
  };
  __publicField(Pointing3, "id", "pointing");

  // ../../../packages/editor/src/lib/app/statechart/TLBoxTool/TLBoxTool.ts
  var TLBoxTool = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "styles", ["opacity"]);
    }
  };
  __publicField(TLBoxTool, "id", "box");
  __publicField(TLBoxTool, "initial", "idle");
  __publicField(TLBoxTool, "children", () => [Idle4, Pointing3]);

  // ../../../packages/editor/src/lib/app/statechart/TLFrameTool/TLFrameTool.ts
  var TLFrameTool = class extends TLBoxTool {
    constructor() {
      super(...arguments);
      __publicField(this, "shapeType", "frame");
      __publicField(this, "styles", ["opacity"]);
    }
  };
  __publicField(TLFrameTool, "id", "frame");
  __publicField(TLFrameTool, "initial", "idle");

  // ../../../packages/editor/src/lib/app/statechart/TLGeoTool/children/Idle.ts
  var Idle5 = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "onPointerDown", (info) => {
        this.parent.transition("pointing", info);
      });
      __publicField(this, "onEnter", () => {
        this.app.setCursor({ type: "cross" });
      });
      __publicField(this, "onKeyUp", (info) => {
        if (info.key === "Enter") {
          const shape = this.app.onlySelectedShape;
          if (shape && shape.type === "geo") {
            this.app.mark("editing shape");
            this.app.setEditingId(shape.id);
            this.app.setSelectedTool("select.editing_shape", __spreadProps(__spreadValues({}, info), {
              target: "shape",
              shape
            }));
          }
        }
      });
      __publicField(this, "onCancel", () => {
        this.app.setSelectedTool("select");
      });
    }
  };
  __publicField(Idle5, "id", "idle");

  // ../../../packages/editor/src/lib/app/statechart/TLGeoTool/children/Pointing.ts
  var Pointing4 = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "onPointerMove", (info) => {
        if (this.app.inputs.isDragging) {
          const { originPagePoint } = this.app.inputs;
          const id = createShapeId();
          this.app.mark("creating");
          this.app.createShapes([
            {
              id,
              type: "geo",
              x: originPagePoint.x,
              y: originPagePoint.y,
              props: {
                w: 1,
                h: 1,
                geo: this.app.instanceState.propsForNextShape.geo
              }
            }
          ]);
          this.app.select(id);
          this.app.setSelectedTool("select.resizing", __spreadProps(__spreadValues({}, info), {
            target: "selection",
            handle: "bottom_right",
            isCreating: true,
            creationCursorOffset: { x: 1, y: 1 },
            onInteractionEnd: "geo"
          }));
        }
      });
      __publicField(this, "onPointerUp", () => {
        this.complete();
      });
      __publicField(this, "onCancel", () => {
        this.cancel();
      });
      __publicField(this, "onComplete", () => {
        this.complete();
      });
      __publicField(this, "onInterrupt", () => {
        this.cancel();
      });
    }
    complete() {
      const { originPagePoint } = this.app.inputs;
      const id = createShapeId();
      this.app.mark("creating");
      this.app.createShapes([
        {
          id,
          type: "geo",
          x: originPagePoint.x,
          y: originPagePoint.y,
          props: {
            geo: this.app.instanceState.propsForNextShape.geo,
            w: 1,
            h: 1
          }
        }
      ]);
      const shape = this.app.getShapeById(id);
      if (!shape)
        return;
      const bounds = shape.props.geo === "star" ? getStarBounds(5, 200, 200) : new Box2d(0, 0, 200, 200);
      const delta = this.app.getDeltaInParentSpace(shape, bounds.center);
      this.app.select(id);
      this.app.updateShapes([
        {
          id: shape.id,
          type: "geo",
          x: shape.x - delta.x,
          y: shape.y - delta.y,
          props: {
            geo: this.app.instanceState.propsForNextShape.geo,
            w: bounds.width,
            h: bounds.height
          }
        }
      ]);
      if (this.app.instanceState.isToolLocked) {
        this.parent.transition("idle", {});
      } else {
        this.app.setSelectedTool("select", {});
      }
    }
    cancel() {
      this.parent.transition("idle", {});
    }
  };
  __publicField(Pointing4, "id", "pointing");

  // ../../../packages/editor/src/lib/app/statechart/TLGeoTool/TLGeoTool.ts
  var TLGeoTool = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "styles", ["color", "opacity", "dash", "fill", "size", "geo", "font", "align"]);
    }
  };
  __publicField(TLGeoTool, "id", "geo");
  __publicField(TLGeoTool, "initial", "idle");
  __publicField(TLGeoTool, "children", () => [Idle5, Pointing4]);

  // ../../../packages/editor/src/lib/app/statechart/TLHandTool/children/Dragging.ts
  var Dragging = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "onEnter", () => {
        this.update();
      });
      __publicField(this, "onPointerMove", () => {
        this.update();
      });
      __publicField(this, "onPointerUp", () => {
        this.complete();
      });
      __publicField(this, "onCancel", () => {
        this.complete();
      });
      __publicField(this, "onComplete", () => {
        this.complete();
      });
    }
    update() {
      const { currentScreenPoint, previousScreenPoint } = this.app.inputs;
      const delta = Vec2d.Sub(currentScreenPoint, previousScreenPoint);
      if (Math.abs(delta.x) > 0 || Math.abs(delta.y) > 0) {
        this.app.pan(delta.x, delta.y);
      }
    }
    complete() {
      this.app.slideCamera({
        speed: Math.min(2, this.app.inputs.pointerVelocity.len()),
        direction: this.app.inputs.pointerVelocity,
        friction: HAND_TOOL_FRICTION
      });
      this.parent.transition("idle", {});
    }
  };
  __publicField(Dragging, "id", "dragging");

  // ../../../packages/editor/src/lib/app/statechart/TLHandTool/children/Idle.ts
  var Idle6 = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "onEnter", () => {
        this.app.setCursor({ type: "grab" });
      });
      __publicField(this, "onPointerDown", (info) => {
        this.parent.transition("pointing", info);
      });
      __publicField(this, "onCancel", () => {
        this.app.setSelectedTool("select");
      });
    }
  };
  __publicField(Idle6, "id", "idle");

  // ../../../packages/editor/src/lib/app/statechart/TLHandTool/children/Pointing.ts
  var Pointing5 = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "onEnter", () => {
        this.app.stopCameraAnimation();
        this.app.setCursor({ type: "grabbing" });
      });
      __publicField(this, "onPointerMove", (info) => {
        if (this.app.inputs.isDragging) {
          this.parent.transition("dragging", info);
        }
      });
      __publicField(this, "onPointerUp", () => {
        this.complete();
      });
      __publicField(this, "onCancel", () => {
        this.complete();
      });
      __publicField(this, "onComplete", () => {
        this.complete();
      });
      __publicField(this, "onInterrupt", () => {
        this.complete();
      });
    }
    complete() {
      this.parent.transition("idle", {});
    }
  };
  __publicField(Pointing5, "id", "pointing");

  // ../../../packages/editor/src/lib/app/statechart/TLHandTool/TLHandTool.ts
  var TLHandTool = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "styles", []);
      __publicField(this, "onDoubleClick", (info) => {
        if (info.phase === "settle") {
          const { currentScreenPoint } = this.app.inputs;
          this.app.zoomIn(currentScreenPoint, { duration: 220, easing: EASINGS.easeOutQuint });
        }
      });
      __publicField(this, "onTripleClick", (info) => {
        if (info.phase === "settle") {
          const { currentScreenPoint } = this.app.inputs;
          this.app.zoomOut(currentScreenPoint, { duration: 320, easing: EASINGS.easeOutQuint });
        }
      });
      __publicField(this, "onQuadrupleClick", (info) => {
        if (info.phase === "settle") {
          const {
            zoomLevel,
            inputs: { currentScreenPoint }
          } = this.app;
          if (zoomLevel === 1) {
            this.app.zoomToFit({ duration: 400, easing: EASINGS.easeOutQuint });
          } else {
            this.app.resetZoom(currentScreenPoint, { duration: 320, easing: EASINGS.easeOutQuint });
          }
        }
      });
    }
  };
  __publicField(TLHandTool, "id", "hand");
  __publicField(TLHandTool, "initial", "idle");
  __publicField(TLHandTool, "children", () => [Idle6, Pointing5, Dragging]);

  // ../../../packages/editor/src/lib/app/statechart/TLLineTool/children/Idle.ts
  var Idle7 = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "shapeId", "");
      __publicField(this, "onEnter", (info) => {
        this.shapeId = info.shapeId;
        this.app.setCursor({ type: "cross" });
      });
      __publicField(this, "onPointerDown", () => {
        this.parent.transition("pointing", { shapeId: this.shapeId });
      });
      __publicField(this, "onCancel", () => {
        this.app.setSelectedTool("select");
      });
    }
  };
  __publicField(Idle7, "id", "idle");

  // ../../../packages/editor/src/lib/app/statechart/TLLineTool/children/Pointing.ts
  var Pointing6 = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "shapeType", "");
      __publicField(this, "shape", {});
      __publicField(this, "markPointId", "");
      __publicField(this, "onEnter", (info) => {
        const { inputs } = this.app;
        const { currentPagePoint } = inputs;
        this.shapeType = this.parent.shapeType;
        this.markPointId = this.app.mark("creating");
        let shapeExists = false;
        if (info.shapeId) {
          const shape = this.app.getShapeById(info.shapeId);
          if (shape) {
            shapeExists = true;
            this.shape = shape;
          }
        }
        if (inputs.shiftKey && shapeExists) {
          const handles = this.app.getShapeUtil(this.shape).handles(this.shape);
          const vertexHandles = handles.filter((h3) => h3.type === "vertex").sort(sortByIndex2);
          const endHandle = vertexHandles[vertexHandles.length - 1];
          const shapePagePoint = Matrix2d.applyToPoint(
            this.app.getParentTransform(this.shape),
            new Vec2d(this.shape.x, this.shape.y)
          );
          let nextEndHandleIndex, nextEndHandleId, nextEndHandle;
          if (vertexHandles.length === 2 && vertexHandles[1].x === 1 && vertexHandles[1].y === 1) {
            nextEndHandleIndex = vertexHandles[1].index;
            nextEndHandleId = vertexHandles[1].id;
            nextEndHandle = __spreadProps(__spreadValues({}, vertexHandles[1]), {
              x: currentPagePoint.x - shapePagePoint.x,
              y: currentPagePoint.y - shapePagePoint.y
            });
          } else {
            nextEndHandleIndex = getIndexAbove(endHandle.index);
            nextEndHandleId = "handle:" + nextEndHandleIndex;
            nextEndHandle = {
              x: currentPagePoint.x - shapePagePoint.x,
              y: currentPagePoint.y - shapePagePoint.y,
              index: nextEndHandleIndex,
              canBind: false,
              type: "vertex",
              id: nextEndHandleId
            };
          }
          const nextHandles = structuredClone(this.shape.props.handles);
          nextHandles[nextEndHandle.id] = nextEndHandle;
          this.app.updateShapes([
            {
              id: this.shape.id,
              type: this.shape.type,
              props: {
                handles: nextHandles
              }
            }
          ]);
        } else {
          const id = createShapeId();
          this.app.createShapes([
            {
              id,
              type: this.shapeType,
              x: currentPagePoint.x,
              y: currentPagePoint.y
            }
          ]);
          this.app.select(id);
          this.shape = this.app.getShapeById(id);
        }
      });
      __publicField(this, "onPointerMove", () => {
        var _a5;
        if (!this.shape)
          return;
        if (this.app.inputs.isDragging) {
          const util = this.app.getShapeUtil(this.shape);
          const handles = (_a5 = util.handles) == null ? void 0 : _a5.call(util, this.shape);
          if (!handles) {
            this.app.bailToMark("creating");
            throw Error("No handles found");
          }
          this.app.setSelectedTool("select.dragging_handle", {
            shape: this.shape,
            isCreating: true,
            handle: last(handles),
            onInteractionEnd: "line"
          });
        }
      });
      __publicField(this, "onPointerUp", () => {
        this.complete();
      });
      __publicField(this, "onCancel", () => {
        this.cancel();
      });
      __publicField(this, "onComplete", () => {
        this.complete();
      });
      __publicField(this, "onInterrupt", () => {
        this.parent.transition("idle", {});
        this.app.bailToMark("creating");
        this.app.snaps.clear();
      });
    }
    complete() {
      this.parent.transition("idle", { shapeId: this.shape.id });
      this.app.snaps.clear();
    }
    cancel() {
      this.app.bailToMark(this.markPointId);
      this.parent.transition("idle", { shapeId: this.shape.id });
      this.app.snaps.clear();
    }
  };
  __publicField(Pointing6, "id", "pointing");

  // ../../../packages/editor/src/lib/app/statechart/TLLineTool/TLLineTool.ts
  var TLLineTool = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "shapeType", "line");
      __publicField(this, "styles", ["color", "opacity", "dash", "size", "spline"]);
    }
  };
  __publicField(TLLineTool, "id", "line");
  __publicField(TLLineTool, "initial", "idle");
  __publicField(TLLineTool, "children", () => [Idle7, Pointing6]);

  // ../../../packages/editor/src/lib/app/statechart/TLNoteTool/children/Idle.ts
  var Idle8 = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "onPointerDown", (info) => {
        this.parent.transition("pointing", info);
      });
      __publicField(this, "onEnter", () => {
        this.app.setCursor({ type: "cross" });
      });
      __publicField(this, "onCancel", () => {
        this.app.setSelectedTool("select");
      });
    }
  };
  __publicField(Idle8, "id", "idle");

  // ../../../packages/editor/src/lib/app/statechart/TLNoteTool/children/Pointing.ts
  var Pointing7 = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "dragged", false);
      __publicField(this, "info", {});
      __publicField(this, "wasFocusedOnEnter", false);
      __publicField(this, "markPointId", "creating");
      __publicField(this, "onEnter", () => {
        this.wasFocusedOnEnter = !this.app.isMenuOpen;
      });
      __publicField(this, "onPointerMove", (info) => {
        if (this.app.inputs.isDragging) {
          this.app.mark(this.markPointId);
          const shape = this.createShape();
          if (!shape)
            return;
          this.app.setSelectedTool("select.translating", __spreadProps(__spreadValues({}, info), {
            target: "shape",
            shape,
            isCreating: true,
            editAfterComplete: true,
            onInteractionEnd: "note"
          }));
        }
      });
      __publicField(this, "onPointerUp", () => {
        this.complete();
      });
      __publicField(this, "onInterrupt", () => {
        this.cancel();
      });
      __publicField(this, "onComplete", () => {
        this.complete();
      });
      __publicField(this, "onCancel", () => {
        this.cancel();
      });
    }
    complete() {
      if (!this.wasFocusedOnEnter) {
        return;
      }
      this.app.mark(this.markPointId);
      const shape = this.createShape();
      if (this.app.instanceState.isToolLocked) {
        this.parent.transition("idle", {});
      } else {
        if (!shape)
          return;
        this.app.setEditingId(shape.id);
        this.app.setSelectedTool("select.editing_shape", __spreadProps(__spreadValues({}, this.info), {
          target: "shape",
          shape
        }));
      }
    }
    cancel() {
      this.app.bailToMark(this.markPointId);
      this.parent.transition("idle", this.info);
    }
    createShape() {
      const {
        inputs: { originPagePoint }
      } = this.app;
      const id = this.app.createShapeId();
      this.app.createShapes(
        [
          {
            id,
            type: "note",
            x: originPagePoint.x,
            y: originPagePoint.y
          }
        ],
        true
      );
      const util = this.app.getShapeUtilByDef(TLNoteShapeDef);
      const shape = this.app.getShapeById(id);
      assert(TLNoteShapeDef.is(shape));
      const bounds = util.bounds(shape);
      this.app.updateShapes([
        {
          id,
          type: "note",
          x: shape.x - bounds.width / 2,
          y: shape.y - bounds.height / 2
        }
      ]);
      return this.app.getShapeById(id);
    }
  };
  __publicField(Pointing7, "id", "pointing");

  // ../../../packages/editor/src/lib/app/statechart/TLNoteTool/TLNoteTool.ts
  var TLNoteTool = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "styles", ["color", "opacity", "size", "align", "font"]);
    }
  };
  __publicField(TLNoteTool, "id", "note");
  __publicField(TLNoteTool, "initial", "idle");
  __publicField(TLNoteTool, "children", () => [Idle8, Pointing7]);

  // ../../../packages/editor/src/lib/app/statechart/TLSelectTool/children/Brushing.ts
  var Brushing = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "info", {});
      __publicField(this, "brush", new Box2d());
      __publicField(this, "initialSelectedIds", []);
      // The shape that the brush started on
      __publicField(this, "initialStartShape", null);
      __publicField(this, "onEnter", (info) => {
        const { altKey: altKey2, currentPagePoint } = this.app.inputs;
        if (altKey2) {
          this.parent.transition("scribble_brushing", info);
          return;
        }
        this.info = info;
        this.initialSelectedIds = this.app.selectedIds.slice();
        this.initialStartShape = this.app.getShapesAtPoint(currentPagePoint)[0];
        this.onPointerMove();
      });
      __publicField(this, "onExit", () => {
        this.initialSelectedIds = [];
        this.app.setBrush(null);
      });
      __publicField(this, "onPointerMove", () => {
        this.hitTestShapes();
      });
      __publicField(this, "onPointerUp", () => {
        this.complete();
      });
      __publicField(this, "onComplete", () => {
        this.complete();
      });
      __publicField(this, "onCancel", (info) => {
        this.app.setSelectedIds(this.initialSelectedIds, true);
        this.parent.transition("idle", info);
      });
      __publicField(this, "onKeyDown", (info) => {
        if (this.app.inputs.altKey) {
          this.parent.transition("scribble_brushing", info);
        } else {
          this.hitTestShapes();
        }
      });
      __publicField(this, "onKeyUp", () => {
        this.hitTestShapes();
      });
      __publicField(this, "onInterrupt", () => {
        this.app.setBrush(null);
      });
    }
    complete() {
      this.parent.transition("idle", {});
    }
    hitTestShapes() {
      const {
        currentPageId,
        shapesArray,
        inputs: { originPagePoint, currentPagePoint, shiftKey, ctrlKey }
      } = this.app;
      this.brush.setTo(Box2d.FromPoints([originPagePoint, currentPagePoint]));
      const results = new Set(shiftKey ? this.initialSelectedIds : []);
      let A2, B, shape, util, pageBounds, pageTransform, localCorners;
      const { corners } = this.brush;
      testAllShapes:
        for (let i3 = 0, n3 = shapesArray.length; i3 < n3; i3++) {
          shape = shapesArray[i3];
          if (shape.type === "group")
            continue testAllShapes;
          if (results.has(shape.id))
            continue testAllShapes;
          pageBounds = this.app.getPageBounds(shape);
          if (!pageBounds)
            continue testAllShapes;
          if (this.brush.contains(pageBounds)) {
            this.handleHit(shape, currentPagePoint, currentPageId, results, corners);
            continue testAllShapes;
          }
          if (ctrlKey || shape.type === "frame") {
            continue testAllShapes;
          }
          if (this.brush.collides(pageBounds)) {
            util = this.app.getShapeUtil(shape);
            pageTransform = this.app.getPageTransform(shape);
            if (!pageTransform) {
              continue testAllShapes;
            }
            localCorners = Matrix2d.applyToPoints(Matrix2d.Inverse(pageTransform), corners);
            hitTestBrushEdges:
              for (let i4 = 0; i4 < localCorners.length; i4++) {
                A2 = localCorners[i4];
                B = localCorners[(i4 + 1) % localCorners.length];
                if (util.hitTestLineSegment(shape, A2, B)) {
                  this.handleHit(shape, currentPagePoint, currentPageId, results, corners);
                  break hitTestBrushEdges;
                }
              }
          }
        }
      this.app.setBrush(__spreadValues({}, this.brush.toJson()));
      this.app.setSelectedIds(Array.from(results), true);
    }
    handleHit(shape, currentPagePoint, currentPageId, results, corners) {
      if (shape.parentId === currentPageId) {
        results.add(shape.id);
        return;
      }
      const selectedShape = this.app.getOutermostSelectableShape(shape);
      const pageMask = this.app.getPageMaskById(selectedShape.id);
      if (pageMask && polygonsIntersect(pageMask, corners) !== null && !pointInPolygon(currentPagePoint, pageMask)) {
        return;
      }
      results.add(selectedShape.id);
    }
  };
  __publicField(Brushing, "id", "brushing");

  // ../../../packages/editor/src/lib/app/statechart/TLSelectTool/children/Crop/children/crop_helpers.ts
  function getTranslateCroppedImageChange(app, shape, delta) {
    if (!shape) {
      throw Error("Needs to translate a cropped shape!");
    }
    const { crop: oldCrop } = shape.props;
    if (!oldCrop) {
      return;
    }
    const flatten = app.inputs.shiftKey ? Math.abs(delta.x) < Math.abs(delta.y) ? "x" : "y" : null;
    if (flatten === "x") {
      delta.x = 0;
    } else if (flatten === "y") {
      delta.y = 0;
    }
    delta.rot(-shape.rotation);
    const w3 = 1 / (oldCrop.bottomRight.x - oldCrop.topLeft.x) * shape.props.w;
    const h3 = 1 / (oldCrop.bottomRight.y - oldCrop.topLeft.y) * shape.props.h;
    const yCrop = oldCrop.bottomRight.y - oldCrop.topLeft.y;
    const xCrop = oldCrop.bottomRight.x - oldCrop.topLeft.x;
    const newCrop = deepCopy(oldCrop);
    newCrop.topLeft.x = Math.min(1 - xCrop, Math.max(0, newCrop.topLeft.x - delta.x / w3));
    newCrop.topLeft.y = Math.min(1 - yCrop, Math.max(0, newCrop.topLeft.y - delta.y / h3));
    newCrop.bottomRight.x = newCrop.topLeft.x + xCrop;
    newCrop.bottomRight.y = newCrop.topLeft.y + yCrop;
    const partial = {
      id: shape.id,
      type: shape.type,
      props: {
        crop: newCrop
      }
    };
    return partial;
  }

  // ../../../packages/editor/src/lib/app/statechart/TLSelectTool/children/Crop/children/Idle.ts
  var Idle9 = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "onEnter", () => {
        this.app.setCursor({ type: "default" });
        const { onlySelectedShape } = this.app;
        this.app.on("change-history", this.cleanupCroppingState);
        this.app.mark("crop");
        if (onlySelectedShape) {
          this.app.setCroppingId(onlySelectedShape.id);
        }
      });
      __publicField(this, "onExit", () => {
        this.app.setCursor({ type: "default" });
        this.app.off("change-history", this.cleanupCroppingState);
      });
      __publicField(this, "onCancel", () => {
        this.app.setCroppingId(null);
        this.app.setSelectedTool("select.idle", {});
      });
      __publicField(this, "onPointerDown", (info) => {
        var _a5;
        if (this.app.isMenuOpen)
          return;
        if (info.ctrlKey) {
          this.app.setCroppingId(null);
          this.app.setSelectedTool("select.brushing", info);
          return;
        }
        switch (info.target) {
          case "canvas": {
            this.cancel();
            break;
          }
          case "shape": {
            if (info.shape.id === this.app.croppingId) {
              this.app.setSelectedTool("select.crop.pointing_crop", info);
              return;
            } else {
              if ((_a5 = this.app.getShapeUtil(info.shape)) == null ? void 0 : _a5.canCrop(info.shape)) {
                this.app.setCroppingId(info.shape.id);
                this.app.setSelectedIds([info.shape.id]);
                this.app.setSelectedTool("select.crop.pointing_crop", info);
              } else {
                this.cancel();
              }
            }
            break;
          }
          case "selection": {
            switch (info.handle) {
              case "mobile_rotate":
              case "top_left_rotate":
              case "top_right_rotate":
              case "bottom_left_rotate":
              case "bottom_right_rotate": {
                this.app.setSelectedTool("select.pointing_rotate_handle", __spreadProps(__spreadValues({}, info), {
                  onInteractionEnd: "select.crop"
                }));
                break;
              }
              case "top":
              case "right":
              case "bottom":
              case "left": {
                this.app.setSelectedTool("select.pointing_crop_handle", __spreadProps(__spreadValues({}, info), {
                  onInteractionEnd: "select.crop"
                }));
                break;
              }
              case "top_left":
              case "top_right":
              case "bottom_left":
              case "bottom_right": {
                this.app.setSelectedTool("select.pointing_crop_handle", __spreadProps(__spreadValues({}, info), {
                  onInteractionEnd: "select.crop"
                }));
                break;
              }
              default: {
                this.cancel();
              }
            }
            break;
          }
        }
      });
      __publicField(this, "onDoubleClick", (info) => {
        var _a5;
        if (info.phase !== "up")
          return;
        if (!this.app.croppingId)
          return;
        const shape = this.app.getShapeById(this.app.croppingId);
        if (!shape)
          return;
        const util = this.app.getShapeUtil(shape);
        if (!util)
          return;
        if (info.target === "selection") {
          (_a5 = util.onDoubleClickEdge) == null ? void 0 : _a5.call(util, shape);
        }
      });
      __publicField(this, "onKeyDown", () => {
        this.nudgeCroppingImage(false);
      });
      __publicField(this, "onKeyRepeat", () => {
        this.nudgeCroppingImage(true);
      });
      __publicField(this, "onKeyUp", (info) => {
        switch (info.code) {
          case "Enter": {
            this.app.setCroppingId(null);
            this.app.setSelectedTool("select.idle", {});
            break;
          }
        }
      });
      __publicField(this, "cleanupCroppingState", () => {
        if (!this.app.croppingId) {
          this.app.setSelectedTool("select.idle", {});
        }
      });
    }
    cancel() {
      this.app.setCroppingId(null);
      this.app.setSelectedTool("select.idle", {});
    }
    nudgeCroppingImage(ephemeral = false) {
      const {
        app: {
          inputs: { keys }
        }
      } = this;
      const shiftKey = keys.has("Shift");
      const delta = new Vec2d(0, 0);
      if (keys.has("ArrowLeft"))
        delta.x += 1;
      if (keys.has("ArrowRight"))
        delta.x -= 1;
      if (keys.has("ArrowUp"))
        delta.y += 1;
      if (keys.has("ArrowDown"))
        delta.y -= 1;
      if (delta.equals(new Vec2d(0, 0)))
        return;
      if (shiftKey)
        delta.mul(10);
      const shape = this.app.getShapeById(this.app.croppingId);
      if (!shape)
        return;
      const partial = getTranslateCroppedImageChange(this.app, shape, delta);
      if (partial) {
        if (!ephemeral) {
          this.app.mark("translate crop");
        }
        this.app.updateShapes([partial]);
      }
    }
  };
  __publicField(Idle9, "id", "idle");

  // ../../../packages/editor/src/lib/app/statechart/TLSelectTool/children/Crop/children/PointingCrop.ts
  var PointingCrop = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "onCancel", () => {
        this.app.setSelectedTool("select.crop.idle", {});
      });
      __publicField(this, "onPointerMove", (info) => {
        if (this.app.inputs.isDragging) {
          this.app.setSelectedTool("select.crop.translating_crop", info);
        }
      });
      __publicField(this, "onPointerUp", (info) => {
        this.app.setSelectedTool("select.crop.idle", info);
      });
    }
  };
  __publicField(PointingCrop, "id", "pointing_crop");

  // ../../../packages/editor/src/lib/app/statechart/TLSelectTool/children/Crop/children/TranslatingCrop.ts
  var TranslatingCrop = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "info", {});
      __publicField(this, "markId", "translating crop");
      __publicField(this, "snapshot", {});
      __publicField(this, "onEnter", (info) => {
        this.info = info;
        this.snapshot = this.createSnapshot();
        this.app.mark(this.markId);
        this.app.setCursor({ type: "move" });
        this.updateShapes();
      });
      __publicField(this, "onExit", () => {
        this.app.setCursor({ type: "default" });
      });
      __publicField(this, "onPointerMove", () => {
        this.updateShapes();
      });
      __publicField(this, "onPointerUp", () => {
        this.complete();
      });
      __publicField(this, "onComplete", () => {
        this.complete();
      });
      __publicField(this, "onCancel", () => {
        this.cancel();
      });
      __publicField(this, "onKeyDown", (info) => {
        switch (info.key) {
          case "Alt":
          case "Shift": {
            this.updateShapes();
            return;
          }
        }
      });
      __publicField(this, "onKeyUp", (info) => {
        switch (info.key) {
          case "Enter": {
            this.complete();
            return;
          }
          case "Alt":
          case "Shift": {
            this.updateShapes();
          }
        }
      });
    }
    complete() {
      this.updateShapes();
      this.app.setSelectedTool("select.crop.idle", this.info);
    }
    cancel() {
      this.app.bailToMark(this.markId);
      this.app.setSelectedTool("select.crop.idle", this.info);
    }
    createSnapshot() {
      const shape = this.app.onlySelectedShape;
      return { shape };
    }
    updateShapes() {
      const shape = this.snapshot.shape;
      if (!shape)
        return;
      const { originPagePoint, currentPagePoint } = this.app.inputs;
      const delta = currentPagePoint.clone().sub(originPagePoint);
      const partial = getTranslateCroppedImageChange(this.app, shape, delta);
      if (partial) {
        this.app.updateShapes([partial], true);
      }
    }
  };
  __publicField(TranslatingCrop, "id", "translating_crop");

  // ../../../packages/editor/src/lib/app/statechart/TLSelectTool/children/Crop/Crop.ts
  var Crop = class extends StateNode {
  };
  __publicField(Crop, "id", "crop");
  __publicField(Crop, "initial", "idle");
  __publicField(Crop, "children", () => [Idle9, TranslatingCrop, PointingCrop]);

  // ../../../packages/editor/src/lib/app/statechart/TLSelectTool/children/PointingResizeHandle.ts
  var CursorTypeMap = {
    bottom: "ns-resize",
    top: "ns-resize",
    left: "ew-resize",
    right: "ew-resize",
    bottom_left: "nesw-resize",
    bottom_right: "nwse-resize",
    top_left: "nwse-resize",
    top_right: "nesw-resize",
    bottom_left_rotate: "swne-rotate",
    bottom_right_rotate: "senw-rotate",
    top_left_rotate: "nwse-rotate",
    top_right_rotate: "nesw-rotate",
    mobile_rotate: "grabbing"
  };
  var PointingResizeHandle = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "info", {});
      __publicField(this, "onEnter", (info) => {
        this.info = info;
        this.updateCursor();
      });
      __publicField(this, "onPointerMove", () => {
        const isDragging = this.app.inputs.isDragging;
        if (isDragging) {
          this.parent.transition("resizing", this.info);
        }
      });
      __publicField(this, "onPointerUp", () => {
        this.complete();
      });
      // override onPinchStart: TLEventHandlers['onPinchStart'] = (info) => {
      // 	this.parent.transition('pinching', info)
      // }
      __publicField(this, "onCancel", () => {
        this.cancel();
      });
      __publicField(this, "onComplete", () => {
        this.cancel();
      });
      __publicField(this, "onInterrupt", () => {
        this.cancel();
      });
    }
    updateCursor() {
      const selected = this.app.selectedShapes;
      const cursorType = CursorTypeMap[this.info.handle];
      this.app.setCursor({
        type: cursorType,
        rotation: selected.length === 1 ? selected[0].rotation : 0
      });
    }
    complete() {
      if (this.info.onInteractionEnd) {
        this.app.setSelectedTool(this.info.onInteractionEnd, {});
      } else {
        this.parent.transition("idle", {});
      }
    }
    cancel() {
      if (this.info.onInteractionEnd) {
        this.app.setSelectedTool(this.info.onInteractionEnd, {});
      } else {
        this.parent.transition("idle", {});
      }
    }
  };
  __publicField(PointingResizeHandle, "id", "pointing_resize_handle");

  // ../../../packages/editor/src/lib/app/statechart/TLSelectTool/children/Cropping.ts
  var Cropping = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "info", {});
      __publicField(this, "markId", "");
      __publicField(this, "snapshot", {});
      __publicField(this, "onEnter", (info) => {
        this.info = info;
        this.markId = this.app.mark("cropping");
        this.snapshot = this.createSnapshot();
        this.updateShapes();
      });
      __publicField(this, "onPointerMove", () => {
        this.updateShapes();
      });
      __publicField(this, "onPointerUp", () => {
        this.complete();
      });
      __publicField(this, "onComplete", () => {
        this.complete();
      });
      __publicField(this, "onCancel", () => {
        this.cancel();
      });
      __publicField(this, "getDefaultCrop", () => ({
        topLeft: { x: 0, y: 0 },
        bottomRight: { x: 1, y: 1 }
      }));
    }
    updateCursor() {
      const selectedShape = this.app.selectedShapes[0];
      if (!selectedShape)
        return;
      const cursorType = CursorTypeMap[this.info.handle];
      this.app.setCursor({
        type: cursorType,
        rotation: selectedShape.rotation
      });
    }
    updateShapes() {
      var _a5;
      const { shape, cursorHandleOffset } = this.snapshot;
      if (!shape)
        return;
      const util = this.app.getShapeUtil(shape);
      if (!util)
        return;
      const props = shape.props;
      const currentPagePoint = this.app.inputs.currentPagePoint.clone().sub(cursorHandleOffset);
      const originPagePoint = this.app.inputs.originPagePoint.clone().sub(cursorHandleOffset);
      const change = currentPagePoint.clone().sub(originPagePoint).rot(-shape.rotation);
      const crop = (_a5 = props.crop) != null ? _a5 : this.getDefaultCrop();
      const newCrop = deepCopy(crop);
      const newPoint = new Vec2d(shape.x, shape.y);
      const pointDelta = new Vec2d(0, 0);
      const w3 = 1 / (crop.bottomRight.x - crop.topLeft.x) * props.w;
      const h3 = 1 / (crop.bottomRight.y - crop.topLeft.y) * props.h;
      let hasCropChanged = false;
      switch (this.info.handle) {
        case "top":
        case "top_left":
        case "top_right": {
          if (h3 < MIN_CROP_SIZE)
            break;
          hasCropChanged = true;
          newCrop.topLeft.y = newCrop.topLeft.y + change.y / h3;
          const heightAfterCrop = h3 * (newCrop.bottomRight.y - newCrop.topLeft.y);
          if (heightAfterCrop < MIN_CROP_SIZE) {
            newCrop.topLeft.y = newCrop.bottomRight.y - MIN_CROP_SIZE / h3;
            pointDelta.y = (newCrop.topLeft.y - crop.topLeft.y) * h3;
          } else {
            if (newCrop.topLeft.y <= 0) {
              newCrop.topLeft.y = 0;
              pointDelta.y = (newCrop.topLeft.y - crop.topLeft.y) * h3;
            } else {
              pointDelta.y = change.y;
            }
          }
          break;
        }
        case "bottom":
        case "bottom_left":
        case "bottom_right": {
          if (h3 < MIN_CROP_SIZE)
            break;
          hasCropChanged = true;
          newCrop.bottomRight.y = Math.min(1, newCrop.bottomRight.y + change.y / h3);
          const heightAfterCrop = h3 * (newCrop.bottomRight.y - newCrop.topLeft.y);
          if (heightAfterCrop < MIN_CROP_SIZE) {
            newCrop.bottomRight.y = newCrop.topLeft.y + MIN_CROP_SIZE / h3;
          }
          break;
        }
      }
      switch (this.info.handle) {
        case "left":
        case "top_left":
        case "bottom_left": {
          if (w3 < MIN_CROP_SIZE)
            break;
          hasCropChanged = true;
          newCrop.topLeft.x = newCrop.topLeft.x + change.x / w3;
          const widthAfterCrop = w3 * (newCrop.bottomRight.x - newCrop.topLeft.x);
          if (widthAfterCrop < MIN_CROP_SIZE) {
            newCrop.topLeft.x = newCrop.bottomRight.x - MIN_CROP_SIZE / w3;
            pointDelta.x = (newCrop.topLeft.x - crop.topLeft.x) * w3;
          } else {
            if (newCrop.topLeft.x <= 0) {
              newCrop.topLeft.x = 0;
              pointDelta.x = (newCrop.topLeft.x - crop.topLeft.x) * w3;
            } else {
              pointDelta.x = change.x;
            }
          }
          break;
        }
        case "right":
        case "top_right":
        case "bottom_right": {
          if (w3 < MIN_CROP_SIZE)
            break;
          hasCropChanged = true;
          newCrop.bottomRight.x = Math.min(1, newCrop.bottomRight.x + change.x / w3);
          const widthAfterCrop = w3 * (newCrop.bottomRight.x - newCrop.topLeft.x);
          if (widthAfterCrop < MIN_CROP_SIZE) {
            newCrop.bottomRight.x = newCrop.topLeft.x + MIN_CROP_SIZE / w3;
          }
          break;
        }
      }
      if (!hasCropChanged)
        return;
      newPoint.add(pointDelta.rot(shape.rotation));
      const partial = {
        id: shape.id,
        type: shape.type,
        x: newPoint.x,
        y: newPoint.y,
        props: {
          crop: newCrop,
          w: (newCrop.bottomRight.x - newCrop.topLeft.x) * w3,
          h: (newCrop.bottomRight.y - newCrop.topLeft.y) * h3
        }
      };
      this.app.updateShapes([partial], true);
      this.updateCursor();
    }
    complete() {
      if (this.info.onInteractionEnd) {
        this.app.setSelectedTool(this.info.onInteractionEnd, this.info);
      } else {
        this.app.setCroppingId(null);
        this.parent.transition("idle", {});
      }
    }
    cancel() {
      this.app.bailToMark(this.markId);
      if (this.info.onInteractionEnd) {
        this.app.setSelectedTool(this.info.onInteractionEnd, this.info);
      } else {
        this.app.setCroppingId(null);
        this.parent.transition("idle", {});
      }
    }
    createSnapshot() {
      const {
        selectionRotation,
        inputs: { originPagePoint }
      } = this.app;
      const shape = this.app.onlySelectedShape;
      const selectionBounds = this.app.selectionBounds;
      const dragHandlePoint = Vec2d.RotWith(
        selectionBounds.getHandlePoint(this.info.handle),
        selectionBounds.point,
        selectionRotation
      );
      const cursorHandleOffset = Vec2d.Sub(originPagePoint, dragHandlePoint);
      return {
        shape,
        cursorHandleOffset
      };
    }
  };
  __publicField(Cropping, "id", "cropping");

  // ../../../packages/editor/src/lib/app/statechart/TLSelectTool/children/DraggingHandle.ts
  var DraggingHandle = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "shapeId", "");
      __publicField(this, "initialHandle", {});
      __publicField(this, "initialAdjacentHandle", null);
      __publicField(this, "markId", "");
      __publicField(this, "initialPageTransform");
      __publicField(this, "initialPageRotation");
      __publicField(this, "info", {});
      __publicField(this, "isPrecise", false);
      __publicField(this, "isPreciseId", null);
      __publicField(this, "pointingId", null);
      __publicField(this, "onEnter", (info) => {
        const { shape, isCreating, handle } = info;
        this.info = info;
        this.shapeId = shape.id;
        this.markId = isCreating ? "creating" : this.app.mark("dragging handle");
        this.initialHandle = deepCopy(handle);
        this.initialPageTransform = this.app.getPageTransform(shape);
        this.initialPageRotation = this.app.getPageRotation(shape);
        this.app.setCursor({ type: isCreating ? "cross" : "grabbing", rotation: 0 });
        const handles = this.app.getShapeUtil(shape).handles(shape).sort(sortByIndex2);
        const index2 = handles.findIndex((h3) => h3.id === info.handle.id);
        this.initialAdjacentHandle = null;
        for (let i3 = index2 + 1; i3 < handles.length; i3++) {
          const handle2 = handles[i3];
          if (handle2.type === "vertex" && handle2.id !== "middle" && handle2.id !== info.handle.id) {
            this.initialAdjacentHandle = handle2;
            break;
          }
        }
        if (!this.initialAdjacentHandle) {
          for (let i3 = handles.length - 1; i3 >= 0; i3--) {
            const handle2 = handles[i3];
            if (handle2.type === "vertex" && handle2.id !== "middle" && handle2.id !== info.handle.id) {
              this.initialAdjacentHandle = handle2;
              break;
            }
          }
        }
        const initialTerminal = shape.props[info.handle.id];
        this.isPrecise = false;
        if ((initialTerminal == null ? void 0 : initialTerminal.type) === "binding") {
          this.app.setHintingIds([initialTerminal.boundShapeId]);
          this.isPrecise = !Vec2d.Equals(initialTerminal.normalizedAnchor, { x: 0.5, y: 0.5 });
          if (this.isPrecise) {
            this.isPreciseId = initialTerminal.boundShapeId;
          } else {
            this.resetExactTimeout();
          }
        }
        this.update();
      });
      __publicField(this, "exactTimeout", -1);
      __publicField(this, "onPointerMove", () => {
        this.update();
      });
      __publicField(this, "onKeyDown", () => {
        this.update();
      });
      __publicField(this, "onKeyUp", () => {
        this.update();
      });
      __publicField(this, "onPointerUp", () => {
        this.complete();
      });
      __publicField(this, "onComplete", () => {
        this.complete();
      });
      __publicField(this, "onCancel", () => {
        this.cancel();
      });
      __publicField(this, "onExit", () => {
        this.app.setHintingIds([]);
        this.app.snaps.clear();
        this.app.setCursor({ type: "default" });
      });
    }
    resetExactTimeout() {
      if (this.exactTimeout !== -1) {
        this.clearExactTimeout();
      }
      this.exactTimeout = setTimeout(() => {
        if (this.isActive && !this.isPrecise) {
          this.isPrecise = true;
          this.isPreciseId = this.pointingId;
          this.update();
        }
        this.exactTimeout = -1;
      }, 750);
    }
    clearExactTimeout() {
      if (this.exactTimeout !== -1) {
        clearTimeout(this.exactTimeout);
        this.exactTimeout = -1;
      }
    }
    complete() {
      this.app.snaps.clear();
      const { onInteractionEnd } = this.info;
      if (this.app.instanceState.isToolLocked && onInteractionEnd) {
        this.app.setSelectedTool(onInteractionEnd, { shapeId: this.shapeId });
        return;
      }
      this.parent.transition("idle", {});
    }
    cancel() {
      this.app.bailToMark(this.markId);
      this.app.snaps.clear();
      const { onInteractionEnd } = this.info;
      if (onInteractionEnd) {
        this.app.setSelectedTool(onInteractionEnd, { shapeId: this.shapeId });
        return;
      }
      this.parent.transition("idle", {});
    }
    update() {
      var _a5;
      const { currentPagePoint, originPagePoint, shiftKey } = this.app.inputs;
      const shape = this.app.getShapeById(this.shapeId);
      if (!shape)
        return;
      let point2 = Vec2d.Add(
        Vec2d.Rot(Vec2d.Sub(currentPagePoint, originPagePoint), -this.initialPageRotation),
        this.initialHandle
      );
      if (shiftKey && this.initialHandle.id !== "middle") {
        const { initialAdjacentHandle } = this;
        if (initialAdjacentHandle) {
          const angle = Vec2d.Angle(initialAdjacentHandle, point2);
          const snappedAngle = snapAngle(angle, 24);
          const angleDifference = snappedAngle - angle;
          point2 = Vec2d.RotWith(point2, initialAdjacentHandle, angleDifference);
        }
      }
      this.app.snaps.clear();
      const { ctrlKey } = this.app.inputs;
      const shouldSnap = this.app.userDocumentSettings.isSnapMode ? !ctrlKey : ctrlKey;
      if (shouldSnap && shape.type === "line") {
        const pagePoint = Matrix2d.applyToPoint(this.app.getPageTransformById(shape.id), point2);
        const snapData = this.app.snaps.snapLineHandleTranslate({
          lineId: shape.id,
          handleId: this.initialHandle.id,
          handlePoint: pagePoint
        });
        const { nudge } = snapData;
        if (nudge.x || nudge.y) {
          const shapeSpaceNudge = this.app.getDeltaInShapeSpace(shape, nudge);
          point2 = Vec2d.Add(point2, shapeSpaceNudge);
        }
      }
      const util = this.app.getShapeUtil(shape);
      const changes = (_a5 = util.onHandleChange) == null ? void 0 : _a5.call(util, shape, {
        handle: __spreadProps(__spreadValues({}, this.initialHandle), {
          x: point2.x,
          y: point2.y
        }),
        isPrecise: this.isPrecise || this.app.inputs.altKey
      });
      const next = __spreadValues(__spreadValues({}, shape), changes);
      if (this.initialHandle.canBind) {
        const bindingAfter = next.props[this.initialHandle.id];
        if ((bindingAfter == null ? void 0 : bindingAfter.type) === "binding") {
          if (this.app.hintingIds[0] !== bindingAfter.boundShapeId) {
            this.app.setHintingIds([bindingAfter.boundShapeId]);
            this.pointingId = bindingAfter.boundShapeId;
            this.isPrecise = this.app.inputs.pointerVelocity.len() < 0.5 || this.app.inputs.altKey;
            this.isPreciseId = this.isPrecise ? bindingAfter.boundShapeId : null;
            this.resetExactTimeout();
          }
        } else {
          if (this.app.hintingIds.length > 0) {
            this.app.setHintingIds([]);
            this.pointingId = null;
            this.isPrecise = false;
            this.isPreciseId = null;
            this.resetExactTimeout();
          }
        }
      }
      if (changes) {
        this.app.updateShapes([next], true);
      }
    }
  };
  __publicField(DraggingHandle, "id", "dragging_handle");

  // ../../../packages/editor/src/lib/app/statechart/TLSelectTool/children/EditingShape.ts
  var EditingShape = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "onPointerEnter", (info) => {
        switch (info.target) {
          case "shape": {
            const { selectedIds, focusLayerId } = this.app;
            const hoveringShape = this.app.getOutermostSelectableShape(
              info.shape,
              (parent) => !selectedIds.includes(parent.id)
            );
            if (hoveringShape.id !== focusLayerId) {
              this.app.setHoveredId(hoveringShape.id);
            }
            break;
          }
        }
      });
      __publicField(this, "onPointerLeave", (info) => {
        switch (info.target) {
          case "shape": {
            this.app.setHoveredId(null);
            break;
          }
        }
      });
      __publicField(this, "onExit", () => {
        var _a5;
        if (!this.app.pageState.editingId)
          return;
        const { editingId } = this.app.pageState;
        if (!editingId)
          return;
        this.app.setEditingId(null);
        const shape = this.app.getShapeById(editingId);
        const util = this.app.getShapeUtil(shape);
        (_a5 = util.onEditEnd) == null ? void 0 : _a5.call(util, shape);
      });
      __publicField(this, "onPointerDown", (info) => {
        var _a5, _b2, _c, _d;
        switch (info.target) {
          case "shape": {
            const { shape } = info;
            const { editingId } = this.app.pageState;
            if (editingId) {
              if (shape.id === editingId) {
                return;
              }
              const editingShape = this.app.getShapeById(editingId);
              if (editingShape) {
                const editingShapeUtil = this.app.getShapeUtil(editingShape);
                (_a5 = editingShapeUtil.onEditEnd) == null ? void 0 : _a5.call(editingShapeUtil, editingShape);
                const util = this.app.getShapeUtil(shape);
                if (shape.type === editingShape.type && ((_b2 = util.canEdit) == null ? void 0 : _b2.call(util, shape))) {
                  this.app.setEditingId(shape.id);
                  this.app.setHoveredId(shape.id);
                  this.app.setSelectedIds([shape.id]);
                  return;
                }
              }
            }
          }
        }
        this.parent.transition("idle", info);
        (_d = (_c = this.parent.current.value) == null ? void 0 : _c.onPointerDown) == null ? void 0 : _d.call(_c, info);
      });
      __publicField(this, "onComplete", (info) => {
        this.parent.transition("idle", info);
      });
      __publicField(this, "onCancel", (info) => {
        this.parent.transition("idle", info);
      });
    }
  };
  __publicField(EditingShape, "id", "editing_shape");

  // ../../../packages/editor/src/lib/app/statechart/TLSelectTool/children/Idle.ts
  var Idle10 = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "onPointerEnter", (info) => {
        switch (info.target) {
          case "canvas": {
            break;
          }
          case "shape": {
            const { selectedIds, focusLayerId } = this.app;
            const hoveringShape = this.app.getOutermostSelectableShape(
              info.shape,
              (parent) => !selectedIds.includes(parent.id)
            );
            if (hoveringShape.id !== focusLayerId) {
              this.app.setHoveredId(hoveringShape.id);
            }
            break;
          }
        }
      });
      __publicField(this, "onPointerLeave", (info) => {
        switch (info.target) {
          case "shape": {
            this.app.setHoveredId(null);
            break;
          }
        }
      });
      __publicField(this, "onPointerDown", (info) => {
        if (this.app.isMenuOpen)
          return;
        const shouldEnterCropMode = this.shouldEnterCropMode(info, true);
        if (info.ctrlKey && !shouldEnterCropMode) {
          this.parent.transition("brushing", info);
          return;
        }
        switch (info.target) {
          case "canvas": {
            this.parent.transition("pointing_canvas", info);
            break;
          }
          case "shape": {
            this.parent.transition("pointing_shape", info);
            break;
          }
          case "handle": {
            if (this.app.isReadOnly)
              break;
            if (this.app.inputs.altKey) {
              this.parent.transition("pointing_shape", info);
            } else {
              this.parent.transition("pointing_handle", info);
            }
            break;
          }
          case "selection": {
            switch (info.handle) {
              case "mobile_rotate":
              case "top_left_rotate":
              case "top_right_rotate":
              case "bottom_left_rotate":
              case "bottom_right_rotate": {
                this.parent.transition("pointing_rotate_handle", info);
                break;
              }
              case "top":
              case "right":
              case "bottom":
              case "left": {
                if (shouldEnterCropMode) {
                  this.parent.transition("pointing_crop_handle", info);
                } else {
                  this.parent.transition("pointing_resize_handle", info);
                }
                break;
              }
              case "top_left":
              case "top_right":
              case "bottom_left":
              case "bottom_right": {
                if (shouldEnterCropMode) {
                  this.parent.transition("pointing_crop_handle", info);
                } else {
                  this.parent.transition("pointing_resize_handle", info);
                }
                break;
              }
              default: {
                this.parent.transition("pointing_selection", info);
              }
            }
            break;
          }
        }
      });
      __publicField(this, "onDoubleClick", (info) => {
        var _a5, _b2, _c, _d;
        if (info.phase !== "up")
          return;
        switch (info.target) {
          case "canvas": {
            if (this.app.isReadOnly)
              break;
            this.createTextShapeAtPoint(info);
            break;
          }
          case "selection": {
            if (this.app.isReadOnly)
              break;
            const { onlySelectedShape } = this.app;
            if (onlySelectedShape) {
              const util = this.app.getShapeUtil(onlySelectedShape);
              if (info.handle === "right" || info.handle === "left" || info.handle === "top" || info.handle === "bottom") {
                const change = (_a5 = util.onDoubleClickEdge) == null ? void 0 : _a5.call(util, onlySelectedShape);
                if (change) {
                  this.app.mark("double click edge");
                  this.app.updateShapes([change]);
                  return;
                }
              }
              if (util.canCrop(onlySelectedShape)) {
                this.parent.transition("crop", info);
                return;
              }
              if (util.canEdit(onlySelectedShape)) {
                this.startEditingShape(onlySelectedShape, info);
              }
            }
            break;
          }
          case "shape": {
            const { shape } = info;
            const util = this.app.getShapeUtil(shape);
            if (shape.type !== "video" && shape.type !== "embed" && this.app.isReadOnly)
              break;
            if (util.onDoubleClick) {
              const change = (_b2 = util.onDoubleClick) == null ? void 0 : _b2.call(util, shape);
              if (change) {
                this.app.updateShapes([change]);
                return;
              } else if (util.canCrop(shape)) {
                this.app.mark("select and crop");
                this.app.select((_c = info.shape) == null ? void 0 : _c.id);
                this.parent.transition("crop", info);
                return;
              }
            }
            if (util.canEdit(shape)) {
              this.startEditingShape(shape, info);
            } else {
              this.createTextShapeAtPoint(info);
            }
            break;
          }
          case "handle": {
            if (this.app.isReadOnly)
              break;
            const { shape, handle } = info;
            const util = this.app.getShapeUtil(shape);
            const changes = (_d = util.onDoubleClickHandle) == null ? void 0 : _d.call(util, shape, handle);
            if (changes) {
              this.app.updateShapes([changes]);
            } else {
              if (util.canEdit(shape)) {
                this.startEditingShape(shape, info);
              }
            }
          }
        }
      });
      __publicField(this, "onRightClick", (info) => {
        switch (info.target) {
          case "canvas": {
            this.app.selectNone();
            break;
          }
          case "shape": {
            const { selectedIds } = this.app.pageState;
            const { shape } = info;
            const targetShape = this.app.getOutermostSelectableShape(
              shape,
              (parent) => !this.app.isSelected(parent.id)
            );
            if (!selectedIds.includes(targetShape.id)) {
              this.app.mark("selecting shape");
              this.app.setSelectedIds([targetShape.id]);
            }
            break;
          }
        }
      });
      __publicField(this, "onEnter", () => {
        this.app.setHoveredId(null);
        this.app.setCursor({ type: "default" });
      });
      __publicField(this, "onCancel", () => {
        if (this.app.focusLayerId !== this.app.currentPageId && this.app.selectedIds.length > 0) {
          this.app.popFocusLayer();
        } else {
          this.app.mark("clearing selection");
          this.app.selectNone();
        }
      });
      __publicField(this, "onKeyDown", (info) => {
        switch (info.code) {
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "ArrowDown": {
            this.nudgeSelectedShapes(false);
            break;
          }
        }
      });
      __publicField(this, "onKeyRepeat", (info) => {
        switch (info.code) {
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "ArrowDown": {
            this.nudgeSelectedShapes(true);
            break;
          }
        }
      });
      __publicField(this, "onKeyUp", (info) => {
        if (this.app.isReadOnly) {
          switch (info.code) {
            case "Enter": {
              if (this.shouldStartEditingShape() && this.app.onlySelectedShape) {
                this.startEditingShape(this.app.onlySelectedShape, __spreadProps(__spreadValues({}, info), {
                  target: "shape",
                  shape: this.app.onlySelectedShape
                }));
                return;
              }
              break;
            }
          }
        } else {
          switch (info.code) {
            case "Enter": {
              const { selectedShapes } = this.app;
              if (selectedShapes.every((shape) => shape.type === "group")) {
                this.app.setSelectedIds(
                  selectedShapes.flatMap((shape) => this.app.getSortedChildIds(shape.id))
                );
                return;
              }
              if (this.shouldStartEditingShape() && this.app.onlySelectedShape) {
                this.startEditingShape(this.app.onlySelectedShape, __spreadProps(__spreadValues({}, info), {
                  target: "shape",
                  shape: this.app.onlySelectedShape
                }));
                return;
              }
              if (this.shouldEnterCropMode(info, false)) {
                this.parent.transition("crop", info);
              }
              break;
            }
          }
        }
      });
    }
    shouldStartEditingShape() {
      const { onlySelectedShape } = this.app;
      if (!onlySelectedShape)
        return false;
      const util = this.app.getShapeUtil(onlySelectedShape);
      return util.canEdit(onlySelectedShape);
    }
    shouldEnterCropMode(info, withCtrlKey) {
      const singleShape = this.app.onlySelectedShape;
      if (!singleShape)
        return false;
      const shapeUtil = this.app.getShapeUtil(singleShape);
      if (withCtrlKey) {
        return shapeUtil.canCrop(singleShape) && info.ctrlKey;
      } else {
        return shapeUtil.canCrop(singleShape);
      }
    }
    startEditingShape(shape, info) {
      this.app.mark("editing shape");
      this.app.setEditingId(shape.id);
      this.parent.transition("editing_shape", info);
    }
    createTextShapeAtPoint(info) {
      this.app.mark("creating text shape");
      const id = createShapeId();
      const { x: x3, y: y3 } = this.app.inputs.currentPagePoint;
      this.app.createShapes([
        {
          id,
          type: "text",
          x: x3,
          y: y3,
          props: {
            text: "",
            autoSize: true
          }
        }
      ]);
      const shape = this.app.getShapeById(id);
      if (!shape)
        return;
      const bounds = this.app.getBounds(shape);
      this.app.updateShapes([
        {
          id,
          type: "text",
          x: shape.x - bounds.width / 2,
          y: shape.y - bounds.height / 2
        }
      ]);
      this.app.setEditingId(id);
      this.app.select(id);
      this.parent.transition("editing_shape", info);
    }
    nudgeSelectedShapes(ephemeral = false) {
      const {
        app: {
          inputs: { keys }
        }
      } = this;
      const shiftKey = keys.has("Shift");
      const delta = new Vec2d(0, 0);
      if (keys.has("ArrowLeft"))
        delta.x -= 1;
      if (keys.has("ArrowRight"))
        delta.x += 1;
      if (keys.has("ArrowUp"))
        delta.y -= 1;
      if (keys.has("ArrowDown"))
        delta.y += 1;
      if (delta.equals(new Vec2d(0, 0)))
        return;
      if (!ephemeral)
        this.app.mark("nudge shapes");
      this.app.nudgeShapes(this.app.selectedIds, delta, shiftKey);
    }
  };
  __publicField(Idle10, "id", "idle");

  // ../../../packages/editor/src/lib/app/statechart/TLSelectTool/children/PointingCanvas.ts
  var PointingCanvas = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "onEnter", () => {
        const { inputs } = this.app;
        if (!inputs.shiftKey) {
          if (this.app.selectedIds.length > 0) {
            this.app.mark("selecting none");
            this.app.selectNone();
          }
        }
      });
      __publicField(this, "onPointerMove", (info) => {
        if (this.app.inputs.isDragging) {
          this.parent.transition("brushing", info);
        }
      });
      __publicField(this, "onPointerUp", () => {
        this.complete();
      });
      __publicField(this, "onComplete", () => {
        this.complete();
      });
      __publicField(this, "onInterrupt", () => {
        this.parent.transition("idle", {});
      });
    }
    _clickWasInsideFocusedGroup() {
      const { focusLayerId, inputs } = this.app;
      if (!isShapeId(focusLayerId)) {
        return false;
      }
      const groupShape = this.app.getShapeById(focusLayerId);
      if (!groupShape) {
        return false;
      }
      const clickPoint = this.app.getPointInShapeSpace(groupShape, inputs.currentPagePoint);
      const util = this.app.getShapeUtil(groupShape);
      return util.hitTestPoint(groupShape, clickPoint);
    }
    complete() {
      const { shiftKey } = this.app.inputs;
      if (!shiftKey) {
        this.app.selectNone();
        if (!this._clickWasInsideFocusedGroup()) {
          this.app.setFocusLayer(null);
        }
      }
      this.parent.transition("idle", {});
    }
  };
  __publicField(PointingCanvas, "id", "pointing_canvas");

  // ../../../packages/editor/src/lib/app/statechart/TLSelectTool/children/PointingCropHandle.ts
  var PointingCropHandle = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "info", {});
      __publicField(this, "onEnter", (info) => {
        this.info = info;
        const selectedShape = this.app.selectedShapes[0];
        if (!selectedShape)
          return;
        this.updateCursor(selectedShape);
        this.app.setCroppingId(selectedShape.id);
      });
      __publicField(this, "onPointerMove", () => {
        const isDragging = this.app.inputs.isDragging;
        if (isDragging) {
          this.parent.transition("cropping", __spreadProps(__spreadValues({}, this.info), {
            onInteractionEnd: this.info.onInteractionEnd
          }));
        }
      });
      __publicField(this, "onPointerUp", () => {
        if (this.info.onInteractionEnd) {
          this.app.setSelectedTool(this.info.onInteractionEnd, this.info);
        } else {
          this.app.setCroppingId(null);
          this.parent.transition("idle", {});
        }
      });
      __publicField(this, "onCancel", () => {
        this.cancel();
      });
      __publicField(this, "onComplete", () => {
        this.cancel();
      });
      __publicField(this, "onInterrupt", () => {
        this.cancel();
      });
    }
    updateCursor(shape) {
      const cursorType = CursorTypeMap[this.info.handle];
      this.app.setCursor({
        type: cursorType,
        rotation: shape.rotation
      });
    }
    cancel() {
      if (this.info.onInteractionEnd) {
        this.app.setSelectedTool(this.info.onInteractionEnd, this.info);
      } else {
        this.app.setCroppingId(null);
        this.parent.transition("idle", {});
      }
    }
  };
  __publicField(PointingCropHandle, "id", "pointing_crop_handle");

  // ../../../packages/editor/src/lib/app/statechart/TLSelectTool/children/PointingHandle.ts
  var PointingHandle = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "info", {});
      __publicField(this, "onEnter", (info) => {
        this.info = info;
        const initialTerminal = info.shape.props[info.handle.id];
        if ((initialTerminal == null ? void 0 : initialTerminal.type) === "binding") {
          this.app.setHintingIds([initialTerminal.boundShapeId]);
        }
        this.app.setCursor({ type: "grabbing" });
      });
      __publicField(this, "onExit", () => {
        this.app.setHintingIds([]);
        this.app.setCursor({ type: "default" });
      });
      __publicField(this, "onPointerUp", () => {
        this.parent.transition("idle", this.info);
      });
      __publicField(this, "onPointerMove", () => {
        if (this.app.inputs.isDragging) {
          this.parent.transition("dragging_handle", this.info);
        }
      });
      __publicField(this, "onCancel", () => {
        this.cancel();
      });
      __publicField(this, "onComplete", () => {
        this.cancel();
      });
      __publicField(this, "onInterrupt", () => {
        this.cancel();
      });
    }
    cancel() {
      this.parent.transition("idle", {});
    }
  };
  __publicField(PointingHandle, "id", "pointing_handle");

  // ../../../packages/editor/src/lib/app/statechart/TLSelectTool/children/PointingRotateHandle.ts
  var PointingRotateHandle = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "info", {});
      __publicField(this, "onEnter", (info) => {
        this.info = info;
        this.updateCursor();
      });
      __publicField(this, "onPointerMove", () => {
        const { isDragging } = this.app.inputs;
        if (isDragging) {
          this.parent.transition("rotating", this.info);
        }
      });
      __publicField(this, "onPointerUp", () => {
        this.complete();
      });
      __publicField(this, "onCancel", () => {
        this.cancel();
      });
      __publicField(this, "onComplete", () => {
        this.cancel();
      });
      __publicField(this, "onInterrupt", () => {
        this.cancel();
      });
    }
    updateCursor() {
      const { selectionRotation } = this.app;
      this.app.setCursor({
        type: CursorTypeMap[this.info.handle],
        rotation: selectionRotation
      });
    }
    complete() {
      if (this.info.onInteractionEnd) {
        this.app.setSelectedTool(this.info.onInteractionEnd, {});
      } else {
        this.parent.transition("idle", {});
      }
    }
    cancel() {
      if (this.info.onInteractionEnd) {
        this.app.setSelectedTool(this.info.onInteractionEnd, {});
      } else {
        this.parent.transition("idle", {});
      }
    }
  };
  __publicField(PointingRotateHandle, "id", "pointing_rotate_handle");

  // ../../../packages/editor/src/lib/app/statechart/TLSelectTool/children/PointingSelection.ts
  var PointingSelection = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "info", {});
      __publicField(this, "onEnter", (info) => {
        this.info = info;
      });
      __publicField(this, "onPointerUp", (info) => {
        this.app.selectNone();
        this.parent.transition("idle", info);
      });
      __publicField(this, "onPointerMove", (info) => {
        if (this.app.inputs.isDragging) {
          if (this.app.isReadOnly)
            return;
          this.parent.transition("translating", info);
        }
      });
      __publicField(this, "onCancel", () => {
        this.cancel();
      });
      __publicField(this, "onComplete", () => {
        this.cancel();
      });
      __publicField(this, "onInterrupt", () => {
        this.cancel();
      });
    }
    cancel() {
      this.parent.transition("idle", {});
    }
  };
  __publicField(PointingSelection, "id", "pointing_selection");

  // ../../../packages/editor/src/lib/app/statechart/TLSelectTool/children/PointingShape.ts
  var PointingShape = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "eventTargetShape", {});
      __publicField(this, "selectingShape", {});
      __publicField(this, "didSelectOnEnter", false);
      __publicField(this, "onEnter", (info) => {
        var _a5;
        this.eventTargetShape = info.shape;
        this.selectingShape = this.app.getOutermostSelectableShape(info.shape);
        const util = this.app.getShapeUtil(info.shape);
        if (util.onClick || this.selectingShape.id === this.app.focusLayerId) {
          this.didSelectOnEnter = false;
          return;
        }
        const isSelected = this.app.isWithinSelection(this.selectingShape.id);
        const isBehindSelectionBounds = this.app.selectedIds.length > 1 && // only on 2+ selected shapes!
        ((_a5 = this.app.selectionBounds) == null ? void 0 : _a5.containsPoint(this.app.inputs.currentPagePoint));
        this.didSelectOnEnter = !isSelected && this.selectingShape.id !== this.app.focusLayerId && !isBehindSelectionBounds;
        if (this.didSelectOnEnter) {
          const { inputs, selectedIds } = this.app;
          const parent = this.app.getParentShape(info.shape);
          if (parent && parent.type === "group") {
            this.app.cancelDoubleClick();
          }
          if (inputs.shiftKey && !inputs.altKey) {
            if (!selectedIds.includes(this.selectingShape.id)) {
              this.app.mark("shift selecting shape");
              this.app.setSelectedIds([...selectedIds, this.selectingShape.id]);
            }
          } else {
            this.app.mark("selecting shape");
            this.app.setSelectedIds([this.selectingShape.id]);
          }
        }
      });
      __publicField(this, "onPointerUp", (info) => {
        var _a5;
        const { shape } = info;
        if (shape) {
          const util = this.app.getShapeUtil(shape);
          if (util.onClick) {
            const change = (_a5 = util.onClick) == null ? void 0 : _a5.call(util, shape);
            if (change) {
              this.app.updateShapes([change]);
              this.parent.transition("idle", info);
              return;
            }
          }
        }
        if (!this.didSelectOnEnter && this.selectingShape.id !== this.app.focusLayerId) {
          this.app.mark("selecting shape (pointer up)");
          const targetShape = this.app.getOutermostSelectableShape(
            this.eventTargetShape,
            // if a group is selected, we want to stop before reaching that group
            // so we can drill down into the group
            (parent) => !this.app.isSelected(parent.id)
          );
          if (this.app.selectedIds.includes(targetShape.id)) {
            this.app.setSelectedIds(
              this.app.inputs.shiftKey ? this.app.selectedIds.filter((id) => id !== this.selectingShape.id) : [this.selectingShape.id]
            );
          } else if (this.app.inputs.shiftKey) {
            const ancestors = this.app.getAncestors(targetShape);
            this.app.setSelectedIds([
              ...this.app.selectedIds.filter((id) => !ancestors.find((a3) => a3.id === id)),
              targetShape.id
            ]);
          } else {
            this.app.setSelectedIds([targetShape.id]);
          }
        } else if (this.selectingShape.id === this.app.focusLayerId) {
          if (this.app.selectedIds.length > 0) {
            this.app.setSelectedIds([]);
          } else {
            this.app.popFocusLayer();
          }
        }
        this.parent.transition("idle", info);
      });
      __publicField(this, "onPointerMove", (info) => {
        if (this.app.inputs.isDragging) {
          if (this.app.isReadOnly)
            return;
          this.parent.transition("translating", info);
        }
      });
      __publicField(this, "onCancel", () => {
        this.cancel();
      });
      __publicField(this, "onComplete", () => {
        this.cancel();
      });
      __publicField(this, "onInterrupt", () => {
        this.cancel();
      });
    }
    cancel() {
      this.parent.transition("idle", {});
    }
  };
  __publicField(PointingShape, "id", "pointing_shape");

  // ../../../packages/editor/src/lib/app/statechart/TLSelectTool/children/Resizing.ts
  var Resizing = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "info", {});
      __publicField(this, "markId", "");
      // we transition into the resizing state from the geo pointing state, which starts with a shape of size w: 1, h: 1,
      // so if the user drags x: +50, y: +50 after mouseDown, the shape will be w: 51, h: 51, which is too many pixels, alas
      // so we allow passing a further offset into this state to negate such issues
      __publicField(this, "creationCursorOffset", { x: 0, y: 0 });
      __publicField(this, "editAfterComplete", false);
      __publicField(this, "snapshot", {});
      __publicField(this, "onEnter", (info) => {
        const {
          isCreating = false,
          editAfterComplete = false,
          creationCursorOffset = { x: 0, y: 0 }
        } = info;
        this.info = info;
        this.editAfterComplete = editAfterComplete;
        this.creationCursorOffset = creationCursorOffset;
        if (info.isCreating) {
          this.app.setCursor({ type: "cross", rotation: 0 });
        }
        this.snapshot = this._createSnapshot();
        this.markId = isCreating ? "creating" : this.app.mark("starting resizing");
        this.handleResizeStart();
        this.updateShapes();
      });
      __publicField(this, "onPointerMove", () => {
        this.updateShapes();
      });
      __publicField(this, "onKeyDown", () => {
        this.updateShapes();
      });
      __publicField(this, "onKeyUp", () => {
        this.updateShapes();
      });
      __publicField(this, "onPointerUp", () => {
        this.complete();
      });
      __publicField(this, "onComplete", () => {
        this.complete();
      });
      __publicField(this, "onCancel", () => {
        this.cancel();
      });
      __publicField(this, "onExit", () => {
        this.app.snaps.clear();
      });
      __publicField(this, "_createSnapshot", () => {
        const {
          selectedIds,
          selectionRotation,
          inputs: { originPagePoint }
        } = this.app;
        const selectionBounds = this.app.selectionBounds;
        const dragHandlePoint = Vec2d.RotWith(
          selectionBounds.getHandlePoint(this.info.handle),
          selectionBounds.point,
          selectionRotation
        );
        const cursorHandleOffset = Vec2d.Sub(originPagePoint, dragHandlePoint);
        const shapeSnapshots = /* @__PURE__ */ new Map();
        selectedIds.forEach((id) => {
          const shape = this.app.getShapeById(id);
          if (shape) {
            shapeSnapshots.set(shape.id, this._createShapeSnapshot(shape));
            if (shape.type === "frame" && selectedIds.length === 1)
              return;
            this.app.visitDescendants(shape.id, (descendantId) => {
              const descendent = this.app.getShapeById(descendantId);
              if (descendent) {
                shapeSnapshots.set(descendent.id, this._createShapeSnapshot(descendent));
                if (descendent.type === "frame") {
                  return false;
                }
              }
            });
          }
        });
        const canShapesDeform = ![...shapeSnapshots.values()].some(
          (shape) => !areAnglesCompatible(shape.pageRotation, selectionRotation) || shape.isAspectRatioLocked
        );
        return {
          shapeSnapshots,
          selectionBounds,
          cursorHandleOffset,
          selectionRotation,
          selectedIds,
          canShapesDeform,
          initialSelectionPageBounds: this.app.selectedPageBounds
        };
      });
      __publicField(this, "_createShapeSnapshot", (shape) => {
        const pageTransform = this.app.getPageTransform(shape);
        const util = this.app.getShapeUtil(shape);
        return {
          shape,
          bounds: util.bounds(shape),
          pageTransform,
          pageRotation: Matrix2d.Decompose(pageTransform).rotation,
          isAspectRatioLocked: util.isAspectRatioLocked(shape)
        };
      });
    }
    cancel() {
      this.app.bailToMark(this.markId);
      if (this.info.onInteractionEnd) {
        this.app.setSelectedTool(this.info.onInteractionEnd, {});
      } else {
        this.parent.transition("idle", {});
      }
    }
    complete() {
      this.handleResizeEnd();
      if (this.editAfterComplete && this.app.onlySelectedShape) {
        this.app.setEditingId(this.app.onlySelectedShape.id);
        this.app.setSelectedTool("select");
        this.app.root.current.value.transition("editing_shape", {});
        return;
      }
      if (this.app.instanceState.isToolLocked && this.info.onInteractionEnd) {
        this.app.setSelectedTool(this.info.onInteractionEnd, {});
        return;
      }
      this.parent.transition("idle", {});
    }
    handleResizeStart() {
      const { shapeSnapshots } = this.snapshot;
      const changes = [];
      shapeSnapshots.forEach(({ shape }) => {
        var _a5;
        const util = this.app.getShapeUtil(shape);
        const change = (_a5 = util.onResizeStart) == null ? void 0 : _a5.call(util, shape);
        if (change) {
          changes.push(change);
        }
      });
      if (changes.length > 0) {
        this.app.updateShapes(changes);
      }
    }
    handleResizeEnd() {
      const { shapeSnapshots } = this.snapshot;
      const changes = [];
      shapeSnapshots.forEach(({ shape }) => {
        var _a5;
        const current = this.app.getShapeById(shape.id);
        const util = this.app.getShapeUtil(shape);
        const change = (_a5 = util.onResizeEnd) == null ? void 0 : _a5.call(util, shape, current);
        if (change) {
          changes.push(change);
        }
      });
      if (changes.length > 0) {
        this.app.updateShapes(changes);
      }
    }
    updateShapes() {
      const { altKey: altKey2, shiftKey } = this.app.inputs;
      const {
        shapeSnapshots,
        selectionBounds,
        cursorHandleOffset,
        selectedIds,
        selectionRotation,
        canShapesDeform
      } = this.snapshot;
      const isAspectRatioLocked = shiftKey || !canShapesDeform;
      const { ctrlKey } = this.app.inputs;
      const currentPagePoint = this.app.inputs.currentPagePoint.clone().sub(cursorHandleOffset).sub(this.creationCursorOffset);
      const originPagePoint = this.app.inputs.originPagePoint.clone().sub(cursorHandleOffset);
      if (this.app.isGridMode && !ctrlKey) {
        currentPagePoint.snapToGrid(this.app.gridSize);
      }
      const dragHandle = this.info.handle;
      const scaleOriginHandle = rotateSelectionHandle2(dragHandle, Math.PI);
      this.app.snaps.clear();
      const shouldSnap = this.app.userDocumentSettings.isSnapMode ? !ctrlKey : ctrlKey;
      if (shouldSnap && selectionRotation % TAU === 0) {
        const { nudge } = this.app.snaps.snapResize({
          dragDelta: Vec2d.Sub(currentPagePoint, originPagePoint),
          initialSelectionPageBounds: this.snapshot.initialSelectionPageBounds,
          handle: rotateSelectionHandle2(dragHandle, selectionRotation),
          isAspectRatioLocked,
          isResizingFromCenter: altKey2
        });
        currentPagePoint.add(nudge);
      }
      const scaleOriginPage = Vec2d.RotWith(
        altKey2 ? selectionBounds.center : selectionBounds.getHandlePoint(scaleOriginHandle),
        selectionBounds.point,
        selectionRotation
      );
      const distanceFromScaleOriginNow = Vec2d.Sub(currentPagePoint, scaleOriginPage).rot(
        -selectionRotation
      );
      const distanceFromScaleOriginAtStart = Vec2d.Sub(originPagePoint, scaleOriginPage).rot(
        -selectionRotation
      );
      const scale = Vec2d.DivV(distanceFromScaleOriginNow, distanceFromScaleOriginAtStart);
      if (!Number.isFinite(scale.x))
        scale.x = 1;
      if (!Number.isFinite(scale.y))
        scale.y = 1;
      const isXLocked = dragHandle === "top" || dragHandle === "bottom";
      const isYLocked = dragHandle === "left" || dragHandle === "right";
      if (isAspectRatioLocked) {
        if (isYLocked) {
          scale.y = Math.abs(scale.x);
        } else if (isXLocked) {
          scale.x = Math.abs(scale.y);
        } else if (Math.abs(scale.x) > Math.abs(scale.y)) {
          scale.y = Math.abs(scale.x) * (scale.y < 0 ? -1 : 1);
        } else {
          scale.x = Math.abs(scale.y) * (scale.x < 0 ? -1 : 1);
        }
      } else {
        if (isXLocked) {
          scale.x = 1;
        }
        if (isYLocked) {
          scale.y = 1;
        }
      }
      if (!this.info.isCreating) {
        this.updateCursor({
          dragHandle,
          isFlippedX: scale.x < 0,
          isFlippedY: scale.y < 0,
          rotation: selectionRotation
        });
      }
      for (const id of shapeSnapshots.keys()) {
        const snapshot = shapeSnapshots.get(id);
        this.app.resizeShape(id, scale, {
          initialBounds: snapshot.bounds,
          dragHandle,
          initialPageTransform: snapshot.pageTransform,
          initialShape: snapshot.shape,
          mode: selectedIds.length === 1 && id === selectedIds[0] ? "resize_bounds" : "scale_shape",
          scaleOrigin: scaleOriginPage,
          scaleAxisRotation: selectionRotation
        });
      }
    }
    // ---
    updateCursor({
      dragHandle,
      isFlippedX,
      isFlippedY,
      rotation
    }) {
      const nextCursor = __spreadValues({}, this.app.cursor);
      switch (dragHandle) {
        case "top_left":
        case "bottom_right": {
          nextCursor.type = "nwse-resize";
          if (isFlippedX !== isFlippedY) {
            nextCursor.type = "nesw-resize";
          }
          break;
        }
        case "top_right":
        case "bottom_left": {
          nextCursor.type = "nesw-resize";
          if (isFlippedX !== isFlippedY) {
            nextCursor.type = "nwse-resize";
          }
          break;
        }
      }
      nextCursor.rotation = rotation;
      this.app.setCursor(nextCursor);
    }
  };
  __publicField(Resizing, "id", "resizing");
  var ORDERED_SELECTION_HANDLES = [
    "top",
    "top_right",
    "right",
    "bottom_right",
    "bottom",
    "bottom_left",
    "left",
    "top_left"
  ];
  function rotateSelectionHandle2(handle, rotation) {
    rotation = rotation % PI2;
    const numSteps = Math.round(rotation / (PI / 4));
    const currentIndex = ORDERED_SELECTION_HANDLES.indexOf(handle);
    return ORDERED_SELECTION_HANDLES[(currentIndex + numSteps) % ORDERED_SELECTION_HANDLES.length];
  }

  // ../../../packages/editor/src/lib/app/statechart/TLSelectTool/children/Rotating.ts
  var Rotating = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "snapshot", {});
      __publicField(this, "info", {});
      __publicField(this, "markId", "");
      __publicField(this, "onEnter", (info) => {
        this.info = info;
        this.markId = this.app.mark("rotate start");
        this.snapshot = getRotationSnapshot({ app: this.app });
        this.handleStart();
      });
      __publicField(this, "onExit", () => {
        this.app.setCursor({ type: "none" });
        this.snapshot = {};
      });
      __publicField(this, "onPointerMove", () => {
        this.update();
      });
      __publicField(this, "onKeyDown", () => {
        this.update();
      });
      __publicField(this, "onKeyUp", () => {
        this.update();
      });
      __publicField(this, "onPointerUp", () => {
        this.complete();
      });
      __publicField(this, "onComplete", () => {
        this.complete();
      });
      __publicField(this, "onCancel", () => {
        this.cancel();
      });
      // ---
      __publicField(this, "update", () => {
        const newSelectionRotation = this._getRotationFromPointerPosition({
          snapToNearestDegree: false
        });
        applyRotationToSnapshotShapes({
          app: this.app,
          delta: newSelectionRotation,
          snapshot: this.snapshot,
          stage: "update"
        });
        this.app.setCursor({
          type: CursorTypeMap[this.info.handle],
          rotation: newSelectionRotation + this.snapshot.initialSelectionRotation
        });
      });
      __publicField(this, "cancel", () => {
        this.app.bailToMark(this.markId);
        if (this.info.onInteractionEnd) {
          this.app.setSelectedTool(this.info.onInteractionEnd, this.info);
        } else {
          this.parent.transition("idle", this.info);
        }
      });
      __publicField(this, "complete", () => {
        applyRotationToSnapshotShapes({
          app: this.app,
          delta: this._getRotationFromPointerPosition({ snapToNearestDegree: true }),
          snapshot: this.snapshot,
          stage: "end"
        });
        if (this.info.onInteractionEnd) {
          this.app.setSelectedTool(this.info.onInteractionEnd, this.info);
        } else {
          this.parent.transition("idle", this.info);
        }
      });
    }
    handleStart() {
      const newSelectionRotation = this._getRotationFromPointerPosition({
        snapToNearestDegree: false
      });
      applyRotationToSnapshotShapes({
        app: this.app,
        delta: this._getRotationFromPointerPosition({ snapToNearestDegree: false }),
        snapshot: this.snapshot,
        stage: "start"
      });
      this.app.setCursor({
        type: CursorTypeMap[this.info.handle],
        rotation: newSelectionRotation + this.snapshot.initialSelectionRotation
      });
    }
    _getRotationFromPointerPosition({ snapToNearestDegree }) {
      const {
        selectionPageCenter,
        inputs: { shiftKey, currentPagePoint }
      } = this.app;
      const { initialCursorAngle, initialSelectionRotation } = this.snapshot;
      const preSnapRotationDelta = selectionPageCenter.angle(currentPagePoint) - initialCursorAngle;
      let newSelectionRotation = initialSelectionRotation + preSnapRotationDelta;
      if (shiftKey) {
        newSelectionRotation = snapAngle(newSelectionRotation, 24);
      } else if (snapToNearestDegree) {
        newSelectionRotation = Math.round(newSelectionRotation / EPSILON) * EPSILON;
        if (this.app.isCoarsePointer) {
          const snappedToRightAngle = snapAngle(newSelectionRotation, 4);
          const angleToRightAngle = angleDelta(newSelectionRotation, snappedToRightAngle);
          if (Math.abs(angleToRightAngle) < degreesToRadians(5)) {
            newSelectionRotation = snappedToRightAngle;
          }
        }
      }
      return newSelectionRotation - initialSelectionRotation;
    }
  };
  __publicField(Rotating, "id", "rotating");

  // ../../../packages/editor/src/lib/app/statechart/TLSelectTool/children/ScribbleBrushing.ts
  var ScribbleBrushing = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "hits", /* @__PURE__ */ new Set());
      __publicField(this, "size", 0);
      __publicField(this, "scribble", {});
      __publicField(this, "initialSelectedIds", /* @__PURE__ */ new Set());
      __publicField(this, "newlySelectedIds", /* @__PURE__ */ new Set());
      __publicField(this, "onEnter", () => {
        this.initialSelectedIds = new Set(
          this.app.inputs.shiftKey ? this.app.selectedIds : []
        );
        this.newlySelectedIds = /* @__PURE__ */ new Set();
        this.size = 0;
        this.hits.clear();
        this.startScribble();
        this.updateBrushSelection();
        requestAnimationFrame(() => {
          this.app.setBrush(null);
        });
      });
      __publicField(this, "onExit", () => {
        this.app.setErasingIds([]);
        this.scribble.stop();
      });
      __publicField(this, "onPointerMove", () => {
        this.updateBrushSelection();
      });
      __publicField(this, "onPointerUp", () => {
        this.complete();
      });
      __publicField(this, "onKeyDown", () => {
        this.updateBrushSelection();
      });
      __publicField(this, "onKeyUp", () => {
        if (!this.app.inputs.altKey) {
          this.parent.transition("brushing", {});
        } else {
          this.updateBrushSelection();
        }
      });
      __publicField(this, "startScribble", () => {
        this.scribble = new ScribbleManager({
          onUpdate: this.onScribbleUpdate,
          onComplete: this.onScribbleComplete,
          color: "selection-stroke",
          opacity: 0.32,
          size: 12
        });
        this.app.on("tick", this.scribble.tick);
      });
      __publicField(this, "pushPointToScribble", () => {
        const { x: x3, y: y3 } = this.app.inputs.currentPagePoint;
        this.scribble.addPoint(x3, y3);
      });
      __publicField(this, "onScribbleUpdate", (scribble) => {
        this.app.setScribble(scribble);
      });
      __publicField(this, "onScribbleComplete", () => {
        this.app.off("tick", this.scribble.tick);
        this.app.setScribble(null);
      });
      __publicField(this, "onCancel", () => {
        this.cancel();
      });
      __publicField(this, "onComplete", () => {
        this.complete();
      });
    }
    updateBrushSelection() {
      const {
        shapesArray,
        inputs: { originPagePoint, previousPagePoint, currentPagePoint }
      } = this.app;
      this.pushPointToScribble();
      const shapes = shapesArray;
      let shape, util;
      for (let i3 = 0, n3 = shapes.length; i3 < n3; i3++) {
        shape = shapes[i3];
        util = this.app.getShapeUtil(shape);
        if (shape.type === "group" || this.newlySelectedIds.has(shape.id) || shape.type === "frame" && util.hitTestPoint(shape, this.app.getPointInShapeSpace(shape, originPagePoint))) {
          continue;
        }
        if (util.hitTestLineSegment(
          shape,
          this.app.getPointInShapeSpace(shape, previousPagePoint),
          this.app.getPointInShapeSpace(shape, currentPagePoint)
        )) {
          const outermostShape = this.app.getOutermostSelectableShape(shape);
          const pageMask = this.app.getPageMaskById(outermostShape.id);
          if (pageMask) {
            const intersection = intersectLineSegmentPolyline(
              previousPagePoint,
              currentPagePoint,
              pageMask
            );
            if (intersection !== null) {
              const isInMask = pointInPolygon(currentPagePoint, pageMask);
              if (!isInMask)
                continue;
            }
          }
          this.newlySelectedIds.add(outermostShape.id);
        }
      }
      this.app.setSelectedIds(
        [.../* @__PURE__ */ new Set([...this.newlySelectedIds, ...this.initialSelectedIds])],
        true
      );
    }
    complete() {
      this.parent.transition("idle", {});
    }
    cancel() {
      this.app.setSelectedIds([...this.initialSelectedIds], true);
      this.parent.transition("idle", {});
    }
  };
  __publicField(ScribbleBrushing, "id", "scribble_brushing");
  __publicField(ScribbleBrushing, "canActivateInReadOnly", true);

  // ../../../packages/editor/src/lib/app/managers/DragAndDropManager.ts
  var LAG_DURATION = 100;
  var DragAndDropManager = class {
    constructor(app) {
      this.app = app;
      __publicField(this, "prevDroppingShapeId", null);
      __publicField(this, "currDroppingShapeId", null);
      __publicField(this, "droppingNodeTimer", null);
      __publicField(this, "dispose", () => {
        this.clear();
      });
      app.disposables.add(this.dispose);
    }
    updateDroppingNode(movingShapes, cb) {
      var _a5, _b2;
      if (this.droppingNodeTimer === null) {
        const { currentPagePoint } = this.app.inputs;
        this.currDroppingShapeId = (_b2 = (_a5 = this.app.getDroppingShape(currentPagePoint, movingShapes)) == null ? void 0 : _a5.id) != null ? _b2 : null;
        this.setDragTimer(movingShapes, LAG_DURATION * 10, cb);
      } else if (this.app.inputs.pointerVelocity.len() > 0.5) {
        clearInterval(this.droppingNodeTimer);
        this.setDragTimer(movingShapes, LAG_DURATION, cb);
      }
    }
    setDragTimer(movingShapes, duration, cb) {
      this.droppingNodeTimer = setTimeout(() => {
        this.app.batch(() => {
          this.handleDrag(movingShapes, cb);
        });
        this.droppingNodeTimer = null;
      }, duration);
    }
    handleDrag(movingShapes, cb) {
      var _a5, _b2, _c, _d, _e, _f;
      const { currentPagePoint } = this.app.inputs;
      movingShapes = compact(movingShapes.map((shape) => this.app.getShapeById(shape.id)));
      const currDroppingShapeId = (_b2 = (_a5 = this.app.getDroppingShape(currentPagePoint, movingShapes)) == null ? void 0 : _a5.id) != null ? _b2 : null;
      if (currDroppingShapeId !== this.currDroppingShapeId) {
        this.prevDroppingShapeId = this.currDroppingShapeId;
        this.currDroppingShapeId = currDroppingShapeId;
      }
      const { prevDroppingShapeId } = this;
      if (currDroppingShapeId === prevDroppingShapeId) {
        return;
      }
      const prevDroppingShape = prevDroppingShapeId && this.app.getShapeById(prevDroppingShapeId);
      const nextDroppingShape = currDroppingShapeId && this.app.getShapeById(currDroppingShapeId);
      this.prevDroppingShapeId = this.currDroppingShapeId;
      if (prevDroppingShape) {
        (_d = (_c = this.app.getShapeUtil(prevDroppingShape)).onDragShapesOut) == null ? void 0 : _d.call(_c, prevDroppingShape, movingShapes);
      }
      if (nextDroppingShape) {
        const res = (_f = (_e = this.app.getShapeUtil(nextDroppingShape)).onDragShapesOver) == null ? void 0 : _f.call(_e, nextDroppingShape, movingShapes);
        if (res && res.shouldHint) {
          this.app.setHintingIds([nextDroppingShape.id]);
        }
      } else {
        this.app.setHintingIds([]);
      }
      cb == null ? void 0 : cb();
    }
    dropShapes(shapes) {
      var _a5, _b2;
      const { currDroppingShapeId } = this;
      this.handleDrag(shapes);
      if (currDroppingShapeId) {
        const shape = this.app.getShapeById(currDroppingShapeId);
        if (!shape)
          return;
        (_b2 = (_a5 = this.app.getShapeUtil(shape)).onDropShapesOver) == null ? void 0 : _b2.call(_a5, shape, shapes);
      }
    }
    clear() {
      this.prevDroppingShapeId = null;
      this.currDroppingShapeId = null;
      if (this.droppingNodeTimer !== null) {
        clearInterval(this.droppingNodeTimer);
      }
      this.droppingNodeTimer = null;
      this.app.setHintingIds([]);
    }
  };

  // ../../../packages/editor/src/lib/app/statechart/TLSelectTool/children/Translating.ts
  var Translating = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "info", {});
      __publicField(this, "selectionSnapshot", {});
      __publicField(this, "snapshot", {});
      __publicField(this, "markId", "");
      __publicField(this, "isCloning", false);
      __publicField(this, "isCreating", false);
      __publicField(this, "editAfterComplete", false);
      __publicField(this, "dragAndDropManager", new DragAndDropManager(this.app));
      __publicField(this, "onEnter", (info) => {
        const { isCreating = false, editAfterComplete = false } = info;
        this.info = info;
        this.isCreating = isCreating;
        this.editAfterComplete = editAfterComplete;
        this.markId = isCreating ? "creating" : this.app.mark("translating");
        this.handleEnter(info);
        this.app.on("tick", this.updateParent);
      });
      __publicField(this, "updateParent", () => {
        const { snapshot } = this;
        this.dragAndDropManager.updateDroppingNode(snapshot.movingShapes, this.updateParentTransforms);
      });
      __publicField(this, "onExit", () => {
        this.app.off("tick", this.updateParent);
        this.selectionSnapshot = {};
        this.snapshot = {};
        this.app.snaps.clear();
        this.app.setCursor({ type: "default" });
        this.dragAndDropManager.clear();
      });
      __publicField(this, "onPointerMove", () => {
        this.updateShapes();
      });
      __publicField(this, "onKeyDown", () => {
        if (this.app.inputs.altKey && !this.isCloning) {
          this.startCloning();
          return;
        }
        this.updateShapes();
      });
      __publicField(this, "onKeyUp", () => {
        if (!this.app.inputs.altKey && this.isCloning) {
          this.stopCloning();
          return;
        }
        this.updateShapes();
      });
      __publicField(this, "onPointerUp", () => {
        this.complete();
      });
      __publicField(this, "onComplete", () => {
        this.complete();
      });
      __publicField(this, "onCancel", () => {
        this.cancel();
      });
      __publicField(this, "updateParentTransforms", () => {
        const {
          app,
          snapshot: { shapeSnapshots }
        } = this;
        const movingShapes = [];
        shapeSnapshots.forEach((shapeSnapshot) => {
          const shape = app.getShapeById(shapeSnapshot.shape.id);
          if (!shape)
            return null;
          movingShapes.push(shape);
          const parentTransform = TLPage.isId(shape.parentId) ? null : Matrix2d.Inverse(app.getPageTransformById(shape.parentId));
          shapeSnapshot.parentTransform = parentTransform;
        });
      });
    }
    reset() {
      this.app.bailToMark(this.markId);
    }
    startCloning() {
      if (this.isCreating)
        return;
      this.isCloning = true;
      this.reset();
      this.markId = this.app.mark("translating");
      this.app.duplicateShapes();
      this.snapshot = getTranslatingSnapshot(this.app);
      this.handleStart();
      this.updateShapes();
    }
    stopCloning() {
      this.isCloning = false;
      this.snapshot = this.selectionSnapshot;
      this.reset();
      this.markId = this.app.mark("translating");
      this.updateShapes();
    }
    complete() {
      this.updateShapes();
      this.dragAndDropManager.dropShapes(this.snapshot.movingShapes);
      this.handleEnd();
      if (this.app.instanceState.isToolLocked && this.info.onInteractionEnd) {
        this.app.setSelectedTool(this.info.onInteractionEnd);
      } else {
        if (this.editAfterComplete) {
          const onlySelected = this.app.onlySelectedShape;
          if (onlySelected) {
            this.app.setEditingId(onlySelected.id);
            this.app.setSelectedTool("select");
            this.app.root.current.value.transition("editing_shape", {});
          }
        } else {
          this.parent.transition("idle", {});
        }
      }
    }
    cancel() {
      this.reset();
      if (this.info.onInteractionEnd) {
        this.app.setSelectedTool(this.info.onInteractionEnd);
      } else {
        this.parent.transition("idle", this.info);
      }
    }
    handleEnter(info) {
      this.isCloning = false;
      this.info = info;
      this.app.setCursor({ type: "move" });
      this.selectionSnapshot = getTranslatingSnapshot(this.app);
      if (!this.isCreating) {
        if (this.app.inputs.altKey) {
          this.startCloning();
          return;
        }
      }
      this.snapshot = this.selectionSnapshot;
      this.handleStart();
      this.updateShapes();
    }
    handleStart() {
      const { movingShapes } = this.snapshot;
      const changes = [];
      movingShapes.forEach((shape) => {
        var _a5;
        const util = this.app.getShapeUtil(shape);
        const change = (_a5 = util.onTranslateStart) == null ? void 0 : _a5.call(util, shape);
        if (change) {
          changes.push(change);
        }
      });
      if (changes.length > 0) {
        this.app.updateShapes(changes);
      }
    }
    handleEnd() {
      const { movingShapes } = this.snapshot;
      const changes = [];
      movingShapes.forEach((shape) => {
        var _a5;
        const current = this.app.getShapeById(shape.id);
        const util = this.app.getShapeUtil(shape);
        const change = (_a5 = util.onTranslateEnd) == null ? void 0 : _a5.call(util, shape, current);
        if (change) {
          changes.push(change);
        }
      });
      if (changes.length > 0) {
        this.app.updateShapes(changes);
      }
    }
    handleChange() {
      const { movingShapes } = this.snapshot;
      const changes = [];
      movingShapes.forEach((shape) => {
        var _a5;
        const current = this.app.getShapeById(shape.id);
        const util = this.app.getShapeUtil(shape);
        const change = (_a5 = util.onTranslate) == null ? void 0 : _a5.call(util, shape, current);
        if (change) {
          changes.push(change);
        }
      });
      if (changes.length > 0) {
        this.app.updateShapes(changes);
      }
    }
    updateShapes() {
      const { snapshot } = this;
      this.dragAndDropManager.updateDroppingNode(snapshot.movingShapes, this.updateParentTransforms);
      moveShapesToPoint({
        app: this.app,
        shapeSnapshots: snapshot.shapeSnapshots,
        averagePagePoint: snapshot.averagePagePoint,
        initialSelectionPageBounds: snapshot.initialPageBounds,
        initialSelectionSnapPoints: snapshot.initialSnapPoints
      });
      this.handleChange();
    }
  };
  __publicField(Translating, "id", "translating");
  function getTranslatingSnapshot(app) {
    const movingShapes = [];
    const pagePoints = [];
    const shapeSnapshots = compact(
      app.selectedIds.map((id) => {
        const shape = app.getShapeById(id);
        if (!shape)
          return null;
        movingShapes.push(shape);
        const pagePoint = app.getPagePointById(id);
        if (!pagePoint)
          return null;
        pagePoints.push(pagePoint);
        const parentTransform = TLPage.isId(shape.parentId) ? null : Matrix2d.Inverse(app.getPageTransformById(shape.parentId));
        return {
          shape,
          pagePoint,
          parentTransform
        };
      })
    );
    return {
      averagePagePoint: Vec2d.Average(pagePoints),
      movingShapes,
      shapeSnapshots,
      initialPageBounds: app.selectedPageBounds,
      initialSnapPoints: app.selectedIds.length === 1 ? app.snaps.snapPointsCache.get(app.selectedIds[0]) : app.selectedPageBounds ? app.selectedPageBounds.snapPoints.map((p3, i3) => ({
        id: "selection:" + i3,
        x: p3.x,
        y: p3.y
      })) : []
    };
  }
  function moveShapesToPoint({
    app,
    shapeSnapshots: snapshots,
    averagePagePoint,
    initialSelectionPageBounds,
    initialSelectionSnapPoints
  }) {
    const { inputs, isGridMode, gridSize } = app;
    const delta = Vec2d.Sub(inputs.currentPagePoint, inputs.originPagePoint);
    const flatten = app.inputs.shiftKey ? Math.abs(delta.x) < Math.abs(delta.y) ? "x" : "y" : null;
    if (flatten === "x") {
      delta.x = 0;
    } else if (flatten === "y") {
      delta.y = 0;
    }
    app.snaps.clear();
    const shouldSnap = (app.userDocumentSettings.isSnapMode ? !inputs.ctrlKey : inputs.ctrlKey) && app.inputs.pointerVelocity.len() < 0.5;
    if (shouldSnap) {
      const { nudge } = app.snaps.snapTranslate({
        dragDelta: delta,
        initialSelectionPageBounds,
        lockedAxis: flatten,
        initialSelectionSnapPoints
      });
      delta.add(nudge);
    }
    const averageSnappedPoint = Vec2d.Add(averagePagePoint, delta);
    if (isGridMode && !inputs.ctrlKey) {
      averageSnappedPoint.snapToGrid(gridSize);
    }
    const averageSnap = Vec2d.Sub(averageSnappedPoint, averagePagePoint);
    app.updateShapes(
      compact(
        snapshots.map(({ shape, pagePoint, parentTransform }) => {
          const newPagePoint = Vec2d.Add(pagePoint, averageSnap);
          const newLocalPoint = parentTransform ? Matrix2d.applyToPoint(parentTransform, newPagePoint) : newPagePoint;
          return {
            id: shape.id,
            type: shape.type,
            x: newLocalPoint.x,
            y: newLocalPoint.y
          };
        })
      ),
      true
    );
  }

  // ../../../packages/editor/src/lib/app/statechart/TLSelectTool/TLSelectTool.ts
  var TLSelectTool = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "styles", ["color", "opacity", "dash", "fill", "size"]);
      __publicField(this, "onExit", () => {
        if (this.app.pageState.editingId) {
          this.app.setEditingId(null);
        }
      });
    }
  };
  __publicField(TLSelectTool, "id", "select");
  __publicField(TLSelectTool, "initial", "idle");
  __publicField(TLSelectTool, "children", () => [
    Crop,
    Cropping,
    Idle10,
    PointingCanvas,
    PointingShape,
    Translating,
    Brushing,
    ScribbleBrushing,
    PointingCropHandle,
    PointingSelection,
    PointingResizeHandle,
    EditingShape,
    Resizing,
    Rotating,
    PointingRotateHandle,
    PointingHandle,
    DraggingHandle
  ]);

  // ../../../packages/editor/src/lib/app/statechart/TLTextTool/children/Idle.ts
  var Idle11 = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "onPointerEnter", (info) => {
        switch (info.target) {
          case "canvas": {
            break;
          }
          case "shape": {
            const { selectedIds, focusLayerId } = this.app;
            const hoveringShape = this.app.getOutermostSelectableShape(
              info.shape,
              (parent) => !selectedIds.includes(parent.id)
            );
            if (hoveringShape.id !== focusLayerId) {
              if (hoveringShape.type === "text") {
                this.app.setHoveredId(hoveringShape.id);
              }
            }
            break;
          }
        }
      });
      __publicField(this, "onPointerLeave", (info) => {
        switch (info.target) {
          case "shape": {
            this.app.setHoveredId(null);
            break;
          }
        }
      });
      __publicField(this, "onPointerDown", (info) => {
        const { hoveredId } = this.app;
        if (hoveredId) {
          const shape = this.app.getShapeById(hoveredId);
          if (shape.type === "text") {
            requestAnimationFrame(() => {
              this.app.setSelectedIds([shape.id]);
              this.app.setEditingId(shape.id);
              this.app.setSelectedTool("select.editing_shape", __spreadProps(__spreadValues({}, info), {
                target: "shape",
                shape
              }));
            });
            return;
          }
        }
        this.parent.transition("pointing", info);
      });
      __publicField(this, "onEnter", () => {
        this.app.setCursor({ type: "cross" });
      });
      __publicField(this, "onKeyDown", (info) => {
        if (info.key === "Enter") {
          const shape = this.app.selectedShapes[0];
          if (shape && shape.type === "geo") {
            this.app.setSelectedTool("select");
            this.app.setEditingId(shape.id);
            this.app.root.current.value.transition("editing_shape", __spreadProps(__spreadValues({}, info), {
              target: "shape",
              shape
            }));
          }
        }
      });
      __publicField(this, "onCancel", () => {
        this.app.setSelectedTool("select");
      });
    }
  };
  __publicField(Idle11, "id", "idle");

  // ../../../packages/editor/src/lib/app/statechart/TLTextTool/children/Pointing.ts
  var Pointing8 = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "shape");
      __publicField(this, "onExit", () => {
        this.app.setHintingIds([]);
      });
      __publicField(this, "onPointerMove", (info) => {
        if (this.app.inputs.isDragging) {
          const {
            inputs: { originPagePoint }
          } = this.app;
          const id = createShapeId();
          this.app.mark("creating");
          this.app.createShapes([
            {
              id,
              type: "text",
              x: originPagePoint.x,
              y: originPagePoint.y,
              props: {
                text: "",
                autoSize: false,
                w: 20
              }
            }
          ]);
          this.app.select(id);
          this.shape = this.app.getShapeById(id);
          if (!this.shape)
            return;
          this.app.setSelectedTool("select.resizing", __spreadProps(__spreadValues({}, info), {
            target: "selection",
            handle: "right",
            isCreating: true,
            creationCursorOffset: { x: 1, y: 1 },
            editAfterComplete: true,
            onInteractionEnd: "text"
          }));
        }
      });
      __publicField(this, "onPointerUp", () => {
        this.complete();
      });
      __publicField(this, "onComplete", () => {
        this.cancel();
      });
      __publicField(this, "onCancel", () => {
        this.cancel();
      });
      __publicField(this, "onInterrupt", () => {
        this.cancel();
      });
    }
    complete() {
      var _a5;
      this.app.mark("creating text shape");
      const id = createShapeId();
      const { x: x3, y: y3 } = this.app.inputs.currentPagePoint;
      this.app.createShapes(
        [
          {
            id,
            type: "text",
            x: x3,
            y: y3,
            props: {
              text: "",
              autoSize: true
            }
          }
        ],
        true
      );
      this.app.setEditingId(id);
      this.app.setSelectedTool("select");
      (_a5 = this.app.root.current.value) == null ? void 0 : _a5.transition("editing_shape", {});
    }
    cancel() {
      this.parent.transition("idle", {});
      this.app.bailToMark("creating");
    }
  };
  __publicField(Pointing8, "id", "pointing");

  // ../../../packages/editor/src/lib/app/statechart/TLTextTool/TLTextTool.ts
  var TLTextTool = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "styles", ["color", "opacity", "font", "align", "size"]);
    }
  };
  __publicField(TLTextTool, "id", "text");
  __publicField(TLTextTool, "initial", "idle");
  __publicField(TLTextTool, "children", () => [Idle11, Pointing8]);

  // ../../../packages/editor/src/lib/app/statechart/TLZoomTool/children/Idle.ts
  var Idle12 = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "info", {});
      __publicField(this, "onEnter", (info) => {
        this.info = info;
      });
      __publicField(this, "onPointerDown", () => {
        this.parent.transition("pointing", this.info);
      });
    }
  };
  __publicField(Idle12, "id", "idle");

  // ../../../packages/editor/src/lib/app/statechart/TLZoomTool/children/Pointing.ts
  var Pointing9 = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "info", {});
      __publicField(this, "onEnter", (info) => {
        this.info = info;
      });
      __publicField(this, "onPointerUp", () => {
        this.complete();
      });
      __publicField(this, "onPointerMove", () => {
        if (this.app.inputs.isDragging) {
          this.parent.transition("zoom_brushing", this.info);
        }
      });
      __publicField(this, "onCancel", () => {
        this.cancel();
      });
    }
    complete() {
      const { currentScreenPoint } = this.app.inputs;
      if (this.app.inputs.altKey) {
        this.app.zoomOut(currentScreenPoint, { duration: 220 });
      } else {
        this.app.zoomIn(currentScreenPoint, { duration: 220 });
      }
      this.parent.transition("idle", this.info);
    }
    cancel() {
      this.parent.transition("idle", this.info);
    }
  };
  __publicField(Pointing9, "id", "pointing");

  // ../../../packages/editor/src/lib/app/statechart/TLZoomTool/children/ZoomBrushing.ts
  var ZoomBrushing = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "info", {});
      __publicField(this, "zoomBrush", new Box2d());
      __publicField(this, "onEnter", (info) => {
        this.info = info;
        this.update();
      });
      __publicField(this, "onExit", () => {
        this.app.setZoomBrush(null);
      });
      __publicField(this, "onPointerMove", () => {
        this.update();
      });
      __publicField(this, "onPointerUp", () => {
        this.complete();
      });
      __publicField(this, "onCancel", () => {
        this.cancel();
      });
    }
    update() {
      const {
        inputs: { originPagePoint, currentPagePoint }
      } = this.app;
      this.zoomBrush.setTo(Box2d.FromPoints([originPagePoint, currentPagePoint]));
      this.app.setZoomBrush(this.zoomBrush.toJson());
    }
    cancel() {
      this.parent.transition("idle", this.info);
    }
    complete() {
      const { zoomBrush } = this;
      const threshold = 8 / this.app.zoomLevel;
      if (zoomBrush.width < threshold && zoomBrush.height < threshold) {
        const point2 = this.app.inputs.currentScreenPoint;
        if (this.app.inputs.altKey) {
          this.app.zoomOut(point2, { duration: 220 });
        } else {
          this.app.zoomIn(point2, { duration: 220 });
        }
      } else {
        const zoomLevel = this.app.inputs.altKey ? this.app.zoomLevel / 2 : void 0;
        this.app.zoomToBounds(
          zoomBrush.x,
          zoomBrush.y,
          zoomBrush.width,
          zoomBrush.height,
          zoomLevel,
          { duration: 220 }
        );
      }
      this.parent.transition("idle", this.info);
    }
  };
  __publicField(ZoomBrushing, "id", "zoom_brushing");

  // ../../../packages/editor/src/lib/app/statechart/TLZoomTool/TLZoomTool.ts
  var TLZoomTool = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "info", {});
      __publicField(this, "onEnter", (info) => {
        this.info = info;
        this.updateCursor();
      });
      __publicField(this, "onExit", () => {
        this.app.setZoomBrush(null);
        this.app.setCursor({ type: "default" });
      });
      __publicField(this, "onKeyDown", () => {
        this.updateCursor();
      });
      __publicField(this, "onKeyUp", (info) => {
        this.updateCursor();
        if (info.code === "KeyZ") {
          this.complete();
        }
      });
      __publicField(this, "onInterrupt", () => {
        this.complete();
      });
    }
    updateCursor() {
      if (this.app.inputs.altKey) {
        this.app.setCursor({ type: "zoom-out" });
      } else {
        this.app.setCursor({ type: "zoom-in" });
      }
    }
    complete() {
      if (this.info.onInteractionEnd && this.info.onInteractionEnd !== "select") {
        this.app.setSelectedTool(this.info.onInteractionEnd, this.info);
      } else {
        this.parent.transition("select", {});
      }
    }
  };
  __publicField(TLZoomTool, "id", "zoom");
  __publicField(TLZoomTool, "initial", "idle");
  __publicField(TLZoomTool, "children", () => [Idle12, ZoomBrushing, Pointing9]);

  // ../../../packages/editor/src/lib/app/statechart/RootState.ts
  var RootState = class extends StateNode {
    constructor() {
      super(...arguments);
      __publicField(this, "onKeyDown", (info) => {
        var _a5;
        switch (info.code) {
          case "KeyZ": {
            if (!(info.shiftKey || info.ctrlKey)) {
              const currentTool = this.current.value;
              if (currentTool && ((_a5 = currentTool.current.value) == null ? void 0 : _a5.id) === "idle") {
                this.app.setSelectedTool("zoom", __spreadProps(__spreadValues({}, info), { onInteractionEnd: currentTool.id }));
              }
            }
            break;
          }
        }
      });
    }
  };
  __publicField(RootState, "id", "root");
  __publicField(RootState, "initial", "select");
  __publicField(RootState, "children", () => [
    TLSelectTool,
    TLHandTool,
    TLEraserTool,
    TLDrawTool,
    TLTextTool,
    TLLineTool,
    TLArrowTool,
    TLGeoTool,
    TLNoteTool,
    TLFrameTool,
    TLZoomTool
  ]);

  // ../../../packages/editor/src/lib/app/App.ts
  function isShapeWithHandles(shape) {
    return shape.type === "arrow" || shape.type === "line" || shape.type === "draw";
  }
  var _App = class extends import_eventemitter3.EventEmitter {
    constructor({ config = TldrawEditorConfig.default, store, getContainer }) {
      super();
      /**
       * The editor's store
       *
       * @public
       */
      __publicField(this, "store");
      /**
       * The editor's config
       *
       * @public
       */
      __publicField(this, "config");
      /**
       * The root state of the statechart.
       *
       * @public
       */
      __publicField(this, "root");
      /**
       * A cache of shape ids in the current page.
       *
       * @internal
       */
      __publicField(this, "_shapeIds");
      /**
       * A set of functions to call when the app is disposed.
       *
       * @public
       */
      __publicField(this, "disposables", /* @__PURE__ */ new Set());
      /** @internal */
      __publicField(this, "_dprManager", new DprManager(this));
      /** @internal */
      __publicField(this, "_cameraManager", new CameraManager(this));
      /** @internal */
      __publicField(this, "_activeAreaManager", new ActiveAreaManager(this));
      /** @internal */
      __publicField(this, "_tickManager", new TickManager(this));
      /** @internal */
      __publicField(this, "_updateDepth", 0);
      /**
       * A manager for the app's snapping feature.
       *
       * @public
       */
      __publicField(this, "snaps", new SnapManager(this));
      /**
       * Whether the editor is running in Safari.
       *
       * @public
       */
      __publicField(this, "isSafari");
      /**
       * Whether the editor is running on iOS.
       *
       * @public
       */
      __publicField(this, "isIos");
      /**
       * Whether the editor is running on iOS.
       *
       * @public
       */
      __publicField(this, "isChromeForIos");
      // Flags
      __publicField(this, "_canMoveCamera", atom("can move camera", true));
      __publicField(this, "_isFocused", atom("_isFocused", false));
      /**
       * The current HTML element containing the editor.
       *
       * @example
       *
       * ```ts
       * const container = app.getContainer()
       * ```
       *
       * @public
       */
      __publicField(this, "getContainer");
      /** @internal */
      __publicField(this, "_crashingError", null);
      __publicField(this, "_openMenus", atom("open-menus", []));
      /**
       * Add an open menu.
       *
       * ```ts
       * app.addOpenMenu('menu-id')
       * ```
       * @public
       */
      __publicField(this, "addOpenMenu", (id) => {
        const menus = new Set(this.openMenus);
        if (!menus.has(id)) {
          menus.add(id);
          this._openMenus.set([...menus]);
        }
        return this;
      });
      /**
       * Delete an open menu.
       *
       * ```ts
       * app.deleteOpenMenu('menu-id')
       * ```
       * @public
       */
      __publicField(this, "deleteOpenMenu", (id) => {
        const menus = new Set(this.openMenus);
        if (menus.has(id)) {
          menus.delete(id);
          this._openMenus.set([...menus]);
        }
        return this;
      });
      /** @internal */
      __publicField(this, "_isCoarsePointer", atom("isCoarsePointer", false));
      /** @internal */
      __publicField(this, "_isChangingStyle", atom("isChangingStyle", false));
      /** @internal */
      __publicField(this, "_isChangingStyleTimeout", -1);
      /**
       * A cache of parents to children.
       *
       * @internal
       */
      __publicField(this, "_parentIdsToChildIds");
      /**
       * A manager for the app's history.
       *
       * @readonly
       */
      __publicField(this, "history", new HistoryManager(
        this,
        () => this._complete(),
        (error) => {
          this.annotateError(error, { origin: "history.batch", willCrashApp: true });
          this.crash(error);
        }
      ));
      /**
       * A map of shape utility classes (TLShapeUtils) by shape type.
       *
       * @public
       */
      __publicField(this, "shapeUtils");
      /**
       * A cache of children for each parent.
       *
       * @internal
       */
      __publicField(this, "_childIdsCache", new WeakMapCache());
      /**
       * A derived object containing all current props among the user's selected shapes.
       *
       * @internal
       */
      __publicField(this, "_selectionSharedProps", computed("_selectionSharedProps", () => {
        const { selectedShapes } = this;
        const sharedProps = {};
        for (let i3 = 0, n3 = selectedShapes.length; i3 < n3; i3++) {
          this._extractSharedProps(selectedShapes[i3], sharedProps);
        }
        return sharedProps;
      }));
      /** @internal */
      __publicField(this, "_prevProps", {});
      /**
       * _invalidParents is used to trigger the 'onChildrenChange' callback that shapes can have.
       *
       * @internal
       */
      __publicField(this, "_invalidParents", /* @__PURE__ */ new Set());
      __publicField(this, "_isReadOnly", atom("isReadOnly", false));
      /** @internal */
      __publicField(this, "_isPenMode", atom("isPenMode", false));
      /** @internal */
      __publicField(this, "_touchEventsRemainingBeforeExitingPenMode", 0);
      /** @internal */
      __publicField(this, "_cullingBounds", atom("culling viewport", new Box2d()));
      /** @internal */
      __publicField(this, "_cullingBoundsExpanded", atom("culling viewport expanded", new Box2d()));
      /** @internal */
      __publicField(this, "_setFocusLayer", this.history.createCommand(
        "setFocusLayer",
        (next) => {
          if (next === null && !this.canUndo) {
            return;
          }
          const prev = this.pageState.focusLayerId;
          return { data: { prev, next }, preservesRedoStack: true, squashing: true };
        },
        {
          do: ({ next }) => {
            this.store.update(this.pageState.id, (s3) => __spreadProps(__spreadValues({}, s3), { focusLayerId: next }));
          },
          undo: ({ prev }) => {
            this.store.update(this.pageState.id, (s3) => __spreadProps(__spreadValues({}, s3), { focusLayerId: prev }));
          },
          squash({ prev }, { next }) {
            return { prev, next };
          }
        }
      ));
      /* --------------------- Styles --------------------- */
      /**
       * A mapping of color ids to CSS color values.
       *
       * @internal
       */
      __publicField(this, "colors");
      /**
       * A mapping of size ids to size values.
       *
       * @internal
       */
      __publicField(this, "sizes", {
        s: 2,
        m: 3.5,
        l: 5,
        xl: 10
      });
      /* --------------------- Inputs --------------------- */
      /**
       * The app's current input state.
       *
       * @public
       */
      __publicField(this, "inputs", {
        /** The most recent pointer down's position in page space. */
        originPagePoint: new Vec2d(),
        /** The most recent pointer down's position in screen space. */
        originScreenPoint: new Vec2d(),
        /** The previous pointer position in page space. */
        previousPagePoint: new Vec2d(),
        /** The previous pointer position in screen space. */
        previousScreenPoint: new Vec2d(),
        /** The most recent pointer position in page space. */
        currentPagePoint: new Vec2d(),
        /** The most recent pointer position in screen space. */
        currentScreenPoint: new Vec2d(),
        /** A set containing the currently pressed keys. */
        keys: /* @__PURE__ */ new Set(),
        /** A set containing the currently pressed buttons. */
        buttons: /* @__PURE__ */ new Set(),
        /** Whether the input is from a pe. */
        isPen: false,
        /** Whether the shift key is currently pressed. */
        shiftKey: false,
        /** Whether the control or command key is currently pressed. */
        ctrlKey: false,
        /** Whether the alt or option key is currently pressed. */
        altKey: false,
        /** Whether the user is dragging. */
        isDragging: false,
        /** Whether the user is pointing. */
        isPointing: false,
        /** Whether the user is pinching. */
        isPinching: false,
        /** Whether the user is editing. */
        isEditing: false,
        /** Whether the user is panning. */
        isPanning: false,
        /** Veclocity of mouse pointer, in pixels per millisecond */
        pointerVelocity: new Vec2d()
      });
      /* --------------------- Events --------------------- */
      /**
       * A manager for recording multiple click events.
       *
       * @internal
       */
      __publicField(this, "_clickManager", new ClickManager(this));
      /**
       * The previous cursor. Used for restoring the cursor after pan events.
       *
       * @internal
       */
      __publicField(this, "_prevCursor", "default");
      /** @internal */
      __publicField(this, "_shiftKeyTimeout", -1);
      /** @internal */
      __publicField(this, "_setShiftKeyTimeout", () => {
        this.inputs.shiftKey = false;
        this.dispatch({
          type: "keyboard",
          name: "key_up",
          key: "Shift",
          shiftKey: this.inputs.shiftKey,
          ctrlKey: this.inputs.ctrlKey,
          altKey: this.inputs.altKey,
          code: "ShiftLeft"
        });
      });
      /** @internal */
      __publicField(this, "_altKeyTimeout", -1);
      /** @internal */
      __publicField(this, "_setAltKeyTimeout", () => {
        this.inputs.altKey = false;
        this.dispatch({
          type: "keyboard",
          name: "key_up",
          key: "Alt",
          shiftKey: this.inputs.shiftKey,
          ctrlKey: this.inputs.ctrlKey,
          altKey: this.inputs.altKey,
          code: "AltLeft"
        });
      });
      /** @internal */
      __publicField(this, "_ctrlKeyTimeout", -1);
      /** @internal */
      __publicField(this, "_setCtrlKeyTimeout", () => {
        this.inputs.ctrlKey = false;
        this.dispatch({
          type: "keyboard",
          name: "key_up",
          key: "Ctrl",
          shiftKey: this.inputs.shiftKey,
          ctrlKey: this.inputs.ctrlKey,
          altKey: this.inputs.altKey,
          code: "CtrlLeft"
        });
      });
      /** @internal */
      __publicField(this, "_restoreToolId", "select");
      /** @internal */
      __publicField(this, "_pinchStart", 1);
      /** @internal */
      __publicField(this, "_didPinch", false);
      /** @internal */
      __publicField(this, "_selectedIdsAtPointerDown", []);
      /**
       * Dispatch an event to the app.
       *
       * @example
       *
       * ```ts
       * app.dispatch(myPointerEvent)
       * ```
       *
       * @param info - The event info.
       * @public
       */
      __publicField(this, "dispatch", (info) => {
        if (this.crashingError)
          return this;
        const { inputs } = this;
        const { type } = info;
        this.batch(() => {
          var _a5;
          if (info.type === "misc") {
            if (info.name === "cancel" || info.name === "complete") {
              this.inputs.isDragging = false;
              if (this.inputs.isPanning) {
                this.inputs.isPanning = false;
                this.setCursor({
                  type: this._prevCursor
                });
              }
            }
            this.root.handleEvent(info);
            return;
          }
          if (info.shiftKey) {
            clearInterval(this._shiftKeyTimeout);
            this._shiftKeyTimeout = -1;
            inputs.shiftKey = true;
          } else if (!info.shiftKey && inputs.shiftKey && this._shiftKeyTimeout === -1) {
            this._shiftKeyTimeout = setTimeout(this._setShiftKeyTimeout, 150);
          }
          if (info.altKey) {
            clearInterval(this._altKeyTimeout);
            this._altKeyTimeout = -1;
            inputs.altKey = true;
          } else if (!info.altKey && inputs.altKey && this._altKeyTimeout === -1) {
            this._altKeyTimeout = setTimeout(this._setAltKeyTimeout, 150);
          }
          if (info.ctrlKey) {
            clearInterval(this._ctrlKeyTimeout);
            this._ctrlKeyTimeout = -1;
            inputs.ctrlKey = true;
          } else if (!info.ctrlKey && inputs.ctrlKey && this._ctrlKeyTimeout === -1) {
            this._ctrlKeyTimeout = setTimeout(this._setCtrlKeyTimeout, 150);
          }
          const { originPagePoint, originScreenPoint, currentPagePoint, currentScreenPoint } = inputs;
          if (!inputs.isPointing) {
            inputs.isDragging = false;
          }
          switch (type) {
            case "pinch": {
              if (!this.canMoveCamera)
                return;
              this._updateInputsFromEvent(info);
              switch (info.name) {
                case "pinch_start": {
                  if (inputs.isPinching)
                    return;
                  if (!inputs.isEditing) {
                    this._pinchStart = this.camera.z;
                    if (!this._selectedIdsAtPointerDown.length) {
                      this._selectedIdsAtPointerDown = this.selectedIds.slice();
                    }
                    this._didPinch = true;
                    inputs.isPinching = true;
                    this.interrupt();
                  }
                  return;
                }
                case "pinch": {
                  if (!inputs.isPinching)
                    return;
                  const {
                    point: { x: x3, y: y3, z: z2 = 1 },
                    delta: { x: dx, y: dy }
                  } = info;
                  const {
                    camera: { x: cx, y: cy, z: cz }
                  } = this;
                  const zoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, z2));
                  this.setCamera(
                    cx + dx / cz - x3 / cz + x3 / zoom,
                    cy + dy / cz - y3 / cz + y3 / zoom,
                    zoom
                  );
                  return;
                }
                case "pinch_end": {
                  if (!inputs.isPinching)
                    return this;
                  inputs.isPinching = false;
                  const { _selectedIdsAtPointerDown } = this;
                  this.setSelectedIds(this._selectedIdsAtPointerDown, true);
                  this._selectedIdsAtPointerDown = [];
                  const {
                    camera: { x: cx, y: cy, z: cz }
                  } = this;
                  let zoom;
                  if (cz > 0.9 && cz < 1.05) {
                    zoom = 1;
                  } else if (cz > 0.49 && cz < 0.505) {
                    zoom = 0.5;
                  }
                  if (cz > this._pinchStart - 0.1 && cz < this._pinchStart + 0.05) {
                    zoom = this._pinchStart;
                  }
                  if (zoom !== void 0) {
                    const { x: x3, y: y3 } = this.viewportScreenCenter;
                    this.animateCamera(
                      cx + (x3 / zoom - x3) - (x3 / cz - x3),
                      cy + (y3 / zoom - y3) - (y3 / cz - y3),
                      zoom,
                      { duration: 100 }
                    );
                  }
                  if (this._didPinch) {
                    this._didPinch = false;
                    requestAnimationFrame(() => {
                      if (!this._didPinch) {
                        this.setSelectedIds(_selectedIdsAtPointerDown, true);
                      }
                    });
                  }
                  return;
                }
              }
            }
            case "wheel": {
              if (!this.canMoveCamera)
                return;
              if (this.isMenuOpen) {
              } else {
                if (inputs.ctrlKey) {
                  const { x: x3, y: y3 } = this.inputs.currentScreenPoint;
                  const { x: cx, y: cy, z: cz } = this.camera;
                  const zoom = Math.min(MAX_ZOOM, Math.max(MIN_ZOOM, cz + ((_a5 = info.delta.z) != null ? _a5 : 0) * cz));
                  this.setCamera(
                    cx + (x3 / zoom - x3) - (x3 / cz - x3),
                    cy + (y3 / zoom - y3) - (y3 / cz - y3),
                    zoom
                  );
                  return;
                }
                this.pan(info.delta.x, info.delta.y);
                if (!inputs.isDragging && inputs.isPointing && originPagePoint.dist(currentPagePoint) > (this.isCoarsePointer ? COARSE_DRAG_DISTANCE : DRAG_DISTANCE) / this.zoomLevel) {
                  inputs.isDragging = true;
                }
              }
              break;
            }
            case "pointer": {
              if (inputs.isPinching)
                return;
              this._updateInputsFromEvent(info);
              const { isPen } = info;
              switch (info.name) {
                case "pointer_down": {
                  this._selectedIdsAtPointerDown = this.selectedIds.slice();
                  inputs.buttons.add(info.button);
                  inputs.isPointing = true;
                  inputs.isDragging = false;
                  if (this.isPenMode) {
                    if (!isPen) {
                      this._touchEventsRemainingBeforeExitingPenMode--;
                      if (this._touchEventsRemainingBeforeExitingPenMode === 0) {
                        this.setPenMode(false);
                      } else {
                        return;
                      }
                    } else {
                      this._touchEventsRemainingBeforeExitingPenMode = 3;
                    }
                  } else {
                    if (isPen) {
                      this.setPenMode(true);
                    }
                  }
                  if (info.button === 5) {
                    this._restoreToolId = this.currentToolId;
                    this.complete();
                    this.setSelectedTool("eraser");
                  } else if (info.button === 1) {
                    if (!this.inputs.isPanning) {
                      this._prevCursor = this.instanceState.cursor.type;
                    }
                    this.inputs.isPanning = true;
                  }
                  if (this.inputs.isPanning) {
                    this.stopCameraAnimation();
                    this.setCursor({
                      type: "grabbing"
                    });
                    return this;
                  }
                  originScreenPoint.setTo(currentScreenPoint);
                  originPagePoint.setTo(currentPagePoint);
                  break;
                }
                case "pointer_move": {
                  if (!isPen && this.isPenMode) {
                    return;
                  }
                  if (this.inputs.isPanning && this.inputs.isPointing) {
                    const { currentScreenPoint: currentScreenPoint2, previousScreenPoint } = this.inputs;
                    const delta = Vec2d.Sub(currentScreenPoint2, previousScreenPoint);
                    this.pan(delta.x, delta.y);
                    return;
                  }
                  if (!inputs.isDragging && inputs.isPointing && originPagePoint.dist(currentPagePoint) > (this.isCoarsePointer ? COARSE_DRAG_DISTANCE : DRAG_DISTANCE) / this.zoomLevel) {
                    inputs.isDragging = true;
                  }
                  break;
                }
                case "pointer_up": {
                  inputs.buttons.delete(info.button);
                  inputs.isPointing = false;
                  inputs.isDragging = false;
                  if (this.isMenuOpen) {
                    return;
                  }
                  if (!isPen && this.isPenMode) {
                    return;
                  }
                  if (inputs.isPanning) {
                    if (info.button === 1) {
                      if (!this.inputs.keys.has(" ")) {
                        inputs.isPanning = false;
                        this.slideCamera({
                          speed: Math.min(2, this.inputs.pointerVelocity.len()),
                          direction: this.inputs.pointerVelocity,
                          friction: HAND_TOOL_FRICTION
                        });
                        this.setCursor({
                          type: this._prevCursor
                        });
                      } else {
                        this.slideCamera({
                          speed: Math.min(2, this.inputs.pointerVelocity.len()),
                          direction: this.inputs.pointerVelocity,
                          friction: HAND_TOOL_FRICTION
                        });
                        this.setCursor({
                          type: "grab"
                        });
                      }
                    } else if (info.button === 0) {
                      this.slideCamera({
                        speed: Math.min(2, this.inputs.pointerVelocity.len()),
                        direction: this.inputs.pointerVelocity,
                        friction: HAND_TOOL_FRICTION
                      });
                      this.setCursor({
                        type: "grab"
                      });
                    }
                  } else {
                    if (info.button === 5) {
                      this.complete();
                      this.setSelectedTool(this._restoreToolId);
                    }
                  }
                  break;
                }
              }
              break;
            }
            case "keyboard": {
              switch (info.name) {
                case "key_down": {
                  inputs.keys.add(info.code);
                  if (!info.ctrlKey && info.code === "Space") {
                    if (!this.inputs.isPanning) {
                      this._prevCursor = this.instanceState.cursor.type;
                    }
                    this.inputs.isPanning = true;
                    this.setCursor({
                      type: this.inputs.isPointing ? "grabbing" : "grab"
                    });
                  }
                  break;
                }
                case "key_up": {
                  inputs.keys.delete(info.code);
                  if (info.code === "Space" && !this.inputs.buttons.has(1)) {
                    this.inputs.isPanning = false;
                    this.setCursor({
                      type: this._prevCursor
                    });
                  }
                  break;
                }
                case "key_repeat": {
                  break;
                }
              }
              break;
            }
          }
          if (info.type === "pointer") {
            if (info.button === 1) {
              info.name = "middle_click";
            } else if (info.button === 2) {
              info.name = "right_click";
            }
            if (info.isPen === this.isPenMode) {
              switch (info.name) {
                case "pointer_down": {
                  const otherEvent = this._clickManager.transformPointerDownEvent(info);
                  if (info.name !== otherEvent.name) {
                    this.root.handleEvent(info);
                    this.emit("event", info);
                    this.root.handleEvent(otherEvent);
                    this.emit("event", otherEvent);
                    return;
                  }
                  break;
                }
                case "pointer_up": {
                  const otherEvent = this._clickManager.transformPointerUpEvent(info);
                  if (info.name !== otherEvent.name) {
                    this.root.handleEvent(info);
                    this.emit("event", info);
                    this.root.handleEvent(otherEvent);
                    this.emit("event", otherEvent);
                    return;
                  }
                  break;
                }
                case "pointer_move": {
                  this._clickManager.handleMove();
                  break;
                }
              }
            }
          }
          this.root.handleEvent(info);
          this.emit("event", info);
        });
        return this;
      });
      /** @internal */
      __publicField(this, "_createShapes", this.history.createCommand(
        "createShapes",
        (partials, select = false) => {
          if (this.isReadOnly)
            return null;
          if (partials.length <= 0)
            return null;
          const { shapeIds, selectedIds } = this;
          const prevSelectedIds = select ? selectedIds : void 0;
          const maxShapesReached = partials.length + shapeIds.size > MAX_SHAPES_PER_PAGE;
          if (maxShapesReached) {
            alertMaxShapes(this);
          }
          const partialsToCreate = maxShapesReached ? partials.slice(0, MAX_SHAPES_PER_PAGE - shapeIds.size) : partials;
          if (partialsToCreate.length === 0)
            return null;
          return {
            data: {
              currentPageId: this.currentPageId,
              createdIds: partials.map((p3) => p3.id),
              prevSelectedIds,
              partials: partialsToCreate,
              select
            }
          };
        },
        {
          do: ({ createdIds, partials, select }) => {
            var _a5, _b2, _c, _d;
            const { focusLayerId } = this;
            partials = partials.map((partial) => {
              var _a6, _b3, _c2, _d2, _e;
              if (
                // No parentId provided
                !partial.parentId || // A parentId is proved but the parent is neither a) in the store
                // or b) among the other creating shape partials
                !this.store.get(partial.parentId) && !partials.find((p3) => p3.id === partial.parentId)
              ) {
                partial = __spreadValues({}, partial);
                const parentId = this.getParentIdForNewShapeAtPoint(
                  { x: (_a6 = partial.x) != null ? _a6 : 0, y: (_b3 = partial.y) != null ? _b3 : 0 },
                  partial.type
                );
                partial.parentId = parentId;
                if (isShapeId(parentId)) {
                  const point2 = this.getPointInShapeSpace(this.getShapeById(parentId), {
                    x: (_c2 = partial.x) != null ? _c2 : 0,
                    y: (_d2 = partial.y) != null ? _d2 : 0
                  });
                  partial.x = point2.x;
                  partial.y = point2.y;
                  partial.rotation = -this.getPageRotationById(parentId) + ((_e = partial.rotation) != null ? _e : 0);
                }
                return partial;
              }
              return partial;
            });
            const parentIndices = /* @__PURE__ */ new Map();
            const shapeRecordsToCreate = [];
            for (const partial of partials) {
              const util = this.getShapeUtil(partial);
              let index2 = partial.index;
              if (!index2) {
                const parentId = (_a5 = partial.parentId) != null ? _a5 : focusLayerId;
                if (!parentIndices.has(parentId)) {
                  parentIndices.set(parentId, this.getHighestIndexForParent(parentId));
                }
                index2 = parentIndices.get(parentId);
                parentIndices.set(parentId, getIndexAbove(index2));
              }
              const initialProps = util.defaultProps();
              const { propsForNextShape } = this.instanceState;
              for (const key in initialProps) {
                if (key in propsForNextShape) {
                  if (key === "url")
                    continue;
                  initialProps[key] = propsForNextShape[key];
                }
              }
              let shapeRecordToCreate = this.config.TLShape.create(__spreadProps(__spreadValues({}, partial), {
                index: index2,
                parentId: (_b2 = partial.parentId) != null ? _b2 : focusLayerId,
                props: "props" in partial ? __spreadValues(__spreadValues({}, initialProps), partial.props) : initialProps
              }));
              if (shapeRecordToCreate.index === void 0) {
                throw Error("no index!");
              }
              const next = (_d = (_c = this.getShapeUtil(shapeRecordToCreate)).onBeforeCreate) == null ? void 0 : _d.call(_c, shapeRecordToCreate);
              if (next) {
                shapeRecordToCreate = next;
              }
              shapeRecordsToCreate.push(shapeRecordToCreate);
            }
            this.store.put(shapeRecordsToCreate);
            if (select) {
              this.store.update(this.pageState.id, (state) => __spreadProps(__spreadValues({}, state), {
                selectedIds: createdIds
              }));
            }
          },
          undo: ({ createdIds, prevSelectedIds }) => {
            this.store.remove(createdIds);
            if (prevSelectedIds) {
              this.store.update(this.pageState.id, (state) => __spreadProps(__spreadValues({}, state), {
                selectedIds: prevSelectedIds
              }));
            }
          }
        }
      ));
      __publicField(this, "animatingShapes", /* @__PURE__ */ new Map());
      /** @internal */
      __publicField(this, "_updateShapes", this.history.createCommand(
        "updateShapes",
        (_partials, squashing = false) => {
          if (this.isReadOnly)
            return null;
          const partials = compact(_partials);
          const snapshots = Object.fromEntries(
            compact(partials.map(({ id }) => this.getShapeById(id))).map((shape) => {
              return [shape.id, shape];
            })
          );
          if (partials.length <= 0)
            return null;
          const updated = compact(
            partials.map((partial) => {
              const prev = snapshots[partial.id];
              if (!prev)
                return null;
              let newRecord = null;
              for (const [k2, v3] of Object.entries(partial)) {
                switch (k2) {
                  case "id":
                  case "type":
                  case "typeName": {
                    continue;
                  }
                  default: {
                    if (v3 !== prev[k2]) {
                      if (!newRecord) {
                        newRecord = __spreadValues({}, prev);
                      }
                      if (k2 === "props") {
                        newRecord.props = __spreadValues(__spreadValues({}, prev.props), v3);
                      } else {
                        ;
                        newRecord[k2] = v3;
                      }
                    }
                  }
                }
              }
              return newRecord != null ? newRecord : prev;
            })
          );
          const updates = Object.fromEntries(updated.map((shape) => [shape.id, shape]));
          return { data: { snapshots, updates }, squashing };
        },
        {
          do: ({ updates }) => {
            var _a5, _b2;
            const result = Object.values(updates);
            for (let i3 = 0; i3 < result.length; i3++) {
              const shape = result[i3];
              const current = this.store.get(shape.id);
              if (!current)
                continue;
              const next = (_b2 = (_a5 = this.getShapeUtil(shape)).onBeforeUpdate) == null ? void 0 : _b2.call(_a5, current, shape);
              if (next) {
                result[i3] = next;
              }
            }
            this.store.put(result);
          },
          undo: ({ snapshots }) => {
            this.store.put(Object.values(snapshots));
          },
          squash(prevData, nextData) {
            return {
              // keep the oldest snapshots
              snapshots: __spreadValues(__spreadValues({}, nextData.snapshots), prevData.snapshots),
              // keep the newest updates
              updates: __spreadValues(__spreadValues({}, prevData.updates), nextData.updates)
            };
          }
        }
      ));
      /** @internal */
      __publicField(this, "_deleteShapes", this.history.createCommand(
        "delete_shapes",
        (ids) => {
          if (this.isReadOnly)
            return null;
          if (ids.length === 0)
            return null;
          const prevSelectedIds = [...this.pageState.selectedIds];
          const allIds = new Set(ids);
          for (const id of ids) {
            this.visitDescendants(id, (childId) => {
              allIds.add(childId);
            });
          }
          const deletedIds = [...allIds];
          const arrowBindings = this._arrowBindingsIndex.value;
          const snapshots = compact(
            deletedIds.flatMap((id) => {
              const shape = this.getShapeById(id);
              const bindings = arrowBindings[id];
              if (bindings && bindings.length > 0) {
                return bindings.map(({ arrowId }) => this.getShapeById(arrowId)).concat(shape);
              }
              return shape;
            })
          );
          const postSelectedIds = prevSelectedIds.filter((id) => !allIds.has(id));
          return { data: { deletedIds, snapshots, prevSelectedIds, postSelectedIds } };
        },
        {
          do: ({ deletedIds, postSelectedIds }) => {
            this.store.remove(deletedIds);
            this.store.update(this.pageState.id, (state) => __spreadProps(__spreadValues({}, state), {
              selectedIds: postSelectedIds
            }));
          },
          undo: ({ snapshots, prevSelectedIds }) => {
            this.store.put(snapshots);
            this.store.update(this.pageState.id, (state) => __spreadProps(__spreadValues({}, state), {
              selectedIds: prevSelectedIds
            }));
          }
        }
      ));
      /** @internal */
      __publicField(this, "_updateUserDocumentSettings", this.history.createCommand(
        "updateUserDocumentSettings",
        (partial, ephemeral = false) => {
          const prev = this.userDocumentSettings;
          const next = __spreadValues(__spreadValues({}, prev), partial);
          return { data: { prev, next }, ephemeral };
        },
        {
          do: ({ next }) => {
            this.store.put([next]);
          },
          undo: ({ prev }) => {
            this.store.put([prev]);
          }
        }
      ));
      /** @internal */
      __publicField(this, "_updatePage", this.history.createCommand(
        "updatePage",
        (partial, squashing = false) => {
          if (this.isReadOnly)
            return null;
          const prev = this.getPageById(partial.id);
          if (!prev)
            return null;
          return { data: { prev, partial }, squashing };
        },
        {
          do: ({ partial }) => {
            this.store.update(partial.id, (page) => __spreadValues(__spreadValues({}, page), partial));
          },
          undo: ({ prev, partial }) => {
            this.store.update(partial.id, () => prev);
          },
          squash(prevData, nextData) {
            return {
              prev: __spreadValues(__spreadValues({}, prevData.prev), nextData.prev),
              partial: nextData.partial
            };
          }
        }
      ));
      /** @internal */
      __publicField(this, "_createPage", this.history.createCommand(
        "createPage",
        (title, id = TLPage.createId(), belowPageIndex) => {
          var _a5, _b2, _c;
          if (this.isReadOnly)
            return null;
          if (this.pages.length >= MAX_PAGES)
            return null;
          const pageInfo = this.pages;
          const topIndex = (_b2 = belowPageIndex != null ? belowPageIndex : (_a5 = pageInfo[pageInfo.length - 1]) == null ? void 0 : _a5.index) != null ? _b2 : "a1";
          const bottomIndex = (_c = pageInfo[pageInfo.findIndex((p3) => p3.index === topIndex) + 1]) == null ? void 0 : _c.index;
          const prevPageState = __spreadValues({}, this.pageState);
          const prevInstanceState = __spreadValues({}, this.instanceState);
          title = getIncrementedName(
            title,
            pageInfo.map((p3) => p3.name)
          );
          const newPage = TLPage.create({
            id,
            name: title,
            index: bottomIndex && topIndex !== bottomIndex ? getIndexBetween(topIndex, bottomIndex) : getIndexAbove(topIndex)
          });
          const newCamera = TLCamera.create({});
          const newTabPageState = TLInstancePageState.create({
            pageId: newPage.id,
            instanceId: this.instanceId,
            cameraId: newCamera.id
          });
          return {
            data: {
              prevPageState,
              prevTabState: prevInstanceState,
              newPage,
              newTabPageState,
              newCamera
            }
          };
        },
        {
          do: ({ newPage, newTabPageState, newCamera }) => {
            this.store.put([
              newPage,
              newCamera,
              newTabPageState,
              __spreadProps(__spreadValues({}, this.instanceState), { currentPageId: newPage.id })
            ]);
            this.updateCullingBounds();
          },
          undo: ({ newPage, prevPageState, prevTabState, newTabPageState }) => {
            this.store.put([prevPageState, prevTabState]);
            this.store.remove([newTabPageState.id, newPage.id, newTabPageState.cameraId]);
            this.updateCullingBounds();
          }
        }
      ));
      /** @internal */
      __publicField(this, "_deletePage", this.history.createCommand(
        "delete_page",
        (id) => {
          var _a5;
          if (this.isReadOnly)
            return null;
          const { pages } = this;
          if (pages.length === 1)
            return null;
          const deletedPage = this.getPageById(id);
          const deletedPageStates = this._pageStates.value.filter((s3) => s3.pageId === id);
          if (!deletedPage)
            return null;
          if (id === this.currentPageId) {
            const index2 = pages.findIndex((page) => page.id === id);
            const next = (_a5 = pages[index2 - 1]) != null ? _a5 : pages[index2 + 1];
            this.setCurrentPageId(next.id);
          }
          return { data: { id, deletedPage, deletedPageStates } };
        },
        {
          do: ({ deletedPage, deletedPageStates }) => {
            var _a5;
            const { pages } = this;
            if (pages.length === 1)
              return;
            if (deletedPage.id === this.currentPageId) {
              const index2 = pages.findIndex((page) => page.id === deletedPage.id);
              const next = (_a5 = pages[index2 - 1]) != null ? _a5 : pages[index2 + 1];
              this.setCurrentPageId(next.id);
            }
            this.store.remove(deletedPageStates.map((s3) => s3.id));
            this.store.remove([deletedPage.id]);
            this.updateCullingBounds();
          },
          undo: ({ deletedPage, deletedPageStates }) => {
            this.store.put([deletedPage]);
            this.store.put(deletedPageStates);
            this.updateCullingBounds();
          }
        }
      ));
      /** @internal */
      __publicField(this, "_setInstancePageState", this.history.createCommand(
        "setInstancePageState",
        (partial, ephemeral = false) => {
          var _a5;
          const prev = this.store.get((_a5 = partial.id) != null ? _a5 : this.pageState.id);
          return { data: { prev, partial }, ephemeral };
        },
        {
          do: ({ prev, partial }) => {
            this.store.update(prev.id, (state) => __spreadValues(__spreadValues({}, state), partial));
          },
          undo: ({ prev }) => {
            this.store.update(prev.id, () => prev);
          }
        }
      ));
      // when a user performs any action in the app, we update their presence record
      __publicField(this, "updateUserPresence", ({
        cursor,
        color,
        viewportPageBounds
      } = {}) => {
        const presence = this._currentUserPresence.value;
        if (!presence) {
          console.error("No presence found for current user");
          return;
        }
        this.store.put([
          __spreadProps(__spreadValues({}, presence), {
            cursor: cursor != null ? cursor : presence.cursor,
            color: color != null ? color : presence.color,
            viewportPageBounds: viewportPageBounds != null ? viewportPageBounds : presence.viewportPageBounds,
            lastUsedInstanceId: this.instanceId,
            lastActivityTimestamp: Date.now()
          })
        ]);
      });
      /** @internal */
      __publicField(this, "_setSelectedIds", this.history.createCommand(
        "setSelectedIds",
        (ids, squashing = false) => {
          const prevSelectedIds = this.pageState.selectedIds;
          const prevSet = new Set(this.pageState.selectedIds);
          if (ids.length === prevSet.size && ids.every((id) => prevSet.has(id)))
            return null;
          return { data: { ids, prevSelectedIds }, squashing, preservesRedoStack: true };
        },
        {
          do: ({ ids }) => {
            this.store.update(this.pageState.id, (state) => __spreadProps(__spreadValues({}, state), { selectedIds: ids }));
          },
          undo: ({ prevSelectedIds }) => {
            this.store.update(this.pageState.id, () => __spreadProps(__spreadValues({}, this.pageState), {
              selectedIds: prevSelectedIds
            }));
          },
          squash(prev, next) {
            return { ids: next.ids, prevSelectedIds: prev.prevSelectedIds };
          }
        }
      ));
      /** @internal */
      __publicField(this, "_createAssets", this.history.createCommand(
        "createAssets",
        (assets) => {
          if (this.isReadOnly)
            return null;
          if (assets.length <= 0)
            return null;
          return { data: { assets } };
        },
        {
          do: ({ assets }) => {
            this.store.put(assets);
          },
          undo: ({ assets }) => {
            this.store.remove(assets.map((a3) => a3.id));
          }
        }
      ));
      /** @internal */
      __publicField(this, "_deleteAssets", this.history.createCommand(
        "deleteAssets",
        (ids) => {
          if (this.isReadOnly)
            return;
          if (ids.length <= 0)
            return;
          const prev = compact(ids.map((id) => this.store.get(id)));
          return { data: { ids, prev } };
        },
        {
          do: ({ ids }) => {
            this.store.remove(ids);
          },
          undo: ({ prev }) => {
            this.store.put(prev);
          }
        }
      ));
      /** @internal */
      __publicField(this, "_updateAssets", this.history.createCommand(
        "updateAssets",
        (assets) => {
          if (this.isReadOnly)
            return;
          if (assets.length <= 0)
            return;
          const snapshots = {};
          return { data: { snapshots, assets } };
        },
        {
          do: ({ assets, snapshots }) => {
            this.store.put(
              assets.map((a3) => {
                const asset = this.store.get(a3.id);
                snapshots[a3.id] = asset;
                return __spreadValues(__spreadValues({}, asset), a3);
              })
            );
          },
          undo: ({ snapshots }) => {
            this.store.put(Object.values(snapshots));
          }
        }
      ));
      /** @internal */
      __publicField(this, "_setCurrentPageId", this.history.createCommand(
        "setCurrentPage",
        (pageId, { stopFollowing = true } = {}) => {
          if (!this.store.has(pageId)) {
            console.error("Tried to set the current page id to a page that doesn't exist.");
            return;
          }
          if (stopFollowing && this.instanceState.followingUserId) {
            this.stopFollowingUser();
          }
          return {
            data: { toId: pageId, fromId: this.currentPageId },
            squashing: true,
            preservesRedoStack: true
          };
        },
        {
          do: ({ toId }) => {
            if (!this.getPageStateByPageId(toId)) {
              const camera = TLCamera.create({});
              this.store.put([
                camera,
                TLInstancePageState.create({
                  pageId: toId,
                  instanceId: this.instanceId,
                  cameraId: camera.id
                })
              ]);
            }
            this.store.put([__spreadProps(__spreadValues({}, this.instanceState), { currentPageId: toId })]);
            this.updateUserPresence({
              viewportPageBounds: this.viewportPageBounds.toJson()
            });
            this.updateCullingBounds();
          },
          undo: ({ fromId }) => {
            this.store.put([__spreadProps(__spreadValues({}, this.instanceState), { currentPageId: fromId })]);
            this.updateUserPresence({
              viewportPageBounds: this.viewportPageBounds.toJson()
            });
            this.updateCullingBounds();
          },
          squash: ({ fromId }, { toId }) => {
            return { toId, fromId };
          }
        }
      ));
      /** @internal */
      __publicField(this, "_updateInstanceState", this.history.createCommand(
        "updateTabState",
        (partial, ephemeral = false, squashing = false) => {
          const prev = this.instanceState;
          const next = __spreadValues(__spreadValues({}, prev), partial);
          return {
            data: { prev, next },
            squashing,
            ephemeral
          };
        },
        {
          do: ({ next }) => {
            this.store.put([next]);
          },
          undo: ({ prev }) => {
            this.store.put([prev]);
          },
          squash({ prev }, { next }) {
            return { prev, next };
          }
        }
      ));
      /** @internal */
      __publicField(this, "_willSetInitialBounds", true);
      /** @internal */
      __publicField(this, "_viewportAnimation", null);
      /**
       * Start viewport-following a user.
       *
       * @param userId - The id of the user to follow.
       * @public
       */
      __publicField(this, "startFollowingUser", (userId) => {
        var _a5;
        const leaderPresenceRecord = this.store.query.record("user_presence", () => ({
          userId: { eq: userId }
        }));
        const leaderInstanceRecord = this.store.query.record("instance", () => ({
          userId: { eq: userId }
        }));
        if (!leaderInstanceRecord || !leaderPresenceRecord) {
          throw new Error("Couldn't find user to follow");
        }
        if (((_a5 = leaderInstanceRecord.value) == null ? void 0 : _a5.followingUserId) === this.userId) {
          return;
        }
        transact(() => {
          this.stopFollowingUser();
          this.updateInstanceState({
            followingUserId: userId
          });
        });
        const cancel = () => {
          this.removeListener("tick", moveTowardsUser);
          this.removeListener("stop-following", cancel);
        };
        let isCaughtUp = false;
        const moveTowardsUser = () => {
          const leaderInstance = leaderInstanceRecord.value;
          const leaderPresence = leaderPresenceRecord.value;
          if (!leaderInstance || !leaderPresence) {
            this.stopFollowingUser();
            return;
          }
          const isOnSamePage = leaderInstance.currentPageId === this.currentPageId;
          const chaseProportion = isOnSamePage ? FOLLOW_CHASE_PROPORTION : 1;
          if (!isOnSamePage) {
            this.setCurrentPageId(leaderInstance.currentPageId, { stopFollowing: false });
          }
          const { center, width, height } = this.viewportPageBounds;
          const {
            width: leaderWidth,
            height: leaderHeight,
            center: leaderCenter
          } = Box2d.From(leaderPresence.viewportPageBounds);
          const isFollowingFollower = leaderInstance.followingUserId === this.userId;
          const desiredWidth = width + (leaderWidth - width) * chaseProportion;
          const desiredHeight = height + (leaderHeight - height) * chaseProportion;
          const ratio = !isFollowingFollower ? Math.min(width / desiredWidth, height / desiredHeight) : height / desiredHeight;
          const targetZoom = clamp(this.camera.z * ratio, MIN_ZOOM, MAX_ZOOM);
          const targetWidth = this.viewportScreenBounds.w / targetZoom;
          const targetHeight = this.viewportScreenBounds.h / targetZoom;
          const displacement = leaderCenter.sub(center);
          const targetCenter = Vec2d.Add(center, Vec2d.Mul(displacement, chaseProportion));
          const distance = Vec2d.Sub(targetCenter, center).len();
          const zoomChange = Math.abs(targetZoom - this.camera.z);
          if (distance < FOLLOW_CHASE_PAN_SNAP && zoomChange < FOLLOW_CHASE_ZOOM_SNAP) {
            isCaughtUp = true;
            return;
          }
          if (isCaughtUp && distance < FOLLOW_CHASE_PAN_UNSNAP && zoomChange < FOLLOW_CHASE_ZOOM_UNSNAP) {
            return;
          }
          isCaughtUp = false;
          this.stopCameraAnimation();
          this.setCamera(
            -(targetCenter.x - targetWidth / 2),
            -(targetCenter.y - targetHeight / 2),
            targetZoom,
            { stopFollowing: false }
          );
        };
        this.once("stop-following", cancel);
        this.addListener("tick", moveTowardsUser);
        return this;
      });
      /**
       * Stop viewport-following a user.
       *
       * @public
       */
      __publicField(this, "stopFollowingUser", () => {
        this.updateInstanceState({
          followingUserId: null
        });
        this.emit("stop-following");
        return this;
      });
      /* ---------------- Text Measurement ---------------- */
      /**
       * A helper for measuring text.
       *
       * @public
       */
      __publicField(this, "textMeasure");
      if (store.schema !== config.storeSchema) {
        throw new Error("Store schema does not match schema given to App");
      }
      this.config = config;
      this.store = store;
      this.getContainer = getContainer != null ? getContainer : () => document.body;
      this.textMeasure = new TextManager(this);
      this.shapeUtils = Object.fromEntries(
        config.shapes.map((def) => [
          def.type,
          def.createShapeUtils(this)
        ])
      );
      if (typeof window !== "undefined" && "navigator" in window) {
        this.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        this.isIos = !!navigator.userAgent.match(/iPad/i) || !!navigator.userAgent.match(/iPhone/i);
        this.isChromeForIos = /crios.*safari/i.test(navigator.userAgent);
      } else {
        this.isSafari = false;
        this.isIos = false;
        this.isChromeForIos = false;
      }
      this.colors = new Map(_App.styles.color.map((c3) => [c3.id, `var(--palette-${c3.id})`]));
      this.root = new RootState(this);
      if (this.root.children) {
        config.tools.forEach((Ctor) => {
          this.root.children[Ctor.id] = new Ctor(this);
        });
      }
      this.store.onBeforeDelete = (record) => {
        if (record.typeName === "shape") {
          this._shapeWillBeDeleted(record);
        } else if (record.typeName === "page") {
          this._pageWillBeDeleted(record);
        }
      };
      this.store.onAfterChange = (prev, next) => {
        this._updateDepth++;
        if (this._updateDepth > 1e3) {
          console.error("[onAfterChange] Maximum update depth exceeded, bailing out.");
        }
        if (prev.typeName === "shape" && next.typeName === "shape") {
          this._shapeDidChange(prev, next);
        } else if (prev.typeName === "instance_page_state" && next.typeName === "instance_page_state") {
          this._tabStateDidChange(prev, next);
        }
        this._updateDepth--;
      };
      this.store.onAfterCreate = (record) => {
        if (record.typeName === "shape" && TLArrowShapeDef.is(record)) {
          this._arrowDidUpdate(record);
        }
      };
      this._shapeIds = shapeIdsInCurrentPage(this.store, () => this.currentPageId);
      this._parentIdsToChildIds = parentsToChildrenWithIndexes(this.store);
      this.disposables.add(
        this.store.listen((changes) => {
          this.emit("change", changes);
        })
      );
      const container = this.getContainer();
      const focusin = () => {
        this._isFocused.set(true);
      };
      const focusout = () => {
        this._isFocused.set(false);
      };
      container.addEventListener("focusin", focusin);
      container.addEventListener("focus", focusin);
      container.addEventListener("focusout", focusout);
      container.addEventListener("blur", focusout);
      this.disposables.add(() => {
        container.removeEventListener("focusin", focusin);
        container.removeEventListener("focus", focusin);
        container.removeEventListener("focusout", focusout);
        container.removeEventListener("blur", focusout);
      });
      this.store.ensureStoreIsUsable();
      this.setInstancePageState(
        {
          editingId: null,
          hoveredId: null,
          erasingIds: []
        },
        true
      );
      this.root.enter(void 0, "initial");
      if (this.instanceState.followingUserId) {
        this.stopFollowingUser();
      }
      this.updateCullingBounds();
      requestAnimationFrame(() => {
        this._tickManager.start();
      });
    }
    /**
     * Set whether the editor's camera can move.
     *
     * @example
     *
     * ```ts
     * app.canMoveCamera = false
     * ```
     *
     * @param canMove - Whether the camera can move.
     * @public
     */
    get canMoveCamera() {
      return this._canMoveCamera.value;
    }
    set canMoveCamera(canMove) {
      this._canMoveCamera.set(canMove);
    }
    /**
     * Whether or not the editor is focused.
     *
     * @public
     */
    get isFocused() {
      return this._isFocused.value;
    }
    /**
     * The editor's userId (defined in its store.props).
     *
     * @example
     *
     * ```ts
     * const userId = app.userId
     * ```
     *
     * @public
     */
    get userId() {
      return this.store.props.userId;
    }
    /**
     * The editor's instanceId (defined in its store.props).
     *
     * @example
     *
     * ```ts
     * const instanceId = app.instanceId
     * ```
     *
     * @public
     */
    get instanceId() {
      return this.store.props.instanceId;
    }
    /** @internal */
    annotateError(error, {
      origin,
      willCrashApp,
      tags,
      extras
    }) {
      const defaultAnnotations = this.createErrorAnnotations(origin, willCrashApp);
      annotateError(error, {
        tags: __spreadValues(__spreadValues({}, defaultAnnotations.tags), tags),
        extras: __spreadValues(__spreadValues({}, defaultAnnotations.extras), extras)
      });
      if (willCrashApp) {
        this.store.markAsPossiblyCorrupted();
      }
    }
    /** @internal */
    createErrorAnnotations(origin, willCrashApp) {
      try {
        return {
          tags: {
            origin,
            willCrashApp
          },
          extras: {
            activeStateNode: this.root.path.value,
            selectedShapes: this.selectedShapes,
            editingShape: this.editingId ? this.getShapeById(this.editingId) : void 0,
            inputs: this.inputs
          }
        };
      } catch (e2) {
        return {
          tags: {
            origin,
            willCrashApp
          },
          extras: {}
        };
      }
    }
    /**
     * We can't use an `atom` here because there's a chance that when `crashAndReportError` is called,
     * we're in a transaction that's about to be rolled back due to the same error we're currently
     * reporting.
     *
     * Instead, to listen to changes to this value, you need to listen to app's `crash` event.
     *
     * @internal
     */
    get crashingError() {
      return this._crashingError;
    }
    /** @internal */
    crash(error) {
      this._crashingError = error;
      this.store.markAsPossiblyCorrupted();
      this.emit("crash", { error });
    }
    get devicePixelRatio() {
      return this._dprManager.dpr.value;
    }
    get openMenus() {
      return this._openMenus.value;
    }
    get isMenuOpen() {
      return this.openMenus.length > 0;
    }
    /**
     * Whether the user is using a "coarse" pointer, such as on a touch screen.
     *
     * @public
     */
    get isCoarsePointer() {
      return this._isCoarsePointer.value;
    }
    set isCoarsePointer(v3) {
      this._isCoarsePointer.set(v3);
    }
    /**
     * Whether the user is currently changing the style of a shape. This may cause the UI to change.
     *
     * @example
     *
     * ```ts
     * app.isChangingStyle = true
     * ```
     *
     * @public
     */
    get isChangingStyle() {
      return this._isChangingStyle.value;
    }
    set isChangingStyle(v3) {
      this._isChangingStyle.set(v3);
      clearTimeout(this._isChangingStyleTimeout);
      if (v3) {
        this._isChangingStyleTimeout = setTimeout(() => this.isChangingStyle = false, 2e3);
      }
    }
    get _pageTransformCache() {
      return this.store.createComputedCache("pageTransformCache", (shape) => {
        if (TLPage.isId(shape.parentId)) {
          return this.getTransform(shape);
        }
        const parent = this._pageTransformCache.get(shape.parentId);
        return Matrix2d.Compose(parent, this.getTransform(shape));
      });
    }
    get _pageBoundsCache() {
      return this.store.createComputedCache("pageBoundsCache", (shape) => {
        const pageTransform = this._pageTransformCache.get(shape.id);
        if (!pageTransform)
          return new Box2d();
        const result = Box2d.FromPoints(
          Matrix2d.applyToPoints(pageTransform, this.getShapeUtil(shape).outline(shape))
        );
        return result;
      });
    }
    get _pageMaskCache() {
      return this.store.createComputedCache("pageMaskCache", (shape) => {
        if (TLPage.isId(shape.parentId)) {
          return void 0;
        }
        const frameAncestors = this.getAncestorsById(shape.id).filter((s3) => s3.type === "frame");
        if (frameAncestors.length === 0)
          return void 0;
        const pageMask = frameAncestors.map(
          (s3) => (
            // Apply the frame transform to the frame outline to get the frame outline in page space
            Matrix2d.applyToPoints(this._pageTransformCache.get(s3.id), this.getOutline(s3))
          )
        ).reduce((acc, b3) => {
          var _a5;
          return b3 && acc ? (_a5 = intersectPolygonPolygon(acc, b3)) != null ? _a5 : void 0 : void 0;
        });
        return pageMask;
      });
    }
    /**
     * Get the page mask for a shape.
     *
     * @example
     *
     * ```ts
     * const pageMask = app.getPageMaskById(shape.id)
     * ```
     *
     * @param id - The id of the shape to get the page mask for.
     * @returns The page mask for the shape.
     * @public
     */
    getPageMaskById(id) {
      return this._pageMaskCache.get(id);
    }
    get _clipPathCache() {
      return this.store.createComputedCache("clipPathCache", (shape) => {
        const pageMask = this._pageMaskCache.get(shape.id);
        if (!pageMask)
          return void 0;
        const pageTransform = this._pageTransformCache.get(shape.id);
        if (!pageTransform)
          return void 0;
        if (pageMask.length === 0) {
          return `polygon(0px 0px, 0px 0px, 0px 0px)`;
        }
        const localMask = Matrix2d.applyToPoints(Matrix2d.Inverse(pageTransform), pageMask);
        return `polygon(${localMask.map((p3) => `${p3.x}px ${p3.y}px`).join(",")})`;
      });
    }
    /**
     * Get the clip path for a shape.
     *
     * @example
     *
     * ```ts
     * const clipPath = app.getClipPathById(shape.id)
     * ```
     *
     * @param id - The shape id.
     * @returns The clip path or undefined.
     * @public
     */
    getClipPathById(id) {
      return this._clipPathCache.get(id);
    }
    /**
     * Dispose the app.
     *
     * @public
     */
    dispose() {
      this.disposables.forEach((dispose) => dispose());
      this.disposables.clear();
    }
    /**
     * Undo to the last mark.
     *
     * @example
     *
     * ```ts
     * app.undo()
     * ```
     *
     * @public
     */
    undo() {
      return this.history.undo();
    }
    get canUndo() {
      return this.history.numUndos > 0;
    }
    /**
     * Redo to the next mark.
     *
     * @example
     *
     * ```ts
     * app.redo()
     * ```
     *
     * @public
     */
    redo() {
      this.history.redo();
      return this;
    }
    get canRedo() {
      return this.history.numRedos > 0;
    }
    /**
     * Create a new "mark", or stopping point, in the undo redo history. Creating a mark will clear
     * any redos.
     *
     * @example
     *
     * ```ts
     * app.mark()
     * app.mark('flip shapes')
     * ```
     *
     * @param reason - The reason for the mark.
     * @param onUndo - Whether to stop at the mark when undoing.
     * @param onRedo - Whether to stop at the mark when redoing.
     * @public
     */
    mark(reason, onUndo, onRedo) {
      return this.history.mark(reason, onUndo, onRedo);
    }
    /**
     * Clear all marks in the undo stack back to the next mark.
     *
     * @example
     *
     * ```ts
     * app.bail()
     * ```
     *
     * @public
     */
    bail() {
      this.history.bail();
      return this;
    }
    /**
     * Clear all marks in the undo stack back to the mark with the provided mark id.
     *
     * @example
     *
     * ```ts
     * app.bailToMark('creating')
     * ```
     *
     * @public
     */
    bailToMark(id) {
      this.history.bailToMark(id);
      return this;
    }
    /**
     * Run a function in a batch, which will be undone/redone as a single action.
     *
     * @example
     *
     * ```ts
     * app.batch(() => {
     * 	app.selectAll()
     * 	app.deleteShapes()
     * 	app.createShapes(myShapes)
     * 	app.selectNone()
     * })
     *
     * app.undo() // will undo all of the above
     * ```
     *
     * @public
     */
    batch(fn) {
      this.history.batch(fn);
      return this;
    }
    /**
     * Get a shape util for a given shape or shape type.
     *
     * @example
     *
     * ```ts
     * app.getShapeUtil(myBoxShape)
     * ```
     *
     * @param type - The shape type.
     * @public
     */
    getShapeUtil(shape) {
      return this.shapeUtils[shape.type];
    }
    /**
     * Get a shape util by its definition.
     *
     * @example
     *
     * ```ts
     * app.getShapeUtilByDef(TLDrawShapeDef)
     * ```
     *
     * @param def - The shape definition.
     * @public
     */
    getShapeUtilByDef(def) {
      return this.shapeUtils[def.type];
    }
    /**
     * Get an array of all the children of a shape.
     *
     * @example
     *
     * ```ts
     * app.getSortedChildIds('frame1')
     * ```
     *
     * @param parentId - The id of the parent shape.
     * @public
     */
    getSortedChildIds(parentId) {
      const withIndices = this._parentIdsToChildIds.value[parentId];
      if (!withIndices)
        return EMPTY_ARRAY;
      return this._childIdsCache.get(withIndices, () => withIndices.map(([id]) => id));
    }
    /**
     * Run a visitor function for all descendants of a shape.
     *
     * @example
     *
     * ```ts
     * app.visitDescendants('frame1', myCallback)
     * ```
     *
     * @param parentId - The id of the parent shape.
     * @param visitor - The visitor function.
     * @public
     */
    visitDescendants(parentId, visitor) {
      const children = this.getSortedChildIds(parentId);
      for (const id of children) {
        if (visitor(id) === false)
          continue;
        this.visitDescendants(id, visitor);
      }
    }
    get erasingIds() {
      return this.pageState.erasingIds;
    }
    get hintingIds() {
      return this.pageState.hintingIds;
    }
    get erasingIdsSet() {
      return new Set(this.erasingIds);
    }
    /**
     * Get all the current props among the users selected shapes
     *
     * @internal
     */
    _extractSharedProps(shape, sharedProps) {
      if (shape.type === "group") {
        const childIds = this._parentIdsToChildIds.value[shape.id];
        if (!childIds)
          return;
        for (let i3 = 0, n3 = childIds.length; i3 < n3; i3++) {
          this._extractSharedProps(this.getShapeById(childIds[i3][0]), sharedProps);
        }
      } else {
        const props = Object.entries(shape.props);
        let prop;
        for (let i3 = 0, n3 = props.length; i3 < n3; i3++) {
          prop = props[i3];
          if (BLACKLISTED_PROPS.has(prop[0]))
            continue;
          switch (sharedProps[prop[0]]) {
            case void 0: {
              sharedProps[prop[0]] = prop[1];
              break;
            }
            case null:
            case prop[1]: {
              continue;
            }
            default: {
              sharedProps[prop[0]] = null;
            }
          }
        }
      }
    }
    get props() {
      let next;
      if (this.isIn("select") && this.selectedIds.length > 0) {
        next = this._selectionSharedProps.value;
      } else {
        const currentState = this.root.current.value;
        if (currentState.styles.length === 0) {
          next = null;
        } else {
          const { propsForNextShape } = this.instanceState;
          next = Object.fromEntries(
            currentState.styles.map((k2) => {
              return [k2, propsForNextShape[k2]];
            })
          );
        }
      }
      if (JSON.stringify(this._prevProps) === JSON.stringify(next)) {
        return this._prevProps;
      }
      this._prevProps = next;
      return next;
    }
    /**
     * An array of all of the shapes on the current page.
     *
     * @public
     */
    get shapeIds() {
      return this._shapeIds.value;
    }
    /** @internal */
    _complete() {
      var _a5;
      const { lastUpdatedPageId, lastUsedTabId } = this.userDocumentSettings;
      if (lastUsedTabId !== this.instanceId || lastUpdatedPageId !== this.currentPageId) {
        this.store.put([
          __spreadProps(__spreadValues({}, this.userDocumentSettings), {
            lastUsedTabId: this.instanceId,
            lastUpdatedPageId: this.currentPageId
          })
        ]);
      }
      for (const parentId of this._invalidParents) {
        this._invalidParents.delete(parentId);
        const parent = this.getShapeById(parentId);
        if (!parent)
          continue;
        const util = this.getShapeUtil(parent);
        const changes = (_a5 = util.onChildrenChange) == null ? void 0 : _a5.call(util, parent);
        if (changes == null ? void 0 : changes.length) {
          this.updateShapes(changes, true);
        }
      }
      this.updateUserPresence();
      this.emit("update");
    }
    get _arrowBindingsIndex() {
      return arrowBindingsIndex(this.store);
    }
    /** GetArrowsBoundTo */
    getArrowsBoundTo(shapeId) {
      return this._arrowBindingsIndex.value[shapeId] || EMPTY_ARRAY;
    }
    /** @internal */
    _reparentArrow(arrowId) {
      var _a5;
      const arrow2 = this.getShapeById(arrowId);
      if (!arrow2)
        return;
      const { start, end } = arrow2.props;
      const startShape = start.type === "binding" ? this.getShapeById(start.boundShapeId) : void 0;
      const endShape = end.type === "binding" ? this.getShapeById(end.boundShapeId) : void 0;
      const parentPageId = this.getParentPageId(arrow2);
      if (!parentPageId)
        return;
      let nextParentId;
      if (startShape && endShape) {
        nextParentId = (_a5 = this.findCommonAncestor([startShape, endShape])) != null ? _a5 : parentPageId;
      } else if (startShape || endShape) {
        nextParentId = parentPageId;
      } else {
        return;
      }
      if (nextParentId && nextParentId !== arrow2.parentId) {
        this.reparentShapesById([arrowId], nextParentId);
      }
      const reparentedArrow = this.getShapeById(arrowId);
      const startSibling = this.getNearestSiblingShape(reparentedArrow, startShape);
      const endSibling = this.getNearestSiblingShape(reparentedArrow, endShape);
      let highestSibling;
      if (startSibling && endSibling) {
        highestSibling = startSibling.index > endSibling.index ? startSibling : endSibling;
      } else if (startSibling && !endSibling) {
        highestSibling = startSibling;
      } else if (endSibling && !startSibling) {
        highestSibling = endSibling;
      } else {
        return;
      }
      let finalIndex;
      const higherSiblings = this.getSortedChildIds(highestSibling.parentId).map((id) => this.getShapeById(id)).filter((sibling) => sibling.index > highestSibling.index);
      if (higherSiblings.length) {
        const nextHighestNonArrowSibling = higherSiblings.find((sibling) => sibling.type !== "arrow");
        if (
          // ...then, if we're above the last shape we want to be above...
          reparentedArrow.index > highestSibling.index && // ...but below the next non-arrow sibling...
          (!nextHighestNonArrowSibling || reparentedArrow.index < nextHighestNonArrowSibling.index)
        ) {
          return;
        }
        finalIndex = getIndexBetween(highestSibling.index, higherSiblings[0].index);
      } else {
        finalIndex = getIndexAbove(highestSibling.index);
      }
      if (finalIndex !== reparentedArrow.index) {
        this.updateShapes([{ id: arrowId, type: "arrow", index: finalIndex }]);
      }
    }
    /** @internal */
    _unbindArrowTerminal(arrow2, handleId) {
      const { x: x3, y: y3 } = getArrowTerminalsInArrowSpace(this, arrow2)[handleId];
      this.store.put([__spreadProps(__spreadValues({}, arrow2), { props: __spreadProps(__spreadValues({}, arrow2.props), { [handleId]: { type: "point", x: x3, y: y3 } }) })]);
    }
    get _allPageStates() {
      return this.store.query.records("instance_page_state");
    }
    /** @internal */
    _shapeWillBeDeleted(deletedShape) {
      if (deletedShape.parentId && isShapeId(deletedShape.parentId)) {
        this._invalidParents.add(deletedShape.parentId);
      }
      const bindings = this._arrowBindingsIndex.value[deletedShape.id];
      if (bindings == null ? void 0 : bindings.length) {
        for (const { arrowId, handleId } of bindings) {
          const arrow2 = this.getShapeById(arrowId);
          if (!arrow2)
            continue;
          this._unbindArrowTerminal(arrow2, handleId);
        }
      }
      const pageStates = this._allPageStates.value;
      const deletedIds = /* @__PURE__ */ new Set([deletedShape.id]);
      const updates = compact(
        pageStates.map((pageState) => {
          return this._cleanupInstancePageState(pageState, deletedIds);
        })
      );
      if (updates.length) {
        this.store.put(updates);
      }
    }
    /** @internal */
    _arrowDidUpdate(arrow2) {
      for (const handle of ["start", "end"]) {
        const terminal = arrow2.props[handle];
        if (terminal.type !== "binding")
          continue;
        const boundShape = this.getShapeById(terminal.boundShapeId);
        const isShapeInSamePageAsArrow = this.getParentPageId(arrow2) === this.getParentPageId(boundShape);
        if (!boundShape || !isShapeInSamePageAsArrow) {
          this._unbindArrowTerminal(arrow2, handle);
        }
      }
      this._reparentArrow(arrow2.id);
    }
    /** @internal */
    _cleanupInstancePageState(prevPageState, shapesNoLongerInPage) {
      let nextPageState = null;
      const selectedIds = prevPageState.selectedIds.filter((id) => !shapesNoLongerInPage.has(id));
      if (selectedIds.length !== prevPageState.selectedIds.length) {
        if (!nextPageState)
          nextPageState = __spreadValues({}, prevPageState);
        nextPageState.selectedIds = selectedIds;
      }
      const erasingIds = prevPageState.erasingIds.filter((id) => !shapesNoLongerInPage.has(id));
      if (erasingIds.length !== prevPageState.erasingIds.length) {
        if (!nextPageState)
          nextPageState = __spreadValues({}, prevPageState);
        nextPageState.erasingIds = erasingIds;
      }
      if (prevPageState.hoveredId && shapesNoLongerInPage.has(prevPageState.hoveredId)) {
        if (!nextPageState)
          nextPageState = __spreadValues({}, prevPageState);
        nextPageState.hoveredId = null;
      }
      if (prevPageState.editingId && shapesNoLongerInPage.has(prevPageState.editingId)) {
        if (!nextPageState)
          nextPageState = __spreadValues({}, prevPageState);
        nextPageState.editingId = null;
      }
      const hintingIds = prevPageState.hintingIds.filter((id) => !shapesNoLongerInPage.has(id));
      if (hintingIds.length !== prevPageState.hintingIds.length) {
        if (!nextPageState)
          nextPageState = __spreadValues({}, prevPageState);
        nextPageState.hintingIds = hintingIds;
      }
      if (prevPageState.focusLayerId && shapesNoLongerInPage.has(prevPageState.focusLayerId)) {
        if (!nextPageState)
          nextPageState = __spreadValues({}, prevPageState);
        nextPageState.focusLayerId = null;
      }
      return nextPageState;
    }
    /** @internal */
    _shapeDidChange(prev, next) {
      if (TLArrowShapeDef.is(next)) {
        this._arrowDidUpdate(next);
      }
      if (prev.parentId !== next.parentId) {
        const reparentBoundArrows = (id) => {
          const boundArrows = this._arrowBindingsIndex.value[id];
          if (boundArrows == null ? void 0 : boundArrows.length) {
            for (const arrow2 of boundArrows) {
              this._reparentArrow(arrow2.arrowId);
            }
          }
        };
        reparentBoundArrows(next.id);
        this.visitDescendants(next.id, reparentBoundArrows);
      }
      if (prev.parentId !== next.parentId && TLPage.isId(next.parentId)) {
        const allMovingIds = /* @__PURE__ */ new Set([prev.id]);
        this.visitDescendants(prev.id, (id) => {
          allMovingIds.add(id);
        });
        for (const instancePageState of this.store.query.records("instance_page_state").value) {
          if (instancePageState.pageId === next.parentId)
            continue;
          const nextPageState = this._cleanupInstancePageState(instancePageState, allMovingIds);
          if (nextPageState) {
            this.store.put([nextPageState]);
          }
        }
      }
      if (prev.parentId && isShapeId(prev.parentId)) {
        this._invalidParents.add(prev.parentId);
      }
      if (next.parentId !== prev.parentId && isShapeId(next.parentId)) {
        this._invalidParents.add(next.parentId);
      }
    }
    /** @internal */
    _tabStateDidChange(prev, next) {
      if ((prev == null ? void 0 : prev.selectedIds) !== (next == null ? void 0 : next.selectedIds)) {
        const filtered = next.selectedIds.filter((id) => {
          var _a5, _b2;
          let parentId = (_a5 = this.getShapeById(id)) == null ? void 0 : _a5.parentId;
          while (isShapeId(parentId)) {
            if (next.selectedIds.includes(parentId)) {
              return false;
            }
            parentId = (_b2 = this.getShapeById(parentId)) == null ? void 0 : _b2.parentId;
          }
          return true;
        });
        const nextFocusLayerId = filtered.length === 0 ? next == null ? void 0 : next.focusLayerId : this.findCommonAncestor(
          compact(filtered.map((id) => this.getShapeById(id))),
          (shape) => shape.type === "group"
        );
        if (filtered.length !== next.selectedIds.length || nextFocusLayerId != next.focusLayerId) {
          this.store.put([__spreadProps(__spreadValues({}, next), { selectedIds: filtered, focusLayerId: nextFocusLayerId != null ? nextFocusLayerId : null })]);
        }
      }
    }
    /** @internal */
    _pageWillBeDeleted(page) {
      var _a5;
      const instanceStates = this.store.query.exec("instance", { currentPageId: { eq: page.id } });
      if (!instanceStates.length)
        return;
      const backupPageId = (_a5 = this.pages.find((p3) => p3.id !== page.id)) == null ? void 0 : _a5.id;
      if (!backupPageId)
        return;
      this.store.put(instanceStates.map((state) => __spreadProps(__spreadValues({}, state), { currentPageId: backupPageId })));
    }
    get documentSettings() {
      return this.store.get(TLDOCUMENT_ID);
    }
    get gridSize() {
      return this.documentSettings.gridSize;
    }
    /**
     * The user's global settings.
     *
     * @public
     * @readonly
     */
    get userSettings() {
      return this.store.get(this.userId);
    }
    get isSnapMode() {
      return this.userDocumentSettings.isSnapMode;
    }
    setSnapMode(isSnapMode) {
      if (isSnapMode !== this.isSnapMode) {
        this.updateUserDocumentSettings({ isSnapMode }, true);
      }
      return this;
    }
    get isDarkMode() {
      return this.userDocumentSettings.isDarkMode;
    }
    setDarkMode(isDarkMode) {
      if (isDarkMode !== this.isDarkMode) {
        this.updateUserDocumentSettings({ isDarkMode }, true);
      }
      return this;
    }
    get isFocusMode() {
      return this.instanceState.isFocusMode;
    }
    setFocusMode(isFocusMode) {
      if (isFocusMode !== this.isFocusMode) {
        this.updateInstanceState({ isFocusMode }, true);
      }
      return this;
    }
    get isToolLocked() {
      return this.instanceState.isToolLocked;
    }
    setToolLocked(isToolLocked) {
      if (isToolLocked !== this.isToolLocked) {
        this.updateInstanceState({ isToolLocked }, true);
      }
      return this;
    }
    get _userDocumentSettings() {
      return this.store.query.record("user_document", () => ({ userId: { eq: this.userId } }));
    }
    get userDocumentSettings() {
      return this._userDocumentSettings.value;
    }
    get isGridMode() {
      return this.userDocumentSettings.isGridMode;
    }
    setGridMode(isGridMode) {
      if (isGridMode !== this.isGridMode) {
        this.updateUserDocumentSettings({ isGridMode }, true);
      }
      return this;
    }
    /** @internal */
    setReadOnly(isReadOnly) {
      this._isReadOnly.set(isReadOnly);
      if (isReadOnly) {
        this.setSelectedTool("hand");
      }
      return this;
    }
    get isReadOnly() {
      return this._isReadOnly.value;
    }
    get isPenMode() {
      return this._isPenMode.value;
    }
    setPenMode(isPenMode) {
      if (isPenMode)
        this._touchEventsRemainingBeforeExitingPenMode = 3;
      if (isPenMode !== this.isPenMode) {
        this._isPenMode.set(isPenMode);
      }
      return this;
    }
    // User / User App State
    /**
     * The current user state.
     *
     * @public
     */
    get user() {
      return this.store.get(this.userId);
    }
    /** The current tab state */
    get instanceState() {
      return this.store.get(this.instanceId);
    }
    get cursor() {
      return this.instanceState.cursor;
    }
    get brush() {
      return this.instanceState.brush;
    }
    get zoomBrush() {
      return this.instanceState.zoomBrush;
    }
    get scribble() {
      return this.instanceState.scribble;
    }
    get _pageState() {
      return this.store.query.record(
        "instance_page_state",
        () => {
          return {
            pageId: { eq: this.currentPageId },
            instanceId: { eq: this.instanceId }
          };
        },
        "app._pageState"
      );
    }
    /**
     * The current page state.
     *
     * @public
     */
    get pageState() {
      return this._pageState.value;
    }
    get camera() {
      return this.store.get(this.pageState.cameraId);
    }
    get zoomLevel() {
      return this.camera.z;
    }
    get selectedIds() {
      return this.pageState.selectedIds;
    }
    get selectedIdsSet() {
      return new Set(this.selectedIds);
    }
    get _pages() {
      return this.store.query.records("page");
    }
    get pages() {
      return this._pages.value.sort(sortByIndex2);
    }
    /**
     * The current page.
     *
     * @public
     */
    get currentPage() {
      return this.getPageById(this.currentPageId);
    }
    /**
     * The current page id.
     *
     * @public
     */
    get currentPageId() {
      return this.instanceState.currentPageId;
    }
    /**
     * Get a page by its ID.
     *
     * @example
     *
     * ```ts
     * app.getPageById(myPage.id)
     * ```
     *
     * @public
     */
    getPageById(id) {
      return this.store.get(id);
    }
    get _pageStates() {
      return this.store.query.records("instance_page_state", () => ({
        instanceId: { eq: this.instanceId }
      }));
    }
    /**
     * Get a page state by its id.
     *
     * @example
     *
     * ```ts
     * app.getPageStateByPageId('page1')
     * ```
     *
     * @public
     */
    getPageStateByPageId(id) {
      return this._pageStates.value.find((p3) => p3.pageId === id);
    }
    /**
     * Get a page by its ID.
     *
     * @example
     *
     * ```ts
     * app.getPageById(myPage.id)
     * ```
     *
     * @public
     */
    getPageInfoById(id) {
      return this.store.get(id);
    }
    /** Get shapes on a page. */
    getShapesInPage(pageId) {
      const result = this.store.query.exec("shape", { parentId: { eq: pageId } });
      return this.getShapesAndDescendantsInOrder(result.map((s3) => s3.id));
    }
    /* --------------------- Shapes --------------------- */
    /**
     * Get the local transform for a shape as a matrix model. This transform reflects both its
     * translation (x, y) from from either its parent's top left corner, if the shape's parent is
     * another shape, or else from the 0,0 of the page, if the shape's parent is the page; and the
     * shape's rotation.
     *
     * @example
     *
     * ```ts
     * app.getTransform(myShape)
     * ```
     *
     * @param shape - The shape to get the local transform for.
     * @public
     */
    getTransform(shape) {
      const util = this.getShapeUtil(shape);
      return util.transform(shape);
    }
    /**
     * Get the local transform of a shape's parent as a matrix model.
     *
     * @example
     *
     * ```ts
     * app.getParentTransform(myShape)
     * ```
     *
     * @param shape - The shape to get the parent transform for.
     * @public
     */
    getParentTransform(shape) {
      var _a5;
      if (TLPage.isId(shape.parentId)) {
        return Matrix2d.Identity();
      }
      return (_a5 = this._pageTransformCache.get(shape.parentId)) != null ? _a5 : Matrix2d.Identity();
    }
    /**
     * Get the page transform (or absolute transform) of a shape.
     *
     * @example
     *
     * ```ts
     * app.getPageTransform(myShape)
     * ```
     *
     * @param shape - The shape to get the page transform for.
     * @public
     */
    getPageTransform(shape) {
      return this.getPageTransformById(shape.id);
    }
    /**
     * Get the page transform (or absolute transform) of a shape by its id.
     *
     * @example
     *
     * ```ts
     * app.getPageTransformById(myShape)
     * ```
     *
     * @param id - The if of the shape to get the page transform for.
     * @public
     */
    getPageTransformById(id) {
      return this._pageTransformCache.get(id);
    }
    /**
     * Get the page point (or absolute point) of a shape.
     *
     * @example
     *
     * ```ts
     * app.getPagePoint(myShape)
     * ```
     *
     * @param shape - The shape to get the page point for.
     * @public
     */
    getPagePointById(id) {
      const pageTransform = this.getPageTransformById(id);
      if (!pageTransform)
        return;
      return Matrix2d.applyToPoint(pageTransform, new Vec2d());
    }
    /**
     * Get the page point (or absolute point) of a shape.
     *
     * @example
     *
     * ```ts
     * app.getPagePoint(myShape)
     * ```
     *
     * @param shape - The shape to get the page point for.
     * @public
     */
    getPageCenter(shape) {
      const pageTransform = this.getPageTransformById(shape.id);
      if (!pageTransform)
        return null;
      const util = this.getShapeUtil(shape);
      const center = util.center(shape);
      return Matrix2d.applyToPoint(pageTransform, center);
    }
    /**
     * Get the page point (or absolute point) of a shape by its id.
     *
     * @example
     *
     * ```ts
     * app.getPagePoint(myShape)
     * ```
     *
     * @param id - The shape id to get the page point for.
     * @public
     */
    getPageCenterById(id) {
      const shape = this.getShapeById(id);
      return this.getPageCenter(shape);
    }
    /**
     * Get the page rotation (or absolute rotation) of a shape.
     *
     * @example
     *
     * ```ts
     * app.getPageRotation(myShape)
     * ```
     *
     * @param shape - The shape to get the page rotation for.
     * @public
     */
    getPageRotation(shape) {
      return this.getPageRotationById(shape.id);
    }
    /**
     * Get the page rotation (or absolute rotation) of a shape by its id.
     *
     * @param id - The id of the shape to get the page rotation for.
     */
    getPageRotationById(id) {
      const pageTransform = this.getPageTransformById(id);
      if (pageTransform) {
        return Matrix2d.Decompose(pageTransform).rotation;
      }
      return 0;
    }
    /**
     * Get the local bounds of a shape.
     *
     * @example
     *
     * ```ts
     * app.getBounds(myShape)
     * ```
     *
     * @param shape - The shape to get the bounds for.
     * @public
     */
    getBounds(shape) {
      return this.getShapeUtil(shape).bounds(shape);
    }
    /**
     * Get the local bounds of a shape by its id.
     *
     * @example
     *
     * ```ts
     * app.getBoundsById(myShape)
     * ```
     *
     * @param id - The id of the shape to get the bounds for.
     * @public
     */
    getBoundsById(id) {
      const shape = this.getShapeById(id);
      if (!shape)
        return void 0;
      return this.getBounds(shape);
    }
    /**
     * Get the page (or absolute) bounds of a shape.
     *
     * @example
     *
     * ```ts
     * app.getPageBounds(myShape)
     * ```
     *
     * @param shape - The shape to get the bounds for.
     * @public
     */
    getPageBounds(shape) {
      return this.getPageBoundsById(shape.id);
    }
    /**
     * Get the page (or absolute) bounds of a shape by its id.
     *
     * @example
     *
     * ```ts
     * app.getPageBoundsById(myShape)
     * ```
     *
     * @param id - The id of the shape to get the page bounds for.
     * @public
     */
    getPageBoundsById(id) {
      return this._pageBoundsCache.get(id);
    }
    /**
     * Get the page (or absolute) bounds of a shape, incorporating any masks. For example, if the
     * shape were the child of a frame and was half way out of the frame, the bounds would be the half
     * of the shape that was in the frame.
     *
     * @example
     *
     * ```ts
     * app.getMaskedPageBounds(myShape)
     * ```
     *
     * @param shape - The shape to get the masked bounds for.
     * @public
     */
    getMaskedPageBounds(shape) {
      return this.getMaskedPageBoundsById(shape.id);
    }
    /**
     * Get the page (or absolute) bounds of a shape by its id, incorporating any masks. For example,
     * if the shape were the child of a frame and was half way out of the frame, the bounds would be
     * the half of the shape that was in the frame.
     *
     * @example
     *
     * ```ts
     * app.getMaskedPageBoundsById(myShape)
     * ```
     *
     * @param id - The id of the shape to get the masked page bounds for.
     * @public
     */
    getMaskedPageBoundsById(id) {
      const pageBounds = this._pageBoundsCache.get(id);
      if (!pageBounds)
        return;
      const pageMask = this._pageMaskCache.get(id);
      if (pageMask) {
        const intersection = intersectPolygonPolygon(pageMask, pageBounds.corners);
        if (!intersection)
          return;
        return Box2d.FromPoints(intersection);
      }
      return pageBounds;
    }
    /**
     * Get the local outline of a shape.
     *
     * @example
     *
     * ```ts
     * app.getOutline(myShape)
     * ```
     *
     * @param shape - The shape to get the outline for.
     * @public
     */
    getOutline(shape) {
      return this.getShapeUtil(shape).outline(shape);
    }
    /**
     * Get the local outline of a shape.
     *
     * @example
     *
     * ```ts
     * app.getOutlineById(myShape)
     * ```
     *
     * @param id - The shape id to get the outline for.
     * @public
     */
    getOutlineById(id) {
      return this.getOutline(this.getShapeById(id));
    }
    /**
     * Get the ancestors of a shape.
     *
     * @example
     *
     * ```ts
     * const ancestors = app.getAncestors(myShape)
     * ```
     *
     * @param shape - The shape to get the ancestors for.
     * @public
     */
    getAncestors(shape, acc = []) {
      const parentId = shape.parentId;
      if (TLPage.isId(parentId)) {
        acc.reverse();
        return acc;
      }
      const parent = this.store.get(parentId);
      acc.push(parent);
      return this.getAncestors(parent, acc);
    }
    /**
     * Get the ancestors of a shape by its id.
     *
     * @example
     *
     * ```ts
     * const ancestors = app.getAncestorsById(myShape)
     * ```
     *
     * @param id - The id of the shape to get the ancestors for.
     * @public
     */
    getAncestorsById(id, acc = []) {
      const shape = this.getShapeById(id);
      return this.getAncestors(shape, acc);
    }
    /**
     * Find the first ancestor matching the given predicate
     *
     * @example
     *
     * ```ts
     * const ancestor = app.findAncestor(myShape)
     * ```
     *
     * @param shape - The shape to check the ancestors for.
     * @public
     */
    findAncestor(shape, predicate) {
      const parentId = shape.parentId;
      if (TLPage.isId(parentId)) {
        return void 0;
      }
      const parent = this.getShapeById(parentId);
      if (parent) {
        if (predicate(parent)) {
          return parent;
        }
        return this.findAncestor(parent, predicate);
      }
      return void 0;
    }
    /** Returns true if the the given shape has the given ancestor */
    hasAncestor(shape, ancestorId) {
      if (!shape)
        return false;
      if (shape.parentId === ancestorId)
        return true;
      return this.hasAncestor(this.getParentShape(shape), ancestorId);
    }
    /**
     * Get the common ancestor of two or more shapes that matches a predicate.
     *
     * @param shapes - The shapes to check.
     * @param predicate - The predicate to match.
     */
    findCommonAncestor(shapes, predicate) {
      var _a5;
      if (shapes.length === 0) {
        return;
      }
      if (shapes.length === 1) {
        const parentId = shapes[0].parentId;
        if (TLPage.isId(parentId)) {
          return;
        }
        return predicate ? (_a5 = this.findAncestor(shapes[0], predicate)) == null ? void 0 : _a5.id : parentId;
      }
      const [nodeA, ...others] = shapes;
      let ancestor = this.getParentShape(nodeA);
      while (ancestor) {
        if (predicate && !predicate(ancestor)) {
          ancestor = this.getParentShape(ancestor);
          continue;
        }
        if (others.every((shape) => this.hasAncestor(shape, ancestor.id))) {
          return ancestor.id;
        }
        ancestor = this.getParentShape(ancestor);
      }
      return void 0;
    }
    /**
     * Check whether a shape is within the bounds of the current viewport.
     *
     * @param id - The id of the shape to check.
     * @public
     */
    isShapeInViewport(id) {
      const pageBounds = this.getPageBoundsById(id);
      if (!pageBounds)
        return false;
      return this.viewportPageBounds.includes(pageBounds);
    }
    get renderingShapes() {
      const { currentPageId, cullingBounds, cullingBoundsExpanded, erasingIdsSet, editingId } = this;
      const renderingShapes = [];
      const getShapeToDisplay = (id, parentOpacity, isAncestorErasing) => {
        const shape = this.getShapeById(id);
        if (!shape)
          return;
        let opacity = +shape.props.opacity * parentOpacity;
        let isShapeErasing = false;
        if (!isAncestorErasing && erasingIdsSet.has(id)) {
          isShapeErasing = true;
          opacity *= 0.32;
        }
        const bounds = this.getMaskedPageBoundsById(id);
        const isInViewport = bounds ? cullingBounds.includes(bounds) : false;
        const isCulled = bounds ? editingId !== id && !cullingBoundsExpanded.includes(bounds) : true;
        renderingShapes.push({ id, index: renderingShapes.length, opacity, isCulled, isInViewport });
        this.getSortedChildIds(id).forEach((id2) => {
          getShapeToDisplay(id2, opacity, isAncestorErasing || isShapeErasing);
        });
      };
      this.getSortedChildIds(currentPageId).forEach((shapeId) => getShapeToDisplay(shapeId, 1, false));
      return renderingShapes.sort(sortById);
    }
    get allShapesCommonBounds() {
      let commonBounds = null;
      this.shapeIds.forEach((shapeId) => {
        const bounds = this.getMaskedPageBoundsById(shapeId);
        if (bounds) {
          if (commonBounds) {
            commonBounds.expand(bounds);
          } else {
            commonBounds = bounds.clone();
          }
        }
      });
      return commonBounds;
    }
    /**
     * Get the corners of a shape in page space.
     *
     * @example
     *
     * ```ts
     * const corners = app.getPageCorners(myShape)
     * ```
     *
     * @param shape - The shape to get the corners for.
     * @public
     */
    getPageCorners(shape) {
      const ancestors = this.getAncestors(shape);
      const corners = this.getBounds(shape).corners;
      const transform = Matrix2d.Compose(
        ...ancestors.flatMap((s3) => [Matrix2d.Translate(s3.x, s3.y), Matrix2d.Rotate(s3.rotation)]),
        Matrix2d.Translate(shape.x, shape.y),
        Matrix2d.Rotate(shape.rotation, 0, 0)
      );
      return Matrix2d.applyToPoints(transform, corners);
    }
    /**
     * Test whether a point (in page space) will will a shape. This method takes into account masks,
     * such as when a shape is the child of a frame and is partially clipped by the frame.
     *
     * @example
     *
     * ```ts
     * app.isPointInShape({ x: 100, y: 100 }, myShape)
     * ```
     *
     * @param point - The page point to test.
     * @param shape - The shape to test against.
     * @public
     */
    isPointInShape(point2, shape) {
      const util = this.getShapeUtil(shape);
      const pageMask = this._pageMaskCache.get(shape.id);
      if (pageMask) {
        const hit = pointInPolygon(point2, pageMask);
        if (!hit)
          return false;
      }
      return util.hitTestPoint(shape, this.getPointInShapeSpace(shape, point2));
    }
    /**
     * Get the shapes, if any, at a given page point.
     *
     * @example
     *
     * ```ts
     * app.getShapesAtPoint({ x: 100, y: 100 })
     * ```
     *
     * @param point - The page point to test.
     * @public
     */
    getShapesAtPoint(point2) {
      return this.shapesArray.filter((shape) => {
        const pageMask = this._pageMaskCache.get(shape.id);
        if (pageMask) {
          return pointInPolygon(point2, pageMask);
        }
        return this.getShapeUtil(shape).hitTestPoint(shape, this.getPointInShapeSpace(shape, point2));
      });
    }
    /**
     * Convert a point in page space to a point in the local space of a shape. For example, if a
     * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at
     * `{ x: 10, y: 10 }` in the shape's local space.
     *
     * @example
     *
     * ```ts
     * app.getPointInShapeSpace(myShape, { x: 100, y: 100 })
     * ```
     *
     * @param shape - The shape to get the point in the local space of.
     * @param point - The page point to get in the local space of the shape.
     * @public
     */
    getPointInShapeSpace(shape, point2) {
      return Matrix2d.applyToPoint(Matrix2d.Inverse(this.getPageTransform(shape)), point2);
    }
    /**
     * Convert a delta in page space to a point in the local space of a shape. For example, if a
     * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at
     * `{ x: 10, y: 10 }` in the shape's local space.
     *
     * @example
     *
     * ```ts
     * app.getPointInShapeSpace(myShape.id, { x: 100, y: 100 })
     * ```
     *
     * @param shape - The shape to get the point in the local space of.
     * @param point - The page point to get in the local space of the shape.
     * @public
     */
    getPointInParentSpace(shapeId, point2) {
      const shape = this.getShapeById(shapeId);
      if (!shape) {
        return new Vec2d(0, 0);
      }
      if (TLPage.isId(shape.parentId))
        return Vec2d.From(point2);
      const parentTransform = this.getPageTransformById(shape.parentId);
      if (!parentTransform)
        return Vec2d.From(point2);
      return Matrix2d.applyToPoint(Matrix2d.Inverse(parentTransform), point2);
    }
    /**
     * Convert a delta in page space to a delta in the local space of a shape.
     *
     * @example
     *
     * ```ts
     * app.getDeltaInShapeSpace(myShape, { x: 100, y: 100 })
     * ```
     *
     * @param shape - The shape to get the delta in the local space of.
     * @param delta - The page delta to convert.
     * @public
     */
    getDeltaInShapeSpace(shape, delta) {
      const pageTransform = this.getPageTransform(shape);
      if (!pageTransform)
        return Vec2d.From(delta);
      return Vec2d.Rot(delta, -Matrix2d.Decompose(pageTransform).rotation);
    }
    /**
     * Convert a delta in page space to a delta in the parent space of a shape.
     *
     * @example
     *
     * ```ts
     * app.getDeltaInParentSpace(myShape, { x: 100, y: 100 })
     * ```
     *
     * @param shape - The shape to get the delta in the parent space of.
     * @param delta - The page delta to convert.
     * @public
     */
    getDeltaInParentSpace(shape, delta) {
      if (TLPage.isId(shape.parentId))
        return Vec2d.From(delta);
      const parent = this.getShapeById(shape.parentId);
      if (!parent)
        return Vec2d.From(delta);
      return this.getDeltaInShapeSpace(parent, delta);
    }
    /**
     * For a given set of ids, get a map containing the ids of their parents and the children of those
     * parents.
     *
     * @example
     *
     * ```ts
     * app.getParentsMappedToChildren(['id1', 'id2', 'id3'])
     * ```
     *
     * @param ids - The ids to get the parents and children of.
     * @public
     */
    getParentsMappedToChildren(ids) {
      const shapes = ids.map((id) => this.store.get(id));
      const parents = /* @__PURE__ */ new Map();
      shapes.forEach((shape) => {
        var _a5;
        if (!parents.has(shape.parentId)) {
          parents.set(shape.parentId, /* @__PURE__ */ new Set());
        }
        (_a5 = parents.get(shape.parentId)) == null ? void 0 : _a5.add(shape);
      });
      return parents;
    }
    /* -------------------- Viewport -------------------- */
    /**
     * Update the viewport. The viewport will measure the size and screen position of its container
     * element. This should be done whenever the container's position on the screen changes.
     *
     * @example
     *
     * ```ts
     * app.updateViewportScreenBounds()
     * ```
     *
     * @param center - Whether to preserve the viewport page center as the viewport changes.
     *   (optional)
     * @public
     */
    updateViewportScreenBounds(center = false) {
      const container = this.getContainer();
      if (!container)
        return this;
      const rect = container.getBoundingClientRect();
      const screenBounds = new Box2d(0, 0, Math.max(rect.width, 1), Math.max(rect.height, 1));
      const boundsAreEqual = screenBounds.equals(this.viewportScreenBounds);
      const { _willSetInitialBounds } = this;
      if (boundsAreEqual) {
        this._willSetInitialBounds = false;
      } else {
        if (_willSetInitialBounds) {
          this._willSetInitialBounds = false;
          this.updateInstanceState({ screenBounds: screenBounds.toJson() }, true, true);
        } else {
          const { zoomLevel } = this;
          if (center) {
            const before = this.viewportPageCenter;
            this.updateInstanceState({ screenBounds: screenBounds.toJson() }, true, true);
            const after = this.viewportPageCenter;
            if (!this.instanceState.followingUserId) {
              this.pan((after.x - before.x) * zoomLevel, (after.y - before.y) * zoomLevel);
            }
          } else {
            const before = this.screenToPage(0, 0);
            this.updateInstanceState({ screenBounds: screenBounds.toJson() }, true, true);
            const after = this.screenToPage(0, 0);
            if (!this.instanceState.followingUserId) {
              this.pan((after.x - before.x) * zoomLevel, (after.y - before.y) * zoomLevel);
            }
          }
        }
      }
      this._cameraManager.tick();
      this.updateCullingBounds();
      const { editingId } = this;
      if (editingId) {
        this.panZoomIntoView([editingId]);
      }
      return this;
    }
    get viewportScreenBounds() {
      const { x: x3, y: y3, w: w3, h: h3 } = this.instanceState.screenBounds;
      return new Box2d(x3, y3, w3, h3);
    }
    get viewportScreenCenter() {
      return this.viewportScreenBounds.center;
    }
    get viewportPageBounds() {
      const { x: x3, y: y3, w: w3, h: h3 } = this.viewportScreenBounds;
      const tl = this.screenToPage(x3, y3);
      const br = this.screenToPage(x3 + w3, y3 + h3);
      return new Box2d(tl.x, tl.y, br.x - tl.x, br.y - tl.y);
    }
    get cullingBounds() {
      return this._cullingBounds.value;
    }
    get cullingBoundsExpanded() {
      return this._cullingBoundsExpanded.value;
    }
    /**
     * Update the culling bounds. This should be called when the viewport has stopped changing, such
     * as at the end of a pan, zoom, or animation.
     *
     * @example
     *
     * ```ts
     * app.updateCullingBounds()
     * ```
     *
     * @internal
     */
    updateCullingBounds() {
      const { viewportPageBounds } = this;
      if (viewportPageBounds.equals(this._cullingBounds.__unsafe__getWithoutCapture()))
        return this;
      this._cullingBounds.set(viewportPageBounds.clone());
      this._cullingBoundsExpanded.set(viewportPageBounds.clone().expandBy(100 / this.zoomLevel));
      return this;
    }
    get viewportPageCenter() {
      return this.viewportPageBounds.center;
    }
    /**
     * Convert a point in screen space to a point in page space.
     *
     * @example
     *
     * ```ts
     * app.screenToPage(100, 100)
     * ```
     *
     * @param x - The x coordinate of the point in screen space.
     * @param y - The y coordinate of the point in screen space.
     * @param camera - The camera to use. Defaults to the current camera.
     * @public
     */
    screenToPage(x3, y3, z2 = 0.5, camera = this.camera) {
      const { screenBounds } = this.store.unsafeGetWithoutCapture(this.instanceId);
      const { x: cx, y: cy, z: cz = 1 } = camera;
      return {
        x: (x3 - screenBounds.x) / cz - cx,
        y: (y3 - screenBounds.y) / cz - cy,
        z: z2
      };
    }
    /**
     * Convert a point in page space to a point in screen space.
     *
     * @example
     *
     * ```ts
     * app.pageToScreen(100, 100)
     * ```
     *
     * @param x - The x coordinate of the point in screen space.
     * @param y - The y coordinate of the point in screen space.
     * @param camera - The camera to use. Defaults to the current camera.
     * @public
     */
    pageToScreen(x3, y3, z2 = 0.5, camera = this.camera) {
      const { x: cx, y: cy, z: cz = 1 } = camera;
      return {
        x: x3 + cx * cz,
        y: y3 + cy * cz,
        z: z2
      };
    }
    /* Focus Layers */
    get focusLayerId() {
      var _a5;
      return (_a5 = this.pageState.focusLayerId) != null ? _a5 : this.currentPageId;
    }
    get focusLayerShape() {
      const id = this.pageState.focusLayerId;
      if (!id) {
        return;
      }
      return this.getShapeById(id);
    }
    popFocusLayer() {
      var _a5;
      const current = this.pageState.focusLayerId;
      const focusedShape = current && this.getShapeById(current);
      if (focusedShape) {
        const match = this.findAncestor(focusedShape, (s3) => s3.type === "group");
        this.setFocusLayer((_a5 = match == null ? void 0 : match.id) != null ? _a5 : null);
        this.select(focusedShape.id);
      } else {
        this.setFocusLayer(null);
        this.selectNone();
      }
      return this;
    }
    /**
     * Set the focus layer to the given shape id.
     *
     * @param next - The next focus layer id or null to reset the focus layer to the page
     * @public
     */
    setFocusLayer(next) {
      this._setFocusLayer(next);
      return this;
    }
    /**
     * Set the hinted shape ids.
     *
     * @param ids - The ids to set as hinted.
     * @public
     */
    setHintingIds(ids) {
      this.store.update(this.pageState.id, (s3) => __spreadProps(__spreadValues({}, s3), { hintingIds: dedupe(ids) }));
      return this;
    }
    /**
     * The current editing shape's id.
     *
     * @public
     */
    get editingId() {
      return this.pageState.editingId;
    }
    /**
     * The current cropping shape's id.
     *
     * @public
     */
    get croppingId() {
      return this.pageState.croppingId;
    }
    get editingShape() {
      var _a5;
      if (!this.editingId)
        return null;
      return (_a5 = this.getShapeById(this.editingId)) != null ? _a5 : null;
    }
    /**
     * Set the current editing id.
     *
     * @param id - The id of the shape to edit or null to clear the editing id.
     * @public
     */
    setEditingId(id) {
      if (!id) {
        this.setInstancePageState({ editingId: null });
      } else {
        if (id !== this.editingId) {
          const shape = this.getShapeById(id);
          const util = this.getShapeUtil(shape);
          if (shape && util.canEdit(shape)) {
            this.setInstancePageState({ editingId: id, hoveredId: null }, false);
            const { viewportPageBounds } = this;
            const localEditingBounds = util.getEditingBounds(shape);
            const pageTransform = this.getPageTransformById(id);
            const pageEditingBounds = Box2d.FromPoints(
              Matrix2d.applyToPoints(pageTransform, localEditingBounds.corners)
            );
            if (!viewportPageBounds.contains(pageEditingBounds)) {
              if (pageEditingBounds.width > viewportPageBounds.width || pageEditingBounds.height > viewportPageBounds.height) {
                this.zoomToBounds(
                  pageEditingBounds.minX,
                  pageEditingBounds.minY,
                  pageEditingBounds.width,
                  pageEditingBounds.height
                );
              } else {
                this.centerOnPoint(pageEditingBounds.midX, pageEditingBounds.midY);
              }
            }
          }
        }
      }
      return this;
    }
    setCroppingId(id) {
      if (id !== this.croppingId) {
        if (!id) {
          this.setInstancePageState({ croppingId: null });
          if (this.isInAny("select.crop", "select.pointing_crop_handle", "select.cropping")) {
            this.setSelectedTool("select.idle");
          }
        } else {
          const shape = this.getShapeById(id);
          const util = this.getShapeUtil(shape);
          if (shape && util.canCrop(shape)) {
            this.setInstancePageState({ croppingId: id, hoveredId: null });
          }
        }
      }
      return this;
    }
    getParentIdForNewShapeAtPoint(point2, shapeType) {
      const shapes = this.sortedShapesArray;
      for (let i3 = shapes.length - 1; i3 >= 0; i3--) {
        const shape = shapes[i3];
        const util = this.getShapeUtil(shape);
        if (!util.canReceiveNewChildrenOfType(shapeType))
          continue;
        const maskedPageBounds = this.getMaskedPageBoundsById(shape.id);
        if (maskedPageBounds && maskedPageBounds.containsPoint(point2) && util.hitTestPoint(shape, this.getPointInShapeSpace(shape, point2))) {
          return shape.id;
        }
      }
      return this.focusLayerId;
    }
    getDroppingShape(point2, droppingShapes = []) {
      const shapes = this.sortedShapesArray;
      for (let i3 = shapes.length - 1; i3 >= 0; i3--) {
        const shape = shapes[i3];
        if (droppingShapes.find((s3) => s3.id === shape.id || this.hasAncestor(shape, s3.id)))
          continue;
        const util = this.getShapeUtil(shape);
        if (!util.canDropShapes(shape, droppingShapes))
          continue;
        const maskedPageBounds = this.getMaskedPageBoundsById(shape.id);
        if (maskedPageBounds && maskedPageBounds.containsPoint(point2) && util.hitTestPoint(shape, this.getPointInShapeSpace(shape, point2))) {
          return shape;
        }
      }
      return void 0;
    }
    // This returns the node that should be selected when you click on this one, assuming there is nothing
    // already selected. It will not return anything higher than or including the current focus layer.
    getOutermostSelectableShape(shape, filter2) {
      var _a5;
      let match = shape;
      let node = shape;
      while (node) {
        if (node.type === "group" && this.focusLayerId !== node.id && !this.hasAncestor(this.focusLayerShape, node.id) && ((_a5 = filter2 == null ? void 0 : filter2(node)) != null ? _a5 : true)) {
          match = node;
        } else if (this.focusLayerId === node.id) {
          break;
        }
        node = this.getParentShape(node);
      }
      return match;
    }
    get selectedPageBounds() {
      const {
        pageState: { selectedIds }
      } = this;
      if (selectedIds.length === 0)
        return null;
      return Box2d.Common(compact(selectedIds.map((id) => this.getPageBoundsById(id))));
    }
    get selectionRotation() {
      const { selectedIds } = this;
      if (selectedIds.length === 0) {
        return 0;
      }
      if (selectedIds.length === 1) {
        return this.getPageRotationById(this.selectedIds[0]);
      }
      const allRotations = selectedIds.map((id) => this.getPageRotationById(id) % (Math.PI / 2));
      if (allRotations.every((rotation) => Math.abs(rotation - allRotations[0]) < Math.PI / 180)) {
        return this.getPageRotationById(selectedIds[0]);
      }
      return 0;
    }
    get selectionBounds() {
      const { selectedIds } = this;
      if (selectedIds.length === 0) {
        return void 0;
      }
      const { selectionRotation } = this;
      if (selectionRotation === 0) {
        return this.selectedPageBounds;
      }
      if (selectedIds.length === 1) {
        const bounds = this.getBounds(this.getShapeById(selectedIds[0])).clone();
        bounds.point = Matrix2d.applyToPoint(this.getPageTransformById(selectedIds[0]), bounds.point);
        return bounds;
      }
      const allPoints = this.selectedIds.flatMap((id) => {
        const pageTransform = this.getPageTransformById(id);
        if (!pageTransform)
          return [];
        return this.getOutlineById(id).map((point2) => Matrix2d.applyToPoint(pageTransform, point2));
      }).map((p3) => Vec2d.Rot(p3, -selectionRotation));
      const box = Box2d.FromPoints(allPoints);
      box.point = box.point.rot(selectionRotation);
      return box;
    }
    get selectionPageCenter() {
      const { selectionBounds, selectionRotation } = this;
      if (!selectionBounds)
        return null;
      return Vec2d.RotWith(selectionBounds.center, selectionBounds.point, selectionRotation);
    }
    get shapesArray() {
      return Array.from(this.shapeIds).map((id) => this.store.get(id));
    }
    get sortedShapesArray() {
      const shapes = new Set(this.shapesArray.sort(sortByIndex2));
      const results = [];
      function pushShapeWithDescendants(shape) {
        results.push(shape);
        shapes.delete(shape);
        shapes.forEach((otherShape) => {
          if (otherShape.parentId === shape.id) {
            pushShapeWithDescendants(otherShape);
          }
        });
      }
      shapes.forEach((shape) => {
        const parent = this.getShapeById(shape.parentId);
        if (!isShape(parent)) {
          pushShapeWithDescendants(shape);
        }
      });
      return results;
    }
    get selectedShapes() {
      const { selectedIds } = this.pageState;
      return compact(selectedIds.map((id) => this.store.get(id)));
    }
    get onlySelectedShape() {
      const { selectedShapes } = this;
      return selectedShapes.length === 1 ? selectedShapes[0] : null;
    }
    /**
     * Get a shape by its id.
     *
     * @example
     *
     * ```ts
     * app.getShapeById('box1')
     * ```
     *
     * @param id - The id of the shape to get.
     * @public
     */
    getShapeById(id) {
      if (!isShapeId(id))
        return void 0;
      return this.store.get(id);
    }
    /**
     * Get the parent shape for a given shape. Returns undefined if the shape is the direct child of
     * the page.
     *
     * @example
     *
     * ```ts
     * app.getParentShape(myShape)
     * ```
     *
     * @public
     */
    getParentShape(shape) {
      if (shape === void 0 || !isShapeId(shape.parentId))
        return void 0;
      return this.store.get(shape.parentId);
    }
    /**
     * If siblingShape and targetShape are siblings, this returns targetShape. If targetShape has an
     * ancestor who is a sibling of siblingShape, this returns that ancestor. Otherwise, this returns
     * undefined
     */
    getNearestSiblingShape(siblingShape, targetShape) {
      if (!targetShape) {
        return void 0;
      }
      if (targetShape.parentId === siblingShape.parentId) {
        return targetShape;
      }
      const ancestor = this.findAncestor(
        targetShape,
        (ancestor2) => ancestor2.parentId === siblingShape.parentId
      );
      return ancestor;
    }
    /** Get the id of the containing page for a given shape. */
    getParentPageId(shape) {
      if (shape === void 0)
        return void 0;
      if (TLPage.isId(shape.parentId)) {
        return shape.parentId;
      } else {
        return this.getParentPageId(this.getShapeById(shape.parentId));
      }
    }
    /**
     * Get whether the given shape is the descendant of the given page.
     *
     * @example
     *
     * ```ts
     * app.isShapeInPage(myShape)
     * app.isShapeInPage(myShape, 'page1')
     * ```
     *
     * @param shape - The shape to check.
     * @param pageId - The id of the page to check against. Defaults to the current page.
     * @public
     */
    isShapeInPage(shape, pageId = this.currentPageId) {
      let shapeIsInPage = false;
      if (shape.parentId === pageId) {
        shapeIsInPage = true;
      } else {
        let parent = this.getShapeById(shape.parentId);
        isInPageSearch:
          while (parent) {
            if (parent.parentId === pageId) {
              shapeIsInPage = true;
              break isInPageSearch;
            }
            parent = this.getShapeById(parent.parentId);
          }
      }
      return shapeIsInPage;
    }
    /**
     * Get the CSS color value for a given color id.
     *
     * @example
     *
     * ```ts
     * app.getCssColor('red')
     * ```
     *
     * @param id - The id of the color to get.
     * @public
     */
    getCssColor(id) {
      return this.colors.get(id);
    }
    /**
     * Get the stroke width value for a given size id.
     *
     * @example
     *
     * ```ts
     * app.getStrokeWidth('m')
     * ```
     *
     * @param id - The id of the size to get.
     * @public
     */
    getStrokeWidth(id) {
      return this.sizes[id];
    }
    /* ------------------- Statechart ------------------- */
    /**
     * The id of the current selected tool.
     *
     * @public
     */
    get currentToolId() {
      var _a5, _b2;
      const activeTool = this.root.current.value;
      let activeToolId = activeTool == null ? void 0 : activeTool.id;
      if (activeToolId === "select" || activeToolId === "zoom") {
        const currentChildState = activeTool == null ? void 0 : activeTool.current.value;
        activeToolId = (_b2 = (_a5 = currentChildState == null ? void 0 : currentChildState.info) == null ? void 0 : _a5.onInteractionEnd) != null ? _b2 : "select";
      }
      return activeToolId != null ? activeToolId : "select";
    }
    /**
     * Set the selected tool.
     *
     * @example
     *
     * ```ts
     * app.setSelectedTool('hand')
     * app.setSelectedTool('hand', { date: Date.now() })
     * ```
     *
     * @param id - The id of the tool to select.
     * @param info - Arbitrary data to pass along into the transition.
     * @public
     */
    setSelectedTool(id, info = {}) {
      this.root.transition(id, info);
      return this;
    }
    /**
     * Get a descendant by its path.
     *
     * @example
     *
     * ```ts
     * state.getStateDescendant('select')
     * state.getStateDescendant('select.brushing')
     * ```
     *
     * @param path - The descendant's path of state ids, separated by periods.
     * @public
     */
    getStateDescendant(path) {
      var _a5;
      const ids = path.split(".").reverse();
      let state = this.root;
      while (ids.length > 0) {
        const id = ids.pop();
        if (!id)
          return state;
        const childState = (_a5 = state.children) == null ? void 0 : _a5[id];
        if (!childState)
          return void 0;
        state = childState;
      }
      return state;
    }
    /**
     * Get whether a certain tool (or other state node) is currently active.
     *
     * @example
     *
     * ```ts
     * app.isIn('select')
     * app.isIn('select.brushing')
     * ```
     *
     * @param path - The path of active states, separated by periods.
     * @public
     */
    isIn(path) {
      const ids = path.split(".").reverse();
      let state = this.root;
      while (ids.length > 0) {
        const id = ids.pop();
        if (!id)
          return true;
        const current = state.current.value;
        if ((current == null ? void 0 : current.id) === id) {
          if (ids.length === 0)
            return true;
          state = current;
          continue;
        } else
          return false;
      }
      return false;
    }
    /**
     * Get whether the state node is in any of the given active paths.
     *
     * @example
     *
     * ```ts
     * state.isInAny('select', 'erase')
     * state.isInAny('select.brushing', 'erase.idle')
     * ```
     *
     * @public
     */
    isInAny(...paths) {
      return paths.some((path) => this.isIn(path));
    }
    /**
     * Update the input points from a pointer or pinch event.
     *
     * @param info - The event info.
     * @internal
     */
    _updateInputsFromEvent(info) {
      const { previousScreenPoint, previousPagePoint, currentScreenPoint, currentPagePoint } = this.inputs;
      const { screenBounds } = this.store.unsafeGetWithoutCapture(this.instanceId);
      const { x: sx, y: sy, z: sz } = info.point;
      const { x: cx, y: cy, z: cz } = this.camera;
      previousScreenPoint.setTo(currentScreenPoint);
      previousPagePoint.setTo(currentPagePoint);
      const px = (sx - screenBounds.x) / cz - cx;
      const py = (sy - screenBounds.y) / cz - cy;
      currentScreenPoint.set(sx, sy);
      currentPagePoint.set(px, py, sz != null ? sz : 0.5);
      this.inputs.isPen = info.type === "pointer" && info.isPen;
      if (info.name === "pointer_down") {
        this.inputs.pointerVelocity = new Vec2d();
      }
      this.updateUserPresence({ cursor: currentPagePoint.toJson() });
    }
    /**
     * Prevent a double click event from firing the next time the user clicks
     *
     * @public
     */
    cancelDoubleClick() {
      this._clickManager.cancelDoubleClickTimeout();
    }
    replaceStoreContentsWithRecordsForOtherDocument(records) {
      transact(() => {
        this.store.clear();
        const [shapes, nonShapes] = partition(records, (record) => record.typeName === "shape");
        this.store.put(nonShapes, "initialize");
        this.store.ensureStoreIsUsable();
        this.store.put(shapes, "initialize");
        this.history.clear();
        this.updateViewportScreenBounds();
        this.updateCullingBounds();
        const bounds = this.allShapesCommonBounds;
        if (bounds) {
          this.zoomToBounds(bounds.minX, bounds.minY, bounds.width, bounds.height, 1);
        }
      });
    }
    getContent(ids = this.selectedIds) {
      if (!ids)
        return;
      if (ids.length === 0)
        return;
      const pageTransforms = {};
      let shapes = dedupe(
        ids.map((id) => this.getShapeById(id)).sort(sortByIndex2).flatMap((shape) => {
          const allShapes = [shape];
          this.visitDescendants(shape.id, (descendant) => {
            allShapes.push(this.getShapeById(descendant));
          });
          return allShapes;
        })
      );
      shapes = shapes.map((shape) => {
        pageTransforms[shape.id] = this.getPageTransformById(shape.id);
        shape = structuredClone(shape);
        if (TLArrowShapeDef.is(shape)) {
          const startBindingId = shape.props.start.type === "binding" ? shape.props.start.boundShapeId : void 0;
          const endBindingId = shape.props.end.type === "binding" ? shape.props.end.boundShapeId : void 0;
          const info = this.getShapeUtilByDef(TLArrowShapeDef).getArrowInfo(shape);
          if (shape.props.start.type === "binding") {
            if (!shapes.some((s3) => s3.id === startBindingId)) {
              if (info == null ? void 0 : info.isValid) {
                const { x: x3, y: y3 } = info.start.point;
                shape.props.start = {
                  type: "point",
                  x: x3,
                  y: y3
                };
              } else {
                const { start } = getArrowTerminalsInArrowSpace(this, shape);
                shape.props.start = {
                  type: "point",
                  x: start.x,
                  y: start.y
                };
              }
            }
          }
          if (shape.props.end.type === "binding") {
            if (!shapes.some((s3) => s3.id === endBindingId)) {
              if (info == null ? void 0 : info.isValid) {
                const { x: x3, y: y3 } = info.end.point;
                shape.props.end = {
                  type: "point",
                  x: x3,
                  y: y3
                };
              } else {
                const { end } = getArrowTerminalsInArrowSpace(this, shape);
                shape.props.end = {
                  type: "point",
                  x: end.x,
                  y: end.y
                };
              }
            }
          }
          const infoAfter = getIsArrowStraight(shape) ? getStraightArrowInfo(this, shape) : getCurvedArrowInfo(this, shape);
          if ((info == null ? void 0 : info.isValid) && (infoAfter == null ? void 0 : infoAfter.isValid) && !getIsArrowStraight(shape)) {
            const mpA = Vec2d.Med(info.start.handle, info.end.handle);
            const distA = Vec2d.Dist(info.middle, mpA);
            const distB = Vec2d.Dist(infoAfter.middle, mpA);
            if (shape.props.bend < 0) {
              shape.props.bend += distB - distA;
            } else {
              shape.props.bend -= distB - distA;
            }
          }
          return shape;
        }
        return shape;
      });
      const rootShapeIds = [];
      shapes.forEach((shape) => {
        if (shapes.find((s3) => s3.id === shape.parentId) === void 0) {
          const pagePoint = this.getPagePointById(shape.id);
          const pageRotation = this.getPageRotationById(shape.id);
          shape.x = pagePoint.x;
          shape.y = pagePoint.y;
          shape.rotation = pageRotation;
          shape.parentId = this.currentPageId;
          rootShapeIds.push(shape.id);
        }
      });
      const assetsSet = /* @__PURE__ */ new Set();
      shapes.forEach((shape) => {
        if ("assetId" in shape.props) {
          if (shape.props.assetId !== null) {
            assetsSet.add(shape.props.assetId);
          }
        }
      });
      return {
        shapes,
        rootShapeIds,
        schema: this.store.schema.serialize(),
        assets: compact(Array.from(assetsSet).map((id) => this.getAssetById(id)))
      };
    }
    /* --------------------- Commands --------------------- */
    putContent(content, options = {}) {
      if (this.isReadOnly)
        return this;
      if (!content.schema) {
        throw Error("Could not put content: content is missing a schema.");
      }
      const { select = false, preserveIds = false, preservePosition = false } = options;
      let { point: point2 = void 0 } = options;
      const { currentPageId } = this;
      const { assets, shapes, rootShapeIds } = content;
      const idMap = new Map(shapes.map((shape) => [shape.id, createShapeId()]));
      let pasteParentId = this.currentPageId;
      let lowestDepth = Infinity;
      let lowestAncestors = [];
      for (const shape of this.selectedShapes) {
        if (lowestDepth === 0)
          break;
        const ancestors = this.getAncestors(shape);
        if (shape.type === "frame")
          ancestors.push(shape);
        const depth = shape.type === "frame" ? ancestors.length + 1 : ancestors.length;
        if (depth < lowestDepth) {
          lowestDepth = depth;
          lowestAncestors = ancestors;
          pasteParentId = shape.type === "frame" ? shape.id : shape.parentId;
        } else if (depth === lowestDepth) {
          if (lowestAncestors.length !== ancestors.length) {
            throw Error(`Ancestors: ${lowestAncestors.length} !== ${ancestors.length}`);
          }
          if (lowestAncestors.length === 0) {
            pasteParentId = currentPageId;
            break;
          } else {
            pasteParentId = currentPageId;
            for (let i3 = 0; i3 < lowestAncestors.length; i3++) {
              if (ancestors[i3] !== lowestAncestors[i3])
                break;
              pasteParentId = ancestors[i3].id;
            }
          }
        }
      }
      let isDuplicating = false;
      if (!TLPage.isId(pasteParentId)) {
        const parent = this.getShapeById(pasteParentId);
        if (parent) {
          if (!this.viewportPageBounds.includes(this.getPageBounds(parent))) {
            pasteParentId = currentPageId;
          } else {
            if (rootShapeIds.length === 1) {
              const rootShape = shapes.find((s3) => s3.id === rootShapeIds[0]);
              if (TLFrameShapeDef.is(parent) && TLFrameShapeDef.is(rootShape) && rootShape.props.w === (parent == null ? void 0 : parent.props.w) && rootShape.props.h === (parent == null ? void 0 : parent.props.h)) {
                isDuplicating = true;
              }
            }
          }
        } else {
          pasteParentId = currentPageId;
        }
      }
      if (!isDuplicating) {
        isDuplicating = idMap.has(pasteParentId);
      }
      if (isDuplicating) {
        pasteParentId = this.getShapeById(pasteParentId).parentId;
      }
      let index2 = this.getHighestIndexForParent(pasteParentId);
      const rootShapes = [];
      const newShapes = shapes.map((shape) => {
        let newShape;
        if (preserveIds) {
          newShape = deepCopy(shape);
          idMap.set(shape.id, shape.id);
        } else {
          const id = idMap.get(shape.id);
          newShape = deepCopy(__spreadProps(__spreadValues({}, shape), { id }));
        }
        if (rootShapeIds.includes(shape.id)) {
          newShape.parentId = currentPageId;
          rootShapes.push(newShape);
        }
        if (idMap.has(newShape.parentId)) {
          newShape.parentId = idMap.get(shape.parentId);
        } else {
          rootShapeIds.push(newShape.id);
          newShape.index = index2;
          index2 = getIndexAbove(index2);
        }
        if (TLArrowShapeDef.is(newShape)) {
          if (newShape.props.start.type === "binding") {
            const mappedId = idMap.get(newShape.props.start.boundShapeId);
            newShape.props.start = mappedId ? __spreadProps(__spreadValues({}, newShape.props.start), { boundShapeId: mappedId }) : (
              // this shouldn't happen, if you copy an arrow but not it's bound shape it should
              // convert the binding to a point at the time of copying
              { type: "point", x: 0, y: 0 }
            );
          }
          if (newShape.props.end.type === "binding") {
            const mappedId = idMap.get(newShape.props.end.boundShapeId);
            newShape.props.end = mappedId ? __spreadProps(__spreadValues({}, newShape.props.end), { boundShapeId: mappedId }) : (
              // this shouldn't happen, if you copy an arrow but not it's bound shape it should
              // convert the binding to a point at the time of copying
              { type: "point", x: 0, y: 0 }
            );
          }
        }
        return newShape;
      });
      if (newShapes.length + this.shapeIds.size > MAX_SHAPES_PER_PAGE) {
        alertMaxShapes(this);
        return this;
      }
      let assetsToCreate = [];
      if (assets) {
        for (let i3 = 0; i3 < assets.length; i3++) {
          const asset = assets[i3];
          const result = this.store.schema.migratePersistedRecord(asset, content.schema);
          if (result.type === "success") {
            assets[i3] = result.value;
          } else {
            throw Error(
              `Could not put content: could not migrate content for asset:
${JSON.stringify(
                asset,
                null,
                2
              )}`
            );
          }
        }
        const assetsToUpdate = [];
        assetsToCreate = assets.filter((asset) => !this.store.has(asset.id)).map((asset) => {
          var _a5;
          if (asset.type === "image" || asset.type === "video") {
            if (asset.props.src && ((_a5 = asset.props.src) == null ? void 0 : _a5.startsWith("data:image"))) {
              assetsToUpdate.push(structuredClone(asset));
              asset.props.src = null;
            } else {
              assetsToUpdate.push(structuredClone(asset));
            }
          }
          return asset;
        });
        Promise.allSettled(
          assetsToUpdate.map((asset) => __async(this, null, function* () {
            var _a5;
            const file = yield dataUrlToFile(
              asset.props.src,
              asset.props.name,
              (_a5 = asset.props.mimeType) != null ? _a5 : "image/png"
            );
            const newAsset = yield this.onCreateAssetFromFile(file);
            return [asset, newAsset];
          }))
        ).then((assets2) => {
          this.updateAssets(
            compact(
              assets2.map(
                (result) => result.status === "fulfilled" ? __spreadProps(__spreadValues({}, result.value[1]), { id: result.value[0].id }) : void 0
              )
            )
          );
        });
      }
      for (let i3 = 0; i3 < newShapes.length; i3++) {
        const shape = newShapes[i3];
        const result = this.store.schema.migratePersistedRecord(shape, content.schema);
        if (result.type === "success") {
          newShapes[i3] = result.value;
        } else {
          throw Error(
            `Could not put content: could not migrate content for shape:
${JSON.stringify(
              shape,
              null,
              2
            )}`
          );
        }
      }
      this.batch(() => {
        if (assetsToCreate.length > 0) {
          this.createAssets(assetsToCreate);
        }
        this.createShapes(newShapes, select);
        if (pasteParentId !== currentPageId) {
          this.reparentShapesById(
            rootShapes.map((s3) => s3.id),
            pasteParentId
          );
        }
        const newCreatedShapes = newShapes.map((s3) => this.getShapeById(s3.id));
        const bounds = Box2d.Common(newCreatedShapes.map((s3) => this.getPageBounds(s3)));
        if (point2 === void 0) {
          if (!TLPage.isId(pasteParentId)) {
            const shape = this.getShapeById(pasteParentId);
            const util = this.getShapeUtil(shape);
            point2 = util.center(shape);
          } else {
            const { viewportPageBounds } = this;
            if (preservePosition || viewportPageBounds.includes(Box2d.From(bounds))) {
              point2 = bounds.center;
            } else {
              point2 = viewportPageBounds.center;
            }
          }
        }
        if (rootShapes.length === 1) {
          const onlyRoot = rootShapes[0];
          if (onlyRoot.type === "frame") {
            while (this.getShapesAtPoint(point2).some(
              (shape) => TLFrameShapeDef.is(shape) && shape.props.w === onlyRoot.props.w && shape.props.h === onlyRoot.props.h
            )) {
              point2.x += bounds.w + 16;
            }
          }
        }
        this.updateShapes(
          rootShapes.map((s3) => {
            var _a5, _b2;
            const delta = {
              x: ((_a5 = s3.x) != null ? _a5 : 0) - (bounds.x + bounds.w / 2),
              y: ((_b2 = s3.y) != null ? _b2 : 0) - (bounds.y + bounds.h / 2)
            };
            return { id: s3.id, type: s3.type, x: point2.x + delta.x, y: point2.y + delta.y };
          })
        );
      });
      return this;
    }
    /* --------------------- Shapes --------------------- */
    /**
     * Get a unique id for a shape.
     *
     * @example
     *
     * ```ts
     * app.createShapeId()
     * app.createShapeId('box1')
     * ```
     *
     * @param id - The id to use.
     * @public
     */
    createShapeId(id) {
      return id ? createCustomShapeId(id) : createShapeId();
    }
    getHighestIndexForParent(parentId) {
      const children = this._parentIdsToChildIds.value[parentId];
      if (!children || children.length === 0) {
        return "a1";
      }
      return getIndexAbove(children[children.length - 1][1]);
    }
    /**
     * Create shapes.
     *
     * @example
     *
     * ```ts
     * app.createShapes([{ id: 'box1', type: 'box' }])
     * ```
     *
     * @param partials - The shape partials to create.
     * @param select - Whether to select the created shapes. Defaults to false.
     * @public
     */
    createShapes(partials, select = false) {
      this._createShapes(partials, select);
      return this;
    }
    /**
     * Animate shapes.
     *
     * @example
     *
     * ```ts
     * app.animateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }])
     * ```
     *
     * @param partials - The shape partials to update.
     * @public
     */
    animateShapes(partials, options = {}) {
      const { duration = 500, ease: ease2 = EASINGS.linear } = options;
      const animationId = uniqueId();
      let remaining = duration;
      let t4;
      const animations = [];
      partials.forEach((partial) => {
        if (!partial)
          return;
        const result = {
          partial,
          values: []
        };
        const shape = this.getShapeById(partial.id);
        if (!shape)
          return;
        for (const key of ["x", "y", "rotation"]) {
          if (partial[key] !== void 0 && shape[key] !== partial[key]) {
            result.values.push({ prop: key, from: shape[key], to: partial[key] });
          }
        }
        animations.push(result);
        this.animatingShapes.set(shape.id, animationId);
      });
      let value;
      const handleTick = (elapsed) => {
        remaining -= elapsed;
        if (remaining < 0) {
          const { animatingShapes: animatingShapes2 } = this;
          const partialsToUpdate = partials.filter(
            (p3) => p3 && animatingShapes2.get(p3.id) === animationId
          );
          if (partialsToUpdate.length) {
            this.updateShapes(partialsToUpdate, false);
          }
          this.removeListener("tick", handleTick);
          return;
        }
        t4 = ease2(1 - remaining / duration);
        const { animatingShapes } = this;
        try {
          const tPartials = [];
          for (let i3 = 0; i3 < animations.length; i3++) {
            value = animations[i3];
            if (animatingShapes.get(value.partial.id) === animationId) {
              tPartials.push(__spreadValues({
                id: value.partial.id,
                type: value.partial.type
              }, value.values.reduce((acc, { prop, from, to }) => {
                acc[prop] = from + (to - from) * t4;
                return acc;
              }, {})));
            }
          }
          this._updateShapes(tPartials, true);
        } catch (e2) {
        }
      };
      this.addListener("tick", handleTick);
      return this;
    }
    /**
     * Update shapes.
     *
     * @example
     *
     * ```ts
     * app.updateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }])
     * ```
     *
     * @param partials - The shape partials to update.
     * @param squashing - Whether the change is ephemeral.
     * @public
     */
    updateShapes(partials, squashing = false) {
      if (this.animatingShapes.size > 0) {
        let partial;
        for (let i3 = 0; i3 < partials.length; i3++) {
          partial = partials[i3];
          if (partial) {
            this.animatingShapes.delete(partial.id);
          }
        }
      }
      this._updateShapes(partials, squashing);
      return this;
    }
    /**
     * Delete shapes.
     *
     * @example
     *
     * ```ts
     * app.deleteShapes()
     * app.deleteShapes(['box1', 'box2'])
     * ```
     *
     * @param ids - The ids of the shapes to delete. Defaults to the selected shapes.
     * @public
     */
    deleteShapes(ids = this.selectedIds) {
      this._deleteShapes(ids);
      return this;
    }
    /**
     * Update user document settings
     *
     * @example
     *
     * ```ts
     * app.updateUserDocumentSettings({ isGridMode: true })
     * ```
     *
     * @public
     */
    updateUserDocumentSettings(partial, ephemeral = false) {
      this._updateUserDocumentSettings(partial, ephemeral);
      return this;
    }
    /**
     * Update a page.
     *
     * @example
     *
     * ```ts
     * app.updatePage({ id: 'page2', name: 'Page 2' })
     * ```
     *
     * @param partial - The partial of the shape to update.
     * @public
     */
    updatePage(partial, squashing = false) {
      this._updatePage(partial, squashing);
      return this;
    }
    /**
     * Create a page.
     *
     * @example
     *
     * ```ts
     * app.createPage('New Page')
     * app.createPage('New Page', 'page1')
     * ```
     *
     * @param id - The new page's id.
     * @param title - The new page's title.
     * @public
     */
    createPage(title, id = TLPage.createId(), belowPageIndex) {
      this._createPage(title, id, belowPageIndex);
      return this;
    }
    duplicatePage(id = this.currentPageId, createId = TLPage.createId()) {
      if (this.pages.length >= MAX_PAGES)
        return;
      const page = this.getPageById(id);
      if (!page)
        return;
      const camera = __spreadValues({}, this.camera);
      const content = this.getContent(this.getSortedChildIds(page.id));
      this.batch(() => {
        this.createPage(page.name + " Copy", createId, page.index);
        this.setCurrentPageId(createId);
        this.setCamera(camera.x, camera.y, camera.z);
        if (content) {
          return this.putContent(content);
        }
      });
    }
    /**
     * Delete a page.
     *
     * @example
     *
     * ```ts
     * app.deletePage('page1')
     * ```
     *
     * @param id - The id of the page to delete.
     * @public
     */
    deletePage(id) {
      this._deletePage(id);
    }
    /**
     * Update a page state.
     *
     * @example
     *
     * ```ts
     * app.setInstancePageState({ id: 'page1', editingId: 'shape:123' })
     * app.setInstancePageState({ id: 'page1', editingId: 'shape:123' }, true)
     * ```
     *
     * @param partial - The partial of the page state object containing the changes.
     * @param ephemeral - Whether the command is ephemeral.
     * @public
     */
    setInstancePageState(partial, ephemeral = false) {
      this._setInstancePageState(partial, ephemeral);
    }
    /**
     * Set user state. Always ephemeral for now.
     *
     * @example
     *
     * ```ts
     * app.updateUser({ color: '#923433' })
     * ```
     *
     * @param partial - The partial of the user state object containing the changes.
     * @public
     */
    updateUser(partial) {
      const next = __spreadValues(__spreadValues({}, this.user), partial);
      this.store.put([next]);
    }
    get _currentUserPresence() {
      return this.store.query.record("user_presence", () => ({ userId: { eq: this.userId } }));
    }
    get userPresence() {
      return this._currentUserPresence.value;
    }
    /**
     * Select one or more shapes.
     *
     * @example
     *
     * ```ts
     * app.setSelectedIds(['id1'])
     * app.setSelectedIds(['id1', 'id2'])
     * ```
     *
     * @param ids - The ids to select.
     * @param squashing - Whether the change should create a new history entry or combine with the
     *   previous (if the previous is the same type).
     * @public
     */
    setSelectedIds(ids, squashing = false) {
      this._setSelectedIds(ids, squashing);
      return this;
    }
    /**
     * Determine whether or not a shape is selected
     *
     * @example
     *
     * ```ts
     * app.isSelected('id1')
     * ```
     *
     * @param id - The id of the shape to check.
     * @public
     */
    isSelected(id) {
      return this.selectedIdsSet.has(id);
    }
    /**
     * Determine whether a not a shape is within the current selection. A shape is within the
     * selection if it or any of its parents is selected.
     *
     * @param id - The id of the shape to check.
     * @public
     */
    isWithinSelection(id) {
      const shape = this.getShapeById(id);
      if (!shape)
        return false;
      if (this.isSelected(id))
        return true;
      return !!this.findAncestor(shape, (parent) => this.isSelected(parent.id));
    }
    get _assets() {
      return this.store.query.records("asset");
    }
    /** Get all assets in the app. */
    get assets() {
      return this._assets.value;
    }
    /**
     * Create one or more assets.
     *
     * @example
     *
     * ```ts
     * app.createAssets([...myAssets])
     * ```
     *
     * @param assets - The assets to create.
     * @public
     */
    createAssets(assets) {
      this._createAssets(assets);
      return this;
    }
    /**
     * Delete one or more assets.
     *
     * @example
     *
     * ```ts
     * app.deleteAssets(['asset1', 'asset2'])
     * ```
     *
     * @param ids - The assets to delete.
     * @public
     */
    deleteAssets(ids) {
      this._deleteAssets(ids);
      return this;
    }
    /**
     * Update one or more assets.
     *
     * @example
     *
     * ```ts
     * app.updateAssets([{ id: 'asset1', name: 'New name' }])
     * ```
     *
     * @param assets - The assets to update.
     * @public
     */
    updateAssets(assets) {
      this._updateAssets(assets);
      return this;
    }
    /**
     * Get an asset by its src property.
     *
     * @example
     *
     * ```ts
     * app.getAssetBySource('https://example.com/image.png')
     * ```
     *
     * @param src - The source value of the asset.
     * @public
     */
    getAssetBySrc(src) {
      return this.assets.find((a3) => a3.props.src === src);
    }
    /**
     * Get an asset by its id.
     *
     * @example
     *
     * ```ts
     * app.getAssetById('asset1')
     * ```
     *
     * @param id - The id of the asset.
     * @public
     */
    getAssetById(id) {
      return this.store.get(id);
    }
    /* ------------------- SubCommands ------------------ */
    getSvg() {
      return __async(this, arguments, function* (ids = this.selectedIds.length ? this.selectedIds : Object.keys(this.shapeIds), opts = {}) {
        var _a5, _b2, _c;
        if (ids.length === 0)
          return;
        if (!window.document)
          throw Error("No document");
        const {
          scale = 1,
          background = false,
          padding = SVG_PADDING,
          darkMode = this.userDocumentSettings.isDarkMode,
          preserveAspectRatio = false
        } = opts;
        const realContainerEl = this.getContainer();
        const realContainerStyle = getComputedStyle(realContainerEl);
        const fakeContainerEl = document.createElement("div");
        fakeContainerEl.className = `tl-container tl-theme__${darkMode ? "dark" : "light"}`;
        document.body.appendChild(fakeContainerEl);
        const containerStyle = getComputedStyle(fakeContainerEl);
        const fontsUsedInExport = /* @__PURE__ */ new Map();
        const colors = {
          fill: Object.fromEntries(
            STYLES.color.map((color) => [
              color.id,
              containerStyle.getPropertyValue(`--palette-${color.id}`)
            ])
          ),
          pattern: Object.fromEntries(
            STYLES.color.map((color) => [
              color.id,
              containerStyle.getPropertyValue(`--palette-${color.id}-pattern`)
            ])
          ),
          semi: Object.fromEntries(
            STYLES.color.map((color) => [
              color.id,
              containerStyle.getPropertyValue(`--palette-${color.id}-semi`)
            ])
          ),
          text: containerStyle.getPropertyValue(`--color-text`),
          background: containerStyle.getPropertyValue(`--color-background`),
          solid: containerStyle.getPropertyValue(`--palette-solid`)
        };
        document.body.removeChild(fakeContainerEl);
        const shapes = this.getShapesAndDescendantsInOrder(ids);
        const bbox = Box2d.FromPoints(
          shapes.map((shape2) => {
            const pageMask = this.getPageMaskById(shape2.id);
            if (pageMask) {
              return pageMask;
            }
            const pageTransform = this.getPageTransform(shape2);
            const pageOutline = Matrix2d.applyToPoints(pageTransform, this.getOutline(shape2));
            return pageOutline;
          }).flat()
        );
        const isSingleFrameShape = ids.length === 1 && shapes[0].type === "frame";
        if (!isSingleFrameShape) {
          bbox.expandBy(padding);
        }
        const w3 = bbox.width * scale;
        const h3 = bbox.height * scale;
        const svg = window.document.createElementNS("http://www.w3.org/2000/svg", "svg");
        if (preserveAspectRatio) {
          svg.setAttribute("preserveAspectRatio", preserveAspectRatio);
        }
        svg.setAttribute("direction", "ltr");
        svg.setAttribute("width", w3 + "");
        svg.setAttribute("height", h3 + "");
        svg.setAttribute("viewBox", `${bbox.minX} ${bbox.minY} ${bbox.width} ${bbox.height}`);
        svg.setAttribute("stroke-linecap", "round");
        svg.setAttribute("stroke-linejoin", "round");
        if (background) {
          if (isSingleFrameShape) {
            svg.style.setProperty("background", colors.solid);
          } else {
            svg.style.setProperty("background-color", colors.background);
          }
        } else {
          svg.style.setProperty("background-color", "transparent");
        }
        const defs = window.document.createElementNS("http://www.w3.org/2000/svg", "defs");
        for (const element of Array.from(exportPatternSvgDefs(colors.solid))) {
          defs.appendChild(element);
        }
        try {
          (_b2 = (_a5 = document.body).focus) == null ? void 0 : _b2.call(_a5);
        } catch (e2) {
        }
        svg.append(defs);
        let shape;
        for (let i3 = 0, n3 = shapes.length; i3 < n3; i3++) {
          shape = shapes[i3];
          if (isSingleFrameShape && i3 === 0)
            continue;
          let font;
          if ("font" in shape.props) {
            if (shape.props.font) {
              if (fontsUsedInExport.has(shape.props.font)) {
                font = fontsUsedInExport.get(shape.props.font);
              } else {
                font = realContainerStyle.getPropertyValue(`--tl-font-${shape.props.font}`);
                fontsUsedInExport.set(shape.props.font, font);
              }
            }
          }
          const util = this.getShapeUtil(shape);
          let utilSvgElement = yield (_c = util.toSvg) == null ? void 0 : _c.call(util, shape, font, colors);
          if (!utilSvgElement) {
            const bounds = this.getPageBounds(shape);
            const elm = window.document.createElementNS("http://www.w3.org/2000/svg", "rect");
            elm.setAttribute("width", bounds.width + "");
            elm.setAttribute("height", bounds.height + "");
            elm.setAttribute("fill", colors.solid);
            elm.setAttribute("stroke", colors.pattern.grey);
            elm.setAttribute("stroke-width", "1");
            utilSvgElement = elm;
          }
          const shapeSvg = utilSvgElement;
          let pageTransform = this.getPageTransform(shape).toCssString();
          if ("scale" in shape.props) {
            if (shape.props.scale !== 1) {
              pageTransform = `${pageTransform} scale(${shape.props.scale}, ${shape.props.scale})`;
            }
          }
          shapeSvg.setAttribute("transform", pageTransform);
          if ("opacity" in shape.props)
            shapeSvg.setAttribute("opacity", shape.props.opacity + "");
          const pageMask = this.getPageMaskById(shape.id);
          if (shapeSvg && pageMask) {
            const clipPathEl = document.createElementNS("http://www.w3.org/2000/svg", "clipPath");
            defs.appendChild(clipPathEl);
            const id = nanoid();
            clipPathEl.id = id;
            const mask = document.createElementNS("http://www.w3.org/2000/svg", "path");
            mask.setAttribute("d", `M${pageMask.map(({ x: x3, y: y3 }) => `${x3},${y3}`).join("L")}Z`);
            clipPathEl.appendChild(mask);
            const outerElement = document.createElementNS("http://www.w3.org/2000/svg", "g");
            outerElement.setAttribute("clip-path", `url(#${id})`);
            outerElement.appendChild(shapeSvg);
            svg.appendChild(outerElement);
          } else {
            svg.appendChild(shapeSvg);
          }
        }
        let styles2 = ``;
        const style = window.document.createElementNS("http://www.w3.org/2000/svg", "style");
        const fontInstances = [];
        if ("fonts" in document) {
          document.fonts.forEach((font) => fontInstances.push(font));
        }
        for (const font of fontInstances) {
          const fileReader = new FileReader();
          let isUsed = false;
          fontsUsedInExport.forEach((fontName) => {
            if (fontName.includes(font.family)) {
              isUsed = true;
            }
          });
          if (!isUsed)
            continue;
          const url = font.$$_url;
          const fontFaceRule = font.$$_fontface;
          if (url) {
            const fontFile = yield (yield fetch(url)).blob();
            const base64Font = yield new Promise((resolve, reject) => {
              fileReader.onload = () => resolve(fileReader.result);
              fileReader.onerror = () => reject(fileReader.error);
              fileReader.readAsDataURL(fontFile);
            });
            const newFontFaceRule = "\n" + fontFaceRule.replaceAll(url, base64Font);
            styles2 += newFontFaceRule;
          }
        }
        style.textContent = styles2;
        defs.append(style);
        return svg;
      });
    }
    /**
     * Rename a page.
     *
     * @example
     *
     * ```ts
     * app.renamePage('page1', 'My Page')
     * ```
     *
     * @param id - The id of the page to rename.
     * @param name - The new name.
     * @public
     */
    renamePage(id, name, squashing = false) {
      if (this.isReadOnly)
        return this;
      this.updatePage({ id, name }, squashing);
      return this;
    }
    /**
     * Move shapes to page.
     *
     * @example
     *
     * ```ts
     * app.moveShapesToPage(['box1', 'box2'], 'page1')
     * ```
     *
     * @param ids - The ids of the shapes to move.
     * @param pageId - The id of the page where the shapes will be moved.
     * @public
     */
    moveShapesToPage(ids, pageId) {
      if (ids.length === 0)
        return this;
      if (this.isReadOnly)
        return this;
      const { currentPageId } = this;
      if (pageId === currentPageId)
        return this;
      if (!this.store.has(pageId))
        return this;
      const content = this.getContent(ids);
      if (!content)
        return this;
      if (this.getShapesInPage(pageId).length + content.shapes.length > MAX_SHAPES_PER_PAGE) {
        alertMaxShapes(this, pageId);
        return this;
      }
      const fromPageZ = this.camera.z;
      this.history.batch(() => {
        this.deleteShapes(ids);
        this.setCurrentPageId(pageId);
        this.setFocusLayer(null);
        this.selectNone();
        this.putContent(content, { select: true, preserveIds: true, preservePosition: true });
        const {
          center: { x: x3, y: y3 }
        } = this.selectionBounds;
        this.setCamera(this.camera.x, this.camera.y, fromPageZ);
        this.centerOnPoint(x3, y3);
      });
      return this;
    }
    lockShapes(_ids = this.pageState.selectedIds) {
      if (this.isReadOnly)
        return this;
      return this;
    }
    /**
     * Reorder shapes.
     *
     * @param operation - The operation to perform.
     * @param ids - The ids to reorder.
     * @public
     */
    reorderShapes(operation, ids) {
      if (this.isReadOnly)
        return this;
      if (ids.length === 0)
        return this;
      const parents = this.getParentsMappedToChildren(ids);
      const changes = [];
      switch (operation) {
        case "toBack": {
          parents.forEach((movingSet, parentId) => {
            const siblings = compact(
              this.getSortedChildIds(parentId).map((id) => this.getShapeById(id))
            );
            if (movingSet.size === siblings.length)
              return;
            let below;
            let above;
            for (const shape of siblings) {
              if (!movingSet.has(shape)) {
                above = shape.index;
                break;
              }
              movingSet.delete(shape);
              below = shape.index;
            }
            if (movingSet.size === 0)
              return;
            const indices = getIndicesBetween(below, above, movingSet.size);
            Array.from(movingSet.values()).sort(sortByIndex2).forEach(
              (node, i3) => changes.push({ id: node.id, type: node.type, index: indices[i3] })
            );
          });
          break;
        }
        case "toFront": {
          parents.forEach((movingSet, parentId) => {
            const siblings = compact(
              this.getSortedChildIds(parentId).map((id) => this.getShapeById(id))
            );
            const len = siblings.length;
            if (movingSet.size === len)
              return;
            let below;
            let above;
            for (let i3 = len - 1; i3 > -1; i3--) {
              const shape = siblings[i3];
              if (!movingSet.has(shape)) {
                below = shape.index;
                break;
              }
              movingSet.delete(shape);
              above = shape.index;
            }
            if (movingSet.size === 0)
              return;
            const indices = getIndicesBetween(below, above, movingSet.size);
            Array.from(movingSet.values()).sort(sortByIndex2).forEach(
              (node, i3) => changes.push({ id: node.id, type: node.type, index: indices[i3] })
            );
          });
          break;
        }
        case "forward": {
          parents.forEach((movingSet, parentId) => {
            var _a5;
            const siblings = compact(
              this.getSortedChildIds(parentId).map((id) => this.getShapeById(id))
            );
            const len = siblings.length;
            if (movingSet.size === len)
              return;
            const movingIndices = new Set(Array.from(movingSet).map((n3) => siblings.indexOf(n3)));
            let selectIndex = -1;
            let isSelecting = false;
            let below;
            let above;
            let count;
            for (let i3 = 0; i3 < len; i3++) {
              const isMoving = movingIndices.has(i3);
              if (!isSelecting && isMoving) {
                isSelecting = true;
                selectIndex = i3;
                above = void 0;
              } else if (isSelecting && !isMoving) {
                isSelecting = false;
                count = i3 - selectIndex;
                below = siblings[i3].index;
                above = (_a5 = siblings[i3 + 1]) == null ? void 0 : _a5.index;
                const indices = getIndicesBetween(below, above, count);
                for (let k2 = 0; k2 < count; k2++) {
                  const node = siblings[selectIndex + k2];
                  changes.push({ id: node.id, type: node.type, index: indices[k2] });
                }
              }
            }
          });
          break;
        }
        case "backward": {
          parents.forEach((movingSet, parentId) => {
            var _a5;
            const siblings = compact(
              this.getSortedChildIds(parentId).map((id) => this.getShapeById(id))
            );
            const len = siblings.length;
            if (movingSet.size === len)
              return;
            const movingIndices = new Set(Array.from(movingSet).map((n3) => siblings.indexOf(n3)));
            let selectIndex = -1;
            let isSelecting = false;
            let count;
            for (let i3 = len - 1; i3 > -1; i3--) {
              const isMoving = movingIndices.has(i3);
              if (!isSelecting && isMoving) {
                isSelecting = true;
                selectIndex = i3;
              } else if (isSelecting && !isMoving) {
                isSelecting = false;
                count = selectIndex - i3;
                const indices = getIndicesBetween((_a5 = siblings[i3 - 1]) == null ? void 0 : _a5.index, siblings[i3].index, count);
                for (let k2 = 0; k2 < count; k2++) {
                  const node = siblings[i3 + k2 + 1];
                  changes.push({ id: node.id, type: node.type, index: indices[k2] });
                }
              }
            }
          });
          break;
        }
      }
      this.updateShapes(changes);
      return this;
    }
    /**
     * Send shapes to the back of the page's object list.
     *
     * @example
     *
     * ```ts
     * app.sendToBack()
     * app.sendToBack(['id1', 'id2'])
     * ```
     *
     * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.
     * @public
     */
    sendToBack(ids = this.pageState.selectedIds) {
      this.reorderShapes("toBack", ids);
      return this;
    }
    /**
     * Send shapes backward in the page's object list.
     *
     * @example
     *
     * ```ts
     * app.sendBackward()
     * app.sendBackward(['id1', 'id2'])
     * ```
     *
     * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.
     * @public
     */
    sendBackward(ids = this.pageState.selectedIds) {
      this.reorderShapes("backward", ids);
      return this;
    }
    /**
     * Bring shapes forward in the page's object list.
     *
     * @example
     *
     * ```ts
     * app.bringForward()
     * app.bringForward(['id1', 'id2'])
     * ```
     *
     * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.
     * @public
     */
    bringForward(ids = this.pageState.selectedIds) {
      this.reorderShapes("forward", ids);
      return this;
    }
    /**
     * Bring shapes to the front of the page's object list.
     *
     * @example
     *
     * ```ts
     * app.bringToFront()
     * app.bringToFront(['id1', 'id2'])
     * ```
     *
     * @param ids - The ids of the shapes to move. Defaults to the ids of the selected shapes.
     * @public
     */
    bringToFront(ids = this.pageState.selectedIds) {
      this.reorderShapes("toFront", ids);
      return this;
    }
    /**
     * Flip shape positions.
     *
     * @example
     *
     * ```ts
     * app.flipShapes('horizontal')
     * app.flipShapes('horizontal', ['box1', 'box2'])
     * ```
     *
     * @param operation - Whether to flip horizontally or vertically.
     * @param ids - The ids of the shapes to flip. Defaults to selected shapes.
     * @public
     */
    flipShapes(operation, ids = this.selectedIds) {
      if (this.isReadOnly)
        return this;
      let shapes = compact(ids.map((id) => this.getShapeById(id)));
      if (!shapes.length)
        return this;
      shapes = shapes.map((shape) => {
        if (shape.type === "group") {
          return this.getSortedChildIds(shape.id).map((id) => this.getShapeById(id));
        }
        return shape;
      }).flat();
      const scaleOriginPage = Box2d.Common(compact(shapes.map((id) => this.getPageBounds(id)))).center;
      this.batch(() => {
        for (const shape of shapes) {
          const util = this.getShapeUtil(shape);
          const bounds = util.bounds(shape);
          const initialPageTransform = this.getPageTransformById(shape.id);
          if (!initialPageTransform)
            continue;
          this.resizeShape(
            shape.id,
            { x: operation === "horizontal" ? -1 : 1, y: operation === "vertical" ? -1 : 1 },
            {
              initialBounds: bounds,
              initialPageTransform,
              initialShape: shape,
              mode: "scale_shape",
              scaleOrigin: scaleOriginPage,
              scaleAxisRotation: 0
            }
          );
        }
      });
      return this;
    }
    /**
     * Stack shape.
     *
     * @example
     *
     * ```ts
     * app.stackShapes('horizontal')
     * app.stackShapes('horizontal', ['box1', 'box2'])
     * app.stackShapes('horizontal', ['box1', 'box2'], 20)
     * ```
     *
     * @param operation - Whether to stack horizontally or vertically.
     * @param ids - The ids of the shapes to stack. Defaults to selected shapes.
     * @param gap - A specific gap to use when stacking.
     * @public
     */
    stackShapes(operation, ids = this.pageState.selectedIds, gap) {
      if (this.isReadOnly)
        return this;
      const shapes = compact(ids.map((id) => this.getShapeById(id))).filter((shape) => {
        if (!shape)
          return false;
        if (TLArrowShapeDef.is(shape)) {
          if (shape.props.start.type === "binding" || shape.props.end.type === "binding") {
            return false;
          }
        }
        return true;
      });
      const len = shapes.length;
      if (gap === void 0 && len < 3 || len < 2)
        return this;
      const pageBounds = Object.fromEntries(
        shapes.map((shape) => [shape.id, this.getPageBounds(shape)])
      );
      let val;
      let min2;
      let max;
      let dim;
      if (operation === "horizontal") {
        val = "x";
        min2 = "minX";
        max = "maxX";
        dim = "width";
      } else {
        val = "y";
        min2 = "minY";
        max = "maxY";
        dim = "height";
      }
      let shapeGap;
      if (gap === void 0) {
        const gaps = [];
        shapes.sort((a3, b3) => pageBounds[a3.id][min2] - pageBounds[b3.id][min2]);
        for (let i3 = 0; i3 < len - 1; i3++) {
          const shape = shapes[i3];
          const nextShape = shapes[i3 + 1];
          const bounds = pageBounds[shape.id];
          const nextBounds = pageBounds[nextShape.id];
          const gap2 = nextBounds[min2] - bounds[max];
          const current = gaps.find((g3) => g3.gap === gap2);
          if (current) {
            current.count++;
          } else {
            gaps.push({ gap: gap2, count: 1 });
          }
        }
        let maxCount = 0;
        gaps.forEach((g3) => {
          if (g3.count > maxCount) {
            maxCount = g3.count;
            shapeGap = g3.gap;
          }
        });
        if (maxCount === 1) {
          shapeGap = Math.max(0, gaps.reduce((a3, c3) => a3 + c3.gap * c3.count, 0) / (len - 1));
        }
      } else {
        shapeGap = gap;
      }
      const changes = [];
      let v3 = pageBounds[shapes[0].id][max];
      shapes.forEach((shape, i3) => {
        var _a5, _b2;
        if (i3 === 0)
          return;
        const delta = { x: 0, y: 0 };
        delta[val] = v3 + shapeGap - pageBounds[shape.id][val];
        const parent = this.getParentShape(shape);
        const localDelta = parent ? Vec2d.Rot(delta, -this.getPageRotation(parent)) : delta;
        const translateStartChanges = (_b2 = (_a5 = this.getShapeUtil(shape)).onTranslateStart) == null ? void 0 : _b2.call(_a5, shape);
        changes.push(
          translateStartChanges ? __spreadProps(__spreadValues({}, translateStartChanges), {
            [val]: shape[val] + localDelta[val]
          }) : {
            id: shape.id,
            type: shape.type,
            [val]: shape[val] + localDelta[val]
          }
        );
        v3 += pageBounds[shape.id][dim] + shapeGap;
      });
      this.updateShapes(changes);
      return this;
    }
    /**
     * Pack shapes into a grid centered on their current position. Based on potpack
     * (https://github.com/mapbox/potpack)
     *
     * @param ids - The ids of the shapes to pack. Defaults to selected shapes.
     * @param padding - The padding to apply to the packed shapes.
     */
    packShapes(ids = this.pageState.selectedIds, padding = 16) {
      var _a5, _b2;
      if (this.isReadOnly)
        return this;
      if (ids.length < 2)
        return this;
      const shapes = compact(
        ids.map((id) => this.getShapeById(id)).filter((shape2) => {
          if (!shape2)
            return false;
          if (TLArrowShapeDef.is(shape2)) {
            if (shape2.props.start.type === "binding" || shape2.props.end.type === "binding") {
              return false;
            }
          }
          return true;
        })
      );
      const shapePageBounds = {};
      const nextShapePageBounds = {};
      let shape, bounds, area = 0;
      for (let i3 = 0; i3 < shapes.length; i3++) {
        shape = shapes[i3];
        bounds = this.getPageBounds(shape);
        shapePageBounds[shape.id] = bounds;
        nextShapePageBounds[shape.id] = bounds.clone();
        area += bounds.width * bounds.height;
      }
      const commonBounds = Box2d.Common(compact(Object.values(shapePageBounds)));
      const maxWidth = commonBounds.width;
      shapes.sort((a3, b3) => shapePageBounds[b3.id].height - shapePageBounds[a3.id].height);
      const startWidth = Math.max(Math.ceil(Math.sqrt(area / 0.95)), maxWidth);
      const spaces = [new Box2d(commonBounds.x, commonBounds.y, startWidth, Infinity)];
      let width = 0;
      let height = 0;
      let space;
      let last2;
      for (let i3 = 0; i3 < shapes.length; i3++) {
        shape = shapes[i3];
        bounds = nextShapePageBounds[shape.id];
        for (let i4 = spaces.length - 1; i4 >= 0; i4--) {
          space = spaces[i4];
          if (bounds.width > space.width || bounds.height > space.height)
            continue;
          bounds.x = space.x;
          bounds.y = space.y;
          height = Math.max(height, bounds.maxY);
          width = Math.max(width, bounds.maxX);
          if (bounds.width === space.width && bounds.height === space.height) {
            last2 = spaces.pop();
            if (i4 < spaces.length)
              spaces[i4] = last2;
          } else if (bounds.height === space.height) {
            space.x += bounds.width + padding;
            space.width -= bounds.width + padding;
          } else if (bounds.width === space.width) {
            space.y += bounds.height + padding;
            space.height -= bounds.height + padding;
          } else {
            spaces.push(
              new Box2d(
                space.x + (bounds.width + padding),
                space.y,
                space.width - (bounds.width + padding),
                bounds.height
              )
            );
            space.y += bounds.height + padding;
            space.height -= bounds.height + padding;
          }
          break;
        }
      }
      const commonAfter = Box2d.Common(Object.values(nextShapePageBounds));
      const centerDelta = Vec2d.Sub(commonBounds.center, commonAfter.center);
      let nextBounds;
      const changes = [];
      for (let i3 = 0; i3 < shapes.length; i3++) {
        shape = shapes[i3];
        bounds = shapePageBounds[shape.id];
        nextBounds = nextShapePageBounds[shape.id];
        const delta = this.getDeltaInParentSpace(
          shape,
          Vec2d.Sub(nextBounds.point, bounds.point).add(centerDelta)
        );
        const change = {
          id: shape.id,
          type: shape.type,
          x: shape.x + delta.x,
          y: shape.y + delta.y
        };
        const translateStartChange = (_b2 = (_a5 = this.getShapeUtil(shape)).onTranslateStart) == null ? void 0 : _b2.call(_a5, __spreadValues(__spreadValues({}, shape), change));
        if (translateStartChange) {
          changes.push(__spreadValues(__spreadValues({}, change), translateStartChange));
        } else {
          changes.push(change);
        }
      }
      if (changes.length) {
        this.updateShapes(changes);
      }
      return this;
    }
    /**
     * Align shape positions.
     *
     * @example
     *
     * ```ts
     * app.alignShapes('left')
     * app.alignShapes('left', ['box1', 'box2'])
     * ```
     *
     * @param operation - The align operation to apply.
     * @param ids - The ids of the shapes to align. Defaults to selected shapes.
     * @public
     */
    alignShapes(operation, ids = this.pageState.selectedIds) {
      if (this.isReadOnly)
        return this;
      if (ids.length < 2)
        return this;
      const shapes = compact(ids.map((id) => this.getShapeById(id)));
      const shapePageBounds = Object.fromEntries(
        shapes.map((shape) => [shape.id, this.getPageBounds(shape)])
      );
      const commonBounds = Box2d.Common(compact(Object.values(shapePageBounds)));
      const changes = [];
      shapes.forEach((shape) => {
        var _a5, _b2;
        const pageBounds = shapePageBounds[shape.id];
        if (!pageBounds)
          return;
        const delta = { x: 0, y: 0 };
        switch (operation) {
          case "top": {
            delta.y = commonBounds.minY - pageBounds.minY;
            break;
          }
          case "center-vertical": {
            delta.y = commonBounds.midY - pageBounds.minY - pageBounds.height / 2;
            break;
          }
          case "bottom": {
            delta.y = commonBounds.maxY - pageBounds.minY - pageBounds.height;
            break;
          }
          case "left": {
            delta.x = commonBounds.minX - pageBounds.minX;
            break;
          }
          case "center-horizontal": {
            delta.x = commonBounds.midX - pageBounds.minX - pageBounds.width / 2;
            break;
          }
          case "right": {
            delta.x = commonBounds.maxX - pageBounds.minX - pageBounds.width;
            break;
          }
        }
        const parent = this.getParentShape(shape);
        const localDelta = parent ? Vec2d.Rot(delta, -this.getPageRotation(parent)) : delta;
        const translateChanges = (_b2 = (_a5 = this.getShapeUtil(shape)).onTranslateStart) == null ? void 0 : _b2.call(_a5, shape);
        changes.push(
          translateChanges ? __spreadProps(__spreadValues({}, translateChanges), {
            x: shape.x + localDelta.x,
            y: shape.y + localDelta.y
          }) : {
            id: shape.id,
            type: shape.type,
            x: shape.x + localDelta.x,
            y: shape.y + localDelta.y
          }
        );
      });
      this.updateShapes(changes);
      return this;
    }
    /**
     * Distribute shape positions.
     *
     * @example
     *
     * ```ts
     * app.distributeShapes('left')
     * app.distributeShapes('left', ['box1', 'box2'])
     * ```
     *
     * @param operation - Whether to distribute shapes horizontally or vertically.
     * @param ids - The ids of the shapes to distribute. Defaults to selected shapes.
     * @public
     */
    distributeShapes(operation, ids = this.pageState.selectedIds) {
      if (this.isReadOnly)
        return this;
      if (ids.length < 3)
        return this;
      const len = ids.length;
      const shapes = compact(ids.map((id) => this.getShapeById(id)));
      const pageBounds = Object.fromEntries(
        shapes.map((shape) => [shape.id, this.getPageBounds(shape)])
      );
      let val;
      let min2;
      let max;
      let mid;
      let dim;
      if (operation === "horizontal") {
        val = "x";
        min2 = "minX";
        max = "maxX";
        mid = "midX";
        dim = "width";
      } else {
        val = "y";
        min2 = "minY";
        max = "maxY";
        mid = "midY";
        dim = "height";
      }
      const changes = [];
      const first = shapes.sort((a3, b3) => pageBounds[a3.id][min2] - pageBounds[b3.id][min2])[0];
      const last2 = shapes.sort((a3, b3) => pageBounds[b3.id][max] - pageBounds[a3.id][max])[0];
      const midFirst = pageBounds[first.id][mid];
      const step = (pageBounds[last2.id][mid] - midFirst) / (len - 1);
      const v3 = midFirst + step;
      shapes.filter((shape) => shape !== first && shape !== last2).sort((a3, b3) => pageBounds[a3.id][mid] - pageBounds[b3.id][mid]).forEach((shape, i3) => {
        var _a5, _b2;
        const delta = { x: 0, y: 0 };
        delta[val] = v3 + step * i3 - pageBounds[shape.id][dim] / 2 - pageBounds[shape.id][val];
        const parent = this.getParentShape(shape);
        const localDelta = parent ? Vec2d.Rot(delta, -this.getPageRotation(parent)) : delta;
        const translateStartChanges = (_b2 = (_a5 = this.getShapeUtil(shape)).onTranslateStart) == null ? void 0 : _b2.call(_a5, shape);
        changes.push(
          translateStartChanges ? __spreadProps(__spreadValues({}, translateStartChanges), {
            [val]: shape[val] + localDelta[val]
          }) : {
            id: shape.id,
            type: shape.type,
            [val]: shape[val] + localDelta[val]
          }
        );
      });
      this.updateShapes(changes);
      return this;
    }
    /** @internal */
    _resizeUnalignedShape(id, scale, options) {
      const { type } = options.initialShape;
      const shapeScale = new Vec2d(scale.x, scale.y);
      if (Math.abs(scale.x) > Math.abs(scale.y)) {
        shapeScale.x = Math.sign(scale.x) * Math.abs(scale.y);
      } else {
        shapeScale.y = Math.sign(scale.y) * Math.abs(scale.x);
      }
      this.resizeShape(id, shapeScale, {
        initialShape: options.initialShape,
        initialBounds: options.initialBounds
      });
      if (Math.sign(scale.x) * Math.sign(scale.y) < 0) {
        let { rotation } = Matrix2d.Decompose(options.initialPageTransform);
        rotation -= 2 * rotation;
        this.updateShapes([{ id, type, rotation }], true);
      }
      const preScaleShapePageCenter = Matrix2d.applyToPoint(
        options.initialPageTransform,
        options.initialBounds.center
      );
      const postScaleShapePageCenter = this._scalePagePoint(
        preScaleShapePageCenter,
        options.scaleOrigin,
        scale,
        options.scaleAxisRotation
      );
      const currentPageCenter = this.getPageCenterById(id);
      const currentPagePoint = this.getPagePointById(id);
      if (!currentPageCenter || !currentPagePoint)
        return this;
      const pageDelta = Vec2d.Sub(postScaleShapePageCenter, currentPageCenter);
      const postScaleShapePagePoint = Vec2d.Add(currentPagePoint, pageDelta);
      const { x: x3, y: y3 } = this.getPointInParentSpace(id, postScaleShapePagePoint);
      this.updateShapes([{ id, type, x: x3, y: y3 }], true);
      return this;
    }
    /** @internal */
    _scalePagePoint(point2, scaleOrigin, scale, scaleAxisRotation) {
      const relativePoint = Vec2d.RotWith(point2, scaleOrigin, -scaleAxisRotation).sub(scaleOrigin);
      const newRelativePagePoint = Vec2d.MulV(relativePoint, scale);
      const destination = Vec2d.Add(newRelativePagePoint, scaleOrigin).rotWith(
        scaleOrigin,
        scaleAxisRotation
      );
      return destination;
    }
    resizeShape(id, scale, options) {
      var _a5, _b2, _c, _d, _e, _f, _g, _h;
      if (this.isReadOnly)
        return this;
      if (!Number.isFinite(scale.x))
        scale = new Vec2d(1, scale.y);
      if (!Number.isFinite(scale.y))
        scale = new Vec2d(scale.x, 1);
      const initialShape = (_a5 = options == null ? void 0 : options.initialShape) != null ? _a5 : this.getShapeById(id);
      if (!initialShape)
        return this;
      const scaleOrigin = (_c = options == null ? void 0 : options.scaleOrigin) != null ? _c : (_b2 = this.getPageBoundsById(id)) == null ? void 0 : _b2.center;
      if (!scaleOrigin)
        return this;
      const pageRotation = this.getPageRotationById(id);
      if (pageRotation == null)
        return this;
      const scaleAxisRotation = (_d = options == null ? void 0 : options.scaleAxisRotation) != null ? _d : pageRotation;
      const pageTransform = (_e = options == null ? void 0 : options.initialPageTransform) != null ? _e : this.getPageTransformById(id);
      if (!pageTransform)
        return this;
      const initialBounds = (_f = options == null ? void 0 : options.initialBounds) != null ? _f : this.getBoundsById(id);
      if (!initialBounds)
        return this;
      if (!areAnglesCompatible(pageRotation, scaleAxisRotation)) {
        return this._resizeUnalignedShape(id, scale, __spreadProps(__spreadValues({}, options), {
          initialBounds,
          scaleOrigin,
          scaleAxisRotation,
          initialPageTransform: pageTransform,
          initialShape
        }));
      }
      const util = this.getShapeUtil(initialShape);
      if (util.isAspectRatioLocked(initialShape)) {
        if (Math.abs(scale.x) > Math.abs(scale.y)) {
          scale = new Vec2d(scale.x, Math.sign(scale.y) * Math.abs(scale.x));
        } else {
          scale = new Vec2d(Math.sign(scale.x) * Math.abs(scale.y), scale.y);
        }
      }
      if (util.onResize && util.canResize(initialShape)) {
        const newPagePoint = this._scalePagePoint(
          Matrix2d.applyToPoint(pageTransform, new Vec2d(0, 0)),
          scaleOrigin,
          scale,
          scaleAxisRotation
        );
        const newLocalPoint = this.getPointInParentSpace(initialShape.id, newPagePoint);
        const myScale = new Vec2d(scale.x, scale.y);
        const areWidthAndHeightAlignedWithCorrectAxis = approximately(
          (pageRotation - scaleAxisRotation) % Math.PI,
          0
        );
        myScale.x = areWidthAndHeightAlignedWithCorrectAxis ? scale.x : scale.y;
        myScale.y = areWidthAndHeightAlignedWithCorrectAxis ? scale.y : scale.x;
        const initialPagePoint = Matrix2d.applyToPoint(pageTransform, new Vec2d());
        const { x: x3, y: y3 } = this.getPointInParentSpace(initialShape.id, initialPagePoint);
        this.updateShapes(
          [
            __spreadValues({
              id,
              type: initialShape.type,
              x: newLocalPoint.x,
              y: newLocalPoint.y
            }, util.onResize(
              __spreadProps(__spreadValues({}, initialShape), { x: x3, y: y3 }),
              {
                newPoint: newLocalPoint,
                handle: (_g = options == null ? void 0 : options.dragHandle) != null ? _g : "bottom_right",
                // don't set isSingle to true for children
                mode: (_h = options == null ? void 0 : options.mode) != null ? _h : "scale_shape",
                scaleX: myScale.x,
                scaleY: myScale.y,
                initialBounds,
                initialShape
              }
            ))
          ],
          true
        );
      } else {
        const initialPageCenter = Matrix2d.applyToPoint(pageTransform, initialBounds.center);
        const newPageCenter = this._scalePagePoint(
          initialPageCenter,
          scaleOrigin,
          scale,
          scaleAxisRotation
        );
        const initialPageCenterInParentSpace = this.getPointInParentSpace(
          initialShape.id,
          initialPageCenter
        );
        const newPageCenterInParentSpace = this.getPointInParentSpace(initialShape.id, newPageCenter);
        const delta = Vec2d.Sub(newPageCenterInParentSpace, initialPageCenterInParentSpace);
        this.updateShapes(
          [
            {
              id,
              type: initialShape.type,
              x: initialShape.x + delta.x,
              y: initialShape.y + delta.y
            }
          ],
          true
        );
      }
      return this;
    }
    /**
     * Stretch shape sizes and positions to fill their common bounding box.
     *
     * @example
     *
     * ```ts
     * app.stretchShapes('horizontal')
     * app.stretchShapes('horizontal', ['box1', 'box2'])
     * ```
     *
     * @param operation - Whether to stretch shapes horizontally or vertically.
     * @param ids - The ids of the shapes to stretch. Defaults to selected shapes.
     * @public
     */
    stretchShapes(operation, ids = this.pageState.selectedIds) {
      if (this.isReadOnly)
        return this;
      if (ids.length < 2)
        return this;
      const shapes = compact(ids.map((id) => this.getShapeById(id)));
      const shapeBounds = Object.fromEntries(shapes.map((shape) => [shape.id, this.getBounds(shape)]));
      const shapePageBounds = Object.fromEntries(
        shapes.map((shape) => [shape.id, this.getPageBounds(shape)])
      );
      const commonBounds = Box2d.Common(compact(Object.values(shapePageBounds)));
      const changes = [];
      switch (operation) {
        case "vertical": {
          this.batch(() => {
            for (const shape of shapes) {
              const pageRotation = this.getPageRotation(shape);
              if (pageRotation % PI2)
                continue;
              const bounds = shapeBounds[shape.id];
              const pageBounds = shapePageBounds[shape.id];
              const localOffset = this.getDeltaInParentSpace(
                shape,
                new Vec2d(0, commonBounds.minY - pageBounds.minY)
              );
              const { x: x3, y: y3 } = Vec2d.Add(localOffset, shape);
              this.updateShapes([{ id: shape.id, type: shape.type, x: x3, y: y3 }], true);
              const scale = new Vec2d(1, commonBounds.height / pageBounds.height);
              this.resizeShape(shape.id, scale, {
                initialBounds: bounds,
                scaleOrigin: new Vec2d(pageBounds.center.x, commonBounds.minY),
                scaleAxisRotation: 0
              });
            }
          });
          break;
        }
        case "horizontal": {
          this.batch(() => {
            for (const shape of shapes) {
              const bounds = shapeBounds[shape.id];
              const pageBounds = shapePageBounds[shape.id];
              const pageRotation = this.getPageRotation(shape);
              if (pageRotation % PI2)
                continue;
              const localOffset = this.getDeltaInParentSpace(
                shape,
                new Vec2d(commonBounds.minX - pageBounds.minX, 0)
              );
              const { x: x3, y: y3 } = Vec2d.Add(localOffset, shape);
              this.updateShapes([{ id: shape.id, type: shape.type, x: x3, y: y3 }], true);
              const scale = new Vec2d(commonBounds.width / pageBounds.width, 1);
              this.resizeShape(shape.id, scale, {
                initialBounds: bounds,
                scaleOrigin: new Vec2d(commonBounds.minX, pageBounds.center.y),
                scaleAxisRotation: 0
              });
            }
          });
          break;
        }
      }
      this.updateShapes(changes);
      return this;
    }
    /**
     * Reparent shapes to a new parent. This operation preserves the shape's current page positions /
     * rotations.
     *
     * @example
     *
     * ```ts
     * app.reparentShapesById(['box1', 'box2'], 'frame1')
     * ```
     *
     * @param ids - The ids of the shapes to reparent.
     * @param parentId - The id of the new parent shape.
     * @param insertIndex - The index to insert the children.
     * @public
     */
    reparentShapesById(ids, parentId, insertIndex) {
      const changes = [];
      const parentTransform = TLPage.isId(parentId) ? Matrix2d.Identity() : this.getPageTransformById(parentId);
      const parentPageRotation = parentTransform.decompose().rotation;
      let indices = [];
      const sibs = compact(this.getSortedChildIds(parentId).map((id2) => this.getShapeById(id2)));
      if (insertIndex) {
        const sibWithInsertIndex = sibs.find((s3) => s3.index === insertIndex);
        if (sibWithInsertIndex) {
          const sibAbove = sibs[sibs.indexOf(sibWithInsertIndex) + 1];
          if (sibAbove) {
            indices = getIndicesBetween(insertIndex, sibAbove.index, ids.length);
          } else {
            indices = getIndicesAbove(insertIndex, ids.length);
          }
        } else {
          const sibAbove = sibs.sort(sortByIndex2).find((s3) => s3.index > insertIndex);
          if (sibAbove) {
            indices = getIndicesBetween(insertIndex, sibAbove.index, ids.length);
          } else {
            indices = getIndicesAbove(insertIndex, ids.length);
          }
        }
      } else {
        const sib = sibs.length && sibs[sibs.length - 1];
        indices = sib ? getIndicesAbove(sib.index, ids.length) : getIndices(ids.length);
      }
      let id;
      for (let i3 = 0; i3 < ids.length; i3++) {
        id = ids[i3];
        const shape = this.getShapeById(id);
        const pagePoint = this.getPagePointById(id);
        if (!shape || !pagePoint)
          continue;
        const newPoint = Matrix2d.applyToPoint(Matrix2d.Inverse(parentTransform), pagePoint);
        const newRotation = this.getPageRotation(shape) - parentPageRotation;
        changes.push({
          id: shape.id,
          type: shape.type,
          parentId,
          x: newPoint.x,
          y: newPoint.y,
          rotation: newRotation,
          index: indices[i3]
        });
      }
      this.updateShapes(changes);
      return this;
    }
    /**
     * Select one or more shapes.
     *
     * @example
     *
     * ```ts
     * app.select('id1')
     * app.select('id1', 'id2')
     * ```
     *
     * @param ids - The ids to select.
     * @public
     */
    select(...ids) {
      this.setSelectedIds(ids);
      return this;
    }
    /**
     * Remove a shpae from the existing set of selected shapes.
     *
     * @example
     *
     * ```ts
     * app.deselect(shape.id)
     * ```
     *
     * @public
     */
    deselect(...ids) {
      const { selectedIds } = this;
      if (selectedIds.length > 0 && ids.length > 0) {
        this.setSelectedIds(selectedIds.filter((id) => !ids.includes(id)));
      }
      return this;
    }
    /**
     * Select all direct children of the current page.
     *
     * @example
     *
     * ```ts
     * app.selectAll()
     * ```
     *
     * @public
     */
    selectAll() {
      const ids = this.getSortedChildIds(this.currentPageId);
      if (ids.length <= 0)
        return this;
      this.setSelectedIds(ids);
      return this;
    }
    getShapesAndDescendantsInOrder(ids) {
      const idsToInclude = [];
      const visitedIds = /* @__PURE__ */ new Set();
      const idsToCheck = [...ids];
      while (idsToCheck.length > 0) {
        const id = idsToCheck.pop();
        if (!id)
          break;
        if (visitedIds.has(id))
          continue;
        idsToInclude.push(id);
        this.getSortedChildIds(id).forEach((id2) => {
          idsToCheck.push(id2);
        });
      }
      const shapes = idsToInclude.map((s3) => this.getShapeById(s3)).filter((s3) => s3.type !== "group");
      const { sortedShapesArray } = this;
      shapes.sort((a3, b3) => sortedShapesArray.indexOf(a3) - sortedShapesArray.indexOf(b3));
      return shapes;
    }
    /**
     * Clear the selection.
     *
     * @example
     *
     * ```ts
     * app.selectNone()
     * ```
     *
     * @public
     */
    selectNone() {
      if (this.selectedIds.length > 0) {
        this.setSelectedIds([]);
      }
      return this;
    }
    /**
     * Set the current page.
     *
     * @example
     *
     * ```ts
     * app.setCurrentPageId('page1')
     * ```
     *
     * @param pageId - The id of the page to set as the current page.
     * @param options - Options for setting the current page.
     * @public
     */
    setCurrentPageId(pageId, { stopFollowing = true } = {}) {
      this._setCurrentPageId(pageId, { stopFollowing });
      return this;
    }
    /** Set the current user tab state */
    updateInstanceState(partial, ephemeral = false, squashing = false) {
      this._updateInstanceState(partial, ephemeral, squashing);
      return this;
    }
    get hoveredId() {
      return this.pageState.hoveredId;
    }
    get hoveredShape() {
      var _a5;
      if (!this.hoveredId)
        return null;
      return (_a5 = this.getShapeById(this.hoveredId)) != null ? _a5 : null;
    }
    /**
     * Set the current hovered shape.
     *
     * @example
     *
     * ```ts
     * app.setHoveredId('box1')
     * app.setHoveredId() // Clears the hovered shape.
     * ```
     *
     * @param id - The id of the page to set as the current page
     * @public
     */
    setHoveredId(id = null) {
      if (id === this.pageState.hoveredId)
        return this;
      this.setInstancePageState({ hoveredId: id }, true);
      return this;
    }
    /**
     * Set the current erasing shapes.
     *
     * @example
     *
     * ```ts
     * app.setErasingIds(['box1', 'box2'])
     * app.setErasingIds() // Clears the erasing set
     * ```
     *
     * @param ids - The ids of shapes to set as erasing.
     * @public
     */
    setErasingIds(ids = []) {
      const erasingIds = this.erasingIdsSet;
      if (ids.length === erasingIds.size && ids.every((id) => erasingIds.has(id)))
        return this;
      this.setInstancePageState({ erasingIds: ids }, true);
      return this;
    }
    /**
     * Set the current cursor.
     *
     * @example
     *
     * ```ts
     * app.setCursor({ type: 'default' })
     * app.setCursor({ type: 'default', rotation: Math.PI / 2, color: 'red' })
     * ```
     *
     * @param cursor - A partial of the cursor object.
     * @public
     */
    setCursor(cursor) {
      const current = this.cursor;
      const next = __spreadValues(__spreadProps(__spreadValues({}, current), {
        rotation: 0
      }), cursor);
      if (!(current.type === next.type && current.rotation === next.rotation && current.color === next.color)) {
        this.updateInstanceState({ cursor: next }, true);
      }
      return this;
    }
    /**
     * Set the current scribble.
     *
     * @example
     *
     * ```ts
     * app.setScribble(nextScribble)
     * app.setScribble() // clears the scribble
     * ```
     *
     * @param scribble - The new scribble object.
     * @public
     */
    setScribble(scribble = null) {
      this.updateInstanceState({ scribble }, true);
      return this;
    }
    /**
     * Set the current brush.
     *
     * @example
     *
     * ```ts
     * app.setBrush({ x: 0, y: 0, w: 100, h: 100 })
     * app.setBrush() // Clears the brush
     * ```
     *
     * @param brush - The brush box model to set, or null for no brush model.
     * @public
     */
    setBrush(brush = null) {
      if (!brush && !this.brush)
        return this;
      this.updateInstanceState({ brush }, true);
      return this;
    }
    /**
     * Set the current zoom brush.
     *
     * @example
     *
     * ```ts
     * app.setZoomBrush({ x: 0, y: 0, w: 100, h: 100 })
     * app.setZoomBrush() // Clears the zoom
     * ```
     *
     * @param zoomBrush - The zoom box model to set, or null for no zoom model.
     * @public
     */
    setZoomBrush(zoomBrush = null) {
      if (!zoomBrush && !this.zoomBrush)
        return this;
      this.updateInstanceState({ zoomBrush }, true);
      return this;
    }
    /**
     * Rotate shapes by a delta in radians.
     *
     * @example
     *
     * ```ts
     * app.rotateShapesBy(['box1', 'box2'], Math.PI)
     * app.rotateShapesBy(['box1', 'box2'], Math.PI / 2)
     * ```
     *
     * @param ids - The ids of the shapes to move.
     * @param delta - The delta in radians to apply to the selection rotation.
     */
    rotateShapesBy(ids, delta) {
      if (ids.length <= 0)
        return this;
      const snapshot = getRotationSnapshot({ app: this });
      applyRotationToSnapshotShapes({ delta, snapshot, app: this, stage: "one-off" });
      return this;
    }
    /**
     * Move shapes by a delta.
     *
     * @example
     *
     * ```ts
     * app.nudgeShapes(['box1', 'box2'], { x: 0, y: 1 })
     * app.nudgeShapes(['box1', 'box2'], { x: 0, y: 1 }, true)
     * ```
     *
     * @param ids - The ids of the shapes to move.
     * @param direction - The direction in which to move the shapes.
     * @param major - Whether this is a major nudge, e.g. a shift + arrow nudge.
     */
    nudgeShapes(ids, direction, major = false, ephemeral = false) {
      var _a5, _b2;
      if (ids.length <= 0)
        return this;
      const step = this.isGridMode ? major ? this.gridSize * GRID_INCREMENT : this.gridSize : major ? MAJOR_NUDGE_FACTOR : MINOR_NUDGE_FACTOR;
      const steppedDelta = Vec2d.Mul(direction, step);
      const changes = [];
      for (const id of ids) {
        const shape = this.getShapeById(id);
        if (!shape) {
          throw Error(`Could not find a shape with the id ${id}.`);
        }
        const localDelta = this.getDeltaInParentSpace(shape, steppedDelta);
        const translateStartChanges = (_b2 = (_a5 = this.getShapeUtil(shape)).onTranslateStart) == null ? void 0 : _b2.call(_a5, shape);
        changes.push(
          translateStartChanges ? __spreadProps(__spreadValues({}, translateStartChanges), {
            x: shape.x + localDelta.x,
            y: shape.y + localDelta.y
          }) : {
            id,
            x: shape.x + localDelta.x,
            y: shape.y + localDelta.y,
            type: shape.type
          }
        );
      }
      this.updateShapes(changes, ephemeral);
      return this;
    }
    /**
     * Duplicate shapes.
     *
     * @example
     *
     * ```ts
     * app.duplicateShapes()
     * app.duplicateShapes(['id1', 'id2'])
     * app.duplicateShapes(['id1', 'id2'], { x: 8, y: 8 })
     * ```
     *
     * @param ids - The ids of the shapes to duplicate. Defaults to the ids of the selected shapes.
     * @param offset - The offset (in pixels) to apply to the duplicated shapes.
     * @public
     */
    duplicateShapes(ids = this.selectedIds, offset) {
      if (ids.length <= 0)
        return this;
      const initialIds = new Set(ids);
      const idsToCreate = [];
      const idsToCheck = [...ids];
      while (idsToCheck.length > 0) {
        const id = idsToCheck.pop();
        if (!id)
          break;
        idsToCreate.push(id);
        this.getSortedChildIds(id).forEach((childId) => idsToCheck.push(childId));
      }
      idsToCreate.reverse();
      const idsMap = new Map(idsToCreate.map((id) => [id, this.createShapeId()]));
      const shapesToCreate = compact(
        idsToCreate.map((id) => {
          var _a5;
          const shape = this.getShapeById(id);
          if (!shape) {
            return null;
          }
          const createId = idsMap.get(id);
          let ox = 0;
          let oy = 0;
          if (offset && initialIds.has(id)) {
            const parentTransform = this.getParentTransform(shape);
            const vec = new Vec2d(offset.x, offset.y).rot(
              -Matrix2d.Decompose(parentTransform).rotation
            );
            ox = vec.x;
            oy = vec.y;
          }
          const parentId = (_a5 = shape.parentId) != null ? _a5 : this.currentPageId;
          const siblings = this.getSortedChildIds(parentId);
          const currentIndex = siblings.indexOf(shape.id);
          const siblingAboveId = siblings[currentIndex + 1];
          const siblingAbove = siblingAboveId ? this.getShapeById(siblingAboveId) : null;
          const index2 = siblingAbove ? getIndexBetween(shape.index, siblingAbove.index) : getIndexAbove(shape.index);
          let newShape = deepCopy(shape);
          if (TLArrowShapeDef.is(shape) && TLArrowShapeDef.is(newShape)) {
            const info = this.getShapeUtilByDef(TLArrowShapeDef).getArrowInfo(shape);
            let newStartShapeId = void 0;
            let newEndShapeId = void 0;
            if (shape.props.start.type === "binding") {
              newStartShapeId = idsMap.get(shape.props.start.boundShapeId);
              if (!newStartShapeId) {
                if (info == null ? void 0 : info.isValid) {
                  const { x: x3, y: y3 } = info.start.point;
                  newShape.props.start = {
                    type: "point",
                    x: x3,
                    y: y3
                  };
                } else {
                  const { start } = getArrowTerminalsInArrowSpace(this, shape);
                  newShape.props.start = {
                    type: "point",
                    x: start.x,
                    y: start.y
                  };
                }
              }
            }
            if (shape.props.end.type === "binding") {
              newEndShapeId = idsMap.get(shape.props.end.boundShapeId);
              if (!newEndShapeId) {
                if (info == null ? void 0 : info.isValid) {
                  const { x: x3, y: y3 } = info.end.point;
                  newShape.props.end = {
                    type: "point",
                    x: x3,
                    y: y3
                  };
                } else {
                  const { end } = getArrowTerminalsInArrowSpace(this, shape);
                  newShape.props.start = {
                    type: "point",
                    x: end.x,
                    y: end.y
                  };
                }
              }
            }
            const infoAfter = getIsArrowStraight(newShape) ? getStraightArrowInfo(this, newShape) : getCurvedArrowInfo(this, newShape);
            if ((info == null ? void 0 : info.isValid) && (infoAfter == null ? void 0 : infoAfter.isValid) && !getIsArrowStraight(shape)) {
              const mpA = Vec2d.Med(info.start.handle, info.end.handle);
              const distA = Vec2d.Dist(info.middle, mpA);
              const distB = Vec2d.Dist(infoAfter.middle, mpA);
              if (newShape.props.bend < 0) {
                newShape.props.bend += distB - distA;
              } else {
                newShape.props.bend -= distB - distA;
              }
            }
            if (newShape.props.start.type === "binding" && newStartShapeId) {
              newShape.props.start.boundShapeId = newStartShapeId;
            }
            if (newShape.props.end.type === "binding" && newEndShapeId) {
              newShape.props.end.boundShapeId = newEndShapeId;
            }
          }
          newShape = __spreadProps(__spreadValues({}, newShape), { id: createId, x: shape.x + ox, y: shape.y + oy, index: index2 });
          return newShape;
        })
      );
      shapesToCreate.forEach((shape) => {
        if (isShapeId(shape.parentId)) {
          if (idsMap.has(shape.parentId)) {
            shape.parentId = idsMap.get(shape.parentId);
          }
        }
      });
      this.history.batch(() => {
        const maxShapesReached = shapesToCreate.length + this.shapeIds.size > MAX_SHAPES_PER_PAGE;
        if (maxShapesReached) {
          alertMaxShapes(this);
        }
        const newShapes = maxShapesReached ? shapesToCreate.slice(0, MAX_SHAPES_PER_PAGE - this.shapeIds.size) : shapesToCreate;
        const ids2 = newShapes.map((s3) => s3.id);
        this.createShapes(newShapes);
        this.setSelectedIds(ids2);
        if (offset !== void 0) {
          const { viewportPageBounds, selectedPageBounds } = this;
          if (selectedPageBounds && !viewportPageBounds.contains(selectedPageBounds)) {
            this.centerOnPoint(selectedPageBounds.center.x, selectedPageBounds.center.y, {
              duration: ANIMATION_MEDIUM_MS
            });
          }
        }
      });
      return this;
    }
    /**
     * Set the current props (generally styles).
     *
     * @example
     *
     * ```ts
     * app.setProp('color', 'red')
     * app.setProp('color', 'red', true)
     * ```
     *
     * @param key - The key to set.
     * @param value - The value to set.
     * @param ephemeral - Whether the style is ephemeral. Defaults to false.
     * @public
     */
    setProp(key, value, ephemeral = false, squashing = false) {
      const children = [];
      const getChildProp = (id) => {
        const childIds = this.getSortedChildIds(id);
        for (const childId of childIds) {
          const childShape = this.getShapeById(childId);
          if ((childShape == null ? void 0 : childShape.type) === "group") {
            getChildProp(childShape.id);
          }
          children.push(childShape);
        }
      };
      this.history.batch(() => {
        this.updateInstanceState(
          {
            propsForNextShape: setPropsForNextShape(this.instanceState.propsForNextShape, {
              [key]: value
            })
          },
          ephemeral,
          squashing
        );
        if (this.isIn("select")) {
          const {
            pageState: { selectedIds }
          } = this;
          if (selectedIds.length > 0) {
            const shapes = compact(
              selectedIds.map((id) => {
                const shape = this.getShapeById(id);
                if ((shape == null ? void 0 : shape.type) === "group") {
                  const childIds = this.getSortedChildIds(shape.id);
                  for (const childId of childIds) {
                    const childShape = this.getShapeById(childId);
                    if ((childShape == null ? void 0 : childShape.type) === "group") {
                      getChildProp(childShape.id);
                    }
                    children.push(childShape);
                  }
                  return children;
                } else {
                  return shape;
                }
              })
            ).flat().filter(
              (shape) => shape.props[key] !== void 0 && (shape == null ? void 0 : shape.type) !== "group"
            );
            this.updateShapes(
              shapes.map((shape) => {
                const props = __spreadProps(__spreadValues({}, shape.props), { [key]: value });
                if (key === "color" && "labelColor" in props) {
                  props.labelColor = "black";
                }
                return {
                  id: shape.id,
                  type: shape.type,
                  props
                };
              }),
              ephemeral
            );
            if (key !== "color" && key !== "opacity") {
              const changes = [];
              for (const shape of shapes) {
                const currentShape = this.getShapeById(shape.id);
                if (!currentShape)
                  continue;
                const util = this.getShapeUtil(currentShape);
                const boundsA = util.bounds(shape);
                const boundsB = util.bounds(currentShape);
                const change = { id: shape.id, type: shape.type };
                let didChange = false;
                if (boundsA.width !== boundsB.width) {
                  didChange = true;
                  if (TLTextShapeDef.is(shape)) {
                    switch (shape.props.align) {
                      case "middle": {
                        change.x = currentShape.x + (boundsA.width - boundsB.width) / 2;
                        break;
                      }
                      case "end": {
                        change.x = currentShape.x + boundsA.width - boundsB.width;
                        break;
                      }
                    }
                  } else {
                    change.x = currentShape.x + (boundsA.width - boundsB.width) / 2;
                  }
                }
                if (boundsA.height !== boundsB.height) {
                  didChange = true;
                  change.y = currentShape.y + (boundsA.height - boundsB.height) / 2;
                }
                if (didChange) {
                  changes.push(change);
                }
              }
              if (changes.length) {
                this.updateShapes(changes, ephemeral);
              }
            }
          }
        }
        this.updateInstanceState(
          {
            propsForNextShape: setPropsForNextShape(this.instanceState.propsForNextShape, {
              [key]: value
            })
          },
          ephemeral,
          squashing
        );
      });
      return this;
    }
    /** @internal */
    _setCamera(x3, y3, z2 = this.camera.z) {
      const currentCamera = this.camera;
      if (currentCamera.x === x3 && currentCamera.y === y3 && currentCamera.z === z2)
        return this;
      const nextCamera = __spreadProps(__spreadValues({}, currentCamera), { x: x3, y: y3, z: z2 });
      this.batch(() => {
        var _a5;
        this.store.put([nextCamera]);
        const { currentScreenPoint } = this.inputs;
        this.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_move",
          point: currentScreenPoint,
          pointerId: 0,
          ctrlKey: this.inputs.ctrlKey,
          altKey: this.inputs.altKey,
          shiftKey: this.inputs.shiftKey,
          button: 0,
          isPen: (_a5 = this.isPenMode) != null ? _a5 : false
        });
        this.updateUserPresence({
          viewportPageBounds: this.viewportPageBounds.toJson()
        });
        this._cameraManager.tick();
      });
      return this;
    }
    /**
     * Set the current camera.
     *
     * @example
     *
     * ```ts
     * app.setCamera(0, 0)
     * app.setCamera(0, 0, 1)
     * ```
     *
     * @param x - The camera's x position.
     * @param y - The camera's y position.
     * @param z - The camera's z position. Defaults to the current zoom.
     * @param options - Options for the camera change.
     * @public
     */
    setCamera(x3, y3, z2 = this.camera.z, { stopFollowing = true } = {}) {
      this.stopCameraAnimation();
      if (stopFollowing && this.instanceState.followingUserId) {
        this.stopFollowingUser();
      }
      x3 = Number.isNaN(x3) ? 0 : x3;
      y3 = Number.isNaN(y3) ? 0 : y3;
      z2 = Number.isNaN(z2) ? 1 : z2;
      this._setCamera(x3, y3, z2);
      return this;
    }
    /**
     * Animate the camera.
     *
     * @example
     *
     * ```ts
     * app.animateCamera(0, 0)
     * app.animateCamera(0, 0, 1)
     * app.animateCamera(0, 0, 1, { duration: 1000, easing: (t) => t * t })
     * ```
     *
     * @param x - The camera's x position.
     * @param y - The camera's y position.
     * @param z - The camera's z position. Defaults to the current zoom.
     * @param opts - Options for the animation.
     * @public
     */
    animateCamera(x3, y3, z2 = this.camera.z, opts = DEFAULT_ANIMATION_OPTIONS) {
      x3 = Number.isNaN(x3) ? 0 : x3;
      y3 = Number.isNaN(y3) ? 0 : y3;
      z2 = Number.isNaN(z2) ? 1 : z2;
      const { width, height } = this.viewportScreenBounds;
      const w3 = width / z2;
      const h3 = height / z2;
      const targetViewport = new Box2d(-x3, -y3, w3, h3);
      return this._animateToViewport(targetViewport, opts);
    }
    /**
     * Center the camera on a point (in page space).
     *
     * @example
     *
     * ```ts
     * app.centerOnPoint(100, 100)
     * ```
     *
     * @param x - The x position of the point.
     * @param y - The y position of the point.
     * @param opts - The options for an animation.
     * @public
     */
    centerOnPoint(x3, y3, opts) {
      if (!this.canMoveCamera)
        return this;
      const {
        viewportPageBounds: { width: pw, height: ph },
        camera
      } = this;
      if (opts == null ? void 0 : opts.duration) {
        this.animateCamera(-(x3 - pw / 2), -(y3 - ph / 2), camera.z, opts);
      } else {
        this.setCamera(-(x3 - pw / 2), -(y3 - ph / 2), camera.z);
      }
      return this;
    }
    /**
     * Move the camera to the nearest content.
     *
     * @public
     */
    zoomToContent() {
      var _a5;
      const bounds = (_a5 = this.selectedPageBounds) != null ? _a5 : this.allShapesCommonBounds;
      if (bounds) {
        this.zoomToBounds(
          bounds.minX,
          bounds.minY,
          bounds.width,
          bounds.height,
          Math.min(1, this.zoomLevel),
          { duration: 220 }
        );
      }
      return this;
    }
    /**
     * Zoom the camera to fit the current page's content in the viewport.
     *
     * @example
     *
     * ```ts
     * app.zoomToFit()
     * ```
     *
     * @public
     */
    zoomToFit(opts) {
      if (!this.canMoveCamera)
        return this;
      const ids = [...this.shapeIds];
      if (ids.length <= 0)
        return this;
      const pageBounds = Box2d.Common(compact(ids.map((id) => this.getPageBoundsById(id))));
      this.zoomToBounds(
        pageBounds.minX,
        pageBounds.minY,
        pageBounds.width,
        pageBounds.height,
        void 0,
        opts
      );
      return this;
    }
    /**
     * Set the zoom back to 100%.
     *
     * @example
     *
     * ```ts
     * app.resetZoom()
     * ```
     *
     * @param opts - The options for an animation.
     * @public
     */
    resetZoom(point2 = this.viewportScreenCenter, opts) {
      if (!this.canMoveCamera)
        return this;
      const { x: cx, y: cy, z: cz } = this.camera;
      const { x: x3, y: y3 } = point2;
      if (opts == null ? void 0 : opts.duration) {
        this.animateCamera(cx + (x3 / 1 - x3) - (x3 / cz - x3), cy + (y3 / 1 - y3) - (y3 / cz - y3), 1, opts);
      } else {
        this.setCamera(cx + (x3 / 1 - x3) - (x3 / cz - x3), cy + (y3 / 1 - y3) - (y3 / cz - y3), 1);
      }
      return this;
    }
    /**
     * Zoom the camera in.
     *
     * @example
     *
     * ```ts
     * app.zoomIn()
     * app.zoomIn(app.viewportScreenCenter, { duration: 120 })
     * app.zoomIn(app.inputs.currentScreenPoint, { duration: 120 })
     * ```
     *
     * @param opts - The options for an animation.
     * @public
     */
    zoomIn(point2 = this.viewportScreenCenter, opts) {
      if (!this.canMoveCamera)
        return this;
      const { x: cx, y: cy, z: cz } = this.camera;
      let zoom = MAX_ZOOM;
      for (let i3 = 1; i3 < ZOOMS.length; i3++) {
        const z1 = ZOOMS[i3 - 1];
        const z2 = ZOOMS[i3];
        if (z2 - cz <= (z2 - z1) / 2)
          continue;
        zoom = z2;
        break;
      }
      const { x: x3, y: y3 } = point2;
      if (opts == null ? void 0 : opts.duration) {
        this.animateCamera(
          cx + (x3 / zoom - x3) - (x3 / cz - x3),
          cy + (y3 / zoom - y3) - (y3 / cz - y3),
          zoom,
          opts
        );
      } else {
        this.setCamera(cx + (x3 / zoom - x3) - (x3 / cz - x3), cy + (y3 / zoom - y3) - (y3 / cz - y3), zoom);
      }
      return this;
    }
    /**
     * Zoom the camera out.
     *
     * @example
     *
     * ```ts
     * app.zoomOut()
     * app.zoomOut(app.viewportScreenCenter, { duration: 120 })
     * app.zoomOut(app.inputs.currentScreenPoint, { duration: 120 })
     * ```
     *
     * @param opts - The options for an animation.
     * @public
     */
    zoomOut(point2 = this.viewportScreenCenter, opts) {
      if (!this.canMoveCamera)
        return this;
      const { x: cx, y: cy, z: cz } = this.camera;
      let zoom = MIN_ZOOM;
      for (let i3 = ZOOMS.length - 1; i3 > 0; i3--) {
        const z1 = ZOOMS[i3 - 1];
        const z2 = ZOOMS[i3];
        if (z2 - cz >= (z2 - z1) / 2)
          continue;
        zoom = z1;
        break;
      }
      const { x: x3, y: y3 } = point2;
      if (opts == null ? void 0 : opts.duration) {
        this.animateCamera(
          cx + (x3 / zoom - x3) - (x3 / cz - x3),
          cy + (y3 / zoom - y3) - (y3 / cz - y3),
          zoom,
          opts
        );
      } else {
        this.setCamera(cx + (x3 / zoom - x3) - (x3 / cz - x3), cy + (y3 / zoom - y3) - (y3 / cz - y3), zoom);
      }
      return this;
    }
    /**
     * Zoom the camera to fit the current selection in the viewport.
     *
     * @example
     *
     * ```ts
     * app.zoomToSelection()
     * ```
     *
     * @param opts - The options for an animation.
     * @public
     */
    zoomToSelection(opts) {
      if (!this.canMoveCamera)
        return this;
      const ids = this.selectedIds;
      if (ids.length <= 0)
        return this;
      const selectedBounds = Box2d.Common(compact(ids.map((id) => this.getPageBoundsById(id))));
      this.zoomToBounds(
        selectedBounds.minX,
        selectedBounds.minY,
        selectedBounds.width,
        selectedBounds.height,
        Math.max(1, this.camera.z),
        opts
      );
      return this;
    }
    /**
     * Pan or pan/zoom the selected ids into view. This method tries to not change the zoom if
     * possible.
     *
     * @param ids - The ids of the shapes to pan and zoom into view.
     * @param opts - The options for an animation.
     * @public
     */
    panZoomIntoView(ids, opts) {
      if (!this.canMoveCamera)
        return this;
      if (ids.length <= 0)
        return this;
      const selectedBounds = Box2d.Common(compact(ids.map((id) => this.getPageBoundsById(id))));
      const { viewportPageBounds } = this;
      if (viewportPageBounds.h < selectedBounds.h || viewportPageBounds.w < selectedBounds.w) {
        this.zoomToBounds(
          selectedBounds.minX,
          selectedBounds.minY,
          selectedBounds.width,
          selectedBounds.height,
          this.camera.z,
          opts
        );
        return this;
      } else {
        const bufferOffsets = this._activeAreaManager.offsets.value;
        const pageTop = viewportPageBounds.y + bufferOffsets.top;
        const pageRight = viewportPageBounds.maxY - bufferOffsets.right;
        const pageBottom = viewportPageBounds.maxY - bufferOffsets.bottom;
        const pageLeft = viewportPageBounds.x + bufferOffsets.left;
        const selectedTop = selectedBounds.y;
        const selectedRight = selectedBounds.maxX;
        const selectedBottom = selectedBounds.maxY;
        const selectedLeft = selectedBounds.x;
        let offsetX = 0;
        let offsetY = 0;
        if (pageBottom < selectedBottom) {
          offsetY = pageBottom - selectedBottom;
        } else if (pageTop > selectedTop) {
          offsetY = pageTop - selectedTop;
        } else {
        }
        if (pageRight < selectedRight) {
          offsetX = pageRight - selectedRight;
        } else if (pageLeft > selectedLeft) {
          offsetX = pageLeft - selectedLeft;
        } else {
        }
        const { camera } = this;
        if (opts == null ? void 0 : opts.duration) {
          this.animateCamera(camera.x + offsetX, camera.y + offsetY, camera.z, opts);
        } else {
          this.setCamera(camera.x + offsetX, camera.y + offsetY, camera.z);
        }
      }
      return this;
    }
    /**
     * Zoom the camera to fit a bounding box (in page space).
     *
     * @example
     *
     * ```ts
     * app.zoomToBounds(0, 0, 100, 100)
     * ```
     *
     * @param x - The bounding box's x position.
     * @param y - The bounding box's y position.
     * @param width - The bounding box's width.
     * @param height - The bounding box's height.
     * @param targetZoom - The desired zoom level. Defaults to 0.1.
     * @public
     */
    zoomToBounds(x3, y3, width, height, targetZoom, opts) {
      if (!this.canMoveCamera)
        return this;
      const { viewportScreenBounds } = this;
      const inset = Math.min(256, viewportScreenBounds.width * 0.28);
      let zoom = clamp(
        Math.min(
          (viewportScreenBounds.width - inset) / width,
          (viewportScreenBounds.height - inset) / height
        ),
        MIN_ZOOM,
        MAX_ZOOM
      );
      if (targetZoom !== void 0) {
        zoom = Math.min(targetZoom, zoom);
      }
      if (opts == null ? void 0 : opts.duration) {
        this.animateCamera(
          -x3 + (viewportScreenBounds.width - width * zoom) / 2 / zoom,
          -y3 + (viewportScreenBounds.height - height * zoom) / 2 / zoom,
          zoom,
          opts
        );
      } else {
        this.setCamera(
          -x3 + (viewportScreenBounds.width - width * zoom) / 2 / zoom,
          -y3 + (viewportScreenBounds.height - height * zoom) / 2 / zoom,
          zoom
        );
      }
      return this;
    }
    /**
     * Pan the camera.
     *
     * @example
     *
     * ```ts
     * app.pan(100, 100)
     * app.pan(100, 100, { duration: 1000 })
     * ```
     *
     * @param dx - The amount to pan on the x axis.
     * @param dy - The amount to pan on the y axis.
     * @param opts - The animation options
     */
    pan(dx, dy, opts) {
      var _a5;
      if (!this.canMoveCamera)
        return this;
      const { camera } = this;
      const { x: cx, y: cy, z: cz } = camera;
      const d3 = new Vec2d(dx, dy).div(cz);
      if ((_a5 = opts == null ? void 0 : opts.duration) != null ? _a5 : 0 > 0) {
        return this.animateCamera(cx + d3.x, cy + d3.y, cz, opts);
      } else {
        this.setCamera(cx + d3.x, cy + d3.y, cz);
      }
      return this;
    }
    /**
     * Stop the current camera animation, if any.
     *
     * @public
     */
    stopCameraAnimation() {
      this.emit("stop-camera-animation");
      return this;
    }
    /** @internal */
    _animateViewport(ms) {
      if (!this._viewportAnimation)
        return;
      const cancel = () => {
        this.removeListener("tick", this._animateViewport);
        this.removeListener("stop-camera-animation", cancel);
        this._viewportAnimation = null;
      };
      this.once("stop-camera-animation", cancel);
      this._viewportAnimation.elapsed += ms;
      const { elapsed, easing, duration, start, end } = this._viewportAnimation;
      if (elapsed > duration) {
        const z3 = this.viewportScreenBounds.width / end.width;
        const x4 = -end.x;
        const y4 = -end.y;
        this._setCamera(x4, y4, z3);
        cancel();
        return;
      }
      const remaining = duration - elapsed;
      const t4 = easing(1 - remaining / duration);
      const left = start.minX + (end.minX - start.minX) * t4;
      const top = start.minY + (end.minY - start.minY) * t4;
      const right = start.maxX + (end.maxX - start.maxX) * t4;
      const bottom = start.maxY + (end.maxY - start.maxY) * t4;
      const easedViewport = new Box2d(left, top, right - left, bottom - top);
      const z2 = this.viewportScreenBounds.width / easedViewport.width;
      const x3 = -easedViewport.x;
      const y3 = -easedViewport.y;
      this._setCamera(x3, y3, z2);
    }
    /** @internal */
    _animateToViewport(targetViewportPage, opts = {}) {
      const { duration = 0, easing = EASINGS.easeInOutCubic } = opts;
      const startViewport = this.viewportPageBounds.clone();
      this.stopCameraAnimation();
      if (this.instanceState.followingUserId) {
        this.stopFollowingUser();
      }
      this._viewportAnimation = {
        elapsed: 0,
        duration,
        easing,
        start: startViewport,
        end: targetViewportPage
      };
      this.addListener("tick", this._animateViewport);
      return this;
    }
    slideCamera(opts = {}) {
      if (!this.canMoveCamera)
        return this;
      const { speed, direction, friction, speedThreshold = 0.01 } = opts;
      let currentSpeed = speed;
      this.stopCameraAnimation();
      const cancel = () => {
        this.removeListener("tick", moveCamera);
        this.removeListener("stop-camera-animation", cancel);
      };
      this.once("stop-camera-animation", cancel);
      const moveCamera = (elapsed) => {
        const { x: cx, y: cy, z: cz } = this.camera;
        const movementVec = direction.clone().mul(currentSpeed * elapsed / cz);
        currentSpeed *= 1 - friction;
        if (currentSpeed < speedThreshold) {
          cancel();
        } else {
          this._setCamera(cx + movementVec.x, cy + movementVec.y, cz);
        }
      };
      this.addListener("tick", moveCamera);
      return this;
    }
    animateToShape(shapeId, opts = DEFAULT_ANIMATION_OPTIONS) {
      if (!this.canMoveCamera)
        return this;
      const activeArea = getActiveAreaScreenSpace(this);
      const viewportAspectRatio = activeArea.width / activeArea.height;
      const shapePageBounds = this.getPageBoundsById(shapeId);
      if (!shapePageBounds)
        return this;
      const shapeAspectRatio = shapePageBounds.width / shapePageBounds.height;
      const targetViewportPage = shapePageBounds.clone();
      const z2 = shapePageBounds.width / activeArea.width;
      targetViewportPage.width += (activeArea.left + activeArea.right) * z2;
      targetViewportPage.height += (activeArea.top + activeArea.bottom) * z2;
      targetViewportPage.x -= activeArea.left * z2;
      targetViewportPage.y -= activeArea.top * z2;
      if (shapeAspectRatio > viewportAspectRatio) {
        targetViewportPage.height = shapePageBounds.width / viewportAspectRatio;
        targetViewportPage.y -= (targetViewportPage.height - shapePageBounds.height) / 2;
      } else {
        targetViewportPage.width = shapePageBounds.height * viewportAspectRatio;
        targetViewportPage.x -= (targetViewportPage.width - shapePageBounds.width) / 2;
      }
      return this._animateToViewport(targetViewportPage, opts);
    }
    /**
     * Blur the app, cancelling any interaction state.
     *
     * @example
     *
     * ```ts
     * app.blur()
     * ```
     *
     * @public
     */
    blur() {
      this.complete();
      this.getContainer().blur();
      this._isFocused.set(false);
      return this;
    }
    /**
     * Focus the app.
     *
     * @example
     *
     * ```ts
     * app.focus()
     * ```
     *
     * @public
     */
    focus() {
      this.getContainer().focus();
      this._isFocused.set(true);
      return this;
    }
    /**
     * Dispatch a cancel event.
     *
     * @example
     *
     * ```ts
     * app.cancel()
     * ```
     *
     * @public
     */
    cancel() {
      this.dispatch({ type: "misc", name: "cancel" });
      return this;
    }
    /**
     * Dispatch an interrupt event.
     *
     * @example
     *
     * ```ts
     * app.interrupt()
     * ```
     *
     * @public
     */
    interrupt() {
      this.dispatch({ type: "misc", name: "interrupt" });
      return this;
    }
    /**
     * Dispatch a complete event.
     *
     * @example
     *
     * ```ts
     * app.complete()
     * ```
     *
     * @public
     */
    complete() {
      this.dispatch({ type: "misc", name: "complete" });
      return this;
    }
    /* -------------------- Callbacks ------------------- */
    /**
     * A callback fired when a file is converted to an asset. This callback should return the asset
     * partial.
     *
     * @example
     *
     * ```ts
     * app.onCreateAssetFromFile(myFile)
     * ```
     *
     * @param file - The file to upload.
     * @public
     */
    onCreateAssetFromFile(file) {
      return __async(this, null, function* () {
        return yield getMediaAssetFromFile(file);
      });
    }
    /**
     * A callback fired when a URL is converted to a bookmark. This callback should return the
     * metadata for the bookmark.
     *
     * @example
     *
     * ```ts
     * app.onCreateBookmarkFromUrl(url, id)
     * ```
     *
     * @param url - The url that was created.
     * @public
     */
    onCreateBookmarkFromUrl(url) {
      return __async(this, null, function* () {
        var _a5, _b2, _c, _d, _e, _f;
        try {
          const resp = yield fetch(url, { method: "GET", mode: "no-cors" });
          const html = yield resp.text();
          const doc = new DOMParser().parseFromString(html, "text/html");
          return {
            image: (_b2 = (_a5 = doc.head.querySelector('meta[property="og:image"]')) == null ? void 0 : _a5.getAttribute("content")) != null ? _b2 : "",
            title: (_d = (_c = doc.head.querySelector('meta[property="og:title"]')) == null ? void 0 : _c.getAttribute("content")) != null ? _d : "",
            description: (_f = (_e = doc.head.querySelector('meta[property="og:description"]')) == null ? void 0 : _e.getAttribute("content")) != null ? _f : ""
          };
        } catch (error) {
          console.error(error);
          return { image: "", title: "", description: "" };
        }
      });
    }
    /* --------------------- Groups --------------------- */
    groupShapes(ids = this.selectedIds, groupId = createShapeId()) {
      var _a5, _b2;
      if (this.isReadOnly)
        return this;
      if (ids.length <= 1)
        return this;
      const shapes = compact(ids.map((id) => this.getShapeById(id)));
      const sortedShapeIds = shapes.sort(sortByIndex2).map((s3) => s3.id);
      const pageBounds = Box2d.Common(compact(shapes.map((id) => this.getPageBounds(id))));
      const { x: x3, y: y3 } = pageBounds.point;
      const parentId = (_a5 = this.findCommonAncestor(shapes)) != null ? _a5 : this.currentPageId;
      if (this.currentToolId !== "select")
        return this;
      if (!this.isIn("select.idle")) {
        this.cancel();
      }
      const shapesWithRootParent = shapes.filter((shape) => shape.parentId === parentId).sort(sortByIndex2);
      const highestIndex = (_b2 = shapesWithRootParent[shapesWithRootParent.length - 1]) == null ? void 0 : _b2.index;
      this.batch(() => {
        this.createShapes([
          {
            id: groupId,
            type: "group",
            parentId,
            index: highestIndex,
            x: x3,
            y: y3,
            props: {
              opacity: "1"
            }
          }
        ]);
        this.reparentShapesById(sortedShapeIds, groupId);
        this.select(groupId);
      });
      return this;
    }
    ungroupShapes(ids = this.selectedIds) {
      if (this.isReadOnly)
        return this;
      if (ids.length === 0)
        return this;
      if (this.currentToolId !== "select")
        return this;
      if (!this.isIn("select.idle")) {
        this.cancel();
      }
      const idsToSelect = /* @__PURE__ */ new Set();
      const shapes = compact(ids.map((id) => this.getShapeById(id)));
      const groups = [];
      shapes.forEach((shape) => {
        if (TLGroupShapeDef.is(shape)) {
          groups.push(shape);
        } else {
          idsToSelect.add(shape.id);
        }
      });
      if (groups.length === 0)
        return this;
      this.batch(() => {
        let group;
        for (let i3 = 0, n3 = groups.length; i3 < n3; i3++) {
          group = groups[i3];
          const childIds = this.getSortedChildIds(group.id);
          for (let j = 0, n4 = childIds.length; j < n4; j++) {
            idsToSelect.add(childIds[j]);
          }
          this.reparentShapesById(childIds, group.parentId, group.index);
        }
        this.deleteShapes(groups.map((group2) => group2.id));
        this.select(...idsToSelect);
      });
      return this;
    }
  };
  var App = _App;
  /* --------------------- Shapes --------------------- */
  /**
   * The app's set of styles.
   *
   * @public
   */
  __publicField(App, "styles", STYLES);
  __decorateClass([
    computed
  ], App.prototype, "openMenus", 1);
  __decorateClass([
    computed
  ], App.prototype, "isMenuOpen", 1);
  __decorateClass([
    computed
  ], App.prototype, "_pageTransformCache", 1);
  __decorateClass([
    computed
  ], App.prototype, "_pageBoundsCache", 1);
  __decorateClass([
    computed
  ], App.prototype, "_pageMaskCache", 1);
  __decorateClass([
    computed
  ], App.prototype, "_clipPathCache", 1);
  __decorateClass([
    computed
  ], App.prototype, "canUndo", 1);
  __decorateClass([
    computed
  ], App.prototype, "canRedo", 1);
  __decorateClass([
    computed
  ], App.prototype, "erasingIds", 1);
  __decorateClass([
    computed
  ], App.prototype, "hintingIds", 1);
  __decorateClass([
    computed
  ], App.prototype, "erasingIdsSet", 1);
  __decorateClass([
    computed
  ], App.prototype, "props", 1);
  __decorateClass([
    computed
  ], App.prototype, "_arrowBindingsIndex", 1);
  __decorateClass([
    computed
  ], App.prototype, "_allPageStates", 1);
  __decorateClass([
    computed
  ], App.prototype, "documentSettings", 1);
  __decorateClass([
    computed
  ], App.prototype, "_userDocumentSettings", 1);
  __decorateClass([
    computed
  ], App.prototype, "_pageState", 1);
  __decorateClass([
    computed
  ], App.prototype, "camera", 1);
  __decorateClass([
    computed
  ], App.prototype, "zoomLevel", 1);
  __decorateClass([
    computed
  ], App.prototype, "selectedIds", 1);
  __decorateClass([
    computed
  ], App.prototype, "selectedIdsSet", 1);
  __decorateClass([
    computed
  ], App.prototype, "_pages", 1);
  __decorateClass([
    computed
  ], App.prototype, "pages", 1);
  __decorateClass([
    computed
  ], App.prototype, "_pageStates", 1);
  __decorateClass([
    computed
  ], App.prototype, "renderingShapes", 1);
  __decorateClass([
    computed
  ], App.prototype, "allShapesCommonBounds", 1);
  __decorateClass([
    computed
  ], App.prototype, "viewportScreenBounds", 1);
  __decorateClass([
    computed
  ], App.prototype, "viewportScreenCenter", 1);
  __decorateClass([
    computed
  ], App.prototype, "viewportPageBounds", 1);
  __decorateClass([
    computed
  ], App.prototype, "cullingBounds", 1);
  __decorateClass([
    computed
  ], App.prototype, "cullingBoundsExpanded", 1);
  __decorateClass([
    computed
  ], App.prototype, "viewportPageCenter", 1);
  __decorateClass([
    computed
  ], App.prototype, "editingShape", 1);
  __decorateClass([
    computed
  ], App.prototype, "selectedPageBounds", 1);
  __decorateClass([
    computed
  ], App.prototype, "selectionRotation", 1);
  __decorateClass([
    computed
  ], App.prototype, "selectionBounds", 1);
  __decorateClass([
    computed
  ], App.prototype, "selectionPageCenter", 1);
  __decorateClass([
    computed
  ], App.prototype, "shapesArray", 1);
  __decorateClass([
    computed
  ], App.prototype, "sortedShapesArray", 1);
  __decorateClass([
    computed
  ], App.prototype, "selectedShapes", 1);
  __decorateClass([
    computed
  ], App.prototype, "onlySelectedShape", 1);
  __decorateClass([
    computed
  ], App.prototype, "_currentUserPresence", 1);
  __decorateClass([
    computed
  ], App.prototype, "_assets", 1);
  __decorateClass([
    computed
  ], App.prototype, "hoveredId", 1);
  __decorateClass([
    computed
  ], App.prototype, "hoveredShape", 1);
  function alertMaxShapes(app, pageId = app.currentPageId) {
    const name = app.getPageById(pageId).name;
    app.emit("max-shapes", { name, pageId, count: MAX_SHAPES_PER_PAGE });
  }

  // ../../../packages/editor/src/lib/assetUrls.ts
  var defaultEditorAssetUrls = {
    fonts: {
      draw: "/fonts/Shantell_Sans-Normal-SemiBold.woff2",
      serif: "/fonts/IBMPlexSerif-Medium.woff2",
      sansSerif: "/fonts/IBMPlexSans-Medium.woff2",
      monospace: "/fonts/IBMPlexMono-Medium.woff2"
    }
  };

  // ../../../packages/editor/src/lib/hooks/useDarkMode.ts
  var import_react37 = __toESM(require_react());
  function useDarkMode() {
    const app = useApp();
    const container = useContainer();
    const isDarkMode = useValue("isDarkMode", () => app.userDocumentSettings.isDarkMode, [app]);
    import_react37.default.useEffect(() => {
      if (isDarkMode) {
        container.setAttribute("data-color-mode", "dark");
        container.classList.remove("tl-theme__light");
        container.classList.add("tl-theme__dark");
        app.setCursor({
          color: "white"
        });
      } else {
        container.setAttribute("data-color-mode", "light");
        container.classList.remove("tl-theme__dark");
        container.classList.add("tl-theme__light");
        app.setCursor({
          color: "black"
        });
      }
    }, [app, container, isDarkMode]);
  }

  // ../../../packages/editor/src/lib/hooks/useEvent.tsx
  var import_react38 = __toESM(require_react());
  function useEvent(handler) {
    const handlerRef = (0, import_react38.useRef)();
    (0, import_react38.useLayoutEffect)(() => {
      handlerRef.current = handler;
    });
    (0, import_react38.useDebugValue)(handler);
    return (0, import_react38.useCallback)((...args) => {
      const fn = handlerRef.current;
      assert(fn, "fn does not exist");
      return fn(...args);
    }, []);
  }

  // ../../../packages/editor/src/lib/hooks/useForceUpdate.ts
  var import_react39 = __toESM(require_react());
  function useForceUpdate() {
    const [_, ss] = (0, import_react39.useState)(0);
    (0, import_react39.useEffect)(() => ss((s3) => s3 + 1), []);
  }

  // ../../../packages/editor/src/lib/hooks/usePreloadAssets.ts
  var import_react40 = __toESM(require_react());
  var usePreloadFont = (id, font) => {
    const [state, setState] = (0, import_react40.useState)(2 /* WAITING */);
    (0, import_react40.useEffect)(() => {
      const {
        url,
        style = "normal",
        weight = "500",
        display,
        featureSettings,
        stretch,
        unicodeRange,
        variant
      } = font;
      let cancelled = false;
      setState(2 /* WAITING */);
      const descriptors = {
        style,
        weight,
        display,
        featureSettings,
        stretch,
        unicodeRange,
        variant
      };
      const fontInstance = new FontFace(id, `url(${url})`, descriptors);
      fontInstance.load().then(() => {
        if (cancelled)
          return;
        document.fonts.add(fontInstance);
        setState(0 /* SUCCESS */);
      }).catch((err) => {
        if (cancelled)
          return;
        console.error(err);
        setState(1 /* FAILED */);
      });
      fontInstance.$$_url = url;
      fontInstance.$$_fontface = `
@font-face {
	font-family: ${fontInstance.family};
	font-stretch: ${fontInstance.stretch};
	font-weight: ${fontInstance.weight};
	font-style: ${fontInstance.style};
	src: url("${url}") format("woff2")
}`;
      return () => {
        document.fonts.delete(fontInstance);
        cancelled = true;
      };
    }, [id, font]);
    return state;
  };
  function getTypefaces(assetUrls) {
    return {
      draw: { url: assetUrls.fonts.draw },
      serif: { url: assetUrls.fonts.serif },
      sansSerif: { url: assetUrls.fonts.sansSerif },
      monospace: { url: assetUrls.fonts.monospace }
    };
  }
  function usePreloadAssets(assetUrls) {
    const typefaces = (0, import_react40.useMemo)(() => getTypefaces(assetUrls), [assetUrls]);
    const results = [
      usePreloadFont("tldraw_draw", typefaces.draw),
      usePreloadFont("tldraw_serif", typefaces.serif),
      usePreloadFont("tldraw_sans", typefaces.sansSerif),
      usePreloadFont("tldraw_mono", typefaces.monospace)
    ];
    return {
      // If any of the results have errored, then preloading has failed
      error: results.some((result) => result === 1 /* FAILED */),
      // If any of the results are waiting, then we're not done yet
      done: !results.some((result) => result === 2 /* WAITING */)
    };
  }

  // ../../../packages/editor/src/lib/hooks/useSafariFocusOutFix.ts
  var React32 = __toESM(require_react());
  var isMobileSafari = false;
  if (typeof window !== "undefined") {
    const ua = window.navigator.userAgent;
    const iOS2 = !!ua.match(/iPad/i) || !!ua.match(/iPhone/i);
    const webkit = !!ua.match(/WebKit/i);
    isMobileSafari = iOS2 && webkit && !ua.match(/CriOS/i);
  }
  function useSafariFocusOutFix() {
    const app = useApp();
    React32.useEffect(() => {
      if (!isMobileSafari)
        return;
      function handleFocusOut(e2) {
        if (e2.target instanceof HTMLInputElement && e2.target.type === "text" || e2.target instanceof HTMLTextAreaElement) {
          app.complete();
        }
      }
      document.addEventListener("focusout", handleFocusOut);
      return () => document.removeEventListener("focusout", handleFocusOut);
    }, [app]);
  }

  // ../../../packages/editor/src/lib/hooks/useZoomCss.ts
  var React33 = __toESM(require_react());
  function useZoomCss() {
    const app = useApp();
    const container = useContainer();
    React33.useEffect(() => {
      const setScale = (s3) => container.style.setProperty("--tl-zoom", s3.toString());
      const setScaleDebounced = debounce(setScale, 100);
      const scheduler = new EffectScheduler("useZoomCss", () => {
        const numShapes = app.shapeIds.size;
        if (numShapes < 300) {
          setScale(app.zoomLevel);
        } else {
          setScaleDebounced(app.zoomLevel);
        }
      });
      scheduler.attach();
      scheduler.execute();
      return () => {
        scheduler.detach();
      };
    }, [app, container]);
  }

  // ../../../packages/editor/src/lib/TldrawEditor.tsx
  var import_jsx_runtime54 = __toESM(require_jsx_runtime());
  function TldrawEditor(props) {
    const [container, setContainer] = import_react41.default.useState(null);
    const _a5 = props, { components } = _a5, rest = __objRest(_a5, ["components"]);
    const ErrorFallback = (components == null ? void 0 : components.ErrorFallback) === void 0 ? DefaultErrorFallback : components == null ? void 0 : components.ErrorFallback;
    return /* @__PURE__ */ (0, import_jsx_runtime54.jsx)("div", { ref: setContainer, draggable: false, className: "tl-container tl-theme__light", tabIndex: 0, children: /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
      OptionalErrorBoundary,
      {
        fallback: ErrorFallback ? (error) => /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(ErrorFallback, { error }) : null,
        onError: (error) => annotateError(error, { tags: { origin: "react.tldraw-before-app" } }),
        children: container && /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(ContainerProvider, { container, children: /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(EditorComponentsProvider, { overrides: components, children: /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(TldrawEditorBeforeLoading, __spreadValues({}, rest)) }) })
      }
    ) });
  }
  function TldrawEditorBeforeLoading(_a5) {
    var _b2 = _a5, {
      config = TldrawEditorConfig.default,
      userId,
      instanceId,
      store
    } = _b2, props = __objRest(_b2, [
      "config",
      "userId",
      "instanceId",
      "store"
    ]);
    var _a6;
    const { done: preloadingComplete, error: preloadingError } = usePreloadAssets(
      (_a6 = props.assetUrls) != null ? _a6 : defaultEditorAssetUrls
    );
    store != null ? store : store = config.createStore({
      userId: userId != null ? userId : TLUser.createId(),
      instanceId: instanceId != null ? instanceId : TLInstance.createId()
    });
    let loadedStore;
    if (!(store instanceof Store)) {
      if (store.error) {
        throw store.error;
      }
      if (!store.store) {
        return /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(LoadingScreen, { children: "Connecting..." });
      }
      loadedStore = store.store;
    } else {
      loadedStore = store;
    }
    if (instanceId && loadedStore.props.instanceId !== instanceId) {
      console.error(
        `The store's instanceId (${loadedStore.props.instanceId}) does not match the instanceId prop (${instanceId}). This may cause unexpected behavior.`
      );
    }
    if (userId && loadedStore.props.userId !== userId) {
      console.error(
        `The store's userId (${loadedStore.props.userId}) does not match the userId prop (${userId}). This may cause unexpected behavior.`
      );
    }
    if (preloadingError) {
      return /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(ErrorScreen, { children: "Could not load assets. Please refresh the page." });
    }
    if (!preloadingComplete) {
      return /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(LoadingScreen, { children: "Loading assets..." });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(TldrawEditorAfterLoading, __spreadProps(__spreadValues({}, props), { store: loadedStore, config }));
  }
  function TldrawEditorAfterLoading({
    onMount,
    config,
    isDarkMode,
    children,
    onCreateAssetFromFile,
    onCreateBookmarkFromUrl: onCreateBookmarkFromUrl2,
    store,
    autoFocus
  }) {
    const container = useContainer();
    const [app, setApp] = import_react41.default.useState(null);
    const { ErrorFallback } = useEditorComponents();
    import_react41.default.useLayoutEffect(() => {
      const app2 = new App({
        store,
        getContainer: () => container,
        config
      });
      setApp(app2);
      if (autoFocus) {
        app2.focus();
      }
      ;
      window.app = app2;
      return () => {
        app2.dispose();
        setApp((prevApp) => prevApp === app2 ? null : prevApp);
      };
    }, [container, config, store, autoFocus]);
    import_react41.default.useEffect(() => {
      if (app) {
        if (onCreateAssetFromFile) {
          app.onCreateAssetFromFile = onCreateAssetFromFile;
        }
        if (onCreateBookmarkFromUrl2) {
          app.onCreateBookmarkFromUrl = onCreateBookmarkFromUrl2;
        }
      }
    }, [app, onCreateAssetFromFile, onCreateBookmarkFromUrl2]);
    const onMountEvent = useEvent((app2) => {
      onMount == null ? void 0 : onMount(app2);
      app2.emit("mount");
    });
    import_react41.default.useEffect(() => {
      if (app) {
        if (isDarkMode !== void 0) {
          app.updateUserDocumentSettings({ isDarkMode });
        }
        window.tldrawReady = true;
        onMountEvent(app);
      }
    }, [app, onMountEvent, isDarkMode]);
    const crashingError = (0, import_react41.useSyncExternalStore)(
      (0, import_react41.useCallback)(
        (onStoreChange) => {
          if (app) {
            app.on("crash", onStoreChange);
            return () => app.off("crash", onStoreChange);
          }
          return () => {
          };
        },
        [app]
      ),
      () => {
        var _a5;
        return (_a5 = app == null ? void 0 : app.crashingError) != null ? _a5 : null;
      }
    );
    if (!app) {
      return null;
    }
    return (
      // the top-level tldraw component also renders an error boundary almost
      // identical to this one. the reason we have two is because this one has
      // access to `App`, which means that here we can enrich errors with data
      // from app for reporting, and also still attempt to render the user's
      // document in the event of an error to reassure them that their work is
      // not lost.
      /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(
        OptionalErrorBoundary,
        {
          fallback: ErrorFallback ? (error) => /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(ErrorFallback, { error, app }) : null,
          onError: (error) => app.annotateError(error, { origin: "react.tldraw", willCrashApp: true }),
          children: crashingError ? /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(Crash, { crashingError }) : /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(AppContext.Provider, { value: app, children: /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(Layout, { children }) })
        }
      )
    );
  }
  function Layout({ children }) {
    useZoomCss();
    useCursor();
    useDarkMode();
    useSafariFocusOutFix();
    useForceUpdate();
    return children;
  }
  function Crash({ crashingError }) {
    throw crashingError;
  }
  function LoadingScreen({ children }) {
    const { Spinner: Spinner2 } = useEditorComponents();
    return /* @__PURE__ */ (0, import_jsx_runtime54.jsxs)("div", { className: "tl-loading", children: [
      Spinner2 ? /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(Spinner2, {}) : null,
      children
    ] });
  }
  function ErrorScreen({ children }) {
    return /* @__PURE__ */ (0, import_jsx_runtime54.jsx)("div", { className: "tl-loading", children });
  }

  // ../../../packages/editor/src/lib/hooks/useReactor.ts
  var import_react42 = __toESM(require_react());

  // ../../../packages/editor/src/lib/utils/buildFromV1Document.ts
  var TLDRAW_V1_VERSION = 15.5;
  function buildFromV1Document(app, document2) {
    transact(() => {
      var _a5, _b2, _c;
      document2 = migrate2(document2, TLDRAW_V1_VERSION);
      app.cancel().cancel().cancel().cancel();
      const firstPageId = app.pages[0].id;
      app.setCurrentPageId(firstPageId);
      for (const page of app.pages.slice(1)) {
        app.deletePage(page.id);
      }
      app.selectAll();
      app.deleteShapes();
      const v1AssetIdsToV2AssetIds = /* @__PURE__ */ new Map();
      Object.values((_a5 = document2.assets) != null ? _a5 : {}).forEach((v1Asset) => {
        var _a6, _b3;
        switch (v1Asset.type) {
          case TDAssetType.Image: {
            const assetId = TLAsset.createId();
            v1AssetIdsToV2AssetIds.set(v1Asset.id, assetId);
            const placeholderAsset = {
              id: assetId,
              typeName: "asset",
              type: "image",
              props: {
                w: coerceDimension(v1Asset.size[0]),
                h: coerceDimension(v1Asset.size[1]),
                name: (_a6 = v1Asset.fileName) != null ? _a6 : "Untitled",
                isAnimated: false,
                mimeType: null,
                src: v1Asset.src
              }
            };
            app.createAssets([placeholderAsset]);
            tryMigrateAsset(app, placeholderAsset);
            break;
          }
          case TDAssetType.Video:
            {
              const assetId = TLAsset.createId();
              v1AssetIdsToV2AssetIds.set(v1Asset.id, assetId);
              app.createAssets([
                {
                  id: assetId,
                  typeName: "asset",
                  type: "video",
                  props: {
                    w: coerceDimension(v1Asset.size[0]),
                    h: coerceDimension(v1Asset.size[1]),
                    name: (_b3 = v1Asset.fileName) != null ? _b3 : "Untitled",
                    isAnimated: true,
                    mimeType: null,
                    src: v1Asset.src
                  }
                }
              ]);
            }
            break;
        }
      });
      const v1PageIdsToV2PageIds = /* @__PURE__ */ new Map();
      Object.values((_b2 = document2.pages) != null ? _b2 : {}).sort((a3, b3) => {
        var _a6, _b3;
        return ((_a6 = a3.childIndex) != null ? _a6 : 1) < ((_b3 = b3.childIndex) != null ? _b3 : 1) ? -1 : 1;
      }).forEach((v1Page, i3) => {
        var _a6;
        if (i3 === 0) {
          v1PageIdsToV2PageIds.set(v1Page.id, app.currentPageId);
        } else {
          const pageId = TLPage.createId();
          v1PageIdsToV2PageIds.set(v1Page.id, pageId);
          app.createPage((_a6 = v1Page.name) != null ? _a6 : "Page", pageId);
        }
      });
      Object.values((_c = document2.pages) != null ? _c : {}).sort((a3, b3) => {
        var _a6, _b3;
        return ((_a6 = a3.childIndex) != null ? _a6 : 1) < ((_b3 = b3.childIndex) != null ? _b3 : 1) ? -1 : 1;
      }).forEach((v1Page) => {
        var _a6;
        app.setCurrentPageId(v1PageIdsToV2PageIds.get(v1Page.id));
        const v1ShapeIdsToV2ShapeIds = /* @__PURE__ */ new Map();
        const v1GroupShapeIdsToV1ChildIds = /* @__PURE__ */ new Map();
        const v1Shapes = Object.values((_a6 = v1Page.shapes) != null ? _a6 : {}).sort((a3, b3) => a3.childIndex < b3.childIndex ? -1 : 1).slice(0, MAX_SHAPES_PER_PAGE);
        v1Shapes.forEach((v1Shape) => {
          if (v1Shape.type !== TDShapeType.Group)
            return;
          const shapeId = app.createShapeId();
          v1ShapeIdsToV2ShapeIds.set(v1Shape.id, shapeId);
          v1GroupShapeIdsToV1ChildIds.set(v1Shape.id, []);
        });
        function decideNotToCreateShape(v1Shape) {
          v1ShapeIdsToV2ShapeIds.delete(v1Shape.id);
          const v1GroupParent = v1GroupShapeIdsToV1ChildIds.has(v1Shape.parentId);
          if (v1GroupParent) {
            const ids = v1GroupShapeIdsToV1ChildIds.get(v1Shape.parentId).filter((id) => id !== v1Shape.id);
            v1GroupShapeIdsToV1ChildIds.set(v1Shape.parentId, ids);
          }
        }
        v1Shapes.forEach((v1Shape) => {
          var _a7, _b3, _c2, _d, _e, _f, _g, _h, _i, _j;
          if (v1Shape.type === TDShapeType.Group) {
            return;
          }
          const shapeId = app.createShapeId();
          v1ShapeIdsToV2ShapeIds.set(v1Shape.id, shapeId);
          if (v1Shape.parentId !== v1Page.id) {
            if (v1GroupShapeIdsToV1ChildIds.has(v1Shape.parentId)) {
              v1GroupShapeIdsToV1ChildIds.get(v1Shape.parentId).push(v1Shape.id);
            } else {
              console.warn("parent does not exist", v1Shape);
            }
          }
          const parentId = v1PageIdsToV2PageIds.get(v1Page.id);
          const inCommon = {
            id: shapeId,
            parentId,
            x: coerceNumber(v1Shape.point[0]),
            y: coerceNumber(v1Shape.point[1]),
            rotation: 0,
            isLocked: !!v1Shape.isLocked
          };
          switch (v1Shape.type) {
            case TDShapeType.Sticky: {
              const partial = __spreadProps(__spreadValues({}, inCommon), {
                type: "note",
                props: {
                  text: (_a7 = v1Shape.text) != null ? _a7 : "",
                  color: getV2Color(v1Shape.style.color),
                  size: getV2Size(v1Shape.style.size),
                  font: getV2Font(v1Shape.style.font),
                  align: getV2Align(v1Shape.style.textAlign)
                }
              });
              app.createShapes([partial]);
              break;
            }
            case TDShapeType.Rectangle: {
              const partial = __spreadProps(__spreadValues({}, inCommon), {
                type: "geo",
                props: {
                  geo: "rectangle",
                  w: coerceDimension(v1Shape.size[0]),
                  h: coerceDimension(v1Shape.size[1]),
                  text: (_b3 = v1Shape.label) != null ? _b3 : "",
                  fill: getV2Fill(v1Shape.style.isFilled, v1Shape.style.color),
                  labelColor: getV2Color(v1Shape.style.color),
                  color: getV2Color(v1Shape.style.color),
                  size: getV2Size(v1Shape.style.size),
                  font: getV2Font(v1Shape.style.font),
                  dash: getV2Dash(v1Shape.style.dash),
                  align: "middle"
                }
              });
              app.createShapes([partial]);
              const pageBoundsBeforeLabel = app.getPageBoundsById(inCommon.id);
              app.updateShapes([
                {
                  id: inCommon.id,
                  type: "geo",
                  props: {
                    text: (_c2 = v1Shape.label) != null ? _c2 : ""
                  }
                }
              ]);
              if (pageBoundsBeforeLabel.width === pageBoundsBeforeLabel.height) {
                const shape = app.getShapeById(inCommon.id);
                const { growY } = shape.props;
                const w3 = coerceDimension(shape.props.w);
                const h3 = coerceDimension(shape.props.h);
                const newW = w3 + growY / 2;
                const newH = h3 + growY / 2;
                app.updateShapes([
                  {
                    id: inCommon.id,
                    type: "geo",
                    x: coerceNumber(shape.x) - (newW - w3) / 2,
                    y: coerceNumber(shape.y) - (newH - h3) / 2,
                    props: {
                      w: newW,
                      h: newH
                    }
                  }
                ]);
              }
              break;
            }
            case TDShapeType.Triangle: {
              const partial = __spreadProps(__spreadValues({}, inCommon), {
                type: "geo",
                props: {
                  geo: "triangle",
                  w: coerceDimension(v1Shape.size[0]),
                  h: coerceDimension(v1Shape.size[1]),
                  fill: getV2Fill(v1Shape.style.isFilled, v1Shape.style.color),
                  labelColor: getV2Color(v1Shape.style.color),
                  color: getV2Color(v1Shape.style.color),
                  size: getV2Size(v1Shape.style.size),
                  font: getV2Font(v1Shape.style.font),
                  dash: getV2Dash(v1Shape.style.dash),
                  align: "middle"
                }
              });
              app.createShapes([partial]);
              const pageBoundsBeforeLabel = app.getPageBoundsById(inCommon.id);
              app.updateShapes([
                {
                  id: inCommon.id,
                  type: "geo",
                  props: {
                    text: (_d = v1Shape.label) != null ? _d : ""
                  }
                }
              ]);
              if (pageBoundsBeforeLabel.width === pageBoundsBeforeLabel.height) {
                const shape = app.getShapeById(inCommon.id);
                const { growY } = shape.props;
                const w3 = coerceDimension(shape.props.w);
                const h3 = coerceDimension(shape.props.h);
                const newW = w3 + growY / 2;
                const newH = h3 + growY / 2;
                app.updateShapes([
                  {
                    id: inCommon.id,
                    type: "geo",
                    x: coerceNumber(shape.x) - (newW - w3) / 2,
                    y: coerceNumber(shape.y) - (newH - h3) / 2,
                    props: {
                      w: newW,
                      h: newH
                    }
                  }
                ]);
              }
              break;
            }
            case TDShapeType.Ellipse: {
              const partial = __spreadProps(__spreadValues({}, inCommon), {
                type: "geo",
                props: {
                  geo: "ellipse",
                  w: coerceDimension(v1Shape.radius[0]) * 2,
                  h: coerceDimension(v1Shape.radius[1]) * 2,
                  fill: getV2Fill(v1Shape.style.isFilled, v1Shape.style.color),
                  labelColor: getV2Color(v1Shape.style.color),
                  color: getV2Color(v1Shape.style.color),
                  size: getV2Size(v1Shape.style.size),
                  font: getV2Font(v1Shape.style.font),
                  dash: getV2Dash(v1Shape.style.dash),
                  align: "middle"
                }
              });
              app.createShapes([partial]);
              const pageBoundsBeforeLabel = app.getPageBoundsById(inCommon.id);
              app.updateShapes([
                {
                  id: inCommon.id,
                  type: "geo",
                  props: {
                    text: (_e = v1Shape.label) != null ? _e : ""
                  }
                }
              ]);
              if (pageBoundsBeforeLabel.width === pageBoundsBeforeLabel.height) {
                const shape = app.getShapeById(inCommon.id);
                const { growY } = shape.props;
                const w3 = coerceDimension(shape.props.w);
                const h3 = coerceDimension(shape.props.h);
                const newW = w3 + growY / 2;
                const newH = h3 + growY / 2;
                app.updateShapes([
                  {
                    id: inCommon.id,
                    type: "geo",
                    x: coerceNumber(shape.x) - (newW - w3) / 2,
                    y: coerceNumber(shape.y) - (newH - h3) / 2,
                    props: {
                      w: newW,
                      h: newH
                    }
                  }
                ]);
              }
              break;
            }
            case TDShapeType.Draw: {
              if (v1Shape.points.length === 0) {
                decideNotToCreateShape(v1Shape);
                break;
              }
              const partial = __spreadProps(__spreadValues({}, inCommon), {
                type: "draw",
                props: {
                  fill: getV2Fill(v1Shape.style.isFilled, v1Shape.style.color),
                  color: getV2Color(v1Shape.style.color),
                  size: getV2Size(v1Shape.style.size),
                  dash: getV2Dash(v1Shape.style.dash),
                  isPen: false,
                  isComplete: v1Shape.isComplete,
                  segments: [{ type: "free", points: v1Shape.points.map(getV2Point) }]
                }
              });
              app.createShapes([partial]);
              break;
            }
            case TDShapeType.Arrow: {
              const v1Bend = coerceNumber(v1Shape.bend);
              const v1Start = getV2Point(v1Shape.handles.start.point);
              const v1End = getV2Point(v1Shape.handles.end.point);
              const dist = Vec2d.Dist(v1Start, v1End);
              const v2Bend = dist * -v1Bend / 2;
              const partial = __spreadProps(__spreadValues({}, inCommon), {
                type: "arrow",
                props: {
                  text: (_f = v1Shape.label) != null ? _f : "",
                  color: getV2Color(v1Shape.style.color),
                  labelColor: getV2Color(v1Shape.style.color),
                  size: getV2Size(v1Shape.style.size),
                  font: getV2Font(v1Shape.style.font),
                  dash: getV2Dash(v1Shape.style.dash),
                  arrowheadStart: getV2Arrowhead((_g = v1Shape.decorations) == null ? void 0 : _g.start),
                  arrowheadEnd: getV2Arrowhead((_h = v1Shape.decorations) == null ? void 0 : _h.end),
                  start: {
                    type: "point",
                    x: coerceNumber(v1Shape.handles.start.point[0]),
                    y: coerceNumber(v1Shape.handles.start.point[1])
                  },
                  end: {
                    type: "point",
                    x: coerceNumber(v1Shape.handles.end.point[0]),
                    y: coerceNumber(v1Shape.handles.end.point[1])
                  },
                  bend: v2Bend
                }
              });
              app.createShapes([partial]);
              break;
            }
            case TDShapeType.Text: {
              const partial = __spreadProps(__spreadValues({}, inCommon), {
                type: "text",
                props: {
                  text: (_i = v1Shape.text) != null ? _i : " ",
                  color: getV2Color(v1Shape.style.color),
                  size: getV2TextSize(v1Shape.style.size),
                  font: getV2Font(v1Shape.style.font),
                  align: getV2Align(v1Shape.style.textAlign),
                  scale: (_j = v1Shape.style.scale) != null ? _j : 1
                }
              });
              app.createShapes([partial]);
              break;
            }
            case TDShapeType.Image: {
              const assetId = v1AssetIdsToV2AssetIds.get(v1Shape.assetId);
              if (!assetId) {
                console.warn("Could not find asset id", v1Shape.assetId);
                return;
              }
              const partial = __spreadProps(__spreadValues({}, inCommon), {
                type: "image",
                props: {
                  w: coerceDimension(v1Shape.size[0]),
                  h: coerceDimension(v1Shape.size[1]),
                  assetId
                }
              });
              app.createShapes([partial]);
              break;
            }
            case TDShapeType.Video: {
              const assetId = v1AssetIdsToV2AssetIds.get(v1Shape.assetId);
              if (!assetId) {
                console.warn("Could not find asset id", v1Shape.assetId);
                return;
              }
              const partial = __spreadProps(__spreadValues({}, inCommon), {
                type: "video",
                props: {
                  w: coerceDimension(v1Shape.size[0]),
                  h: coerceDimension(v1Shape.size[1]),
                  assetId
                }
              });
              app.createShapes([partial]);
              break;
            }
          }
          const rotation = coerceNumber(v1Shape.rotation);
          if (rotation !== 0) {
            app.select(shapeId);
            app.rotateShapesBy([shapeId], rotation);
          }
        });
        v1GroupShapeIdsToV1ChildIds.forEach((v1ChildIds, v1GroupId) => {
          const v2ChildShapeIds = v1ChildIds.map((id) => v1ShapeIdsToV2ShapeIds.get(id));
          const v2GroupId = v1ShapeIdsToV2ShapeIds.get(v1GroupId);
          app.groupShapes(v2ChildShapeIds, v2GroupId);
          const v1Group = v1Page.shapes[v1GroupId];
          const rotation = coerceNumber(v1Group.rotation);
          if (rotation !== 0) {
            app.select(v2GroupId);
            app.rotateShapesBy([v2GroupId], rotation);
          }
        });
        v1Shapes.forEach((v1Shape) => {
          var _a7, _b3;
          if (v1Shape.type !== TDShapeType.Arrow) {
            return;
          }
          const v2ShapeId = v1ShapeIdsToV2ShapeIds.get(v1Shape.id);
          const v2ShapeStale = app.getShapeById(v2ShapeId);
          const util = app.getShapeUtil(v2ShapeStale);
          app.inputs.ctrlKey = false;
          for (const handleId of ["start", "end"]) {
            const bindingId = v1Shape.handles[handleId].bindingId;
            if (bindingId) {
              const binding = v1Page.bindings[bindingId];
              if (!binding) {
                continue;
              }
              const targetId = v1ShapeIdsToV2ShapeIds.get(binding.toId);
              const targetShape = app.getShapeById(targetId);
              if (!targetShape)
                continue;
              if (targetId) {
                const bounds2 = app.getPageBoundsById(targetId);
                const v2ShapeFresh = app.getShapeById(v2ShapeId);
                const nx = clamp((coerceNumber(binding.point[0]) + 0.5) / 2, 0.2, 0.8);
                const ny = clamp((coerceNumber(binding.point[1]) + 0.5) / 2, 0.2, 0.8);
                const point2 = app.getPointInShapeSpace(v2ShapeFresh, {
                  x: bounds2.minX + bounds2.width * nx,
                  y: bounds2.minY + bounds2.height * ny
                });
                const handles = util.handles(v2ShapeFresh);
                const change = util.onHandleChange(v2ShapeFresh, {
                  handle: __spreadProps(__spreadValues({}, handles.find((h3) => h3.id === handleId)), {
                    x: point2.x,
                    y: point2.y
                  }),
                  isPrecise: point2.x !== 0.5 || point2.y !== 0.5
                });
                if (change) {
                  if ((_a7 = change.props) == null ? void 0 : _a7[handleId]) {
                    const terminal = (_b3 = change.props) == null ? void 0 : _b3[handleId];
                    if (terminal.type === "binding") {
                      terminal.isExact = binding.distance === 0;
                      if (terminal.boundShapeId !== targetId) {
                        console.warn("Hit the wrong shape!");
                        terminal.boundShapeId = targetId;
                        terminal.normalizedAnchor = { x: 0.5, y: 0.5 };
                      }
                    }
                  }
                  app.updateShapes([change]);
                }
              }
            }
          }
        });
      });
      app.setCurrentPageId(firstPageId);
      app.history.clear();
      app.selectNone();
      app.updateViewportScreenBounds();
      const bounds = app.allShapesCommonBounds;
      if (bounds) {
        app.zoomToBounds(bounds.minX, bounds.minY, bounds.width, bounds.height, 1);
      }
    });
  }
  function coerceNumber(n3) {
    if (typeof n3 !== "number")
      return 0;
    if (Number.isNaN(n3))
      return 0;
    if (!Number.isFinite(n3))
      return 0;
    return n3;
  }
  function coerceDimension(d3) {
    const n3 = coerceNumber(d3);
    if (n3 <= 0)
      return 1;
    return n3;
  }
  function tryMigrateAsset(app, placeholderAsset) {
    return __async(this, null, function* () {
      var _a5, _b2;
      try {
        if (placeholderAsset.type === "bookmark" || !placeholderAsset.props.src)
          return;
        const response = yield fetch(placeholderAsset.props.src);
        if (!response.ok)
          return;
        const file = new File([yield response.blob()], placeholderAsset.props.name, {
          type: (_b2 = (_a5 = response.headers.get("content-type")) != null ? _a5 : placeholderAsset.props.mimeType) != null ? _b2 : void 0
        });
        const newAsset = yield app.onCreateAssetFromFile(file);
        if (newAsset.type === "bookmark")
          return;
        app.updateAssets([
          {
            id: placeholderAsset.id,
            type: placeholderAsset.type,
            props: __spreadProps(__spreadValues({}, newAsset.props), {
              name: placeholderAsset.props.name
            })
          }
        ]);
      } catch (err) {
      }
    });
  }
  function migrate2(document2, newVersion) {
    const { version = 0 } = document2;
    if (!document2.assets) {
      document2.assets = {};
    }
    const assetIdsInUse = /* @__PURE__ */ new Set();
    Object.values(document2.pages).forEach(
      (page) => Object.values(page.shapes).forEach((shape) => {
        const { parentId, children, assetId } = shape;
        if (assetId) {
          assetIdsInUse.add(assetId);
        }
        if (parentId !== page.id && !page.shapes[parentId]) {
          console.warn("Encountered a shape with a missing parent!");
          shape.parentId = page.id;
        }
        if (shape.type === TDShapeType.Group && children) {
          children.forEach((childId) => {
            if (!page.shapes[childId]) {
              console.warn("Encountered a parent with a missing child!", shape.id, childId);
              children == null ? void 0 : children.splice(children.indexOf(childId), 1);
            }
          });
        }
      })
    );
    Object.keys(document2.assets).forEach((assetId) => {
      if (!assetIdsInUse.has(assetId)) {
        delete document2.assets[assetId];
      }
    });
    if (version !== newVersion) {
      if (version < 14) {
        Object.values(document2.pages).forEach((page) => {
          Object.values(page.shapes).filter((shape) => shape.type === TDShapeType.Text).forEach((shape) => {
            if (shape.style.font === void 0) {
              ;
              shape.style.font === FontStyle.Script;
            }
          });
        });
      }
      if (version <= 13) {
        Object.values(document2.pages).forEach((page) => {
          Object.values(page.bindings).forEach((binding) => {
            Object.assign(binding, binding.meta);
          });
          Object.values(page.shapes).forEach((shape) => {
            Object.entries(shape.style).forEach(([id, style]) => {
              if (typeof style === "string") {
                shape.style[id] = style.toLowerCase();
              }
            });
            if (shape.type === TDShapeType.Arrow) {
              if (shape.decorations) {
                Object.entries(shape.decorations).forEach(([id, decoration]) => {
                  if (decoration === "Arrow") {
                    shape.decorations = __spreadProps(__spreadValues({}, shape.decorations), {
                      [id]: Decoration.Arrow
                    });
                  }
                });
              }
            }
          });
        });
      }
      if (version <= 13.1 && document2.name == null) {
        document2.name = "New Document";
      }
      if (version < 15 && document2.assets == null) {
        document2.assets = {};
      }
      Object.values(document2.pages).forEach((page) => {
        Object.values(page.shapes).forEach((shape) => {
          if (version < 15.2) {
            if ((shape.type === TDShapeType.Image || shape.type === TDShapeType.Video) && shape.style.isFilled == null) {
              shape.style.isFilled = true;
            }
          }
          if (version < 15.3) {
            if (shape.type === TDShapeType.Rectangle || shape.type === TDShapeType.Triangle || shape.type === TDShapeType.Ellipse || shape.type === TDShapeType.Arrow) {
              if ("text" in shape && typeof shape.text === "string") {
                shape.label = shape.text;
              }
              if (!shape.label) {
                shape.label = "";
              }
              if (!shape.labelPoint) {
                shape.labelPoint = [0.5, 0.5];
              }
            }
          }
        });
      });
    }
    Object.values(document2.pageStates).forEach((pageState) => {
      pageState.selectedIds = pageState.selectedIds.filter((id) => {
        return document2.pages[pageState.id].shapes[id] !== void 0;
      });
      pageState.bindingId = void 0;
      pageState.editingId = void 0;
      pageState.hoveredId = void 0;
      pageState.pointedId = void 0;
    });
    document2.version = newVersion;
    return document2;
  }
  var TDShapeType = /* @__PURE__ */ ((TDShapeType2) => {
    TDShapeType2["Sticky"] = "sticky";
    TDShapeType2["Ellipse"] = "ellipse";
    TDShapeType2["Rectangle"] = "rectangle";
    TDShapeType2["Triangle"] = "triangle";
    TDShapeType2["Draw"] = "draw";
    TDShapeType2["Arrow"] = "arrow";
    TDShapeType2["Text"] = "text";
    TDShapeType2["Group"] = "group";
    TDShapeType2["Image"] = "image";
    TDShapeType2["Video"] = "video";
    return TDShapeType2;
  })(TDShapeType || {});
  var FontStyle = /* @__PURE__ */ ((FontStyle2) => {
    FontStyle2["Script"] = "script";
    FontStyle2["Sans"] = "sans";
    FontStyle2["Serif"] = "serif";
    FontStyle2["Mono"] = "mono";
    return FontStyle2;
  })(FontStyle || {});
  var Decoration = /* @__PURE__ */ ((Decoration2) => {
    Decoration2["Arrow"] = "arrow";
    return Decoration2;
  })(Decoration || {});
  var TDAssetType = /* @__PURE__ */ ((TDAssetType2) => {
    TDAssetType2["Image"] = "image";
    TDAssetType2["Video"] = "video";
    return TDAssetType2;
  })(TDAssetType || {});
  var v1ColorsToV2Colors = {
    ["white" /* White */]: "black",
    ["black" /* Black */]: "black",
    ["lightGray" /* LightGray */]: "grey",
    ["gray" /* Gray */]: "grey",
    ["green" /* Green */]: "light-green",
    ["cyan" /* Cyan */]: "green",
    ["blue" /* Blue */]: "light-blue",
    ["indigo" /* Indigo */]: "blue",
    ["orange" /* Orange */]: "orange",
    ["yellow" /* Yellow */]: "yellow",
    ["red" /* Red */]: "red",
    ["violet" /* Violet */]: "light-violet"
  };
  var v1FontsToV2Fonts = {
    ["mono" /* Mono */]: "mono",
    ["sans" /* Sans */]: "sans",
    ["script" /* Script */]: "draw",
    ["serif" /* Serif */]: "serif"
  };
  var v1AlignsToV2Aligns = {
    ["start" /* Start */]: "start",
    ["middle" /* Middle */]: "middle",
    ["end" /* End */]: "end",
    ["justify" /* Justify */]: "start"
  };
  var v1TextSizesToV2TextSizes = {
    ["small" /* Small */]: "s",
    ["medium" /* Medium */]: "l",
    ["large" /* Large */]: "xl"
  };
  var v1SizesToV2Sizes = {
    ["small" /* Small */]: "m",
    ["medium" /* Medium */]: "l",
    ["large" /* Large */]: "xl"
  };
  var v1DashesToV2Dashes = {
    ["solid" /* Solid */]: "solid",
    ["dashed" /* Dashed */]: "dashed",
    ["dotted" /* Dotted */]: "dotted",
    ["draw" /* Draw */]: "draw"
  };
  function getV2Color(color) {
    var _a5;
    return color ? (_a5 = v1ColorsToV2Colors[color]) != null ? _a5 : "black" : "black";
  }
  function getV2Font(font) {
    var _a5;
    return font ? (_a5 = v1FontsToV2Fonts[font]) != null ? _a5 : "draw" : "draw";
  }
  function getV2Align(align) {
    var _a5;
    return align ? (_a5 = v1AlignsToV2Aligns[align]) != null ? _a5 : "middle" : "middle";
  }
  function getV2TextSize(size) {
    var _a5;
    return size ? (_a5 = v1TextSizesToV2TextSizes[size]) != null ? _a5 : "m" : "m";
  }
  function getV2Size(size) {
    var _a5;
    return size ? (_a5 = v1SizesToV2Sizes[size]) != null ? _a5 : "l" : "l";
  }
  function getV2Dash(dash) {
    var _a5;
    return dash ? (_a5 = v1DashesToV2Dashes[dash]) != null ? _a5 : "draw" : "draw";
  }
  function getV2Point(point2) {
    return {
      x: coerceNumber(point2[0]),
      y: coerceNumber(point2[1]),
      z: point2[2] == null ? 0.5 : coerceNumber(point2[2])
    };
  }
  function getV2Arrowhead(decoration) {
    return decoration === "arrow" /* Arrow */ ? "arrow" : "none";
  }
  function getV2Fill(isFilled, color) {
    return isFilled ? color === "black" /* Black */ || color === "white" /* White */ ? "semi" : "solid" : "none";
  }

  // ../../../packages/editor/src/lib/utils/export.ts
  function getSvgAsString(svg) {
    const clone = svg.cloneNode(true);
    svg.setAttribute("width", +svg.getAttribute("width") + "");
    svg.setAttribute("height", +svg.getAttribute("height") + "");
    const out = new XMLSerializer().serializeToString(clone).replaceAll("&#10;      ", "").replaceAll(/((\s|")[0-9]*\.[0-9]{2})([0-9]*)(\b|"|\))/g, "$1");
    return out;
  }
  function getSvgAsImage(svg, options) {
    return __async(this, null, function* () {
      const { type, quality, scale } = options;
      const width = +svg.getAttribute("width");
      const height = +svg.getAttribute("height");
      const dataUrl = yield getSvgAsDataUrl(svg);
      const canvas = yield new Promise((resolve) => {
        const image = new Image();
        image.crossOrigin = "anonymous";
        image.onload = () => __async(this, null, function* () {
          yield new Promise((resolve2) => setTimeout(resolve2, 250));
          const canvas2 = document.createElement("canvas");
          const ctx = canvas2.getContext("2d");
          canvas2.width = width * scale;
          canvas2.height = height * scale;
          ctx.imageSmoothingEnabled = true;
          ctx.imageSmoothingQuality = "high";
          ctx.drawImage(image, 0, 0, width * scale, height * scale);
          URL.revokeObjectURL(dataUrl);
          resolve(canvas2);
        });
        image.onerror = () => {
          resolve(null);
        };
        image.src = dataUrl;
      });
      if (!canvas)
        return null;
      const blob = yield new Promise(
        (resolve) => canvas.toBlob(
          (blob2) => {
            if (!blob2 || debugFlags.throwToBlob.value) {
              resolve(null);
            }
            resolve(blob2);
          },
          "image/" + type,
          quality
        )
      );
      if (!blob)
        return null;
      const view = new DataView(yield blob.arrayBuffer());
      return setPhysChunk(view, scale, {
        type: "image/" + type
      });
    });
  }
  function getSvgAsDataUrl(svg) {
    return __async(this, null, function* () {
      const clone = svg.cloneNode(true);
      clone.setAttribute("encoding", 'UTF-8"');
      const fileReader = new FileReader();
      const imgs = Array.from(clone.querySelectorAll("image"));
      for (const img of imgs) {
        const src = img.getAttribute("xlink:href");
        if (src) {
          if (!src.startsWith("data:")) {
            const blob = yield (yield fetch(src)).blob();
            const base64 = yield new Promise((resolve, reject) => {
              fileReader.onload = () => resolve(fileReader.result);
              fileReader.onerror = () => reject(fileReader.error);
              fileReader.readAsDataURL(blob);
            });
            img.setAttribute("xlink:href", base64);
          }
        }
      }
      return getSvgAsDataUrlSync(clone);
    });
  }
  function getSvgAsDataUrlSync(node) {
    const svgStr = new XMLSerializer().serializeToString(node);
    const base64SVG = window.btoa(unescape(encodeURIComponent(svgStr)));
    return `data:image/svg+xml;base64,${base64SVG}`;
  }
  function downloadDataURLAsFile(dataUrl, filename) {
    const link = document.createElement("a");
    link.href = dataUrl;
    link.download = filename;
    link.click();
  }

  // ../../../packages/editor/src/lib/utils/window-open.ts
  function openWindow(url, target = "_blank") {
    runtime.openWindow(url, target);
  }

  // ../../../node_modules/@babel/runtime/helpers/esm/extends.js
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i3 = 1; i3 < arguments.length; i3++) {
        var source = arguments[i3];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }

  // ../../../node_modules/@radix-ui/react-dialog/dist/index.module.js
  var import_react57 = __toESM(require_react());

  // ../../../node_modules/@radix-ui/primitive/dist/index.module.js
  function $e42e1063c40fb3ef$export$b9ecd428b558ff10(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
    return function handleEvent(event) {
      originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event);
      if (checkForDefaultPrevented === false || !event.defaultPrevented)
        return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);
    };
  }

  // ../../../node_modules/@radix-ui/react-compose-refs/dist/index.module.js
  var import_react43 = __toESM(require_react());
  function $6ed0406888f73fc4$var$setRef(ref, value) {
    if (typeof ref === "function")
      ref(value);
    else if (ref !== null && ref !== void 0)
      ref.current = value;
  }
  function $6ed0406888f73fc4$export$43e446d32b3d21af(...refs) {
    return (node) => refs.forEach(
      (ref) => $6ed0406888f73fc4$var$setRef(ref, node)
    );
  }
  function $6ed0406888f73fc4$export$c7b2cbe3552a0d05(...refs) {
    return (0, import_react43.useCallback)($6ed0406888f73fc4$export$43e446d32b3d21af(...refs), refs);
  }

  // ../../../node_modules/@radix-ui/react-context/dist/index.module.js
  var import_react44 = __toESM(require_react());
  function $c512c27ab02ef895$export$fd42f52fd3ae1109(rootComponentName, defaultContext) {
    const Context = /* @__PURE__ */ (0, import_react44.createContext)(defaultContext);
    function Provider(props) {
      const _a5 = props, { children } = _a5, context = __objRest(_a5, ["children"]);
      const value = (0, import_react44.useMemo)(
        () => context,
        Object.values(context)
      );
      return /* @__PURE__ */ (0, import_react44.createElement)(Context.Provider, {
        value
      }, children);
    }
    function useContext11(consumerName) {
      const context = (0, import_react44.useContext)(Context);
      if (context)
        return context;
      if (defaultContext !== void 0)
        return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider.displayName = rootComponentName + "Provider";
    return [
      Provider,
      useContext11
    ];
  }
  function $c512c27ab02ef895$export$50c7b4e9d9f19c1(scopeName, createContextScopeDeps = []) {
    let defaultContexts = [];
    function $c512c27ab02ef895$export$fd42f52fd3ae11092(rootComponentName, defaultContext) {
      const BaseContext = /* @__PURE__ */ (0, import_react44.createContext)(defaultContext);
      const index2 = defaultContexts.length;
      defaultContexts = [
        ...defaultContexts,
        defaultContext
      ];
      function Provider(props) {
        const _a5 = props, { scope, children } = _a5, context = __objRest(_a5, ["scope", "children"]);
        const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
        const value = (0, import_react44.useMemo)(
          () => context,
          Object.values(context)
        );
        return /* @__PURE__ */ (0, import_react44.createElement)(Context.Provider, {
          value
        }, children);
      }
      function useContext11(consumerName, scope) {
        const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
        const context = (0, import_react44.useContext)(Context);
        if (context)
          return context;
        if (defaultContext !== void 0)
          return defaultContext;
        throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
      }
      Provider.displayName = rootComponentName + "Provider";
      return [
        Provider,
        useContext11
      ];
    }
    const createScope = () => {
      const scopeContexts = defaultContexts.map((defaultContext) => {
        return /* @__PURE__ */ (0, import_react44.createContext)(defaultContext);
      });
      return function useScope(scope) {
        const contexts = (scope === null || scope === void 0 ? void 0 : scope[scopeName]) || scopeContexts;
        return (0, import_react44.useMemo)(
          () => ({
            [`__scope${scopeName}`]: __spreadProps(__spreadValues({}, scope), {
              [scopeName]: contexts
            })
          }),
          [
            scope,
            contexts
          ]
        );
      };
    };
    createScope.scopeName = scopeName;
    return [
      $c512c27ab02ef895$export$fd42f52fd3ae11092,
      $c512c27ab02ef895$var$composeContextScopes(createScope, ...createContextScopeDeps)
    ];
  }
  function $c512c27ab02ef895$var$composeContextScopes(...scopes) {
    const baseScope = scopes[0];
    if (scopes.length === 1)
      return baseScope;
    const createScope1 = () => {
      const scopeHooks = scopes.map(
        (createScope) => ({
          useScope: createScope(),
          scopeName: createScope.scopeName
        })
      );
      return function useComposedScopes(overrideScopes) {
        const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {
          const scopeProps = useScope(overrideScopes);
          const currentScope = scopeProps[`__scope${scopeName}`];
          return __spreadValues(__spreadValues({}, nextScopes), currentScope);
        }, {});
        return (0, import_react44.useMemo)(
          () => ({
            [`__scope${baseScope.scopeName}`]: nextScopes1
          }),
          [
            nextScopes1
          ]
        );
      };
    };
    createScope1.scopeName = baseScope.scopeName;
    return createScope1;
  }

  // ../../../node_modules/@radix-ui/react-id/dist/index.module.js
  var $2AODx$react = __toESM(require_react());

  // ../../../node_modules/@radix-ui/react-use-layout-effect/dist/index.module.js
  var import_react45 = __toESM(require_react());
  var $9f79659886946c16$export$e5c5a5f917a5871c = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? import_react45.useLayoutEffect : () => {
  };

  // ../../../node_modules/@radix-ui/react-id/dist/index.module.js
  var $1746a345f3d73bb7$var$useReactId = $2AODx$react["useId".toString()] || (() => void 0);
  var $1746a345f3d73bb7$var$count = 0;
  function $1746a345f3d73bb7$export$f680877a34711e37(deterministicId) {
    const [id, setId] = $2AODx$react.useState($1746a345f3d73bb7$var$useReactId());
    $9f79659886946c16$export$e5c5a5f917a5871c(() => {
      if (!deterministicId)
        setId(
          (reactId) => reactId !== null && reactId !== void 0 ? reactId : String($1746a345f3d73bb7$var$count++)
        );
    }, [
      deterministicId
    ]);
    return deterministicId || (id ? `radix-${id}` : "");
  }

  // ../../../node_modules/@radix-ui/react-use-controllable-state/dist/index.module.js
  var import_react47 = __toESM(require_react());

  // ../../../node_modules/@radix-ui/react-use-callback-ref/dist/index.module.js
  var import_react46 = __toESM(require_react());
  function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(callback) {
    const callbackRef = (0, import_react46.useRef)(callback);
    (0, import_react46.useEffect)(() => {
      callbackRef.current = callback;
    });
    return (0, import_react46.useMemo)(
      () => (...args) => {
        var _callbackRef$current;
        return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, ...args);
      },
      []
    );
  }

  // ../../../node_modules/@radix-ui/react-use-controllable-state/dist/index.module.js
  function $71cd76cc60e0454e$export$6f32135080cb4c3({ prop, defaultProp, onChange = () => {
  } }) {
    const [uncontrolledProp, setUncontrolledProp] = $71cd76cc60e0454e$var$useUncontrolledState({
      defaultProp,
      onChange
    });
    const isControlled = prop !== void 0;
    const value1 = isControlled ? prop : uncontrolledProp;
    const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
    const setValue = (0, import_react47.useCallback)((nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value !== prop)
          handleChange(value);
      } else
        setUncontrolledProp(nextValue);
    }, [
      isControlled,
      prop,
      setUncontrolledProp,
      handleChange
    ]);
    return [
      value1,
      setValue
    ];
  }
  function $71cd76cc60e0454e$var$useUncontrolledState({ defaultProp, onChange }) {
    const uncontrolledState = (0, import_react47.useState)(defaultProp);
    const [value] = uncontrolledState;
    const prevValueRef = (0, import_react47.useRef)(value);
    const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
    (0, import_react47.useEffect)(() => {
      if (prevValueRef.current !== value) {
        handleChange(value);
        prevValueRef.current = value;
      }
    }, [
      value,
      prevValueRef,
      handleChange
    ]);
    return uncontrolledState;
  }

  // ../../../node_modules/@radix-ui/react-dismissable-layer/dist/index.module.js
  var import_react51 = __toESM(require_react());

  // ../../../node_modules/@radix-ui/react-primitive/dist/index.module.js
  var import_react49 = __toESM(require_react());
  var import_react_dom = __toESM(require_react_dom());

  // ../../../node_modules/@radix-ui/react-slot/dist/index.module.js
  var import_react48 = __toESM(require_react());
  var $5e63c961fc1ce211$export$8c6ed5c666ac1360 = /* @__PURE__ */ (0, import_react48.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { children } = _a5, slotProps = __objRest(_a5, ["children"]);
    const childrenArray = import_react48.Children.toArray(children);
    const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (import_react48.Children.count(newElement) > 1)
            return import_react48.Children.only(null);
          return /* @__PURE__ */ (0, import_react48.isValidElement)(newElement) ? newElement.props.children : null;
        } else
          return child;
      });
      return /* @__PURE__ */ (0, import_react48.createElement)($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
        ref: forwardedRef
      }), /* @__PURE__ */ (0, import_react48.isValidElement)(newElement) ? /* @__PURE__ */ (0, import_react48.cloneElement)(newElement, void 0, newChildren) : null);
    }
    return /* @__PURE__ */ (0, import_react48.createElement)($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
      ref: forwardedRef
    }), children);
  });
  $5e63c961fc1ce211$export$8c6ed5c666ac1360.displayName = "Slot";
  var $5e63c961fc1ce211$var$SlotClone = /* @__PURE__ */ (0, import_react48.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { children } = _a5, slotProps = __objRest(_a5, ["children"]);
    if (/* @__PURE__ */ (0, import_react48.isValidElement)(children))
      return /* @__PURE__ */ (0, import_react48.cloneElement)(children, __spreadProps(__spreadValues({}, $5e63c961fc1ce211$var$mergeProps(slotProps, children.props)), {
        ref: $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, children.ref)
      }));
    return import_react48.Children.count(children) > 1 ? import_react48.Children.only(null) : null;
  });
  $5e63c961fc1ce211$var$SlotClone.displayName = "SlotClone";
  var $5e63c961fc1ce211$export$d9f1ccf0bdb05d45 = ({ children }) => {
    return /* @__PURE__ */ (0, import_react48.createElement)(import_react48.Fragment, null, children);
  };
  function $5e63c961fc1ce211$var$isSlottable(child) {
    return /* @__PURE__ */ (0, import_react48.isValidElement)(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45;
  }
  function $5e63c961fc1ce211$var$mergeProps(slotProps, childProps) {
    const overrideProps = __spreadValues({}, childProps);
    for (const propName in childProps) {
      const slotPropValue = slotProps[propName];
      const childPropValue = childProps[propName];
      const isHandler = /^on[A-Z]/.test(propName);
      if (isHandler) {
        if (slotPropValue && childPropValue)
          overrideProps[propName] = (...args) => {
            childPropValue(...args);
            slotPropValue(...args);
          };
        else if (slotPropValue)
          overrideProps[propName] = slotPropValue;
      } else if (propName === "style")
        overrideProps[propName] = __spreadValues(__spreadValues({}, slotPropValue), childPropValue);
      else if (propName === "className")
        overrideProps[propName] = [
          slotPropValue,
          childPropValue
        ].filter(Boolean).join(" ");
    }
    return __spreadValues(__spreadValues({}, slotProps), overrideProps);
  }

  // ../../../node_modules/@radix-ui/react-primitive/dist/index.module.js
  var $8927f6f2acc4f386$var$NODES = [
    "a",
    "button",
    "div",
    "form",
    "h2",
    "h3",
    "img",
    "input",
    "label",
    "li",
    "nav",
    "ol",
    "p",
    "span",
    "svg",
    "ul"
  ];
  var $8927f6f2acc4f386$export$250ffa63cdc0d034 = $8927f6f2acc4f386$var$NODES.reduce((primitive, node) => {
    const Node = /* @__PURE__ */ (0, import_react49.forwardRef)((props, forwardedRef) => {
      const _a5 = props, { asChild } = _a5, primitiveProps = __objRest(_a5, ["asChild"]);
      const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac1360 : node;
      (0, import_react49.useEffect)(() => {
        window[Symbol.for("radix-ui")] = true;
      }, []);
      return /* @__PURE__ */ (0, import_react49.createElement)(Comp, _extends({}, primitiveProps, {
        ref: forwardedRef
      }));
    });
    Node.displayName = `Primitive.${node}`;
    return __spreadProps(__spreadValues({}, primitive), {
      [node]: Node
    });
  }, {});
  function $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event) {
    if (target)
      (0, import_react_dom.flushSync)(
        () => target.dispatchEvent(event)
      );
  }

  // ../../../node_modules/@radix-ui/react-use-escape-keydown/dist/index.module.js
  var import_react50 = __toESM(require_react());
  function $addc16e1bbe58fd0$export$3a72a57244d6e765(onEscapeKeyDownProp, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
    const onEscapeKeyDown = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEscapeKeyDownProp);
    (0, import_react50.useEffect)(() => {
      const handleKeyDown = (event) => {
        if (event.key === "Escape")
          onEscapeKeyDown(event);
      };
      ownerDocument.addEventListener("keydown", handleKeyDown);
      return () => ownerDocument.removeEventListener("keydown", handleKeyDown);
    }, [
      onEscapeKeyDown,
      ownerDocument
    ]);
  }

  // ../../../node_modules/@radix-ui/react-dismissable-layer/dist/index.module.js
  var $5cb92bef7577960e$var$CONTEXT_UPDATE = "dismissableLayer.update";
  var $5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
  var $5cb92bef7577960e$var$FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
  var $5cb92bef7577960e$var$originalBodyPointerEvents;
  var $5cb92bef7577960e$var$DismissableLayerContext = /* @__PURE__ */ (0, import_react51.createContext)({
    layers: /* @__PURE__ */ new Set(),
    layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
    branches: /* @__PURE__ */ new Set()
  });
  var $5cb92bef7577960e$export$177fb62ff3ec1f22 = /* @__PURE__ */ (0, import_react51.forwardRef)((props, forwardedRef) => {
    var _node$ownerDocument;
    const _a5 = props, { disableOutsidePointerEvents = false, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, onDismiss } = _a5, layerProps = __objRest(_a5, ["disableOutsidePointerEvents", "onEscapeKeyDown", "onPointerDownOutside", "onFocusOutside", "onInteractOutside", "onDismiss"]);
    const context = (0, import_react51.useContext)($5cb92bef7577960e$var$DismissableLayerContext);
    const [node1, setNode] = (0, import_react51.useState)(null);
    const ownerDocument = (_node$ownerDocument = node1 === null || node1 === void 0 ? void 0 : node1.ownerDocument) !== null && _node$ownerDocument !== void 0 ? _node$ownerDocument : globalThis === null || globalThis === void 0 ? void 0 : globalThis.document;
    const [, force] = (0, import_react51.useState)({});
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
      forwardedRef,
      (node) => setNode(node)
    );
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [
      ...context.layersWithOutsidePointerEventsDisabled
    ].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node1 ? layers.indexOf(node1) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = $5cb92bef7577960e$var$usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [
        ...context.branches
      ].some(
        (branch) => branch.contains(target)
      );
      if (!isPointerEventsEnabled || isPointerDownOnBranch)
        return;
      onPointerDownOutside === null || onPointerDownOutside === void 0 || onPointerDownOutside(event);
      onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
      if (!event.defaultPrevented)
        onDismiss === null || onDismiss === void 0 || onDismiss();
    }, ownerDocument);
    const focusOutside = $5cb92bef7577960e$var$useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [
        ...context.branches
      ].some(
        (branch) => branch.contains(target)
      );
      if (isFocusInBranch)
        return;
      onFocusOutside === null || onFocusOutside === void 0 || onFocusOutside(event);
      onInteractOutside === null || onInteractOutside === void 0 || onInteractOutside(event);
      if (!event.defaultPrevented)
        onDismiss === null || onDismiss === void 0 || onDismiss();
    }, ownerDocument);
    $addc16e1bbe58fd0$export$3a72a57244d6e765((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer)
        return;
      onEscapeKeyDown === null || onEscapeKeyDown === void 0 || onEscapeKeyDown(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    (0, import_react51.useEffect)(() => {
      if (!node1)
        return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          $5cb92bef7577960e$var$originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node1);
      }
      context.layers.add(node1);
      $5cb92bef7577960e$var$dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1)
          ownerDocument.body.style.pointerEvents = $5cb92bef7577960e$var$originalBodyPointerEvents;
      };
    }, [
      node1,
      ownerDocument,
      disableOutsidePointerEvents,
      context
    ]);
    (0, import_react51.useEffect)(() => {
      return () => {
        if (!node1)
          return;
        context.layers.delete(node1);
        context.layersWithOutsidePointerEventsDisabled.delete(node1);
        $5cb92bef7577960e$var$dispatchUpdate();
      };
    }, [
      node1,
      context
    ]);
    (0, import_react51.useEffect)(() => {
      const handleUpdate = () => force({});
      document.addEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener($5cb92bef7577960e$var$CONTEXT_UPDATE, handleUpdate);
    }, []);
    return /* @__PURE__ */ (0, import_react51.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, layerProps, {
      ref: composedRefs,
      style: __spreadValues({
        pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0
      }, props.style),
      onFocusCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocusCapture, focusOutside.onFocusCapture),
      onBlurCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlurCapture, focusOutside.onBlurCapture),
      onPointerDownCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture)
    }));
  });
  var $5cb92bef7577960e$export$4d5eb2109db14228 = /* @__PURE__ */ (0, import_react51.forwardRef)((props, forwardedRef) => {
    const context = (0, import_react51.useContext)($5cb92bef7577960e$var$DismissableLayerContext);
    const ref = (0, import_react51.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
    (0, import_react51.useEffect)(() => {
      const node = ref.current;
      if (node) {
        context.branches.add(node);
        return () => {
          context.branches.delete(node);
        };
      }
    }, [
      context.branches
    ]);
    return /* @__PURE__ */ (0, import_react51.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, props, {
      ref: composedRefs
    }));
  });
  function $5cb92bef7577960e$var$usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
    const handlePointerDownOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPointerDownOutside);
    const isPointerInsideReactTreeRef = (0, import_react51.useRef)(false);
    const handleClickRef = (0, import_react51.useRef)(() => {
    });
    (0, import_react51.useEffect)(() => {
      const handlePointerDown = (event) => {
        if (event.target && !isPointerInsideReactTreeRef.current) {
          let handleAndDispatchPointerDownOutsideEvent = function() {
            $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$POINTER_DOWN_OUTSIDE, handlePointerDownOutside, eventDetail, {
              discrete: true
            });
          };
          const eventDetail = {
            originalEvent: event
          };
          if (event.pointerType === "touch") {
            ownerDocument.removeEventListener("click", handleClickRef.current);
            handleClickRef.current = handleAndDispatchPointerDownOutsideEvent;
            ownerDocument.addEventListener("click", handleClickRef.current, {
              once: true
            });
          } else
            handleAndDispatchPointerDownOutsideEvent();
        }
        isPointerInsideReactTreeRef.current = false;
      };
      const timerId = window.setTimeout(() => {
        ownerDocument.addEventListener("pointerdown", handlePointerDown);
      }, 0);
      return () => {
        window.clearTimeout(timerId);
        ownerDocument.removeEventListener("pointerdown", handlePointerDown);
        ownerDocument.removeEventListener("click", handleClickRef.current);
      };
    }, [
      ownerDocument,
      handlePointerDownOutside
    ]);
    return {
      // ensures we check React component tree (not just DOM tree)
      onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
    };
  }
  function $5cb92bef7577960e$var$useFocusOutside(onFocusOutside, ownerDocument = globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) {
    const handleFocusOutside = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onFocusOutside);
    const isFocusInsideReactTreeRef = (0, import_react51.useRef)(false);
    (0, import_react51.useEffect)(() => {
      const handleFocus = (event) => {
        if (event.target && !isFocusInsideReactTreeRef.current) {
          const eventDetail = {
            originalEvent: event
          };
          $5cb92bef7577960e$var$handleAndDispatchCustomEvent($5cb92bef7577960e$var$FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
            discrete: false
          });
        }
      };
      ownerDocument.addEventListener("focusin", handleFocus);
      return () => ownerDocument.removeEventListener("focusin", handleFocus);
    }, [
      ownerDocument,
      handleFocusOutside
    ]);
    return {
      onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
      onBlurCapture: () => isFocusInsideReactTreeRef.current = false
    };
  }
  function $5cb92bef7577960e$var$dispatchUpdate() {
    const event = new CustomEvent($5cb92bef7577960e$var$CONTEXT_UPDATE);
    document.dispatchEvent(event);
  }
  function $5cb92bef7577960e$var$handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
    const target = detail.originalEvent.target;
    const event = new CustomEvent(name, {
      bubbles: false,
      cancelable: true,
      detail
    });
    if (handler)
      target.addEventListener(name, handler, {
        once: true
      });
    if (discrete)
      $8927f6f2acc4f386$export$6d1a0317bde7de7f(target, event);
    else
      target.dispatchEvent(event);
  }
  var $5cb92bef7577960e$export$be92b6f5f03c0fe9 = $5cb92bef7577960e$export$177fb62ff3ec1f22;
  var $5cb92bef7577960e$export$aecb2ddcb55c95be = $5cb92bef7577960e$export$4d5eb2109db14228;

  // ../../../node_modules/@radix-ui/react-focus-scope/dist/index.module.js
  var import_react52 = __toESM(require_react());
  var $d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
  var $d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
  var $d3863c46a17e8a28$var$EVENT_OPTIONS = {
    bubbles: false,
    cancelable: true
  };
  var $d3863c46a17e8a28$export$20e40289641fbbb6 = /* @__PURE__ */ (0, import_react52.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { loop = false, trapped = false, onMountAutoFocus: onMountAutoFocusProp, onUnmountAutoFocus: onUnmountAutoFocusProp } = _a5, scopeProps = __objRest(_a5, ["loop", "trapped", "onMountAutoFocus", "onUnmountAutoFocus"]);
    const [container1, setContainer] = (0, import_react52.useState)(null);
    const onMountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onMountAutoFocusProp);
    const onUnmountAutoFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onUnmountAutoFocusProp);
    const lastFocusedElementRef = (0, import_react52.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
      forwardedRef,
      (node) => setContainer(node)
    );
    const focusScope = (0, import_react52.useRef)({
      paused: false,
      pause() {
        this.paused = true;
      },
      resume() {
        this.paused = false;
      }
    }).current;
    (0, import_react52.useEffect)(() => {
      if (trapped) {
        let handleFocusIn = function(event) {
          if (focusScope.paused || !container1)
            return;
          const target = event.target;
          if (container1.contains(target))
            lastFocusedElementRef.current = target;
          else
            $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
              select: true
            });
        }, handleFocusOut = function(event) {
          if (focusScope.paused || !container1)
            return;
          if (!container1.contains(event.relatedTarget))
            $d3863c46a17e8a28$var$focus(lastFocusedElementRef.current, {
              select: true
            });
        };
        document.addEventListener("focusin", handleFocusIn);
        document.addEventListener("focusout", handleFocusOut);
        return () => {
          document.removeEventListener("focusin", handleFocusIn);
          document.removeEventListener("focusout", handleFocusOut);
        };
      }
    }, [
      trapped,
      container1,
      focusScope.paused
    ]);
    (0, import_react52.useEffect)(() => {
      if (container1) {
        $d3863c46a17e8a28$var$focusScopesStack.add(focusScope);
        const previouslyFocusedElement = document.activeElement;
        const hasFocusedCandidate = container1.contains(previouslyFocusedElement);
        if (!hasFocusedCandidate) {
          const mountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
          container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
          container1.dispatchEvent(mountEvent);
          if (!mountEvent.defaultPrevented) {
            $d3863c46a17e8a28$var$focusFirst($d3863c46a17e8a28$var$removeLinks($d3863c46a17e8a28$var$getTabbableCandidates(container1)), {
              select: true
            });
            if (document.activeElement === previouslyFocusedElement)
              $d3863c46a17e8a28$var$focus(container1);
          }
        }
        return () => {
          container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
          setTimeout(() => {
            const unmountEvent = new CustomEvent($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, $d3863c46a17e8a28$var$EVENT_OPTIONS);
            container1.addEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
            container1.dispatchEvent(unmountEvent);
            if (!unmountEvent.defaultPrevented)
              $d3863c46a17e8a28$var$focus(previouslyFocusedElement !== null && previouslyFocusedElement !== void 0 ? previouslyFocusedElement : document.body, {
                select: true
              });
            container1.removeEventListener($d3863c46a17e8a28$var$AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
            $d3863c46a17e8a28$var$focusScopesStack.remove(focusScope);
          }, 0);
        };
      }
    }, [
      container1,
      onMountAutoFocus,
      onUnmountAutoFocus,
      focusScope
    ]);
    const handleKeyDown = (0, import_react52.useCallback)((event) => {
      if (!loop && !trapped)
        return;
      if (focusScope.paused)
        return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container = event.currentTarget;
        const [first, last2] = $d3863c46a17e8a28$var$getTabbableEdges(container);
        const hasTabbableElementsInside = first && last2;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container)
            event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last2) {
            event.preventDefault();
            if (loop)
              $d3863c46a17e8a28$var$focus(first, {
                select: true
              });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop)
              $d3863c46a17e8a28$var$focus(last2, {
                select: true
              });
          }
        }
      }
    }, [
      loop,
      trapped,
      focusScope.paused
    ]);
    return /* @__PURE__ */ (0, import_react52.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
      tabIndex: -1
    }, scopeProps, {
      ref: composedRefs,
      onKeyDown: handleKeyDown
    }));
  });
  function $d3863c46a17e8a28$var$focusFirst(candidates, { select = false } = {}) {
    const previouslyFocusedElement = document.activeElement;
    for (const candidate of candidates) {
      $d3863c46a17e8a28$var$focus(candidate, {
        select
      });
      if (document.activeElement !== previouslyFocusedElement)
        return;
    }
  }
  function $d3863c46a17e8a28$var$getTabbableEdges(container) {
    const candidates = $d3863c46a17e8a28$var$getTabbableCandidates(container);
    const first = $d3863c46a17e8a28$var$findVisible(candidates, container);
    const last2 = $d3863c46a17e8a28$var$findVisible(candidates.reverse(), container);
    return [
      first,
      last2
    ];
  }
  function $d3863c46a17e8a28$var$getTabbableCandidates(container) {
    const nodes = [];
    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (node) => {
        const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
        if (node.disabled || node.hidden || isHiddenInput)
          return NodeFilter.FILTER_SKIP;
        return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    while (walker.nextNode())
      nodes.push(walker.currentNode);
    return nodes;
  }
  function $d3863c46a17e8a28$var$findVisible(elements, container) {
    for (const element of elements) {
      if (!$d3863c46a17e8a28$var$isHidden(element, {
        upTo: container
      }))
        return element;
    }
  }
  function $d3863c46a17e8a28$var$isHidden(node, { upTo }) {
    if (getComputedStyle(node).visibility === "hidden")
      return true;
    while (node) {
      if (upTo !== void 0 && node === upTo)
        return false;
      if (getComputedStyle(node).display === "none")
        return true;
      node = node.parentElement;
    }
    return false;
  }
  function $d3863c46a17e8a28$var$isSelectableInput(element) {
    return element instanceof HTMLInputElement && "select" in element;
  }
  function $d3863c46a17e8a28$var$focus(element, { select = false } = {}) {
    if (element && element.focus) {
      const previouslyFocusedElement = document.activeElement;
      element.focus({
        preventScroll: true
      });
      if (element !== previouslyFocusedElement && $d3863c46a17e8a28$var$isSelectableInput(element) && select)
        element.select();
    }
  }
  var $d3863c46a17e8a28$var$focusScopesStack = $d3863c46a17e8a28$var$createFocusScopesStack();
  function $d3863c46a17e8a28$var$createFocusScopesStack() {
    let stack3 = [];
    return {
      add(focusScope) {
        const activeFocusScope = stack3[0];
        if (focusScope !== activeFocusScope)
          activeFocusScope === null || activeFocusScope === void 0 || activeFocusScope.pause();
        stack3 = $d3863c46a17e8a28$var$arrayRemove(stack3, focusScope);
        stack3.unshift(focusScope);
      },
      remove(focusScope) {
        var _stack$;
        stack3 = $d3863c46a17e8a28$var$arrayRemove(stack3, focusScope);
        (_stack$ = stack3[0]) === null || _stack$ === void 0 || _stack$.resume();
      }
    };
  }
  function $d3863c46a17e8a28$var$arrayRemove(array2, item) {
    const updatedArray = [
      ...array2
    ];
    const index2 = updatedArray.indexOf(item);
    if (index2 !== -1)
      updatedArray.splice(index2, 1);
    return updatedArray;
  }
  function $d3863c46a17e8a28$var$removeLinks(items) {
    return items.filter(
      (item) => item.tagName !== "A"
    );
  }

  // ../../../node_modules/@radix-ui/react-portal/dist/index.module.js
  var import_react53 = __toESM(require_react());
  var import_react_dom2 = __toESM(require_react_dom());
  var $f1701beae083dbae$export$602eac185826482c = /* @__PURE__ */ (0, import_react53.forwardRef)((props, forwardedRef) => {
    var _globalThis$document;
    const _a5 = props, { container = globalThis === null || globalThis === void 0 ? void 0 : (_globalThis$document = globalThis.document) === null || _globalThis$document === void 0 ? void 0 : _globalThis$document.body } = _a5, portalProps = __objRest(_a5, ["container"]);
    return container ? /* @__PURE__ */ import_react_dom2.default.createPortal(/* @__PURE__ */ (0, import_react53.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, portalProps, {
      ref: forwardedRef
    })), container) : null;
  });

  // ../../../node_modules/@radix-ui/react-presence/dist/index.module.js
  var import_react54 = __toESM(require_react());
  var import_react_dom3 = __toESM(require_react_dom());
  function $fe963b355347cc68$export$3e6543de14f8614f(initialState2, machine) {
    return (0, import_react54.useReducer)((state, event) => {
      const nextState = machine[state][event];
      return nextState !== null && nextState !== void 0 ? nextState : state;
    }, initialState2);
  }
  var $921a889cee6df7e8$export$99c2b779aa4e8b8b = (props) => {
    const { present, children } = props;
    const presence = $921a889cee6df7e8$var$usePresence(present);
    const child = typeof children === "function" ? children({
      present: presence.isPresent
    }) : import_react54.Children.only(children);
    const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(presence.ref, child.ref);
    const forceMount = typeof children === "function";
    return forceMount || presence.isPresent ? /* @__PURE__ */ (0, import_react54.cloneElement)(child, {
      ref
    }) : null;
  };
  $921a889cee6df7e8$export$99c2b779aa4e8b8b.displayName = "Presence";
  function $921a889cee6df7e8$var$usePresence(present) {
    const [node1, setNode] = (0, import_react54.useState)();
    const stylesRef = (0, import_react54.useRef)({});
    const prevPresentRef = (0, import_react54.useRef)(present);
    const prevAnimationNameRef = (0, import_react54.useRef)("none");
    const initialState2 = present ? "mounted" : "unmounted";
    const [state, send] = $fe963b355347cc68$export$3e6543de14f8614f(initialState2, {
      mounted: {
        UNMOUNT: "unmounted",
        ANIMATION_OUT: "unmountSuspended"
      },
      unmountSuspended: {
        MOUNT: "mounted",
        ANIMATION_END: "unmounted"
      },
      unmounted: {
        MOUNT: "mounted"
      }
    });
    (0, import_react54.useEffect)(() => {
      const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
      prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
    }, [
      state
    ]);
    $9f79659886946c16$export$e5c5a5f917a5871c(() => {
      const styles2 = stylesRef.current;
      const wasPresent = prevPresentRef.current;
      const hasPresentChanged = wasPresent !== present;
      if (hasPresentChanged) {
        const prevAnimationName = prevAnimationNameRef.current;
        const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(styles2);
        if (present)
          send("MOUNT");
        else if (currentAnimationName === "none" || (styles2 === null || styles2 === void 0 ? void 0 : styles2.display) === "none")
          send("UNMOUNT");
        else {
          const isAnimating = prevAnimationName !== currentAnimationName;
          if (wasPresent && isAnimating)
            send("ANIMATION_OUT");
          else
            send("UNMOUNT");
        }
        prevPresentRef.current = present;
      }
    }, [
      present,
      send
    ]);
    $9f79659886946c16$export$e5c5a5f917a5871c(() => {
      if (node1) {
        const handleAnimationEnd = (event) => {
          const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
          const isCurrentAnimation = currentAnimationName.includes(event.animationName);
          if (event.target === node1 && isCurrentAnimation)
            (0, import_react_dom3.flushSync)(
              () => send("ANIMATION_END")
            );
        };
        const handleAnimationStart = (event) => {
          if (event.target === node1)
            prevAnimationNameRef.current = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
        };
        node1.addEventListener("animationstart", handleAnimationStart);
        node1.addEventListener("animationcancel", handleAnimationEnd);
        node1.addEventListener("animationend", handleAnimationEnd);
        return () => {
          node1.removeEventListener("animationstart", handleAnimationStart);
          node1.removeEventListener("animationcancel", handleAnimationEnd);
          node1.removeEventListener("animationend", handleAnimationEnd);
        };
      } else
        send("ANIMATION_END");
    }, [
      node1,
      send
    ]);
    return {
      isPresent: [
        "mounted",
        "unmountSuspended"
      ].includes(state),
      ref: (0, import_react54.useCallback)((node) => {
        if (node)
          stylesRef.current = getComputedStyle(node);
        setNode(node);
      }, [])
    };
  }
  function $921a889cee6df7e8$var$getAnimationName(styles2) {
    return (styles2 === null || styles2 === void 0 ? void 0 : styles2.animationName) || "none";
  }

  // ../../../node_modules/@radix-ui/react-focus-guards/dist/index.module.js
  var import_react55 = __toESM(require_react());
  var $3db38b7d1fb3fe6a$var$count = 0;
  function $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c() {
    (0, import_react55.useEffect)(() => {
      var _edgeGuards$, _edgeGuards$2;
      const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
      document.body.insertAdjacentElement("afterbegin", (_edgeGuards$ = edgeGuards[0]) !== null && _edgeGuards$ !== void 0 ? _edgeGuards$ : $3db38b7d1fb3fe6a$var$createFocusGuard());
      document.body.insertAdjacentElement("beforeend", (_edgeGuards$2 = edgeGuards[1]) !== null && _edgeGuards$2 !== void 0 ? _edgeGuards$2 : $3db38b7d1fb3fe6a$var$createFocusGuard());
      $3db38b7d1fb3fe6a$var$count++;
      return () => {
        if ($3db38b7d1fb3fe6a$var$count === 1)
          document.querySelectorAll("[data-radix-focus-guard]").forEach(
            (node) => node.remove()
          );
        $3db38b7d1fb3fe6a$var$count--;
      };
    }, []);
  }
  function $3db38b7d1fb3fe6a$var$createFocusGuard() {
    const element = document.createElement("span");
    element.setAttribute("data-radix-focus-guard", "");
    element.tabIndex = 0;
    element.style.cssText = "outline: none; opacity: 0; position: fixed; pointer-events: none";
    return element;
  }

  // ../../../node_modules/tslib/tslib.es6.js
  var __assign = function() {
    __assign = Object.assign || function __assign2(t4) {
      for (var s3, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
        s3 = arguments[i3];
        for (var p3 in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p3))
            t4[p3] = s3[p3];
      }
      return t4;
    };
    return __assign.apply(this, arguments);
  };
  function __rest(s3, e2) {
    var t4 = {};
    for (var p3 in s3)
      if (Object.prototype.hasOwnProperty.call(s3, p3) && e2.indexOf(p3) < 0)
        t4[p3] = s3[p3];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i3 = 0, p3 = Object.getOwnPropertySymbols(s3); i3 < p3.length; i3++) {
        if (e2.indexOf(p3[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i3]))
          t4[p3[i3]] = s3[p3[i3]];
      }
    return t4;
  }
  function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2)
      for (var i3 = 0, l3 = from.length, ar; i3 < l3; i3++) {
        if (ar || !(i3 in from)) {
          if (!ar)
            ar = Array.prototype.slice.call(from, 0, i3);
          ar[i3] = from[i3];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from));
  }

  // ../../../node_modules/react-remove-scroll/dist/es2015/Combination.js
  var React40 = __toESM(require_react());

  // ../../../node_modules/react-remove-scroll/dist/es2015/UI.js
  var React36 = __toESM(require_react());

  // ../../../node_modules/react-remove-scroll-bar/dist/es2015/constants.js
  var zeroRightClassName = "right-scroll-bar-position";
  var fullWidthClassName = "width-before-scroll-bar";
  var noScrollbarsClassName = "with-scroll-bars-hidden";
  var removedBarSizeVariable = "--removed-body-scroll-bar-size";

  // ../../../node_modules/use-callback-ref/dist/es2015/assignRef.js
  function assignRef(ref, value) {
    if (typeof ref === "function") {
      ref(value);
    } else if (ref) {
      ref.current = value;
    }
    return ref;
  }

  // ../../../node_modules/use-callback-ref/dist/es2015/useRef.js
  var import_react56 = __toESM(require_react());
  function useCallbackRef(initialValue, callback) {
    var ref = (0, import_react56.useState)(function() {
      return {
        // value
        value: initialValue,
        // last callback
        callback,
        // "memoized" public interface
        facade: {
          get current() {
            return ref.value;
          },
          set current(value) {
            var last2 = ref.value;
            if (last2 !== value) {
              ref.value = value;
              ref.callback(value, last2);
            }
          }
        }
      };
    })[0];
    ref.callback = callback;
    return ref.facade;
  }

  // ../../../node_modules/use-callback-ref/dist/es2015/useMergeRef.js
  function useMergeRefs(refs, defaultValue) {
    return useCallbackRef(defaultValue || null, function(newValue) {
      return refs.forEach(function(ref) {
        return assignRef(ref, newValue);
      });
    });
  }

  // ../../../node_modules/use-sidecar/dist/es2015/medium.js
  function ItoI(a3) {
    return a3;
  }
  function innerCreateMedium(defaults, middleware) {
    if (middleware === void 0) {
      middleware = ItoI;
    }
    var buffer = [];
    var assigned = false;
    var medium = {
      read: function() {
        if (assigned) {
          throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
        }
        if (buffer.length) {
          return buffer[buffer.length - 1];
        }
        return defaults;
      },
      useMedium: function(data) {
        var item = middleware(data, assigned);
        buffer.push(item);
        return function() {
          buffer = buffer.filter(function(x3) {
            return x3 !== item;
          });
        };
      },
      assignSyncMedium: function(cb) {
        assigned = true;
        while (buffer.length) {
          var cbs = buffer;
          buffer = [];
          cbs.forEach(cb);
        }
        buffer = {
          push: function(x3) {
            return cb(x3);
          },
          filter: function() {
            return buffer;
          }
        };
      },
      assignMedium: function(cb) {
        assigned = true;
        var pendingQueue = [];
        if (buffer.length) {
          var cbs = buffer;
          buffer = [];
          cbs.forEach(cb);
          pendingQueue = buffer;
        }
        var executeQueue = function() {
          var cbs2 = pendingQueue;
          pendingQueue = [];
          cbs2.forEach(cb);
        };
        var cycle = function() {
          return Promise.resolve().then(executeQueue);
        };
        cycle();
        buffer = {
          push: function(x3) {
            pendingQueue.push(x3);
            cycle();
          },
          filter: function(filter2) {
            pendingQueue = pendingQueue.filter(filter2);
            return buffer;
          }
        };
      }
    };
    return medium;
  }
  function createSidecarMedium(options) {
    if (options === void 0) {
      options = {};
    }
    var medium = innerCreateMedium(null);
    medium.options = __assign({ async: true, ssr: false }, options);
    return medium;
  }

  // ../../../node_modules/use-sidecar/dist/es2015/exports.js
  var React35 = __toESM(require_react());
  var SideCar = function(_a5) {
    var sideCar = _a5.sideCar, rest = __rest(_a5, ["sideCar"]);
    if (!sideCar) {
      throw new Error("Sidecar: please provide `sideCar` property to import the right car");
    }
    var Target = sideCar.read();
    if (!Target) {
      throw new Error("Sidecar medium not found");
    }
    return React35.createElement(Target, __assign({}, rest));
  };
  SideCar.isSideCarExport = true;
  function exportSidecar(medium, exported) {
    medium.useMedium(exported);
    return SideCar;
  }

  // ../../../node_modules/react-remove-scroll/dist/es2015/medium.js
  var effectCar = createSidecarMedium();

  // ../../../node_modules/react-remove-scroll/dist/es2015/UI.js
  var nothing = function() {
    return;
  };
  var RemoveScroll = React36.forwardRef(function(props, parentRef) {
    var ref = React36.useRef(null);
    var _a5 = React36.useState({
      onScrollCapture: nothing,
      onWheelCapture: nothing,
      onTouchMoveCapture: nothing
    }), callbacks = _a5[0], setCallbacks = _a5[1];
    var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b2 = props.as, Container = _b2 === void 0 ? "div" : _b2, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
    var SideCar2 = sideCar;
    var containerRef = useMergeRefs([ref, parentRef]);
    var containerProps = __assign(__assign({}, rest), callbacks);
    return React36.createElement(
      React36.Fragment,
      null,
      enabled && React36.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref }),
      forwardProps ? React36.cloneElement(React36.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React36.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
    );
  });
  RemoveScroll.defaultProps = {
    enabled: true,
    removeScrollBar: true,
    inert: false
  };
  RemoveScroll.classNames = {
    fullWidth: fullWidthClassName,
    zeroRight: zeroRightClassName
  };

  // ../../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
  var React39 = __toESM(require_react());

  // ../../../node_modules/react-remove-scroll-bar/dist/es2015/component.js
  var React38 = __toESM(require_react());

  // ../../../node_modules/react-style-singleton/dist/es2015/hook.js
  var React37 = __toESM(require_react());

  // ../../../node_modules/get-nonce/dist/es2015/index.js
  var currentNonce;
  var getNonce = function() {
    if (currentNonce) {
      return currentNonce;
    }
    if (typeof __webpack_nonce__ !== "undefined") {
      return __webpack_nonce__;
    }
    return void 0;
  };

  // ../../../node_modules/react-style-singleton/dist/es2015/singleton.js
  function makeStyleTag() {
    if (!document)
      return null;
    var tag = document.createElement("style");
    tag.type = "text/css";
    var nonce = getNonce();
    if (nonce) {
      tag.setAttribute("nonce", nonce);
    }
    return tag;
  }
  function injectStyles(tag, css) {
    if (tag.styleSheet) {
      tag.styleSheet.cssText = css;
    } else {
      tag.appendChild(document.createTextNode(css));
    }
  }
  function insertStyleTag(tag) {
    var head = document.head || document.getElementsByTagName("head")[0];
    head.appendChild(tag);
  }
  var stylesheetSingleton = function() {
    var counter = 0;
    var stylesheet = null;
    return {
      add: function(style) {
        if (counter == 0) {
          if (stylesheet = makeStyleTag()) {
            injectStyles(stylesheet, style);
            insertStyleTag(stylesheet);
          }
        }
        counter++;
      },
      remove: function() {
        counter--;
        if (!counter && stylesheet) {
          stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
          stylesheet = null;
        }
      }
    };
  };

  // ../../../node_modules/react-style-singleton/dist/es2015/hook.js
  var styleHookSingleton = function() {
    var sheet = stylesheetSingleton();
    return function(styles2, isDynamic) {
      React37.useEffect(function() {
        sheet.add(styles2);
        return function() {
          sheet.remove();
        };
      }, [styles2 && isDynamic]);
    };
  };

  // ../../../node_modules/react-style-singleton/dist/es2015/component.js
  var styleSingleton = function() {
    var useStyle = styleHookSingleton();
    var Sheet = function(_a5) {
      var styles2 = _a5.styles, dynamic = _a5.dynamic;
      useStyle(styles2, dynamic);
      return null;
    };
    return Sheet;
  };

  // ../../../node_modules/react-remove-scroll-bar/dist/es2015/utils.js
  var zeroGap = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0
  };
  var parse2 = function(x3) {
    return parseInt(x3 || "", 10) || 0;
  };
  var getOffset = function(gapMode) {
    var cs = window.getComputedStyle(document.body);
    var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
    var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
    var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
    return [parse2(left), parse2(top), parse2(right)];
  };
  var getGapWidth = function(gapMode) {
    if (gapMode === void 0) {
      gapMode = "margin";
    }
    if (typeof window === "undefined") {
      return zeroGap;
    }
    var offsets = getOffset(gapMode);
    var documentWidth = document.documentElement.clientWidth;
    var windowWidth = window.innerWidth;
    return {
      left: offsets[0],
      top: offsets[1],
      right: offsets[2],
      gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
    };
  };

  // ../../../node_modules/react-remove-scroll-bar/dist/es2015/component.js
  var Style = styleSingleton();
  var getStyles = function(_a5, allowRelative, gapMode, important) {
    var left = _a5.left, top = _a5.top, right = _a5.right, gap = _a5.gap;
    if (gapMode === void 0) {
      gapMode = "margin";
    }
    return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
      allowRelative && "position: relative ".concat(important, ";"),
      gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
      gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
    ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
  };
  var RemoveScrollBar = function(props) {
    var noRelative = props.noRelative, noImportant = props.noImportant, _a5 = props.gapMode, gapMode = _a5 === void 0 ? "margin" : _a5;
    var gap = React38.useMemo(function() {
      return getGapWidth(gapMode);
    }, [gapMode]);
    return React38.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
  };

  // ../../../node_modules/react-remove-scroll/dist/es2015/aggresiveCapture.js
  var passiveSupported = false;
  if (typeof window !== "undefined") {
    try {
      options = Object.defineProperty({}, "passive", {
        get: function() {
          passiveSupported = true;
          return true;
        }
      });
      window.addEventListener("test", options, options);
      window.removeEventListener("test", options, options);
    } catch (err) {
      passiveSupported = false;
    }
  }
  var options;
  var nonPassive = passiveSupported ? { passive: false } : false;

  // ../../../node_modules/react-remove-scroll/dist/es2015/handleScroll.js
  var alwaysContainsScroll = function(node) {
    return node.tagName === "TEXTAREA";
  };
  var elementCanBeScrolled = function(node, overflow) {
    var styles2 = window.getComputedStyle(node);
    return (
      // not-not-scrollable
      styles2[overflow] !== "hidden" && // contains scroll inside self
      !(styles2.overflowY === styles2.overflowX && !alwaysContainsScroll(node) && styles2[overflow] === "visible")
    );
  };
  var elementCouldBeVScrolled = function(node) {
    return elementCanBeScrolled(node, "overflowY");
  };
  var elementCouldBeHScrolled = function(node) {
    return elementCanBeScrolled(node, "overflowX");
  };
  var locationCouldBeScrolled = function(axis, node) {
    var current = node;
    do {
      if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
        current = current.host;
      }
      var isScrollable = elementCouldBeScrolled(axis, current);
      if (isScrollable) {
        var _a5 = getScrollVariables(axis, current), s3 = _a5[1], d3 = _a5[2];
        if (s3 > d3) {
          return true;
        }
      }
      current = current.parentNode;
    } while (current && current !== document.body);
    return false;
  };
  var getVScrollVariables = function(_a5) {
    var scrollTop = _a5.scrollTop, scrollHeight = _a5.scrollHeight, clientHeight = _a5.clientHeight;
    return [
      scrollTop,
      scrollHeight,
      clientHeight
    ];
  };
  var getHScrollVariables = function(_a5) {
    var scrollLeft = _a5.scrollLeft, scrollWidth = _a5.scrollWidth, clientWidth = _a5.clientWidth;
    return [
      scrollLeft,
      scrollWidth,
      clientWidth
    ];
  };
  var elementCouldBeScrolled = function(axis, node) {
    return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
  };
  var getScrollVariables = function(axis, node) {
    return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
  };
  var getDirectionFactor = function(axis, direction) {
    return axis === "h" && direction === "rtl" ? -1 : 1;
  };
  var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
    var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
    var delta = directionFactor * sourceDelta;
    var target = event.target;
    var targetInLock = endTarget.contains(target);
    var shouldCancelScroll = false;
    var isDeltaPositive = delta > 0;
    var availableScroll = 0;
    var availableScrollTop = 0;
    do {
      var _a5 = getScrollVariables(axis, target), position = _a5[0], scroll_1 = _a5[1], capacity = _a5[2];
      var elementScroll = scroll_1 - capacity - directionFactor * position;
      if (position || elementScroll) {
        if (elementCouldBeScrolled(axis, target)) {
          availableScroll += elementScroll;
          availableScrollTop += position;
        }
      }
      target = target.parentNode;
    } while (
      // portaled content
      !targetInLock && target !== document.body || // self content
      targetInLock && (endTarget.contains(target) || endTarget === target)
    );
    if (isDeltaPositive && (noOverscroll && availableScroll === 0 || !noOverscroll && delta > availableScroll)) {
      shouldCancelScroll = true;
    } else if (!isDeltaPositive && (noOverscroll && availableScrollTop === 0 || !noOverscroll && -delta > availableScrollTop)) {
      shouldCancelScroll = true;
    }
    return shouldCancelScroll;
  };

  // ../../../node_modules/react-remove-scroll/dist/es2015/SideEffect.js
  var getTouchXY = function(event) {
    return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
  };
  var getDeltaXY = function(event) {
    return [event.deltaX, event.deltaY];
  };
  var extractRef = function(ref) {
    return ref && "current" in ref ? ref.current : ref;
  };
  var deltaCompare = function(x3, y3) {
    return x3[0] === y3[0] && x3[1] === y3[1];
  };
  var generateStyle = function(id) {
    return "\n  .block-interactivity-".concat(id, " {pointer-events: none;}\n  .allow-interactivity-").concat(id, " {pointer-events: all;}\n");
  };
  var idCounter = 0;
  var lockStack = [];
  function RemoveScrollSideCar(props) {
    var shouldPreventQueue = React39.useRef([]);
    var touchStartRef = React39.useRef([0, 0]);
    var activeAxis = React39.useRef();
    var id = React39.useState(idCounter++)[0];
    var Style2 = React39.useState(function() {
      return styleSingleton();
    })[0];
    var lastProps = React39.useRef(props);
    React39.useEffect(function() {
      lastProps.current = props;
    }, [props]);
    React39.useEffect(function() {
      if (props.inert) {
        document.body.classList.add("block-interactivity-".concat(id));
        var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
        allow_1.forEach(function(el) {
          return el.classList.add("allow-interactivity-".concat(id));
        });
        return function() {
          document.body.classList.remove("block-interactivity-".concat(id));
          allow_1.forEach(function(el) {
            return el.classList.remove("allow-interactivity-".concat(id));
          });
        };
      }
      return;
    }, [props.inert, props.lockRef.current, props.shards]);
    var shouldCancelEvent = React39.useCallback(function(event, parent) {
      if ("touches" in event && event.touches.length === 2) {
        return !lastProps.current.allowPinchZoom;
      }
      var touch = getTouchXY(event);
      var touchStart = touchStartRef.current;
      var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
      var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
      var currentAxis;
      var target = event.target;
      var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
      if ("touches" in event && moveDirection === "h" && target.type === "range") {
        return false;
      }
      var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
      if (!canBeScrolledInMainDirection) {
        return true;
      }
      if (canBeScrolledInMainDirection) {
        currentAxis = moveDirection;
      } else {
        currentAxis = moveDirection === "v" ? "h" : "v";
        canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
      }
      if (!canBeScrolledInMainDirection) {
        return false;
      }
      if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
        activeAxis.current = currentAxis;
      }
      if (!currentAxis) {
        return true;
      }
      var cancelingAxis = activeAxis.current || currentAxis;
      return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
    }, []);
    var shouldPrevent = React39.useCallback(function(_event) {
      var event = _event;
      if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
        return;
      }
      var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
      var sourceEvent = shouldPreventQueue.current.filter(function(e2) {
        return e2.name === event.type && e2.target === event.target && deltaCompare(e2.delta, delta);
      })[0];
      if (sourceEvent && sourceEvent.should) {
        if (event.cancelable) {
          event.preventDefault();
        }
        return;
      }
      if (!sourceEvent) {
        var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
          return node.contains(event.target);
        });
        var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
        if (shouldStop) {
          if (event.cancelable) {
            event.preventDefault();
          }
        }
      }
    }, []);
    var shouldCancel = React39.useCallback(function(name, delta, target, should) {
      var event = { name, delta, target, should };
      shouldPreventQueue.current.push(event);
      setTimeout(function() {
        shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
          return e2 !== event;
        });
      }, 1);
    }, []);
    var scrollTouchStart = React39.useCallback(function(event) {
      touchStartRef.current = getTouchXY(event);
      activeAxis.current = void 0;
    }, []);
    var scrollWheel = React39.useCallback(function(event) {
      shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []);
    var scrollTouchMove = React39.useCallback(function(event) {
      shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
    }, []);
    React39.useEffect(function() {
      lockStack.push(Style2);
      props.setCallbacks({
        onScrollCapture: scrollWheel,
        onWheelCapture: scrollWheel,
        onTouchMoveCapture: scrollTouchMove
      });
      document.addEventListener("wheel", shouldPrevent, nonPassive);
      document.addEventListener("touchmove", shouldPrevent, nonPassive);
      document.addEventListener("touchstart", scrollTouchStart, nonPassive);
      return function() {
        lockStack = lockStack.filter(function(inst) {
          return inst !== Style2;
        });
        document.removeEventListener("wheel", shouldPrevent, nonPassive);
        document.removeEventListener("touchmove", shouldPrevent, nonPassive);
        document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
      };
    }, []);
    var removeScrollBar = props.removeScrollBar, inert = props.inert;
    return React39.createElement(
      React39.Fragment,
      null,
      inert ? React39.createElement(Style2, { styles: generateStyle(id) }) : null,
      removeScrollBar ? React39.createElement(RemoveScrollBar, { gapMode: "margin" }) : null
    );
  }

  // ../../../node_modules/react-remove-scroll/dist/es2015/sidecar.js
  var sidecar_default = exportSidecar(effectCar, RemoveScrollSideCar);

  // ../../../node_modules/react-remove-scroll/dist/es2015/Combination.js
  var ReactRemoveScroll = React40.forwardRef(function(props, ref) {
    return React40.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: sidecar_default }));
  });
  ReactRemoveScroll.classNames = RemoveScroll.classNames;
  var Combination_default = ReactRemoveScroll;

  // ../../../node_modules/aria-hidden/dist/es2015/index.js
  var getDefaultParent = function(originalTarget) {
    if (typeof document === "undefined") {
      return null;
    }
    var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
    return sampleTarget.ownerDocument.body;
  };
  var counterMap = /* @__PURE__ */ new WeakMap();
  var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
  var markerMap = {};
  var lockCount = 0;
  var unwrapHost = function(node) {
    return node && (node.host || unwrapHost(node.parentNode));
  };
  var correctTargets = function(parent, targets) {
    return targets.map(function(target) {
      if (parent.contains(target)) {
        return target;
      }
      var correctedTarget = unwrapHost(target);
      if (correctedTarget && parent.contains(correctedTarget)) {
        return correctedTarget;
      }
      console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
      return null;
    }).filter(function(x3) {
      return Boolean(x3);
    });
  };
  var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
    var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
    if (!markerMap[markerName]) {
      markerMap[markerName] = /* @__PURE__ */ new WeakMap();
    }
    var markerCounter = markerMap[markerName];
    var hiddenNodes = [];
    var elementsToKeep = /* @__PURE__ */ new Set();
    var elementsToStop = new Set(targets);
    var keep = function(el) {
      if (!el || elementsToKeep.has(el)) {
        return;
      }
      elementsToKeep.add(el);
      keep(el.parentNode);
    };
    targets.forEach(keep);
    var deep = function(parent) {
      if (!parent || elementsToStop.has(parent)) {
        return;
      }
      Array.prototype.forEach.call(parent.children, function(node) {
        if (elementsToKeep.has(node)) {
          deep(node);
        } else {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        }
      });
    };
    deep(parentNode);
    elementsToKeep.clear();
    lockCount++;
    return function() {
      hiddenNodes.forEach(function(node) {
        var counterValue = counterMap.get(node) - 1;
        var markerValue = markerCounter.get(node) - 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        if (!counterValue) {
          if (!uncontrolledNodes.has(node)) {
            node.removeAttribute(controlAttribute);
          }
          uncontrolledNodes.delete(node);
        }
        if (!markerValue) {
          node.removeAttribute(markerName);
        }
      });
      lockCount--;
      if (!lockCount) {
        counterMap = /* @__PURE__ */ new WeakMap();
        counterMap = /* @__PURE__ */ new WeakMap();
        uncontrolledNodes = /* @__PURE__ */ new WeakMap();
        markerMap = {};
      }
    };
  };
  var hideOthers = function(originalTarget, parentNode, markerName) {
    if (markerName === void 0) {
      markerName = "data-aria-hidden";
    }
    var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
    var activeParentNode = parentNode || getDefaultParent(originalTarget);
    if (!activeParentNode) {
      return function() {
        return null;
      };
    }
    targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
    return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
  };

  // ../../../node_modules/@radix-ui/react-dialog/dist/index.module.js
  var $5d3850c4d0b4e6c7$var$DIALOG_NAME = "Dialog";
  var [$5d3850c4d0b4e6c7$var$createDialogContext, $5d3850c4d0b4e6c7$export$cc702773b8ea3e41] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($5d3850c4d0b4e6c7$var$DIALOG_NAME);
  var [$5d3850c4d0b4e6c7$var$DialogProvider, $5d3850c4d0b4e6c7$var$useDialogContext] = $5d3850c4d0b4e6c7$var$createDialogContext($5d3850c4d0b4e6c7$var$DIALOG_NAME);
  var $5d3850c4d0b4e6c7$export$3ddf2d174ce01153 = (props) => {
    const { __scopeDialog, children, open: openProp, defaultOpen, onOpenChange, modal = true } = props;
    const triggerRef = (0, import_react57.useRef)(null);
    const contentRef = (0, import_react57.useRef)(null);
    const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    return /* @__PURE__ */ (0, import_react57.createElement)($5d3850c4d0b4e6c7$var$DialogProvider, {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
      titleId: $1746a345f3d73bb7$export$f680877a34711e37(),
      descriptionId: $1746a345f3d73bb7$export$f680877a34711e37(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: (0, import_react57.useCallback)(
        () => setOpen(
          (prevOpen) => !prevOpen
        ),
        [
          setOpen
        ]
      ),
      modal
    }, children);
  };
  var $5d3850c4d0b4e6c7$var$PORTAL_NAME = "DialogPortal";
  var [$5d3850c4d0b4e6c7$var$PortalProvider, $5d3850c4d0b4e6c7$var$usePortalContext] = $5d3850c4d0b4e6c7$var$createDialogContext($5d3850c4d0b4e6c7$var$PORTAL_NAME, {
    forceMount: void 0
  });
  var $5d3850c4d0b4e6c7$export$dad7c95542bacce0 = (props) => {
    const { __scopeDialog, forceMount, children, container } = props;
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$PORTAL_NAME, __scopeDialog);
    return /* @__PURE__ */ (0, import_react57.createElement)($5d3850c4d0b4e6c7$var$PortalProvider, {
      scope: __scopeDialog,
      forceMount
    }, import_react57.Children.map(
      children,
      (child) => /* @__PURE__ */ (0, import_react57.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: forceMount || context.open
      }, /* @__PURE__ */ (0, import_react57.createElement)($f1701beae083dbae$export$602eac185826482c, {
        asChild: true,
        container
      }, child))
    ));
  };
  var $5d3850c4d0b4e6c7$var$OVERLAY_NAME = "DialogOverlay";
  var $5d3850c4d0b4e6c7$export$bd1d06c79be19e17 = /* @__PURE__ */ (0, import_react57.forwardRef)((props, forwardedRef) => {
    const portalContext = $5d3850c4d0b4e6c7$var$usePortalContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, props.__scopeDialog);
    const _a5 = props, { forceMount = portalContext.forceMount } = _a5, overlayProps = __objRest(_a5, ["forceMount"]);
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, props.__scopeDialog);
    return context.modal ? /* @__PURE__ */ (0, import_react57.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
      present: forceMount || context.open
    }, /* @__PURE__ */ (0, import_react57.createElement)($5d3850c4d0b4e6c7$var$DialogOverlayImpl, _extends({}, overlayProps, {
      ref: forwardedRef
    }))) : null;
  });
  var $5d3850c4d0b4e6c7$var$DialogOverlayImpl = /* @__PURE__ */ (0, import_react57.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeDialog } = _a5, overlayProps = __objRest(_a5, ["__scopeDialog"]);
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ (0, import_react57.createElement)(Combination_default, {
        as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
        allowPinchZoom: true,
        shards: [
          context.contentRef
        ]
      }, /* @__PURE__ */ (0, import_react57.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
        "data-state": $5d3850c4d0b4e6c7$var$getState(context.open)
      }, overlayProps, {
        ref: forwardedRef,
        style: __spreadValues({
          pointerEvents: "auto"
        }, overlayProps.style)
      })))
    );
  });
  var $5d3850c4d0b4e6c7$var$CONTENT_NAME = "DialogContent";
  var $5d3850c4d0b4e6c7$export$b6d9565de1e068cf = /* @__PURE__ */ (0, import_react57.forwardRef)((props, forwardedRef) => {
    const portalContext = $5d3850c4d0b4e6c7$var$usePortalContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
    const _a5 = props, { forceMount = portalContext.forceMount } = _a5, contentProps = __objRest(_a5, ["forceMount"]);
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
    return /* @__PURE__ */ (0, import_react57.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
      present: forceMount || context.open
    }, context.modal ? /* @__PURE__ */ (0, import_react57.createElement)($5d3850c4d0b4e6c7$var$DialogContentModal, _extends({}, contentProps, {
      ref: forwardedRef
    })) : /* @__PURE__ */ (0, import_react57.createElement)($5d3850c4d0b4e6c7$var$DialogContentNonModal, _extends({}, contentProps, {
      ref: forwardedRef
    })));
  });
  var $5d3850c4d0b4e6c7$var$DialogContentModal = /* @__PURE__ */ (0, import_react57.forwardRef)((props, forwardedRef) => {
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
    const contentRef = (0, import_react57.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.contentRef, contentRef);
    (0, import_react57.useEffect)(() => {
      const content = contentRef.current;
      if (content)
        return hideOthers(content);
    }, []);
    return /* @__PURE__ */ (0, import_react57.createElement)($5d3850c4d0b4e6c7$var$DialogContentImpl, _extends({}, props, {
      ref: composedRefs,
      trapFocus: context.open,
      disableOutsidePointerEvents: true,
      onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event) => {
        var _context$triggerRef$c;
        event.preventDefault();
        (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();
      }),
      onPointerDownOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownOutside, (event) => {
        const originalEvent = event.detail.originalEvent;
        const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
        const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
        if (isRightClick)
          event.preventDefault();
      }),
      onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
        props.onFocusOutside,
        (event) => event.preventDefault()
      )
    }));
  });
  var $5d3850c4d0b4e6c7$var$DialogContentNonModal = /* @__PURE__ */ (0, import_react57.forwardRef)((props, forwardedRef) => {
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, props.__scopeDialog);
    const hasInteractedOutsideRef = (0, import_react57.useRef)(false);
    return /* @__PURE__ */ (0, import_react57.createElement)($5d3850c4d0b4e6c7$var$DialogContentImpl, _extends({}, props, {
      ref: forwardedRef,
      trapFocus: false,
      disableOutsidePointerEvents: false,
      onCloseAutoFocus: (event) => {
        var _props$onCloseAutoFoc;
        (_props$onCloseAutoFoc = props.onCloseAutoFocus) === null || _props$onCloseAutoFoc === void 0 || _props$onCloseAutoFoc.call(props, event);
        if (!event.defaultPrevented) {
          var _context$triggerRef$c2;
          if (!hasInteractedOutsideRef.current)
            (_context$triggerRef$c2 = context.triggerRef.current) === null || _context$triggerRef$c2 === void 0 || _context$triggerRef$c2.focus();
          event.preventDefault();
        }
        hasInteractedOutsideRef.current = false;
      },
      onInteractOutside: (event) => {
        var _props$onInteractOuts, _context$triggerRef$c3;
        (_props$onInteractOuts = props.onInteractOutside) === null || _props$onInteractOuts === void 0 || _props$onInteractOuts.call(props, event);
        if (!event.defaultPrevented)
          hasInteractedOutsideRef.current = true;
        const target = event.target;
        const targetIsTrigger = (_context$triggerRef$c3 = context.triggerRef.current) === null || _context$triggerRef$c3 === void 0 ? void 0 : _context$triggerRef$c3.contains(target);
        if (targetIsTrigger)
          event.preventDefault();
      }
    }));
  });
  var $5d3850c4d0b4e6c7$var$DialogContentImpl = /* @__PURE__ */ (0, import_react57.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus } = _a5, contentProps = __objRest(_a5, ["__scopeDialog", "trapFocus", "onOpenAutoFocus", "onCloseAutoFocus"]);
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CONTENT_NAME, __scopeDialog);
    const contentRef = (0, import_react57.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef);
    $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();
    return /* @__PURE__ */ (0, import_react57.createElement)(import_react57.Fragment, null, /* @__PURE__ */ (0, import_react57.createElement)($d3863c46a17e8a28$export$20e40289641fbbb6, {
      asChild: true,
      loop: true,
      trapped: trapFocus,
      onMountAutoFocus: onOpenAutoFocus,
      onUnmountAutoFocus: onCloseAutoFocus
    }, /* @__PURE__ */ (0, import_react57.createElement)($5cb92bef7577960e$export$177fb62ff3ec1f22, _extends({
      role: "dialog",
      id: context.contentId,
      "aria-describedby": context.descriptionId,
      "aria-labelledby": context.titleId,
      "data-state": $5d3850c4d0b4e6c7$var$getState(context.open)
    }, contentProps, {
      ref: composedRefs,
      onDismiss: () => context.onOpenChange(false)
    }))), false);
  });
  var $5d3850c4d0b4e6c7$var$TITLE_NAME = "DialogTitle";
  var $5d3850c4d0b4e6c7$export$16f7638e4a34b909 = /* @__PURE__ */ (0, import_react57.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeDialog } = _a5, titleProps = __objRest(_a5, ["__scopeDialog"]);
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$TITLE_NAME, __scopeDialog);
    return /* @__PURE__ */ (0, import_react57.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.h2, _extends({
      id: context.titleId
    }, titleProps, {
      ref: forwardedRef
    }));
  });
  var $5d3850c4d0b4e6c7$var$CLOSE_NAME = "DialogClose";
  var $5d3850c4d0b4e6c7$export$fba2fb7cd781b7ac = /* @__PURE__ */ (0, import_react57.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeDialog } = _a5, closeProps = __objRest(_a5, ["__scopeDialog"]);
    const context = $5d3850c4d0b4e6c7$var$useDialogContext($5d3850c4d0b4e6c7$var$CLOSE_NAME, __scopeDialog);
    return /* @__PURE__ */ (0, import_react57.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
      type: "button"
    }, closeProps, {
      ref: forwardedRef,
      onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
        props.onClick,
        () => context.onOpenChange(false)
      )
    }));
  });
  function $5d3850c4d0b4e6c7$var$getState(open) {
    return open ? "open" : "closed";
  }
  var $5d3850c4d0b4e6c7$var$TITLE_WARNING_NAME = "DialogTitleWarning";
  var [$5d3850c4d0b4e6c7$export$69b62a49393917d6, $5d3850c4d0b4e6c7$var$useWarningContext] = $c512c27ab02ef895$export$fd42f52fd3ae1109($5d3850c4d0b4e6c7$var$TITLE_WARNING_NAME, {
    contentName: $5d3850c4d0b4e6c7$var$CONTENT_NAME,
    titleName: $5d3850c4d0b4e6c7$var$TITLE_NAME,
    docsSlug: "dialog"
  });
  var $5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9 = $5d3850c4d0b4e6c7$export$3ddf2d174ce01153;
  var $5d3850c4d0b4e6c7$export$602eac185826482c = $5d3850c4d0b4e6c7$export$dad7c95542bacce0;
  var $5d3850c4d0b4e6c7$export$c6fdb837b070b4ff = $5d3850c4d0b4e6c7$export$bd1d06c79be19e17;
  var $5d3850c4d0b4e6c7$export$7c6e2c02157bb7d2 = $5d3850c4d0b4e6c7$export$b6d9565de1e068cf;

  // ../../../packages/ui/src/lib/components/primitives/Dialog.tsx
  var import_classnames13 = __toESM(require_classnames());

  // ../../../packages/ui/src/lib/components/primitives/Button.tsx
  var import_classnames12 = __toESM(require_classnames());
  var React42 = __toESM(require_react());

  // ../../../packages/ui/src/lib/hooks/useTranslation/useTranslation.tsx
  var React41 = __toESM(require_react());

  // ../../../packages/ui/src/lib/hooks/useAssetUrls.tsx
  var import_react58 = __toESM(require_react());
  var import_jsx_runtime55 = __toESM(require_jsx_runtime());
  var AssetUrlsContext = (0, import_react58.createContext)(null);
  function AssetUrlsProvider({
    assetUrls,
    children
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(AssetUrlsContext.Provider, { value: assetUrls, children });
  }
  function useAssetUrls() {
    const assetUrls = (0, import_react58.useContext)(AssetUrlsContext);
    if (!assetUrls) {
      throw new Error("useAssetUrls must be used within an AssetUrlsProvider");
    }
    return assetUrls;
  }

  // ../../../packages/ui/src/lib/hooks/useTranslation/defaultTranslation.ts
  var DEFAULT_TRANSLATION = {
    "action.convert-to-bookmark": "Convert to Bookmark",
    "action.convert-to-embed": "Convert to Embed",
    "action.open-embed-link": "Open link",
    "action.align-bottom": "Align bottom",
    "action.align-center-horizontal": "Align horizontally",
    "action.align-center-vertical": "Align vertically",
    "action.align-center-horizontal.short": "Align H",
    "action.align-center-vertical.short": "Align V",
    "action.align-left": "Align left",
    "action.align-right": "Align right",
    "action.align-top": "Align top",
    "action.back-to-content": "Back to content",
    "action.bring-forward": "Bring forward",
    "action.bring-to-front": "Bring to front",
    "action.copy-as-json.short": "JSON",
    "action.copy-as-json": "Copy as JSON",
    "action.copy-as-png.short": "PNG",
    "action.copy-as-png": "Copy as PNG",
    "action.copy-as-svg.short": "SVG",
    "action.copy-as-svg": "Copy as SVG",
    "action.copy": "Copy",
    "action.cut": "Cut",
    "action.delete": "Delete",
    "action.distribute-horizontal": "Distribute horizontally",
    "action.distribute-vertical": "Distribute vertically",
    "action.distribute-horizontal.short": "Distribute H",
    "action.distribute-vertical.short": "Distribute V",
    "action.duplicate": "Duplicate",
    "action.edit-link": "Edit link",
    "action.exit-pen-mode": "Exit pen mode",
    "action.export-as-json.short": "JSON",
    "action.export-as-json": "Export as JSON",
    "action.export-as-png.short": "PNG",
    "action.export-as-png": "Export as PNG",
    "action.export-as-svg.short": "SVG",
    "action.export-as-svg": "Export as SVG",
    "action.flip-horizontal": "Flip horizontally",
    "action.flip-vertical": "Flip vertically",
    "action.flip-horizontal.short": "Flip H",
    "action.flip-vertical.short": "Flip V",
    "action.group": "Group",
    "action.insert-embed": "Insert embed",
    "action.insert-media": "Upload media",
    "action.new-project": "New project",
    "action.new-shared-project": "New shared project",
    "action.open-file": "Open file",
    "action.pack": "Pack",
    "action.paste": "Paste",
    "action.print": "Print",
    "action.redo": "Redo",
    "action.rotate-ccw": "Rotate counterclockwise",
    "action.rotate-cw": "Rotate clockwise",
    "action.save-copy": "Save a copy",
    "action.select-all": "Select all",
    "action.select-none": "Select none",
    "action.send-backward": "Send backward",
    "action.send-to-back": "Send to back",
    "action.share-project": "Share this project",
    "action.stack-horizontal": "Stack horizontally",
    "action.stack-vertical": "Stack vertically",
    "action.stack-horizontal.short": "Stack H",
    "action.stack-vertical.short": "Stack V",
    "action.stop-following": "Stop following",
    "action.stretch-horizontal": "Stretch horizontally",
    "action.stretch-vertical": "Stretch vertically",
    "action.stretch-horizontal.short": "Stretch H",
    "action.stretch-vertical.short": "Stretch V",
    "action.toggle-auto-size": "Toggle auto size",
    "action.toggle-dark-mode.menu": "Dark mode",
    "action.toggle-dark-mode": "Toggle dark mode",
    "action.toggle-debug-mode.menu": "Debug mode",
    "action.toggle-debug-mode": "Toggle debug mode",
    "action.toggle-focus-mode.menu": "Focus mode",
    "action.toggle-focus-mode": "Toggle focus mode",
    "action.toggle-grid.menu": "Show grid",
    "action.toggle-grid": "Toggle grid",
    "action.toggle-snap-mode.menu": "Always snap",
    "action.toggle-snap-mode": "Toggle always snap",
    "action.toggle-tool-lock.menu": "Tool lock",
    "action.toggle-tool-lock": "Toggle tool lock",
    "action.toggle-transparent.context-menu": "Transparent",
    "action.toggle-transparent.menu": "Transparent",
    "action.toggle-transparent": "Toggle transparent background",
    "action.undo": "Undo",
    "action.ungroup": "Ungroup",
    "action.zoom-in": "Zoom in",
    "action.zoom-out": "Zoom out",
    "action.zoom-to-100": "Zoom to 100%",
    "action.zoom-to-fit": "Zoom to fit",
    "action.zoom-to-selection": "Zoom to selection",
    "color-style.black": "Black",
    "color-style.blue": "Blue",
    "color-style.green": "Green",
    "color-style.grey": "Grey",
    "color-style.light-blue": "Light blue",
    "color-style.light-green": "Light green",
    "color-style.light-red": "Light red",
    "color-style.light-violet": "Light violet",
    "color-style.orange": "Orange",
    "color-style.red": "Red",
    "color-style.violet": "Violet",
    "color-style.yellow": "Yellow",
    "fill-style.none": "None",
    "fill-style.semi": "Semi",
    "fill-style.solid": "Solid",
    "fill-style.pattern": "Pattern",
    "dash-style.dashed": "Dashed",
    "dash-style.dotted": "Dotted",
    "dash-style.draw": "Draw",
    "dash-style.solid": "Solid",
    "size-style.s": "Small",
    "size-style.m": "Medium",
    "size-style.l": "Large",
    "size-style.xl": "Extra large",
    "opacity-style.0.1": "10%",
    "opacity-style.0.25": "25%",
    "opacity-style.0.5": "50%",
    "opacity-style.0.75": "75%",
    "opacity-style.1": "100%",
    "font-style.draw": "Draw",
    "font-style.sans": "Sans",
    "font-style.serif": "Serif",
    "font-style.mono": "Mono",
    "align-style.start": "Start",
    "align-style.middle": "Middle",
    "align-style.end": "End",
    "align-style.justify": "Justify",
    "geo-style.arrow-down": "Arrow down",
    "geo-style.arrow-left": "Arrow left",
    "geo-style.arrow-right": "Arrow right",
    "geo-style.arrow-up": "Arrow up",
    "geo-style.diamond": "Diamond",
    "geo-style.ellipse": "Ellipse",
    "geo-style.hexagon": "Hexagon",
    "geo-style.octagon": "Octagon",
    "geo-style.oval": "Oval",
    "geo-style.pentagon": "Pentagon",
    "geo-style.rectangle": "Rectangle",
    "geo-style.rhombus-2": "Rhombus 2",
    "geo-style.rhombus": "Rhombus",
    "geo-style.star": "Star",
    "geo-style.trapezoid": "Trapezoid",
    "geo-style.triangle": "Triangle",
    "geo-style.x-box": "X box",
    "geo-style.check-box": "Check box",
    "arrowheadStart-style.none": "None",
    "arrowheadStart-style.arrow": "Arrow",
    "arrowheadStart-style.bar": "Bar",
    "arrowheadStart-style.diamond": "Diamond",
    "arrowheadStart-style.dot": "Dot",
    "arrowheadStart-style.inverted": "Inverted",
    "arrowheadStart-style.pipe": "Pipe",
    "arrowheadStart-style.square": "Square",
    "arrowheadStart-style.triangle": "Triangle",
    "arrowheadEnd-style.none": "None",
    "arrowheadEnd-style.arrow": "Arrow",
    "arrowheadEnd-style.bar": "Bar",
    "arrowheadEnd-style.diamond": "Diamond",
    "arrowheadEnd-style.dot": "Dot",
    "arrowheadEnd-style.inverted": "Inverted",
    "arrowheadEnd-style.pipe": "Pipe",
    "arrowheadEnd-style.square": "Square",
    "arrowheadEnd-style.triangle": "Triangle",
    "spline-style.line": "Line",
    "spline-style.cubic": "Cubic",
    "tool.select": "Select",
    "tool.hand": "Hand",
    "tool.draw": "Draw",
    "tool.eraser": "Eraser",
    "tool.arrow-down": "Arrow down",
    "tool.arrow-left": "Arrow left",
    "tool.arrow-right": "Arrow right",
    "tool.arrow-up": "Arrow up",
    "tool.arrow": "Arrow",
    "tool.diamond": "Diamond",
    "tool.ellipse": "Ellipse",
    "tool.hexagon": "Hexagon",
    "tool.line": "Line",
    "tool.octagon": "Octagon",
    "tool.oval": "Oval",
    "tool.pentagon": "Pentagon",
    "tool.rectangle": "Rectangle",
    "tool.rhombus": "Rhombus",
    "tool.star": "Star",
    "tool.trapezoid": "Trapezoid",
    "tool.triangle": "Triangle",
    "tool.x-box": "X box",
    "tool.check-box": "Check box",
    "tool.asset": "Asset",
    "tool.frame": "Frame",
    "tool.note": "Note",
    "tool.embed": "Embed",
    "tool.text": "Text",
    "menu.title": "Menu",
    "menu.copy-as": "Copy as",
    "menu.edit": "Edit",
    "menu.export-as": "Export as",
    "menu.file": "File",
    "menu.language": "Language",
    "menu.preferences": "Preferences",
    "menu.view": "View",
    "context-menu.arrange": "Arrange",
    "context-menu.copy-as": "Copy as",
    "context-menu.export-as": "Export as",
    "context-menu.move-to-page": "Move to page",
    "context-menu.reorder": "Reorder",
    "page-menu.title": "Pages",
    "page-menu.create-new-page": "Create new page",
    "page-menu.max-page-count-reached": "Max pages reached",
    "page-menu.new-page-initial-name": "Page 1",
    "page-menu.edit-start": "Edit",
    "page-menu.edit-done": "Done",
    "page-menu.go-to-page": "Go to page",
    "page-menu.submenu.rename": "Rename",
    "page-menu.submenu.duplicate-page": "Duplicate",
    "page-menu.submenu.title": "Menu",
    "page-menu.submenu.move-down": "Move down",
    "page-menu.submenu.move-up": "Move up",
    "page-menu.submenu.delete": "Delete",
    "share-menu.title": "Share",
    "share-menu.save-note": "Download this project to your computer as a .tldr file.",
    "share-menu.fork-note": "Create a new shared project based on this snapshot.",
    "share-menu.share-project": "Share this project",
    "share-menu.copy-link": "Copy share link",
    "share-menu.readonly-link": "Read-only",
    "share-menu.create-snapshot-link": "Copy snapshot link",
    "share-menu.snapshot-link-note": "Capture and share this project as a read-only snapshot link.",
    "share-menu.copy-readonly-link": "Copy read-only link",
    "share-menu.offline-note": "Create a new shared project based on your current project.",
    "share-menu.copy-link-note": "Anyone with the link will be able to view and edit this project.",
    "share-menu.copy-readonly-link-note": "Anyone with the link will be able to view (but not edit) this project.",
    "share-menu.project-too-large": "Sorry, this project can't be shared because it's too large. We're working on it!",
    "share-menu.upload-failed": "Sorry, we couldn't upload your project at the moment. Please try again or let us know if the problem persists.",
    "people-menu.title": "People",
    "people-menu.change-name": "Change name",
    "people-menu.change-color": "Change color",
    "people-menu.follow": "Following",
    "people-menu.following": "Following",
    "people-menu.leading": "Following You",
    "people-menu.user": "(You)",
    "people-menu.invite": "Invite others",
    "help-menu.title": "Help and resources",
    "help-menu.about": "About",
    "help-menu.discord": "Discord",
    "help-menu.github": "GitHub",
    "help-menu.keyboard-shortcuts": "Keyboard shortcuts",
    "help-menu.twitter": "Twitter",
    "actions-menu.title": "Actions",
    "edit-link-dialog.title": "Edit link",
    "edit-link-dialog.invalid-url": "A link must be a valid URL.",
    "edit-link-dialog.detail": "Links will open in a new tab.",
    "edit-link-dialog.url": "URL",
    "edit-link-dialog.clear": "Clear",
    "edit-link-dialog.save": "Continue",
    "edit-link-dialog.cancel": "Cancel",
    "embed-dialog.title": "Insert embed",
    "embed-dialog.back": "Back",
    "embed-dialog.create": "Create",
    "embed-dialog.cancel": "Cancel",
    "embed-dialog.url": "URL",
    "embed-dialog.instruction": "Paste in the site's URL to create the embed.",
    "embed-dialog.invalid-url": "We could not create an embed from that URL.",
    "edit-pages-dialog.move-down": "Move down",
    "edit-pages-dialog.move-up": "Move up",
    "shortcuts-dialog.title": "Keyboard shortcuts",
    "shortcuts-dialog.edit": "Edit",
    "shortcuts-dialog.file": "File",
    "shortcuts-dialog.preferences": "Preferences",
    "shortcuts-dialog.tools": "Tools",
    "shortcuts-dialog.transform": "Transform",
    "shortcuts-dialog.view": "View",
    "style-panel.title": "Styles",
    "style-panel.align": "Align",
    "style-panel.position": "Position",
    "style-panel.arrowheads": "Arrowheads",
    "style-panel.arrowhead-start": "Start",
    "style-panel.arrowhead-end": "End",
    "style-panel.color": "Color",
    "style-panel.dash": "Dash",
    "style-panel.fill": "Fill",
    "style-panel.font": "Font",
    "style-panel.geo": "Shape",
    "style-panel.mixed": "Mixed",
    "style-panel.opacity": "Opacity",
    "style-panel.size": "Size",
    "style-panel.spline": "Spline",
    "tool-panel.drawing": "Drawing",
    "tool-panel.shapes": "Shapes",
    "tool-panel.more": "More",
    "debug-panel.more": "More",
    "navigation-zone.toggle-minimap": "Toggle minimap",
    "navigation-zone.zoom": "Zoom",
    "focus-mode.toggle-focus-mode": "Toggle focus mode",
    "toast.close": "Close",
    "file-system.file-open-error.title": "Could not open file",
    "file-system.file-open-error.not-a-tldraw-file": "The file you tried to open doesn't look like a tldraw file.",
    "file-system.file-open-error.file-format-version-too-new": "The file you tried to open is from a newer version of tldraw. Please reload the page and try again.",
    "file-system.file-open-error.generic-corrupted-file": "The file you tried to open is corrupted.",
    "file-system.confirm-open.title": "Overwrite current project?",
    "file-system.confirm-open.description": "Opening a file will replace your current project and any unsaved changes will be lost. Are you sure you want to continue?",
    "file-system.confirm-open.cancel": "Cancel",
    "file-system.confirm-open.open": "Open file",
    "file-system.confirm-open.dont-show-again": "Don't ask again",
    "file-system.confirm-clear.title": "Clear current project?",
    "file-system.confirm-clear.description": "Creating a new project will clear your current project and any unsaved changes will be lost. Are you sure you want to continue?",
    "file-system.confirm-clear.cancel": "Cancel",
    "file-system.confirm-clear.continue": "Continue",
    "file-system.confirm-clear.dont-show-again": "Don't ask again",
    "file-system.shared-document-file-open-error.title": "Could not open file",
    "file-system.shared-document-file-open-error.description": "Opening files from shared projects is not supported.",
    "toast.error.export-fail.title": "Failed export",
    "toast.error.export-fail.desc": "Failed to export image",
    "toast.error.copy-fail.title": "Failed copy",
    "toast.error.copy-fail.desc": "Failed to copy image",
    "context.pages.new-page": "New page",
    "vscode.file-open.desc": "We've updated this document to work with the current version of tldraw. If you'd like to keep the original version (which will work on old.tldraw.com), click below to create a backup.",
    "vscode.file-open.open": "Continue",
    "vscode.file-open.backup": "Backup",
    "vscode.file-open.backup-saved": "Backup saved",
    "vscode.file-open.backup-failed": "Backup failed: this is not a .tldr file.",
    "vscode.file-open.dont-show-again": "Don't ask again"
  };

  // ../../../packages/ui/src/lib/hooks/useTranslation/languages.ts
  var LANGUAGES2 = [
    { locale: "ar", label: "\u0639\u0631\u0628\u064A" },
    { locale: "ca", label: "Catal\xE0" },
    { locale: "da", label: "Danish" },
    { locale: "de", label: "Deutsch" },
    { locale: "en", label: "English" },
    { locale: "es", label: "Espa\xF1ol" },
    { locale: "fa", label: "\u0641\u0627\u0631\u0633\u06CC" },
    { locale: "fi", label: "Suomi" },
    { locale: "fr", label: "Fran\xE7ais" },
    { locale: "gl", label: "Galego" },
    { locale: "he", label: "\u05E2\u05D1\u05E8\u05D9\u05EA" },
    { locale: "it", label: "Italiano" },
    { locale: "ja", label: "\u65E5\u672C\u8A9E" },
    { locale: "ko-kr", label: "\uD55C\uAD6D\uC5B4" },
    { locale: "ku", label: "\u06A9\u0648\u0631\u062F\u06CC" },
    { locale: "hi-in", label: "\u0939\u093F\u0928\u094D\u0926\u0940" },
    { locale: "hu", label: "Magyar" },
    { locale: "my", label: "\u1019\u103C\u1014\u103A\u1019\u102C\u1005\u102C" },
    { locale: "ne", label: "\u0928\u0947\u092A\u093E\u0932\u0940" },
    { locale: "no", label: "Norwegian" },
    { locale: "pl", label: "Polski" },
    { locale: "pt-br", label: "Portugu\xEAs - Brasil" },
    { locale: "pt-pt", label: "Portugu\xEAs - Europeu" },
    { locale: "ro", label: "Rom\xE2n\u0103" },
    { locale: "ru", label: "Russian" },
    { locale: "sv", label: "Svenska" },
    { locale: "te", label: "\u0C24\u0C46\u0C32\u0C41\u0C17\u0C41" },
    { locale: "th", label: "\u0E20\u0E32\u0E29\u0E32\u0E44\u0E17\u0E22" },
    { locale: "tr", label: "T\xFCrk\xE7e" },
    { locale: "uk", label: "Ukrainian" },
    { locale: "vi", label: "Ti\u1EBFng Vi\u1EC7t" },
    { locale: "zh-cn", label: "Chinese - Simplified" },
    { locale: "zh-tw", label: "\u7E41\u9AD4\u4E2D\u6587 (\u53F0\u7063)" }
  ];

  // ../../../packages/ui/src/lib/hooks/useTranslation/translations.ts
  var EN_TRANSLATION = {
    locale: "en",
    label: "English",
    messages: DEFAULT_TRANSLATION
  };
  function fetchTranslation(locale, assetUrls) {
    return __async(this, null, function* () {
      const mainRes = yield fetch(assetUrls.translations.en);
      if (!mainRes.ok) {
        console.warn(`No main translations found.`);
        return EN_TRANSLATION;
      }
      if (locale === "en") {
        return EN_TRANSLATION;
      }
      const language = LANGUAGES2.find((t4) => t4.locale === locale);
      if (!language) {
        console.warn(`No translation found for locale ${locale}`);
        return EN_TRANSLATION;
      }
      const res = yield fetch(assetUrls.translations[language.locale]);
      const messages = yield res.json();
      if (!messages) {
        console.warn(`No messages found for locale ${locale}`);
        return EN_TRANSLATION;
      }
      const missing = [];
      for (const key in EN_TRANSLATION) {
        if (!messages[key]) {
          missing.push(key);
        }
      }
      if (missing.length > 0 && false) {
        console.warn(`Language ${locale}: missing messages for keys:
${missing.join("\n")}`);
      }
      return {
        locale,
        label: language.label,
        messages: __spreadValues(__spreadValues({}, EN_TRANSLATION.messages), messages)
      };
    });
  }
  function getTranslation(locale, assetUrls) {
    return __async(this, null, function* () {
      return yield fetchTranslation(locale, assetUrls);
    });
  }

  // ../../../packages/ui/src/lib/hooks/useTranslation/useTranslation.tsx
  var import_jsx_runtime56 = __toESM(require_jsx_runtime());
  var TranslationsContext = React41.createContext({});
  var useCurrentTranslation = () => React41.useContext(TranslationsContext);
  var TranslationProvider = track(function TranslationProvider2({
    overrides,
    children
  }) {
    const app = useApp();
    const locale = app.userSettings.locale;
    const getAssetUrl = useAssetUrls();
    const [currentTranslation, setCurrentTranslation] = React41.useState(() => {
      if (overrides && overrides["en"]) {
        return {
          locale: "en",
          label: "English",
          messages: __spreadValues(__spreadValues({}, DEFAULT_TRANSLATION), overrides["en"])
        };
      }
      return {
        locale: "en",
        label: "English",
        messages: DEFAULT_TRANSLATION
      };
    });
    React41.useEffect(() => {
      let isCancelled = false;
      function loadTranslation() {
        return __async(this, null, function* () {
          const translation = yield getTranslation(locale, getAssetUrl);
          if (translation && !isCancelled) {
            if (overrides && overrides[locale]) {
              setCurrentTranslation(__spreadProps(__spreadValues({}, translation), {
                messages: __spreadValues(__spreadValues({}, translation.messages), overrides[locale])
              }));
            } else {
              setCurrentTranslation(translation);
            }
          }
        });
      }
      loadTranslation();
      return () => {
        isCancelled = true;
      };
    }, [getAssetUrl, locale, overrides]);
    return /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(TranslationsContext.Provider, { value: currentTranslation, children });
  });
  function useTranslation() {
    const translation = useCurrentTranslation();
    return React41.useCallback(
      function msg2(id) {
        var _a5;
        return (_a5 = translation.messages[id]) != null ? _a5 : id;
      },
      [translation]
    );
  }

  // ../../../packages/ui/src/lib/components/Spinner.tsx
  var import_jsx_runtime57 = __toESM(require_jsx_runtime());
  function Spinner(props) {
    return /* @__PURE__ */ (0, import_jsx_runtime57.jsx)("svg", __spreadProps(__spreadValues({ width: 16, height: 16, viewBox: "0 0 16 16" }, props), { children: /* @__PURE__ */ (0, import_jsx_runtime57.jsxs)("g", { strokeWidth: 2, fill: "none", fillRule: "evenodd", children: [
      /* @__PURE__ */ (0, import_jsx_runtime57.jsx)("circle", { strokeOpacity: 0.25, cx: 8, cy: 8, r: 7, stroke: "currentColor" }),
      /* @__PURE__ */ (0, import_jsx_runtime57.jsx)("path", { strokeLinecap: "round", d: "M15 8c0-4.5-4.5-7-7-7", stroke: "currentColor", children: /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(
        "animateTransform",
        {
          attributeName: "transform",
          type: "rotate",
          from: "0 8 8",
          to: "360 8 8",
          dur: "1s",
          repeatCount: "indefinite"
        }
      ) })
    ] }) }));
  }

  // ../../../packages/ui/src/lib/components/primitives/Icon.tsx
  var import_classnames11 = __toESM(require_classnames());
  var import_react59 = __toESM(require_react());
  var import_jsx_runtime58 = __toESM(require_jsx_runtime());
  var Icon = (0, import_react59.memo)(function Icon2(_a5) {
    var _b2 = _a5, {
      small,
      invertIcon,
      icon,
      color,
      className
    } = _b2, props = __objRest(_b2, [
      "small",
      "invertIcon",
      "icon",
      "color",
      "className"
    ]);
    const assetUrls = useAssetUrls();
    const asset = assetUrls.icons[icon];
    const ref = (0, import_react59.useRef)(null);
    (0, import_react59.useLayoutEffect)(() => {
      if (ref == null ? void 0 : ref.current) {
        ref.current.style.webkitMask = `url(${asset}) center 100% / 100% no-repeat`;
      }
    }, [ref, asset]);
    return /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(
      "div",
      __spreadProps(__spreadValues({}, props), {
        ref,
        className: (0, import_classnames11.default)("tlui-icon", { "tlui-icon__small": small }, className),
        style: {
          color,
          mask: `url(${asset}) center 100% / 100% no-repeat`,
          transform: invertIcon ? "scale(-1, 1)" : void 0
        }
      })
    );
  });

  // ../../../packages/ui/src/lib/components/primitives/shared.ts
  var isDarwin = typeof window === "undefined" ? false : window.navigator.userAgent.toLowerCase().indexOf("mac") > -1;
  var cmdKey = isDarwin ? "\u2318" : "Ctrl";
  var altKey = isDarwin ? "\u2325" : "Alt";
  function kbd(str) {
    return str.split(",")[0].split("").map((sub) => {
      const subStr = sub.replace(/\$/g, cmdKey).replace(/\?/g, altKey).replace(/!/g, "\u21E7");
      return subStr[0].toUpperCase() + subStr.slice(1);
    });
  }
  function kbdStr(str) {
    return "\u2014 " + str.split(",")[0].split("").map((sub) => {
      const subStr = sub.replace(/\$/g, cmdKey).replace(/\?/g, altKey).replace(/!/g, "\u21E7");
      return subStr[0].toUpperCase() + subStr.slice(1);
    }).join("\u2009");
  }
  var getBaseUrl = () => {
    if (typeof process === "undefined") {
      return "http://localhost:5420";
    }
    if (false) {
      return "http://localhost:3000";
    }
    if (process.env.NEXT_PUBLIC_VERCEL_ENV === "production") {
      return "https://www.tldraw.com";
    }
    if (process.env.NEXT_PUBLIC_VERCEL_ENV === "preview") {
      return `https://${process.env.NEXT_PUBLIC_VERCEL_URL}`;
    }
    return "http://localhost:3000";
  };
  var BASE_URL = getBaseUrl();

  // ../../../packages/ui/src/lib/components/primitives/Kbd.tsx
  var import_jsx_runtime59 = __toESM(require_jsx_runtime());
  function Kbd({ children }) {
    return /* @__PURE__ */ (0, import_jsx_runtime59.jsx)("kbd", { className: "tlui-kbd", children: kbd(children).map((k2, i3) => /* @__PURE__ */ (0, import_jsx_runtime59.jsx)("span", { children: k2 }, i3)) });
  }

  // ../../../packages/ui/src/lib/components/primitives/Button.tsx
  var import_jsx_runtime60 = __toESM(require_jsx_runtime());
  var Button = React42.forwardRef(function Button2(_a5, ref) {
    var _b2 = _a5, {
      label,
      icon,
      invertIcon,
      iconLeft,
      smallIcon,
      kbd: kbd2,
      isChecked = false,
      type = "normal",
      children,
      spinner
    } = _b2, props = __objRest(_b2, [
      "label",
      "icon",
      "invertIcon",
      "iconLeft",
      "smallIcon",
      "kbd",
      "isChecked",
      "type",
      "children",
      "spinner"
    ]);
    var _a6;
    const msg2 = useTranslation();
    const labelStr = label ? msg2(label) : "";
    return /* @__PURE__ */ (0, import_jsx_runtime60.jsxs)(
      "button",
      __spreadProps(__spreadValues({
        ref,
        draggable: false,
        type: "button"
      }, props), {
        title: (_a6 = props.title) != null ? _a6 : labelStr,
        className: (0, import_classnames12.default)("tlui-button", `tlui-button__${type}`, props.className),
        children: [
          iconLeft && /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(Icon, { icon: iconLeft, className: "tlui-icon-left", small: true }),
          children,
          label && /* @__PURE__ */ (0, import_jsx_runtime60.jsxs)("span", { draggable: false, children: [
            labelStr,
            isChecked && /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(Icon, { icon: "check" })
          ] }),
          kbd2 && /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(Kbd, { children: kbd2 }),
          icon && !spinner && /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(Icon, { icon, small: !!label || smallIcon, invertIcon }),
          spinner && /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(Spinner, {})
        ]
      })
    );
  });

  // ../../../packages/ui/src/lib/components/primitives/Dialog.tsx
  var import_jsx_runtime61 = __toESM(require_jsx_runtime());
  function Header({ className, children }) {
    return /* @__PURE__ */ (0, import_jsx_runtime61.jsx)("div", { className: (0, import_classnames13.default)("tlui-dialog__header", className), children });
  }
  function Title({ className, children }) {
    return /* @__PURE__ */ (0, import_jsx_runtime61.jsx)($5d3850c4d0b4e6c7$export$16f7638e4a34b909, { dir: "ltr", className: (0, import_classnames13.default)("tlui-dialog__header__title", className), children });
  }
  function CloseButton() {
    return /* @__PURE__ */ (0, import_jsx_runtime61.jsx)("div", { className: "tlui-dialog__header__close", children: /* @__PURE__ */ (0, import_jsx_runtime61.jsx)($5d3850c4d0b4e6c7$export$fba2fb7cd781b7ac, { "data-wd": "dialog.close", dir: "ltr", asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(Button, { "aria-label": "Close", onTouchEnd: (e2) => e2.target.click(), children: /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(Icon, { small: true, icon: "cross-2" }) }) }) });
  }
  function Body({
    className,
    children,
    style
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime61.jsx)("div", { className: (0, import_classnames13.default)("tlui-dialog__body", className), style, children });
  }
  function Footer({ className, children }) {
    return /* @__PURE__ */ (0, import_jsx_runtime61.jsx)("div", { className: (0, import_classnames13.default)("tlui-dialog__footer", className), children });
  }

  // ../../../node_modules/@radix-ui/react-dropdown-menu/dist/index.module.js
  var import_react67 = __toESM(require_react());

  // ../../../node_modules/@radix-ui/react-menu/dist/index.module.js
  var import_react66 = __toESM(require_react());

  // ../../../node_modules/@radix-ui/react-collection/dist/index.module.js
  var import_react60 = __toESM(require_react());
  function $e02a7d9cb1dc128c$export$c74125a8e3af6bb2(name) {
    const PROVIDER_NAME = name + "CollectionProvider";
    const [createCollectionContext, createCollectionScope] = $c512c27ab02ef895$export$50c7b4e9d9f19c1(PROVIDER_NAME);
    const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(PROVIDER_NAME, {
      collectionRef: {
        current: null
      },
      itemMap: /* @__PURE__ */ new Map()
    });
    const CollectionProvider = (props) => {
      const { scope, children } = props;
      const ref = import_react60.default.useRef(null);
      const itemMap = import_react60.default.useRef(/* @__PURE__ */ new Map()).current;
      return /* @__PURE__ */ import_react60.default.createElement(CollectionProviderImpl, {
        scope,
        itemMap,
        collectionRef: ref
      }, children);
    };
    /* @__PURE__ */ Object.assign(CollectionProvider, {
      displayName: PROVIDER_NAME
    });
    const COLLECTION_SLOT_NAME = name + "CollectionSlot";
    const CollectionSlot = /* @__PURE__ */ import_react60.default.forwardRef((props, forwardedRef) => {
      const { scope, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.collectionRef);
      return /* @__PURE__ */ import_react60.default.createElement($5e63c961fc1ce211$export$8c6ed5c666ac1360, {
        ref: composedRefs
      }, children);
    });
    /* @__PURE__ */ Object.assign(CollectionSlot, {
      displayName: COLLECTION_SLOT_NAME
    });
    const ITEM_SLOT_NAME = name + "CollectionItemSlot";
    const ITEM_DATA_ATTR = "data-radix-collection-item";
    const CollectionItemSlot = /* @__PURE__ */ import_react60.default.forwardRef((props, forwardedRef) => {
      const _a5 = props, { scope, children } = _a5, itemData = __objRest(_a5, ["scope", "children"]);
      const ref = import_react60.default.useRef(null);
      const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      import_react60.default.useEffect(() => {
        context.itemMap.set(ref, __spreadValues({
          ref
        }, itemData));
        return () => void context.itemMap.delete(ref);
      });
      return /* @__PURE__ */ import_react60.default.createElement($5e63c961fc1ce211$export$8c6ed5c666ac1360, {
        [ITEM_DATA_ATTR]: "",
        ref: composedRefs
      }, children);
    });
    /* @__PURE__ */ Object.assign(CollectionItemSlot, {
      displayName: ITEM_SLOT_NAME
    });
    function useCollection(scope) {
      const context = useCollectionContext(name + "CollectionConsumer", scope);
      const getItems = import_react60.default.useCallback(() => {
        const collectionNode = context.collectionRef.current;
        if (!collectionNode)
          return [];
        const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
        const items = Array.from(context.itemMap.values());
        const orderedItems = items.sort(
          (a3, b3) => orderedNodes.indexOf(a3.ref.current) - orderedNodes.indexOf(b3.ref.current)
        );
        return orderedItems;
      }, [
        context.collectionRef,
        context.itemMap
      ]);
      return getItems;
    }
    return [
      {
        Provider: CollectionProvider,
        Slot: CollectionSlot,
        ItemSlot: CollectionItemSlot
      },
      useCollection,
      createCollectionScope
    ];
  }

  // ../../../node_modules/@radix-ui/react-direction/dist/index.module.js
  var import_react61 = __toESM(require_react());
  var $f631663db3294ace$var$DirectionContext = /* @__PURE__ */ (0, import_react61.createContext)(void 0);
  function $f631663db3294ace$export$b39126d51d94e6f3(localDir) {
    const globalDir = (0, import_react61.useContext)($f631663db3294ace$var$DirectionContext);
    return localDir || globalDir || "ltr";
  }

  // ../../../node_modules/@radix-ui/react-popper/dist/index.module.js
  var import_react64 = __toESM(require_react());

  // ../../../node_modules/@floating-ui/core/dist/floating-ui.core.browser.min.mjs
  function t2(t4) {
    return t4.split("-")[0];
  }
  function e(t4) {
    return t4.split("-")[1];
  }
  function n(e2) {
    return ["top", "bottom"].includes(t2(e2)) ? "x" : "y";
  }
  function r(t4) {
    return "y" === t4 ? "height" : "width";
  }
  function i(i3, o3, a3) {
    let { reference: l3, floating: s3 } = i3;
    const c3 = l3.x + l3.width / 2 - s3.width / 2, f3 = l3.y + l3.height / 2 - s3.height / 2, u3 = n(o3), m3 = r(u3), g3 = l3[m3] / 2 - s3[m3] / 2, d3 = "x" === u3;
    let p3;
    switch (t2(o3)) {
      case "top":
        p3 = { x: c3, y: l3.y - s3.height };
        break;
      case "bottom":
        p3 = { x: c3, y: l3.y + l3.height };
        break;
      case "right":
        p3 = { x: l3.x + l3.width, y: f3 };
        break;
      case "left":
        p3 = { x: l3.x - s3.width, y: f3 };
        break;
      default:
        p3 = { x: l3.x, y: l3.y };
    }
    switch (e(o3)) {
      case "start":
        p3[u3] -= g3 * (a3 && d3 ? -1 : 1);
        break;
      case "end":
        p3[u3] += g3 * (a3 && d3 ? -1 : 1);
    }
    return p3;
  }
  var o = (t4, e2, n3) => __async(void 0, null, function* () {
    const { placement: r3 = "bottom", strategy: o3 = "absolute", middleware: a3 = [], platform: l3 } = n3, s3 = yield null == l3.isRTL ? void 0 : l3.isRTL(e2);
    let c3 = yield l3.getElementRects({ reference: t4, floating: e2, strategy: o3 }), { x: f3, y: u3 } = i(c3, r3, s3), m3 = r3, g3 = {}, d3 = 0;
    for (let n4 = 0; n4 < a3.length; n4++) {
      const { name: p3, fn: h3 } = a3[n4], { x: y3, y: x3, data: w3, reset: v3 } = yield h3({ x: f3, y: u3, initialPlacement: r3, placement: m3, strategy: o3, middlewareData: g3, rects: c3, platform: l3, elements: { reference: t4, floating: e2 } });
      f3 = null != y3 ? y3 : f3, u3 = null != x3 ? x3 : u3, g3 = __spreadProps(__spreadValues({}, g3), { [p3]: __spreadValues(__spreadValues({}, g3[p3]), w3) }), v3 && d3 <= 50 && (d3++, "object" == typeof v3 && (v3.placement && (m3 = v3.placement), v3.rects && (c3 = true === v3.rects ? yield l3.getElementRects({ reference: t4, floating: e2, strategy: o3 }) : v3.rects), { x: f3, y: u3 } = i(c3, m3, s3)), n4 = -1);
    }
    return { x: f3, y: u3, placement: m3, strategy: o3, middlewareData: g3 };
  });
  function a(t4) {
    return "number" != typeof t4 ? function(t5) {
      return __spreadValues({ top: 0, right: 0, bottom: 0, left: 0 }, t5);
    }(t4) : { top: t4, right: t4, bottom: t4, left: t4 };
  }
  function l(t4) {
    return __spreadProps(__spreadValues({}, t4), { top: t4.y, left: t4.x, right: t4.x + t4.width, bottom: t4.y + t4.height });
  }
  function s(t4, e2) {
    return __async(this, null, function* () {
      var n3;
      void 0 === e2 && (e2 = {});
      const { x: r3, y: i3, platform: o3, rects: s3, elements: c3, strategy: f3 } = t4, { boundary: u3 = "clippingAncestors", rootBoundary: m3 = "viewport", elementContext: g3 = "floating", altBoundary: d3 = false, padding: p3 = 0 } = e2, h3 = a(p3), y3 = c3[d3 ? "floating" === g3 ? "reference" : "floating" : g3], x3 = l(yield o3.getClippingRect({ element: null == (n3 = yield null == o3.isElement ? void 0 : o3.isElement(y3)) || n3 ? y3 : y3.contextElement || (yield null == o3.getDocumentElement ? void 0 : o3.getDocumentElement(c3.floating)), boundary: u3, rootBoundary: m3, strategy: f3 })), w3 = l(o3.convertOffsetParentRelativeRectToViewportRelativeRect ? yield o3.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: "floating" === g3 ? __spreadProps(__spreadValues({}, s3.floating), { x: r3, y: i3 }) : s3.reference, offsetParent: yield null == o3.getOffsetParent ? void 0 : o3.getOffsetParent(c3.floating), strategy: f3 }) : s3[g3]);
      return { top: x3.top - w3.top + h3.top, bottom: w3.bottom - x3.bottom + h3.bottom, left: x3.left - w3.left + h3.left, right: w3.right - x3.right + h3.right };
    });
  }
  var c = Math.min;
  var f = Math.max;
  function u(t4, e2, n3) {
    return f(t4, c(e2, n3));
  }
  var m = (t4) => ({ name: "arrow", options: t4, fn(i3) {
    return __async(this, null, function* () {
      const { element: o3, padding: l3 = 0 } = null != t4 ? t4 : {}, { x: s3, y: c3, placement: f3, rects: m3, platform: g3 } = i3;
      if (null == o3)
        return {};
      const d3 = a(l3), p3 = { x: s3, y: c3 }, h3 = n(f3), y3 = e(f3), x3 = r(h3), w3 = yield g3.getDimensions(o3), v3 = "y" === h3 ? "top" : "left", b3 = "y" === h3 ? "bottom" : "right", R3 = m3.reference[x3] + m3.reference[h3] - p3[h3] - m3.floating[x3], A2 = p3[h3] - m3.reference[h3], P2 = yield null == g3.getOffsetParent ? void 0 : g3.getOffsetParent(o3);
      let T3 = P2 ? "y" === h3 ? P2.clientHeight || 0 : P2.clientWidth || 0 : 0;
      0 === T3 && (T3 = m3.floating[x3]);
      const O2 = R3 / 2 - A2 / 2, D3 = d3[v3], L3 = T3 - w3[x3] - d3[b3], k2 = T3 / 2 - w3[x3] / 2 + O2, E3 = u(D3, k2, L3), C2 = ("start" === y3 ? d3[v3] : d3[b3]) > 0 && k2 !== E3 && m3.reference[x3] <= m3.floating[x3];
      return { [h3]: p3[h3] - (C2 ? k2 < D3 ? D3 - k2 : L3 - k2 : 0), data: { [h3]: E3, centerOffset: k2 - E3 } };
    });
  } });
  var g = { left: "right", right: "left", bottom: "top", top: "bottom" };
  function d(t4) {
    return t4.replace(/left|right|bottom|top/g, (t5) => g[t5]);
  }
  function p(t4, i3, o3) {
    void 0 === o3 && (o3 = false);
    const a3 = e(t4), l3 = n(t4), s3 = r(l3);
    let c3 = "x" === l3 ? a3 === (o3 ? "end" : "start") ? "right" : "left" : "start" === a3 ? "bottom" : "top";
    return i3.reference[s3] > i3.floating[s3] && (c3 = d(c3)), { main: c3, cross: d(c3) };
  }
  var h = { start: "end", end: "start" };
  function y(t4) {
    return t4.replace(/start|end/g, (t5) => h[t5]);
  }
  var x = ["top", "right", "bottom", "left"];
  var w = x.reduce((t4, e2) => t4.concat(e2, e2 + "-start", e2 + "-end"), []);
  var b = function(e2) {
    return void 0 === e2 && (e2 = {}), { name: "flip", options: e2, fn(n3) {
      return __async(this, null, function* () {
        var r3;
        const { placement: i3, middlewareData: o3, rects: a3, initialPlacement: l3, platform: c3, elements: f3 } = n3, _a6 = e2, { mainAxis: u3 = true, crossAxis: m3 = true, fallbackPlacements: g3, fallbackStrategy: h3 = "bestFit", flipAlignment: x3 = true } = _a6, w3 = __objRest(_a6, ["mainAxis", "crossAxis", "fallbackPlacements", "fallbackStrategy", "flipAlignment"]), v3 = t2(i3), b3 = g3 || (v3 === l3 || !x3 ? [d(l3)] : function(t4) {
          const e3 = d(t4);
          return [y(t4), e3, y(e3)];
        }(l3)), R3 = [l3, ...b3], A2 = yield s(n3, w3), P2 = [];
        let T3 = (null == (r3 = o3.flip) ? void 0 : r3.overflows) || [];
        if (u3 && P2.push(A2[v3]), m3) {
          const { main: t4, cross: e3 } = p(i3, a3, yield null == c3.isRTL ? void 0 : c3.isRTL(f3.floating));
          P2.push(A2[t4], A2[e3]);
        }
        if (T3 = [...T3, { placement: i3, overflows: P2 }], !P2.every((t4) => t4 <= 0)) {
          var O2, D3;
          const t4 = (null != (O2 = null == (D3 = o3.flip) ? void 0 : D3.index) ? O2 : 0) + 1, e3 = R3[t4];
          if (e3)
            return { data: { index: t4, overflows: T3 }, reset: { placement: e3 } };
          let n4 = "bottom";
          switch (h3) {
            case "bestFit": {
              var L3;
              const t5 = null == (L3 = T3.map((t6) => [t6, t6.overflows.filter((t7) => t7 > 0).reduce((t7, e4) => t7 + e4, 0)]).sort((t6, e4) => t6[1] - e4[1])[0]) ? void 0 : L3[0].placement;
              t5 && (n4 = t5);
              break;
            }
            case "initialPlacement":
              n4 = l3;
          }
          if (i3 !== n4)
            return { reset: { placement: n4 } };
        }
        return {};
      });
    } };
  };
  function R(t4, e2) {
    return { top: t4.top - e2.height, right: t4.right - e2.width, bottom: t4.bottom - e2.height, left: t4.left - e2.width };
  }
  function A(t4) {
    return x.some((e2) => t4[e2] >= 0);
  }
  var P = function(t4) {
    let _a5 = void 0 === t4 ? {} : t4, { strategy: e2 = "referenceHidden" } = _a5, n3 = __objRest(_a5, ["strategy"]);
    return { name: "hide", fn(t5) {
      return __async(this, null, function* () {
        const { rects: r3 } = t5;
        switch (e2) {
          case "referenceHidden": {
            const e3 = R(yield s(t5, __spreadProps(__spreadValues({}, n3), { elementContext: "reference" })), r3.reference);
            return { data: { referenceHiddenOffsets: e3, referenceHidden: A(e3) } };
          }
          case "escaped": {
            const e3 = R(yield s(t5, __spreadProps(__spreadValues({}, n3), { altBoundary: true })), r3.floating);
            return { data: { escapedOffsets: e3, escaped: A(e3) } };
          }
          default:
            return {};
        }
      });
    } };
  };
  var T = function(r3) {
    return void 0 === r3 && (r3 = 0), { name: "offset", options: r3, fn(i3) {
      return __async(this, null, function* () {
        const { x: o3, y: a3 } = i3, l3 = yield function(r4, i4) {
          return __async(this, null, function* () {
            const { placement: o4, platform: a4, elements: l4 } = r4, s3 = yield null == a4.isRTL ? void 0 : a4.isRTL(l4.floating), c3 = t2(o4), f3 = e(o4), u3 = "x" === n(o4), m3 = ["left", "top"].includes(c3) ? -1 : 1, g3 = s3 && u3 ? -1 : 1, d3 = "function" == typeof i4 ? i4(r4) : i4;
            let { mainAxis: p3, crossAxis: h3, alignmentAxis: y3 } = "number" == typeof d3 ? { mainAxis: d3, crossAxis: 0, alignmentAxis: null } : __spreadValues({ mainAxis: 0, crossAxis: 0, alignmentAxis: null }, d3);
            return f3 && "number" == typeof y3 && (h3 = "end" === f3 ? -1 * y3 : y3), u3 ? { x: h3 * g3, y: p3 * m3 } : { x: p3 * m3, y: h3 * g3 };
          });
        }(i3, r3);
        return { x: o3 + l3.x, y: a3 + l3.y, data: l3 };
      });
    } };
  };
  function O(t4) {
    return "x" === t4 ? "y" : "x";
  }
  var D = function(e2) {
    return void 0 === e2 && (e2 = {}), { name: "shift", options: e2, fn(r3) {
      return __async(this, null, function* () {
        const { x: i3, y: o3, placement: a3 } = r3, _a6 = e2, { mainAxis: l3 = true, crossAxis: c3 = false, limiter: f3 = { fn: (t4) => {
          let { x: e3, y: n3 } = t4;
          return { x: e3, y: n3 };
        } } } = _a6, m3 = __objRest(_a6, ["mainAxis", "crossAxis", "limiter"]), g3 = { x: i3, y: o3 }, d3 = yield s(r3, m3), p3 = n(t2(a3)), h3 = O(p3);
        let y3 = g3[p3], x3 = g3[h3];
        if (l3) {
          const t4 = "y" === p3 ? "bottom" : "right";
          y3 = u(y3 + d3["y" === p3 ? "top" : "left"], y3, y3 - d3[t4]);
        }
        if (c3) {
          const t4 = "y" === h3 ? "bottom" : "right";
          x3 = u(x3 + d3["y" === h3 ? "top" : "left"], x3, x3 - d3[t4]);
        }
        const w3 = f3.fn(__spreadProps(__spreadValues({}, r3), { [p3]: y3, [h3]: x3 }));
        return __spreadProps(__spreadValues({}, w3), { data: { x: w3.x - i3, y: w3.y - o3 } });
      });
    } };
  };
  var L = function(e2) {
    return void 0 === e2 && (e2 = {}), { options: e2, fn(r3) {
      const { x: i3, y: o3, placement: a3, rects: l3, middlewareData: s3 } = r3, { offset: c3 = 0, mainAxis: f3 = true, crossAxis: u3 = true } = e2, m3 = { x: i3, y: o3 }, g3 = n(a3), d3 = O(g3);
      let p3 = m3[g3], h3 = m3[d3];
      const y3 = "function" == typeof c3 ? c3(__spreadProps(__spreadValues({}, l3), { placement: a3 })) : c3, x3 = "number" == typeof y3 ? { mainAxis: y3, crossAxis: 0 } : __spreadValues({ mainAxis: 0, crossAxis: 0 }, y3);
      if (f3) {
        const t4 = "y" === g3 ? "height" : "width", e3 = l3.reference[g3] - l3.floating[t4] + x3.mainAxis, n3 = l3.reference[g3] + l3.reference[t4] - x3.mainAxis;
        p3 < e3 ? p3 = e3 : p3 > n3 && (p3 = n3);
      }
      if (u3) {
        var w3, v3, b3, R3;
        const e3 = "y" === g3 ? "width" : "height", n3 = ["top", "left"].includes(t2(a3)), r4 = l3.reference[d3] - l3.floating[e3] + (n3 && null != (w3 = null == (v3 = s3.offset) ? void 0 : v3[d3]) ? w3 : 0) + (n3 ? 0 : x3.crossAxis), i4 = l3.reference[d3] + l3.reference[e3] + (n3 ? 0 : null != (b3 = null == (R3 = s3.offset) ? void 0 : R3[d3]) ? b3 : 0) - (n3 ? x3.crossAxis : 0);
        h3 < r4 ? h3 = r4 : h3 > i4 && (h3 = i4);
      }
      return { [g3]: p3, [d3]: h3 };
    } };
  };
  var k = function(n3) {
    return void 0 === n3 && (n3 = {}), { name: "size", options: n3, fn(r3) {
      return __async(this, null, function* () {
        const { placement: i3, rects: o3, platform: a3, elements: l3 } = r3, _a6 = n3, { apply: c3 } = _a6, u3 = __objRest(_a6, ["apply"]), m3 = yield s(r3, u3), g3 = t2(i3), d3 = e(i3);
        let p3, h3;
        "top" === g3 || "bottom" === g3 ? (p3 = g3, h3 = d3 === ((yield null == a3.isRTL ? void 0 : a3.isRTL(l3.floating)) ? "start" : "end") ? "left" : "right") : (h3 = g3, p3 = "end" === d3 ? "top" : "bottom");
        const y3 = f(m3.left, 0), x3 = f(m3.right, 0), w3 = f(m3.top, 0), v3 = f(m3.bottom, 0), b3 = { availableHeight: o3.floating.height - (["left", "right"].includes(i3) ? 2 * (0 !== w3 || 0 !== v3 ? w3 + v3 : f(m3.top, m3.bottom)) : m3[p3]), availableWidth: o3.floating.width - (["top", "bottom"].includes(i3) ? 2 * (0 !== y3 || 0 !== x3 ? y3 + x3 : f(m3.left, m3.right)) : m3[h3]) }, R3 = yield a3.getDimensions(l3.floating);
        null == c3 || c3(__spreadValues(__spreadValues({}, r3), b3));
        const A2 = yield a3.getDimensions(l3.floating);
        return R3.width !== A2.width || R3.height !== A2.height ? { reset: { rects: true } } : {};
      });
    } };
  };

  // ../../../node_modules/@floating-ui/dom/dist/floating-ui.dom.browser.min.mjs
  function n2(t4) {
    return t4 && t4.document && t4.location && t4.alert && t4.setInterval;
  }
  function o2(t4) {
    if (null == t4)
      return window;
    if (!n2(t4)) {
      const e2 = t4.ownerDocument;
      return e2 && e2.defaultView || window;
    }
    return t4;
  }
  function i2(t4) {
    return o2(t4).getComputedStyle(t4);
  }
  function r2(t4) {
    return n2(t4) ? "" : t4 ? (t4.nodeName || "").toLowerCase() : "";
  }
  function l2() {
    const t4 = navigator.userAgentData;
    return null != t4 && t4.brands ? t4.brands.map((t5) => t5.brand + "/" + t5.version).join(" ") : navigator.userAgent;
  }
  function c2(t4) {
    return t4 instanceof o2(t4).HTMLElement;
  }
  function f2(t4) {
    return t4 instanceof o2(t4).Element;
  }
  function s2(t4) {
    if ("undefined" == typeof ShadowRoot)
      return false;
    return t4 instanceof o2(t4).ShadowRoot || t4 instanceof ShadowRoot;
  }
  function u2(t4) {
    const { overflow: e2, overflowX: n3, overflowY: o3 } = i2(t4);
    return /auto|scroll|overlay|hidden/.test(e2 + o3 + n3);
  }
  function d2(t4) {
    return ["table", "td", "th"].includes(r2(t4));
  }
  function h2(t4) {
    const e2 = /firefox/i.test(l2()), n3 = i2(t4);
    return "none" !== n3.transform || "none" !== n3.perspective || "paint" === n3.contain || ["transform", "perspective"].includes(n3.willChange) || e2 && "filter" === n3.willChange || e2 && !!n3.filter && "none" !== n3.filter;
  }
  function a2() {
    return !/^((?!chrome|android).)*safari/i.test(l2());
  }
  var g2 = Math.min;
  var p2 = Math.max;
  var m2 = Math.round;
  function w2(t4, e2, n3) {
    var i3, r3, l3, s3;
    void 0 === e2 && (e2 = false), void 0 === n3 && (n3 = false);
    const u3 = t4.getBoundingClientRect();
    let d3 = 1, h3 = 1;
    e2 && c2(t4) && (d3 = t4.offsetWidth > 0 && m2(u3.width) / t4.offsetWidth || 1, h3 = t4.offsetHeight > 0 && m2(u3.height) / t4.offsetHeight || 1);
    const g3 = f2(t4) ? o2(t4) : window, p3 = !a2() && n3, w3 = (u3.left + (p3 && null != (i3 = null == (r3 = g3.visualViewport) ? void 0 : r3.offsetLeft) ? i3 : 0)) / d3, v3 = (u3.top + (p3 && null != (l3 = null == (s3 = g3.visualViewport) ? void 0 : s3.offsetTop) ? l3 : 0)) / h3, y3 = u3.width / d3, x3 = u3.height / h3;
    return { width: y3, height: x3, top: v3, right: w3 + y3, bottom: v3 + x3, left: w3, x: w3, y: v3 };
  }
  function v2(t4) {
    return (e2 = t4, (e2 instanceof o2(e2).Node ? t4.ownerDocument : t4.document) || window.document).documentElement;
    var e2;
  }
  function y2(t4) {
    return f2(t4) ? { scrollLeft: t4.scrollLeft, scrollTop: t4.scrollTop } : { scrollLeft: t4.pageXOffset, scrollTop: t4.pageYOffset };
  }
  function x2(t4) {
    return w2(v2(t4)).left + y2(t4).scrollLeft;
  }
  function b2(t4, e2, n3) {
    const o3 = c2(e2), i3 = v2(e2), l3 = w2(t4, o3 && function(t5) {
      const e3 = w2(t5);
      return m2(e3.width) !== t5.offsetWidth || m2(e3.height) !== t5.offsetHeight;
    }(e2), "fixed" === n3);
    let f3 = { scrollLeft: 0, scrollTop: 0 };
    const s3 = { x: 0, y: 0 };
    if (o3 || !o3 && "fixed" !== n3)
      if (("body" !== r2(e2) || u2(i3)) && (f3 = y2(e2)), c2(e2)) {
        const t5 = w2(e2, true);
        s3.x = t5.x + e2.clientLeft, s3.y = t5.y + e2.clientTop;
      } else
        i3 && (s3.x = x2(i3));
    return { x: l3.left + f3.scrollLeft - s3.x, y: l3.top + f3.scrollTop - s3.y, width: l3.width, height: l3.height };
  }
  function L2(t4) {
    return "html" === r2(t4) ? t4 : t4.assignedSlot || t4.parentNode || (s2(t4) ? t4.host : null) || v2(t4);
  }
  function R2(t4) {
    return c2(t4) && "fixed" !== getComputedStyle(t4).position ? t4.offsetParent : null;
  }
  function T2(t4) {
    const e2 = o2(t4);
    let n3 = R2(t4);
    for (; n3 && d2(n3) && "static" === getComputedStyle(n3).position; )
      n3 = R2(n3);
    return n3 && ("html" === r2(n3) || "body" === r2(n3) && "static" === getComputedStyle(n3).position && !h2(n3)) ? e2 : n3 || function(t5) {
      let e3 = L2(t5);
      for (s2(e3) && (e3 = e3.host); c2(e3) && !["html", "body"].includes(r2(e3)); ) {
        if (h2(e3))
          return e3;
        e3 = e3.parentNode;
      }
      return null;
    }(t4) || e2;
  }
  function W(t4) {
    if (c2(t4))
      return { width: t4.offsetWidth, height: t4.offsetHeight };
    const e2 = w2(t4);
    return { width: e2.width, height: e2.height };
  }
  function E2(t4) {
    const e2 = L2(t4);
    return ["html", "body", "#document"].includes(r2(e2)) ? t4.ownerDocument.body : c2(e2) && u2(e2) ? e2 : E2(e2);
  }
  function H(t4, e2) {
    var n3;
    void 0 === e2 && (e2 = []);
    const i3 = E2(t4), r3 = i3 === (null == (n3 = t4.ownerDocument) ? void 0 : n3.body), l3 = o2(i3), c3 = r3 ? [l3].concat(l3.visualViewport || [], u2(i3) ? i3 : []) : i3, f3 = e2.concat(c3);
    return r3 ? f3 : f3.concat(H(c3));
  }
  function C(e2, n3, r3) {
    return "viewport" === n3 ? l(function(t4, e3) {
      const n4 = o2(t4), i3 = v2(t4), r4 = n4.visualViewport;
      let l3 = i3.clientWidth, c3 = i3.clientHeight, f3 = 0, s3 = 0;
      if (r4) {
        l3 = r4.width, c3 = r4.height;
        const t5 = a2();
        (t5 || !t5 && "fixed" === e3) && (f3 = r4.offsetLeft, s3 = r4.offsetTop);
      }
      return { width: l3, height: c3, x: f3, y: s3 };
    }(e2, r3)) : f2(n3) ? function(t4, e3) {
      const n4 = w2(t4, false, "fixed" === e3), o3 = n4.top + t4.clientTop, i3 = n4.left + t4.clientLeft;
      return { top: o3, left: i3, x: i3, y: o3, right: i3 + t4.clientWidth, bottom: o3 + t4.clientHeight, width: t4.clientWidth, height: t4.clientHeight };
    }(n3, r3) : l(function(t4) {
      var e3;
      const n4 = v2(t4), o3 = y2(t4), r4 = null == (e3 = t4.ownerDocument) ? void 0 : e3.body, l3 = p2(n4.scrollWidth, n4.clientWidth, r4 ? r4.scrollWidth : 0, r4 ? r4.clientWidth : 0), c3 = p2(n4.scrollHeight, n4.clientHeight, r4 ? r4.scrollHeight : 0, r4 ? r4.clientHeight : 0);
      let f3 = -o3.scrollLeft + x2(t4);
      const s3 = -o3.scrollTop;
      return "rtl" === i2(r4 || n4).direction && (f3 += p2(n4.clientWidth, r4 ? r4.clientWidth : 0) - l3), { width: l3, height: c3, x: f3, y: s3 };
    }(v2(e2)));
  }
  function S(t4) {
    const e2 = H(t4), n3 = ["absolute", "fixed"].includes(i2(t4).position) && c2(t4) ? T2(t4) : t4;
    return f2(n3) ? e2.filter((t5) => f2(t5) && function(t6, e3) {
      const n4 = null == e3.getRootNode ? void 0 : e3.getRootNode();
      if (t6.contains(e3))
        return true;
      if (n4 && s2(n4)) {
        let n5 = e3;
        do {
          if (n5 && t6 === n5)
            return true;
          n5 = n5.parentNode || n5.host;
        } while (n5);
      }
      return false;
    }(t5, n3) && "body" !== r2(t5)) : [];
  }
  var D2 = { getClippingRect: function(t4) {
    let { element: e2, boundary: n3, rootBoundary: o3, strategy: i3 } = t4;
    const r3 = [..."clippingAncestors" === n3 ? S(e2) : [].concat(n3), o3], l3 = r3[0], c3 = r3.reduce((t5, n4) => {
      const o4 = C(e2, n4, i3);
      return t5.top = p2(o4.top, t5.top), t5.right = g2(o4.right, t5.right), t5.bottom = g2(o4.bottom, t5.bottom), t5.left = p2(o4.left, t5.left), t5;
    }, C(e2, l3, i3));
    return { width: c3.right - c3.left, height: c3.bottom - c3.top, x: c3.left, y: c3.top };
  }, convertOffsetParentRelativeRectToViewportRelativeRect: function(t4) {
    let { rect: e2, offsetParent: n3, strategy: o3 } = t4;
    const i3 = c2(n3), l3 = v2(n3);
    if (n3 === l3)
      return e2;
    let f3 = { scrollLeft: 0, scrollTop: 0 };
    const s3 = { x: 0, y: 0 };
    if ((i3 || !i3 && "fixed" !== o3) && (("body" !== r2(n3) || u2(l3)) && (f3 = y2(n3)), c2(n3))) {
      const t5 = w2(n3, true);
      s3.x = t5.x + n3.clientLeft, s3.y = t5.y + n3.clientTop;
    }
    return __spreadProps(__spreadValues({}, e2), { x: e2.x - f3.scrollLeft + s3.x, y: e2.y - f3.scrollTop + s3.y });
  }, isElement: f2, getDimensions: W, getOffsetParent: T2, getDocumentElement: v2, getElementRects: (t4) => {
    let { reference: e2, floating: n3, strategy: o3 } = t4;
    return { reference: b2(e2, T2(n3), o3), floating: __spreadProps(__spreadValues({}, W(n3)), { x: 0, y: 0 }) };
  }, getClientRects: (t4) => Array.from(t4.getClientRects()), isRTL: (t4) => "rtl" === i2(t4).direction };
  function N(t4, e2, n3, o3) {
    void 0 === o3 && (o3 = {});
    const { ancestorScroll: i3 = true, ancestorResize: r3 = true, elementResize: l3 = true, animationFrame: c3 = false } = o3, s3 = i3 && !c3, u3 = r3 && !c3, d3 = s3 || u3 ? [...f2(t4) ? H(t4) : [], ...H(e2)] : [];
    d3.forEach((t5) => {
      s3 && t5.addEventListener("scroll", n3, { passive: true }), u3 && t5.addEventListener("resize", n3);
    });
    let h3, a3 = null;
    if (l3) {
      let o4 = true;
      a3 = new ResizeObserver(() => {
        o4 || n3(), o4 = false;
      }), f2(t4) && !c3 && a3.observe(t4), a3.observe(e2);
    }
    let g3 = c3 ? w2(t4) : null;
    return c3 && function e3() {
      const o4 = w2(t4);
      !g3 || o4.x === g3.x && o4.y === g3.y && o4.width === g3.width && o4.height === g3.height || n3();
      g3 = o4, h3 = requestAnimationFrame(e3);
    }(), n3(), () => {
      var t5;
      d3.forEach((t6) => {
        s3 && t6.removeEventListener("scroll", n3), u3 && t6.removeEventListener("resize", n3);
      }), null == (t5 = a3) || t5.disconnect(), a3 = null, c3 && cancelAnimationFrame(h3);
    };
  }
  var z = (t4, n3, o3) => o(t4, n3, __spreadValues({ platform: D2 }, o3));

  // ../../../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.esm.js
  var React43 = __toESM(require_react());
  var import_react62 = __toESM(require_react());
  var ReactDOM = __toESM(require_react_dom());
  var index = typeof document !== "undefined" ? import_react62.useLayoutEffect : import_react62.useEffect;
  function deepEqual(a3, b3) {
    if (a3 === b3) {
      return true;
    }
    if (typeof a3 !== typeof b3) {
      return false;
    }
    if (typeof a3 === "function" && a3.toString() === b3.toString()) {
      return true;
    }
    let length, i3, keys;
    if (a3 && b3 && typeof a3 == "object") {
      if (Array.isArray(a3)) {
        length = a3.length;
        if (length != b3.length)
          return false;
        for (i3 = length; i3-- !== 0; ) {
          if (!deepEqual(a3[i3], b3[i3])) {
            return false;
          }
        }
        return true;
      }
      keys = Object.keys(a3);
      length = keys.length;
      if (length !== Object.keys(b3).length) {
        return false;
      }
      for (i3 = length; i3-- !== 0; ) {
        if (!Object.prototype.hasOwnProperty.call(b3, keys[i3])) {
          return false;
        }
      }
      for (i3 = length; i3-- !== 0; ) {
        const key = keys[i3];
        if (key === "_owner" && a3.$$typeof) {
          continue;
        }
        if (!deepEqual(a3[key], b3[key])) {
          return false;
        }
      }
      return true;
    }
    return a3 !== a3 && b3 !== b3;
  }
  function useLatestRef(value) {
    const ref = React43.useRef(value);
    index(() => {
      ref.current = value;
    });
    return ref;
  }
  function useFloating(_temp) {
    let {
      middleware,
      placement = "bottom",
      strategy = "absolute",
      whileElementsMounted
    } = _temp === void 0 ? {} : _temp;
    const reference = React43.useRef(null);
    const floating = React43.useRef(null);
    const whileElementsMountedRef = useLatestRef(whileElementsMounted);
    const cleanupRef = React43.useRef(null);
    const [data, setData] = React43.useState({
      // Setting these to `null` will allow the consumer to determine if
      // `computePosition()` has run yet
      x: null,
      y: null,
      strategy,
      placement,
      middlewareData: {}
    });
    const [latestMiddleware, setLatestMiddleware] = React43.useState(middleware);
    if (!deepEqual(latestMiddleware == null ? void 0 : latestMiddleware.map((_ref) => {
      let {
        options
      } = _ref;
      return options;
    }), middleware == null ? void 0 : middleware.map((_ref2) => {
      let {
        options
      } = _ref2;
      return options;
    }))) {
      setLatestMiddleware(middleware);
    }
    const update = React43.useCallback(() => {
      if (!reference.current || !floating.current) {
        return;
      }
      z(reference.current, floating.current, {
        middleware: latestMiddleware,
        placement,
        strategy
      }).then((data2) => {
        if (isMountedRef.current) {
          ReactDOM.flushSync(() => {
            setData(data2);
          });
        }
      });
    }, [latestMiddleware, placement, strategy]);
    index(() => {
      if (isMountedRef.current) {
        update();
      }
    }, [update]);
    const isMountedRef = React43.useRef(false);
    index(() => {
      isMountedRef.current = true;
      return () => {
        isMountedRef.current = false;
      };
    }, []);
    const runElementMountCallback = React43.useCallback(() => {
      if (typeof cleanupRef.current === "function") {
        cleanupRef.current();
        cleanupRef.current = null;
      }
      if (reference.current && floating.current) {
        if (whileElementsMountedRef.current) {
          const cleanupFn = whileElementsMountedRef.current(reference.current, floating.current, update);
          cleanupRef.current = cleanupFn;
        } else {
          update();
        }
      }
    }, [update, whileElementsMountedRef]);
    const setReference = React43.useCallback((node) => {
      reference.current = node;
      runElementMountCallback();
    }, [runElementMountCallback]);
    const setFloating = React43.useCallback((node) => {
      floating.current = node;
      runElementMountCallback();
    }, [runElementMountCallback]);
    const refs = React43.useMemo(() => ({
      reference,
      floating
    }), []);
    return React43.useMemo(() => __spreadProps(__spreadValues({}, data), {
      update,
      refs,
      reference: setReference,
      floating: setFloating
    }), [data, update, refs, setReference, setFloating]);
  }
  var arrow = (options) => {
    const {
      element,
      padding
    } = options;
    function isRef(value) {
      return Object.prototype.hasOwnProperty.call(value, "current");
    }
    return {
      name: "arrow",
      options,
      fn(args) {
        if (isRef(element)) {
          if (element.current != null) {
            return m({
              element: element.current,
              padding
            }).fn(args);
          }
          return {};
        } else if (element) {
          return m({
            element,
            padding
          }).fn(args);
        }
        return {};
      }
    };
  };

  // ../../../node_modules/@radix-ui/react-use-size/dist/index.module.js
  var import_react63 = __toESM(require_react());
  function $db6c3485150b8e66$export$1ab7ae714698c4b8(element) {
    const [size, setSize] = (0, import_react63.useState)(void 0);
    $9f79659886946c16$export$e5c5a5f917a5871c(() => {
      if (element) {
        setSize({
          width: element.offsetWidth,
          height: element.offsetHeight
        });
        const resizeObserver = new ResizeObserver((entries) => {
          if (!Array.isArray(entries))
            return;
          if (!entries.length)
            return;
          const entry = entries[0];
          let width;
          let height;
          if ("borderBoxSize" in entry) {
            const borderSizeEntry = entry["borderBoxSize"];
            const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
            width = borderSize["inlineSize"];
            height = borderSize["blockSize"];
          } else {
            width = element.offsetWidth;
            height = element.offsetHeight;
          }
          setSize({
            width,
            height
          });
        });
        resizeObserver.observe(element, {
          box: "border-box"
        });
        return () => resizeObserver.unobserve(element);
      } else
        setSize(void 0);
    }, [
      element
    ]);
    return size;
  }

  // ../../../node_modules/@radix-ui/react-popper/dist/index.module.js
  var $cf1ac5d9fe0e8206$var$POPPER_NAME = "Popper";
  var [$cf1ac5d9fe0e8206$var$createPopperContext, $cf1ac5d9fe0e8206$export$722aac194ae923] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cf1ac5d9fe0e8206$var$POPPER_NAME);
  var [$cf1ac5d9fe0e8206$var$PopperProvider, $cf1ac5d9fe0e8206$var$usePopperContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$POPPER_NAME);
  var $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9 = (props) => {
    const { __scopePopper, children } = props;
    const [anchor, setAnchor] = (0, import_react64.useState)(null);
    return /* @__PURE__ */ (0, import_react64.createElement)($cf1ac5d9fe0e8206$var$PopperProvider, {
      scope: __scopePopper,
      anchor,
      onAnchorChange: setAnchor
    }, children);
  };
  var $cf1ac5d9fe0e8206$var$ANCHOR_NAME = "PopperAnchor";
  var $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d = /* @__PURE__ */ (0, import_react64.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopePopper, virtualRef } = _a5, anchorProps = __objRest(_a5, ["__scopePopper", "virtualRef"]);
    const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$ANCHOR_NAME, __scopePopper);
    const ref = (0, import_react64.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
    (0, import_react64.useEffect)(() => {
      context.onAnchorChange((virtualRef === null || virtualRef === void 0 ? void 0 : virtualRef.current) || ref.current);
    });
    return virtualRef ? null : /* @__PURE__ */ (0, import_react64.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, anchorProps, {
      ref: composedRefs
    }));
  });
  var $cf1ac5d9fe0e8206$var$CONTENT_NAME = "PopperContent";
  var [$cf1ac5d9fe0e8206$var$PopperContentProvider, $cf1ac5d9fe0e8206$var$useContentContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME);
  var [$cf1ac5d9fe0e8206$var$PositionContextProvider, $cf1ac5d9fe0e8206$var$usePositionContext] = $cf1ac5d9fe0e8206$var$createPopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, {
    hasParent: false,
    positionUpdateFns: /* @__PURE__ */ new Set()
  });
  var $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc = /* @__PURE__ */ (0, import_react64.forwardRef)((props, forwardedRef) => {
    var _arrowSize$width, _arrowSize$height, _middlewareData$arrow, _middlewareData$arrow2, _middlewareData$arrow3, _middlewareData$hide, _middlewareData$trans, _middlewareData$trans2;
    const _a5 = props, { __scopePopper, side = "bottom", sideOffset = 0, align = "center", alignOffset = 0, arrowPadding = 0, collisionBoundary = [], collisionPadding: collisionPaddingProp = 0, sticky = "partial", hideWhenDetached = false, avoidCollisions = true, onPlaced } = _a5, contentProps = __objRest(_a5, ["__scopePopper", "side", "sideOffset", "align", "alignOffset", "arrowPadding", "collisionBoundary", "collisionPadding", "sticky", "hideWhenDetached", "avoidCollisions", "onPlaced"]);
    const context = $cf1ac5d9fe0e8206$var$usePopperContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, __scopePopper);
    const [content, setContent] = (0, import_react64.useState)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
      forwardedRef,
      (node) => setContent(node)
    );
    const [arrow2, setArrow] = (0, import_react64.useState)(null);
    const arrowSize = $db6c3485150b8e66$export$1ab7ae714698c4b8(arrow2);
    const arrowWidth = (_arrowSize$width = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.width) !== null && _arrowSize$width !== void 0 ? _arrowSize$width : 0;
    const arrowHeight = (_arrowSize$height = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.height) !== null && _arrowSize$height !== void 0 ? _arrowSize$height : 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : __spreadValues({
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }, collisionPaddingProp);
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [
      collisionBoundary
    ];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter($cf1ac5d9fe0e8206$var$isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { reference, floating, strategy, x: x3, y: y3, placement, middlewareData, update } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: N,
      middleware: [
        $cf1ac5d9fe0e8206$var$anchorCssProperties(),
        T({
          mainAxis: sideOffset + arrowHeight,
          alignmentAxis: alignOffset
        }),
        avoidCollisions ? D(__spreadValues({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? L() : void 0
        }, detectOverflowOptions)) : void 0,
        arrow2 ? arrow({
          element: arrow2,
          padding: arrowPadding
        }) : void 0,
        avoidCollisions ? b(__spreadValues({}, detectOverflowOptions)) : void 0,
        k(__spreadProps(__spreadValues({}, detectOverflowOptions), {
          apply: ({ elements, availableWidth: width, availableHeight: height }) => {
            elements.floating.style.setProperty("--radix-popper-available-width", `${width}px`);
            elements.floating.style.setProperty("--radix-popper-available-height", `${height}px`);
          }
        })),
        $cf1ac5d9fe0e8206$var$transformOrigin({
          arrowWidth,
          arrowHeight
        }),
        hideWhenDetached ? P({
          strategy: "referenceHidden"
        }) : void 0
      ].filter($cf1ac5d9fe0e8206$var$isDefined)
    });
    $9f79659886946c16$export$e5c5a5f917a5871c(() => {
      reference(context.anchor);
    }, [
      reference,
      context.anchor
    ]);
    const isPlaced = x3 !== null && y3 !== null;
    const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
    const handlePlaced = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPlaced);
    $9f79659886946c16$export$e5c5a5f917a5871c(() => {
      if (isPlaced)
        handlePlaced === null || handlePlaced === void 0 || handlePlaced();
    }, [
      isPlaced,
      handlePlaced
    ]);
    const arrowX = (_middlewareData$arrow = middlewareData.arrow) === null || _middlewareData$arrow === void 0 ? void 0 : _middlewareData$arrow.x;
    const arrowY = (_middlewareData$arrow2 = middlewareData.arrow) === null || _middlewareData$arrow2 === void 0 ? void 0 : _middlewareData$arrow2.y;
    const cannotCenterArrow = ((_middlewareData$arrow3 = middlewareData.arrow) === null || _middlewareData$arrow3 === void 0 ? void 0 : _middlewareData$arrow3.centerOffset) !== 0;
    const [contentZIndex, setContentZIndex] = (0, import_react64.useState)();
    $9f79659886946c16$export$e5c5a5f917a5871c(() => {
      if (content)
        setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [
      content
    ]);
    const { hasParent, positionUpdateFns } = $cf1ac5d9fe0e8206$var$usePositionContext($cf1ac5d9fe0e8206$var$CONTENT_NAME, __scopePopper);
    const isRoot = !hasParent;
    (0, import_react64.useLayoutEffect)(() => {
      if (!isRoot) {
        positionUpdateFns.add(update);
        return () => {
          positionUpdateFns.delete(update);
        };
      }
    }, [
      isRoot,
      positionUpdateFns,
      update
    ]);
    $9f79659886946c16$export$e5c5a5f917a5871c(() => {
      if (isRoot && isPlaced)
        Array.from(positionUpdateFns).reverse().forEach(
          (fn) => requestAnimationFrame(fn)
        );
    }, [
      isRoot,
      isPlaced,
      positionUpdateFns
    ]);
    const commonProps = __spreadProps(__spreadValues({
      "data-side": placedSide,
      "data-align": placedAlign
    }, contentProps), {
      ref: composedRefs,
      style: __spreadProps(__spreadValues({}, contentProps.style), {
        // if the PopperContent hasn't been placed yet (not all measurements done)
        // we prevent animations so that users's animation don't kick in too early referring wrong sides
        animation: !isPlaced ? "none" : void 0,
        // hide the content if using the hide middleware and should be hidden
        opacity: (_middlewareData$hide = middlewareData.hide) !== null && _middlewareData$hide !== void 0 && _middlewareData$hide.referenceHidden ? 0 : void 0
      })
    });
    return /* @__PURE__ */ (0, import_react64.createElement)("div", {
      ref: floating,
      "data-radix-popper-content-wrapper": "",
      style: {
        position: strategy,
        left: 0,
        top: 0,
        transform: isPlaced ? `translate3d(${Math.round(x3)}px, ${Math.round(y3)}px, 0)` : "translate3d(0, -200%, 0)",
        // keep off the page when measuring
        minWidth: "max-content",
        zIndex: contentZIndex,
        ["--radix-popper-transform-origin"]: [
          (_middlewareData$trans = middlewareData.transformOrigin) === null || _middlewareData$trans === void 0 ? void 0 : _middlewareData$trans.x,
          (_middlewareData$trans2 = middlewareData.transformOrigin) === null || _middlewareData$trans2 === void 0 ? void 0 : _middlewareData$trans2.y
        ].join(" ")
      },
      dir: props.dir
    }, /* @__PURE__ */ (0, import_react64.createElement)($cf1ac5d9fe0e8206$var$PopperContentProvider, {
      scope: __scopePopper,
      placedSide,
      onArrowChange: setArrow,
      arrowX,
      arrowY,
      shouldHideArrow: cannotCenterArrow
    }, isRoot ? /* @__PURE__ */ (0, import_react64.createElement)($cf1ac5d9fe0e8206$var$PositionContextProvider, {
      scope: __scopePopper,
      hasParent: true,
      positionUpdateFns
    }, /* @__PURE__ */ (0, import_react64.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, commonProps)) : /* @__PURE__ */ (0, import_react64.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, commonProps)));
  });
  function $cf1ac5d9fe0e8206$var$isDefined(value) {
    return value !== void 0;
  }
  function $cf1ac5d9fe0e8206$var$isNotNull(value) {
    return value !== null;
  }
  var $cf1ac5d9fe0e8206$var$anchorCssProperties = () => ({
    name: "anchorCssProperties",
    fn(data) {
      const { rects, elements } = data;
      const { width, height } = rects.reference;
      elements.floating.style.setProperty("--radix-popper-anchor-width", `${width}px`);
      elements.floating.style.setProperty("--radix-popper-anchor-height", `${height}px`);
      return {};
    }
  });
  var $cf1ac5d9fe0e8206$var$transformOrigin = (options) => ({
    name: "transformOrigin",
    options,
    fn(data) {
      var _middlewareData$arrow4, _middlewareData$arrow5, _middlewareData$arrow6, _middlewareData$arrow7, _middlewareData$arrow8;
      const { placement, rects, middlewareData } = data;
      const cannotCenterArrow = ((_middlewareData$arrow4 = middlewareData.arrow) === null || _middlewareData$arrow4 === void 0 ? void 0 : _middlewareData$arrow4.centerOffset) !== 0;
      const isArrowHidden = cannotCenterArrow;
      const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
      const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
      const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement);
      const noArrowAlign = {
        start: "0%",
        center: "50%",
        end: "100%"
      }[placedAlign];
      const arrowXCenter = ((_middlewareData$arrow5 = (_middlewareData$arrow6 = middlewareData.arrow) === null || _middlewareData$arrow6 === void 0 ? void 0 : _middlewareData$arrow6.x) !== null && _middlewareData$arrow5 !== void 0 ? _middlewareData$arrow5 : 0) + arrowWidth / 2;
      const arrowYCenter = ((_middlewareData$arrow7 = (_middlewareData$arrow8 = middlewareData.arrow) === null || _middlewareData$arrow8 === void 0 ? void 0 : _middlewareData$arrow8.y) !== null && _middlewareData$arrow7 !== void 0 ? _middlewareData$arrow7 : 0) + arrowHeight / 2;
      let x3 = "";
      let y3 = "";
      if (placedSide === "bottom") {
        x3 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y3 = `${-arrowHeight}px`;
      } else if (placedSide === "top") {
        x3 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y3 = `${rects.floating.height + arrowHeight}px`;
      } else if (placedSide === "right") {
        x3 = `${-arrowHeight}px`;
        y3 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      } else if (placedSide === "left") {
        x3 = `${rects.floating.width + arrowHeight}px`;
        y3 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      }
      return {
        data: {
          x: x3,
          y: y3
        }
      };
    }
  });
  function $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement(placement) {
    const [side, align = "center"] = placement.split("-");
    return [
      side,
      align
    ];
  }
  var $cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9 = $cf1ac5d9fe0e8206$export$badac9ada3a0bdf9;
  var $cf1ac5d9fe0e8206$export$b688253958b8dfe7 = $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d;
  var $cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2 = $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc;

  // ../../../node_modules/@radix-ui/react-roving-focus/dist/index.module.js
  var import_react65 = __toESM(require_react());
  var $d7bdfb9eb0fdf311$var$ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
  var $d7bdfb9eb0fdf311$var$EVENT_OPTIONS = {
    bubbles: false,
    cancelable: true
  };
  var $d7bdfb9eb0fdf311$var$GROUP_NAME = "RovingFocusGroup";
  var [$d7bdfb9eb0fdf311$var$Collection, $d7bdfb9eb0fdf311$var$useCollection, $d7bdfb9eb0fdf311$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($d7bdfb9eb0fdf311$var$GROUP_NAME);
  var [$d7bdfb9eb0fdf311$var$createRovingFocusGroupContext, $d7bdfb9eb0fdf311$export$c7109489551a4f4] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($d7bdfb9eb0fdf311$var$GROUP_NAME, [
    $d7bdfb9eb0fdf311$var$createCollectionScope
  ]);
  var [$d7bdfb9eb0fdf311$var$RovingFocusProvider, $d7bdfb9eb0fdf311$var$useRovingFocusContext] = $d7bdfb9eb0fdf311$var$createRovingFocusGroupContext($d7bdfb9eb0fdf311$var$GROUP_NAME);
  var $d7bdfb9eb0fdf311$export$8699f7c8af148338 = /* @__PURE__ */ (0, import_react65.forwardRef)((props, forwardedRef) => {
    return /* @__PURE__ */ (0, import_react65.createElement)($d7bdfb9eb0fdf311$var$Collection.Provider, {
      scope: props.__scopeRovingFocusGroup
    }, /* @__PURE__ */ (0, import_react65.createElement)($d7bdfb9eb0fdf311$var$Collection.Slot, {
      scope: props.__scopeRovingFocusGroup
    }, /* @__PURE__ */ (0, import_react65.createElement)($d7bdfb9eb0fdf311$var$RovingFocusGroupImpl, _extends({}, props, {
      ref: forwardedRef
    }))));
  });
  var $d7bdfb9eb0fdf311$var$RovingFocusGroupImpl = /* @__PURE__ */ (0, import_react65.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeRovingFocusGroup, orientation, loop = false, dir, currentTabStopId: currentTabStopIdProp, defaultCurrentTabStopId, onCurrentTabStopIdChange, onEntryFocus } = _a5, groupProps = __objRest(_a5, ["__scopeRovingFocusGroup", "orientation", "loop", "dir", "currentTabStopId", "defaultCurrentTabStopId", "onCurrentTabStopIdChange", "onEntryFocus"]);
    const ref = (0, import_react65.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
    const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
    const [currentTabStopId = null, setCurrentTabStopId] = $71cd76cc60e0454e$export$6f32135080cb4c3({
      prop: currentTabStopIdProp,
      defaultProp: defaultCurrentTabStopId,
      onChange: onCurrentTabStopIdChange
    });
    const [isTabbingBackOut, setIsTabbingBackOut] = (0, import_react65.useState)(false);
    const handleEntryFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onEntryFocus);
    const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);
    const isClickFocusRef = (0, import_react65.useRef)(false);
    const [focusableItemsCount, setFocusableItemsCount] = (0, import_react65.useState)(0);
    (0, import_react65.useEffect)(() => {
      const node = ref.current;
      if (node) {
        node.addEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);
        return () => node.removeEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);
      }
    }, [
      handleEntryFocus
    ]);
    return /* @__PURE__ */ (0, import_react65.createElement)($d7bdfb9eb0fdf311$var$RovingFocusProvider, {
      scope: __scopeRovingFocusGroup,
      orientation,
      dir: direction,
      loop,
      currentTabStopId,
      onItemFocus: (0, import_react65.useCallback)(
        (tabStopId) => setCurrentTabStopId(tabStopId),
        [
          setCurrentTabStopId
        ]
      ),
      onItemShiftTab: (0, import_react65.useCallback)(
        () => setIsTabbingBackOut(true),
        []
      ),
      onFocusableItemAdd: (0, import_react65.useCallback)(
        () => setFocusableItemsCount(
          (prevCount) => prevCount + 1
        ),
        []
      ),
      onFocusableItemRemove: (0, import_react65.useCallback)(
        () => setFocusableItemsCount(
          (prevCount) => prevCount - 1
        ),
        []
      )
    }, /* @__PURE__ */ (0, import_react65.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
      tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
      "data-orientation": orientation
    }, groupProps, {
      ref: composedRefs,
      style: __spreadValues({
        outline: "none"
      }, props.style),
      onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, () => {
        isClickFocusRef.current = true;
      }),
      onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, (event) => {
        const isKeyboardFocus = !isClickFocusRef.current;
        if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
          const entryFocusEvent = new CustomEvent($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, $d7bdfb9eb0fdf311$var$EVENT_OPTIONS);
          event.currentTarget.dispatchEvent(entryFocusEvent);
          if (!entryFocusEvent.defaultPrevented) {
            const items = getItems().filter(
              (item) => item.focusable
            );
            const activeItem = items.find(
              (item) => item.active
            );
            const currentItem = items.find(
              (item) => item.id === currentTabStopId
            );
            const candidateItems = [
              activeItem,
              currentItem,
              ...items
            ].filter(Boolean);
            const candidateNodes = candidateItems.map(
              (item) => item.ref.current
            );
            $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes);
          }
        }
        isClickFocusRef.current = false;
      }),
      onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
        props.onBlur,
        () => setIsTabbingBackOut(false)
      )
    })));
  });
  var $d7bdfb9eb0fdf311$var$ITEM_NAME = "RovingFocusGroupItem";
  var $d7bdfb9eb0fdf311$export$ab9df7c53fe8454 = /* @__PURE__ */ (0, import_react65.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeRovingFocusGroup, focusable = true, active = false, tabStopId } = _a5, itemProps = __objRest(_a5, ["__scopeRovingFocusGroup", "focusable", "active", "tabStopId"]);
    const autoId = $1746a345f3d73bb7$export$f680877a34711e37();
    const id = tabStopId || autoId;
    const context = $d7bdfb9eb0fdf311$var$useRovingFocusContext($d7bdfb9eb0fdf311$var$ITEM_NAME, __scopeRovingFocusGroup);
    const isCurrentTabStop = context.currentTabStopId === id;
    const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);
    const { onFocusableItemAdd, onFocusableItemRemove } = context;
    (0, import_react65.useEffect)(() => {
      if (focusable) {
        onFocusableItemAdd();
        return () => onFocusableItemRemove();
      }
    }, [
      focusable,
      onFocusableItemAdd,
      onFocusableItemRemove
    ]);
    return /* @__PURE__ */ (0, import_react65.createElement)($d7bdfb9eb0fdf311$var$Collection.ItemSlot, {
      scope: __scopeRovingFocusGroup,
      id,
      focusable,
      active
    }, /* @__PURE__ */ (0, import_react65.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({
      tabIndex: isCurrentTabStop ? 0 : -1,
      "data-orientation": context.orientation
    }, itemProps, {
      ref: forwardedRef,
      onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, (event) => {
        if (!focusable)
          event.preventDefault();
        else
          context.onItemFocus(id);
      }),
      onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
        props.onFocus,
        () => context.onItemFocus(id)
      ),
      onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
        if (event.key === "Tab" && event.shiftKey) {
          context.onItemShiftTab();
          return;
        }
        if (event.target !== event.currentTarget)
          return;
        const focusIntent = $d7bdfb9eb0fdf311$var$getFocusIntent(event, context.orientation, context.dir);
        if (focusIntent !== void 0) {
          event.preventDefault();
          const items = getItems().filter(
            (item) => item.focusable
          );
          let candidateNodes = items.map(
            (item) => item.ref.current
          );
          if (focusIntent === "last")
            candidateNodes.reverse();
          else if (focusIntent === "prev" || focusIntent === "next") {
            if (focusIntent === "prev")
              candidateNodes.reverse();
            const currentIndex = candidateNodes.indexOf(event.currentTarget);
            candidateNodes = context.loop ? $d7bdfb9eb0fdf311$var$wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
          }
          setTimeout(
            () => $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes)
          );
        }
      })
    })));
  });
  var $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT = {
    ArrowLeft: "prev",
    ArrowUp: "prev",
    ArrowRight: "next",
    ArrowDown: "next",
    PageUp: "first",
    Home: "first",
    PageDown: "last",
    End: "last"
  };
  function $d7bdfb9eb0fdf311$var$getDirectionAwareKey(key, dir) {
    if (dir !== "rtl")
      return key;
    return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
  }
  function $d7bdfb9eb0fdf311$var$getFocusIntent(event, orientation, dir) {
    const key = $d7bdfb9eb0fdf311$var$getDirectionAwareKey(event.key, dir);
    if (orientation === "vertical" && [
      "ArrowLeft",
      "ArrowRight"
    ].includes(key))
      return void 0;
    if (orientation === "horizontal" && [
      "ArrowUp",
      "ArrowDown"
    ].includes(key))
      return void 0;
    return $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT[key];
  }
  function $d7bdfb9eb0fdf311$var$focusFirst(candidates) {
    const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
    for (const candidate of candidates) {
      if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
        return;
      candidate.focus();
      if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
        return;
    }
  }
  function $d7bdfb9eb0fdf311$var$wrapArray(array2, startIndex) {
    return array2.map(
      (_, index2) => array2[(startIndex + index2) % array2.length]
    );
  }
  var $d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9 = $d7bdfb9eb0fdf311$export$8699f7c8af148338;
  var $d7bdfb9eb0fdf311$export$6d08773d2e66f8f2 = $d7bdfb9eb0fdf311$export$ab9df7c53fe8454;

  // ../../../node_modules/@radix-ui/react-menu/dist/index.module.js
  var $6cc32821e9371a1c$var$SELECTION_KEYS = [
    "Enter",
    " "
  ];
  var $6cc32821e9371a1c$var$FIRST_KEYS = [
    "ArrowDown",
    "PageUp",
    "Home"
  ];
  var $6cc32821e9371a1c$var$LAST_KEYS = [
    "ArrowUp",
    "PageDown",
    "End"
  ];
  var $6cc32821e9371a1c$var$FIRST_LAST_KEYS = [
    ...$6cc32821e9371a1c$var$FIRST_KEYS,
    ...$6cc32821e9371a1c$var$LAST_KEYS
  ];
  var $6cc32821e9371a1c$var$SUB_OPEN_KEYS = {
    ltr: [
      ...$6cc32821e9371a1c$var$SELECTION_KEYS,
      "ArrowRight"
    ],
    rtl: [
      ...$6cc32821e9371a1c$var$SELECTION_KEYS,
      "ArrowLeft"
    ]
  };
  var $6cc32821e9371a1c$var$SUB_CLOSE_KEYS = {
    ltr: [
      "ArrowLeft"
    ],
    rtl: [
      "ArrowRight"
    ]
  };
  var $6cc32821e9371a1c$var$MENU_NAME = "Menu";
  var [$6cc32821e9371a1c$var$Collection, $6cc32821e9371a1c$var$useCollection, $6cc32821e9371a1c$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($6cc32821e9371a1c$var$MENU_NAME);
  var [$6cc32821e9371a1c$var$createMenuContext, $6cc32821e9371a1c$export$4027731b685e72eb] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($6cc32821e9371a1c$var$MENU_NAME, [
    $6cc32821e9371a1c$var$createCollectionScope,
    $cf1ac5d9fe0e8206$export$722aac194ae923,
    $d7bdfb9eb0fdf311$export$c7109489551a4f4
  ]);
  var $6cc32821e9371a1c$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae923();
  var $6cc32821e9371a1c$var$useRovingFocusGroupScope = $d7bdfb9eb0fdf311$export$c7109489551a4f4();
  var [$6cc32821e9371a1c$var$MenuProvider, $6cc32821e9371a1c$var$useMenuContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$MENU_NAME);
  var [$6cc32821e9371a1c$var$MenuRootProvider, $6cc32821e9371a1c$var$useMenuRootContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$MENU_NAME);
  var $6cc32821e9371a1c$export$d9b273488cd8ce6f = (props) => {
    const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;
    const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
    const [content, setContent] = (0, import_react66.useState)(null);
    const isUsingKeyboardRef = (0, import_react66.useRef)(false);
    const handleOpenChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onOpenChange);
    const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
    (0, import_react66.useEffect)(() => {
      const handleKeyDown = () => {
        isUsingKeyboardRef.current = true;
        document.addEventListener("pointerdown", handlePointer, {
          capture: true,
          once: true
        });
        document.addEventListener("pointermove", handlePointer, {
          capture: true,
          once: true
        });
      };
      const handlePointer = () => isUsingKeyboardRef.current = false;
      document.addEventListener("keydown", handleKeyDown, {
        capture: true
      });
      return () => {
        document.removeEventListener("keydown", handleKeyDown, {
          capture: true
        });
        document.removeEventListener("pointerdown", handlePointer, {
          capture: true
        });
        document.removeEventListener("pointermove", handlePointer, {
          capture: true
        });
      };
    }, []);
    return /* @__PURE__ */ (0, import_react66.createElement)($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, /* @__PURE__ */ (0, import_react66.createElement)($6cc32821e9371a1c$var$MenuProvider, {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content,
      onContentChange: setContent
    }, /* @__PURE__ */ (0, import_react66.createElement)($6cc32821e9371a1c$var$MenuRootProvider, {
      scope: __scopeMenu,
      onClose: (0, import_react66.useCallback)(
        () => handleOpenChange(false),
        [
          handleOpenChange
        ]
      ),
      isUsingKeyboardRef,
      dir: direction,
      modal
    }, children)));
  };
  var $6cc32821e9371a1c$export$9fa5ebd18bee4d43 = /* @__PURE__ */ (0, import_react66.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeMenu } = _a5, anchorProps = __objRest(_a5, ["__scopeMenu"]);
    const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
    return /* @__PURE__ */ (0, import_react66.createElement)($cf1ac5d9fe0e8206$export$b688253958b8dfe7, _extends({}, popperScope, anchorProps, {
      ref: forwardedRef
    }));
  });
  var $6cc32821e9371a1c$var$PORTAL_NAME = "MenuPortal";
  var [$6cc32821e9371a1c$var$PortalProvider, $6cc32821e9371a1c$var$usePortalContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$PORTAL_NAME, {
    forceMount: void 0
  });
  var $6cc32821e9371a1c$export$793392f970497feb = (props) => {
    const { __scopeMenu, forceMount, children, container } = props;
    const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$PORTAL_NAME, __scopeMenu);
    return /* @__PURE__ */ (0, import_react66.createElement)($6cc32821e9371a1c$var$PortalProvider, {
      scope: __scopeMenu,
      forceMount
    }, /* @__PURE__ */ (0, import_react66.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
      present: forceMount || context.open
    }, /* @__PURE__ */ (0, import_react66.createElement)($f1701beae083dbae$export$602eac185826482c, {
      asChild: true,
      container
    }, children)));
  };
  var $6cc32821e9371a1c$var$CONTENT_NAME = "MenuContent";
  var [$6cc32821e9371a1c$var$MenuContentProvider, $6cc32821e9371a1c$var$useMenuContentContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$CONTENT_NAME);
  var $6cc32821e9371a1c$export$479f0f2f71193efe = /* @__PURE__ */ (0, import_react66.forwardRef)((props, forwardedRef) => {
    const portalContext = $6cc32821e9371a1c$var$usePortalContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
    const _a5 = props, { forceMount = portalContext.forceMount } = _a5, contentProps = __objRest(_a5, ["forceMount"]);
    const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
    const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
    return /* @__PURE__ */ (0, import_react66.createElement)($6cc32821e9371a1c$var$Collection.Provider, {
      scope: props.__scopeMenu
    }, /* @__PURE__ */ (0, import_react66.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
      present: forceMount || context.open
    }, /* @__PURE__ */ (0, import_react66.createElement)($6cc32821e9371a1c$var$Collection.Slot, {
      scope: props.__scopeMenu
    }, rootContext.modal ? /* @__PURE__ */ (0, import_react66.createElement)($6cc32821e9371a1c$var$MenuRootContentModal, _extends({}, contentProps, {
      ref: forwardedRef
    })) : /* @__PURE__ */ (0, import_react66.createElement)($6cc32821e9371a1c$var$MenuRootContentNonModal, _extends({}, contentProps, {
      ref: forwardedRef
    })))));
  });
  var $6cc32821e9371a1c$var$MenuRootContentModal = /* @__PURE__ */ (0, import_react66.forwardRef)((props, forwardedRef) => {
    const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
    const ref = (0, import_react66.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
    (0, import_react66.useEffect)(() => {
      const content = ref.current;
      if (content)
        return hideOthers(content);
    }, []);
    return /* @__PURE__ */ (0, import_react66.createElement)($6cc32821e9371a1c$var$MenuContentImpl, _extends({}, props, {
      ref: composedRefs,
      trapFocus: context.open,
      disableOutsidePointerEvents: context.open,
      disableOutsideScroll: true,
      onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
        props.onFocusOutside,
        (event) => event.preventDefault(),
        {
          checkForDefaultPrevented: false
        }
      ),
      onDismiss: () => context.onOpenChange(false)
    }));
  });
  var $6cc32821e9371a1c$var$MenuRootContentNonModal = /* @__PURE__ */ (0, import_react66.forwardRef)((props, forwardedRef) => {
    const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
    return /* @__PURE__ */ (0, import_react66.createElement)($6cc32821e9371a1c$var$MenuContentImpl, _extends({}, props, {
      ref: forwardedRef,
      trapFocus: false,
      disableOutsidePointerEvents: false,
      disableOutsideScroll: false,
      onDismiss: () => context.onOpenChange(false)
    }));
  });
  var $6cc32821e9371a1c$var$MenuContentImpl = /* @__PURE__ */ (0, import_react66.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeMenu, loop = false, trapFocus, onOpenAutoFocus, onCloseAutoFocus, disableOutsidePointerEvents, onEntryFocus, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside, onDismiss, disableOutsideScroll } = _a5, contentProps = __objRest(_a5, ["__scopeMenu", "loop", "trapFocus", "onOpenAutoFocus", "onCloseAutoFocus", "disableOutsidePointerEvents", "onEntryFocus", "onEscapeKeyDown", "onPointerDownOutside", "onFocusOutside", "onInteractOutside", "onDismiss", "disableOutsideScroll"]);
    const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, __scopeMenu);
    const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$CONTENT_NAME, __scopeMenu);
    const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
    const rovingFocusGroupScope = $6cc32821e9371a1c$var$useRovingFocusGroupScope(__scopeMenu);
    const getItems = $6cc32821e9371a1c$var$useCollection(__scopeMenu);
    const [currentItemId, setCurrentItemId] = (0, import_react66.useState)(null);
    const contentRef = (0, import_react66.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef, context.onContentChange);
    const timerRef = (0, import_react66.useRef)(0);
    const searchRef = (0, import_react66.useRef)("");
    const pointerGraceTimerRef = (0, import_react66.useRef)(0);
    const pointerGraceIntentRef = (0, import_react66.useRef)(null);
    const pointerDirRef = (0, import_react66.useRef)("right");
    const lastPointerXRef = (0, import_react66.useRef)(0);
    const ScrollLockWrapper = disableOutsideScroll ? Combination_default : import_react66.Fragment;
    const scrollLockWrapperProps = disableOutsideScroll ? {
      as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
      allowPinchZoom: true
    } : void 0;
    const handleTypeaheadSearch = (key) => {
      var _items$find, _items$find2;
      const search = searchRef.current + key;
      const items = getItems().filter(
        (item) => !item.disabled
      );
      const currentItem = document.activeElement;
      const currentMatch = (_items$find = items.find(
        (item) => item.ref.current === currentItem
      )) === null || _items$find === void 0 ? void 0 : _items$find.textValue;
      const values = items.map(
        (item) => item.textValue
      );
      const nextMatch = $6cc32821e9371a1c$var$getNextMatch(values, search, currentMatch);
      const newItem = (_items$find2 = items.find(
        (item) => item.textValue === nextMatch
      )) === null || _items$find2 === void 0 ? void 0 : _items$find2.ref.current;
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "")
          timerRef.current = window.setTimeout(
            () => updateSearch(""),
            1e3
          );
      })(search);
      if (newItem)
        setTimeout(
          () => newItem.focus()
        );
    };
    (0, import_react66.useEffect)(() => {
      return () => window.clearTimeout(timerRef.current);
    }, []);
    $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();
    const isPointerMovingToSubmenu = (0, import_react66.useCallback)((event) => {
      var _pointerGraceIntentRe, _pointerGraceIntentRe2;
      const isMovingTowards = pointerDirRef.current === ((_pointerGraceIntentRe = pointerGraceIntentRef.current) === null || _pointerGraceIntentRe === void 0 ? void 0 : _pointerGraceIntentRe.side);
      return isMovingTowards && $6cc32821e9371a1c$var$isPointerInGraceArea(event, (_pointerGraceIntentRe2 = pointerGraceIntentRef.current) === null || _pointerGraceIntentRe2 === void 0 ? void 0 : _pointerGraceIntentRe2.area);
    }, []);
    return /* @__PURE__ */ (0, import_react66.createElement)($6cc32821e9371a1c$var$MenuContentProvider, {
      scope: __scopeMenu,
      searchRef,
      onItemEnter: (0, import_react66.useCallback)((event) => {
        if (isPointerMovingToSubmenu(event))
          event.preventDefault();
      }, [
        isPointerMovingToSubmenu
      ]),
      onItemLeave: (0, import_react66.useCallback)((event) => {
        var _contentRef$current;
        if (isPointerMovingToSubmenu(event))
          return;
        (_contentRef$current = contentRef.current) === null || _contentRef$current === void 0 || _contentRef$current.focus();
        setCurrentItemId(null);
      }, [
        isPointerMovingToSubmenu
      ]),
      onTriggerLeave: (0, import_react66.useCallback)((event) => {
        if (isPointerMovingToSubmenu(event))
          event.preventDefault();
      }, [
        isPointerMovingToSubmenu
      ]),
      pointerGraceTimerRef,
      onPointerGraceIntentChange: (0, import_react66.useCallback)((intent) => {
        pointerGraceIntentRef.current = intent;
      }, [])
    }, /* @__PURE__ */ (0, import_react66.createElement)(ScrollLockWrapper, scrollLockWrapperProps, /* @__PURE__ */ (0, import_react66.createElement)($d3863c46a17e8a28$export$20e40289641fbbb6, {
      asChild: true,
      trapped: trapFocus,
      onMountAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(onOpenAutoFocus, (event) => {
        var _contentRef$current2;
        event.preventDefault();
        (_contentRef$current2 = contentRef.current) === null || _contentRef$current2 === void 0 || _contentRef$current2.focus();
      }),
      onUnmountAutoFocus: onCloseAutoFocus
    }, /* @__PURE__ */ (0, import_react66.createElement)($5cb92bef7577960e$export$177fb62ff3ec1f22, {
      asChild: true,
      disableOutsidePointerEvents,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss
    }, /* @__PURE__ */ (0, import_react66.createElement)($d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9, _extends({
      asChild: true
    }, rovingFocusGroupScope, {
      dir: rootContext.dir,
      orientation: "vertical",
      loop,
      currentTabStopId: currentItemId,
      onCurrentTabStopIdChange: setCurrentItemId,
      onEntryFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(onEntryFocus, (event) => {
        if (!rootContext.isUsingKeyboardRef.current)
          event.preventDefault();
      })
    }), /* @__PURE__ */ (0, import_react66.createElement)($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d2, _extends({
      role: "menu",
      "aria-orientation": "vertical",
      "data-state": $6cc32821e9371a1c$var$getOpenState(context.open),
      "data-radix-menu-content": "",
      dir: rootContext.dir
    }, popperScope, contentProps, {
      ref: composedRefs,
      style: __spreadValues({
        outline: "none"
      }, contentProps.style),
      onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(contentProps.onKeyDown, (event) => {
        const target = event.target;
        const isKeyDownInside = target.closest("[data-radix-menu-content]") === event.currentTarget;
        const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
        const isCharacterKey = event.key.length === 1;
        if (isKeyDownInside) {
          if (event.key === "Tab")
            event.preventDefault();
          if (!isModifierKey && isCharacterKey)
            handleTypeaheadSearch(event.key);
        }
        const content = contentRef.current;
        if (event.target !== content)
          return;
        if (!$6cc32821e9371a1c$var$FIRST_LAST_KEYS.includes(event.key))
          return;
        event.preventDefault();
        const items = getItems().filter(
          (item) => !item.disabled
        );
        const candidateNodes = items.map(
          (item) => item.ref.current
        );
        if ($6cc32821e9371a1c$var$LAST_KEYS.includes(event.key))
          candidateNodes.reverse();
        $6cc32821e9371a1c$var$focusFirst(candidateNodes);
      }),
      onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onBlur, (event) => {
        if (!event.currentTarget.contains(event.target)) {
          window.clearTimeout(timerRef.current);
          searchRef.current = "";
        }
      }),
      onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $6cc32821e9371a1c$var$whenMouse((event) => {
        const target = event.target;
        const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
        if (event.currentTarget.contains(target) && pointerXHasChanged) {
          const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
          pointerDirRef.current = newDir;
          lastPointerXRef.current = event.clientX;
        }
      }))
    })))))));
  });
  var $6cc32821e9371a1c$export$22a631d1f72787bb = /* @__PURE__ */ (0, import_react66.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeMenu } = _a5, groupProps = __objRest(_a5, ["__scopeMenu"]);
    return /* @__PURE__ */ (0, import_react66.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
      role: "group"
    }, groupProps, {
      ref: forwardedRef
    }));
  });
  var $6cc32821e9371a1c$var$ITEM_NAME = "MenuItem";
  var $6cc32821e9371a1c$var$ITEM_SELECT = "menu.itemSelect";
  var $6cc32821e9371a1c$export$2ce376c2cc3355c8 = /* @__PURE__ */ (0, import_react66.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { disabled = false, onSelect } = _a5, itemProps = __objRest(_a5, ["disabled", "onSelect"]);
    const ref = (0, import_react66.useRef)(null);
    const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$ITEM_NAME, props.__scopeMenu);
    const contentContext = $6cc32821e9371a1c$var$useMenuContentContext($6cc32821e9371a1c$var$ITEM_NAME, props.__scopeMenu);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
    const isPointerDownRef = (0, import_react66.useRef)(false);
    const handleSelect = () => {
      const menuItem2 = ref.current;
      if (!disabled && menuItem2) {
        const itemSelectEvent = new CustomEvent($6cc32821e9371a1c$var$ITEM_SELECT, {
          bubbles: true,
          cancelable: true
        });
        menuItem2.addEventListener(
          $6cc32821e9371a1c$var$ITEM_SELECT,
          (event) => onSelect === null || onSelect === void 0 ? void 0 : onSelect(event),
          {
            once: true
          }
        );
        $8927f6f2acc4f386$export$6d1a0317bde7de7f(menuItem2, itemSelectEvent);
        if (itemSelectEvent.defaultPrevented)
          isPointerDownRef.current = false;
        else
          rootContext.onClose();
      }
    };
    return /* @__PURE__ */ (0, import_react66.createElement)($6cc32821e9371a1c$var$MenuItemImpl, _extends({}, itemProps, {
      ref: composedRefs,
      disabled,
      onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, handleSelect),
      onPointerDown: (event) => {
        var _props$onPointerDown;
        (_props$onPointerDown = props.onPointerDown) === null || _props$onPointerDown === void 0 || _props$onPointerDown.call(props, event);
        isPointerDownRef.current = true;
      },
      onPointerUp: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerUp, (event) => {
        var _event$currentTarget;
        if (!isPointerDownRef.current)
          (_event$currentTarget = event.currentTarget) === null || _event$currentTarget === void 0 || _event$currentTarget.click();
      }),
      onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
        const isTypingAhead = contentContext.searchRef.current !== "";
        if (disabled || isTypingAhead && event.key === " ")
          return;
        if ($6cc32821e9371a1c$var$SELECTION_KEYS.includes(event.key)) {
          event.currentTarget.click();
          event.preventDefault();
        }
      })
    }));
  });
  var $6cc32821e9371a1c$var$MenuItemImpl = /* @__PURE__ */ (0, import_react66.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeMenu, disabled = false, textValue } = _a5, itemProps = __objRest(_a5, ["__scopeMenu", "disabled", "textValue"]);
    const contentContext = $6cc32821e9371a1c$var$useMenuContentContext($6cc32821e9371a1c$var$ITEM_NAME, __scopeMenu);
    const rovingFocusGroupScope = $6cc32821e9371a1c$var$useRovingFocusGroupScope(__scopeMenu);
    const ref = (0, import_react66.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
    const [isFocused, setIsFocused] = (0, import_react66.useState)(false);
    const [textContent, setTextContent] = (0, import_react66.useState)("");
    (0, import_react66.useEffect)(() => {
      const menuItem2 = ref.current;
      if (menuItem2) {
        var _menuItem$textContent;
        setTextContent(((_menuItem$textContent = menuItem2.textContent) !== null && _menuItem$textContent !== void 0 ? _menuItem$textContent : "").trim());
      }
    }, [
      itemProps.children
    ]);
    return /* @__PURE__ */ (0, import_react66.createElement)($6cc32821e9371a1c$var$Collection.ItemSlot, {
      scope: __scopeMenu,
      disabled,
      textValue: textValue !== null && textValue !== void 0 ? textValue : textContent
    }, /* @__PURE__ */ (0, import_react66.createElement)($d7bdfb9eb0fdf311$export$6d08773d2e66f8f2, _extends({
      asChild: true
    }, rovingFocusGroupScope, {
      focusable: !disabled
    }), /* @__PURE__ */ (0, import_react66.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
      role: "menuitem",
      "data-highlighted": isFocused ? "" : void 0,
      "aria-disabled": disabled || void 0,
      "data-disabled": disabled ? "" : void 0
    }, itemProps, {
      ref: composedRefs,
      onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $6cc32821e9371a1c$var$whenMouse((event) => {
        if (disabled)
          contentContext.onItemLeave(event);
        else {
          contentContext.onItemEnter(event);
          if (!event.defaultPrevented) {
            const item = event.currentTarget;
            item.focus();
          }
        }
      })),
      onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, $6cc32821e9371a1c$var$whenMouse(
        (event) => contentContext.onItemLeave(event)
      )),
      onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
        props.onFocus,
        () => setIsFocused(true)
      ),
      onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
        props.onBlur,
        () => setIsFocused(false)
      )
    }))));
  });
  var $6cc32821e9371a1c$export$f6f243521332502d = /* @__PURE__ */ (0, import_react66.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { checked = false, onCheckedChange } = _a5, checkboxItemProps = __objRest(_a5, ["checked", "onCheckedChange"]);
    return /* @__PURE__ */ (0, import_react66.createElement)($6cc32821e9371a1c$var$ItemIndicatorProvider, {
      scope: props.__scopeMenu,
      checked
    }, /* @__PURE__ */ (0, import_react66.createElement)($6cc32821e9371a1c$export$2ce376c2cc3355c8, _extends({
      role: "menuitemcheckbox",
      "aria-checked": $6cc32821e9371a1c$var$isIndeterminate(checked) ? "mixed" : checked
    }, checkboxItemProps, {
      ref: forwardedRef,
      "data-state": $6cc32821e9371a1c$var$getCheckedState(checked),
      onSelect: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
        checkboxItemProps.onSelect,
        () => onCheckedChange === null || onCheckedChange === void 0 ? void 0 : onCheckedChange($6cc32821e9371a1c$var$isIndeterminate(checked) ? true : !checked),
        {
          checkForDefaultPrevented: false
        }
      )
    })));
  });
  var $6cc32821e9371a1c$var$RADIO_GROUP_NAME = "MenuRadioGroup";
  var [$6cc32821e9371a1c$var$RadioGroupProvider, $6cc32821e9371a1c$var$useRadioGroupContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$RADIO_GROUP_NAME, {
    value: void 0,
    onValueChange: () => {
    }
  });
  var $6cc32821e9371a1c$var$ITEM_INDICATOR_NAME = "MenuItemIndicator";
  var [$6cc32821e9371a1c$var$ItemIndicatorProvider, $6cc32821e9371a1c$var$useItemIndicatorContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$ITEM_INDICATOR_NAME, {
    checked: false
  });
  var $6cc32821e9371a1c$export$a2593e23056970a3 = /* @__PURE__ */ (0, import_react66.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeMenu, forceMount } = _a5, itemIndicatorProps = __objRest(_a5, ["__scopeMenu", "forceMount"]);
    const indicatorContext = $6cc32821e9371a1c$var$useItemIndicatorContext($6cc32821e9371a1c$var$ITEM_INDICATOR_NAME, __scopeMenu);
    return /* @__PURE__ */ (0, import_react66.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
      present: forceMount || $6cc32821e9371a1c$var$isIndeterminate(indicatorContext.checked) || indicatorContext.checked === true
    }, /* @__PURE__ */ (0, import_react66.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({}, itemIndicatorProps, {
      ref: forwardedRef,
      "data-state": $6cc32821e9371a1c$var$getCheckedState(indicatorContext.checked)
    })));
  });
  var $6cc32821e9371a1c$var$SUB_NAME = "MenuSub";
  var [$6cc32821e9371a1c$var$MenuSubProvider, $6cc32821e9371a1c$var$useMenuSubContext] = $6cc32821e9371a1c$var$createMenuContext($6cc32821e9371a1c$var$SUB_NAME);
  var $6cc32821e9371a1c$export$71bdb9d1e2909932 = (props) => {
    const { __scopeMenu, children, open = false, onOpenChange } = props;
    const parentMenuContext = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$SUB_NAME, __scopeMenu);
    const popperScope = $6cc32821e9371a1c$var$usePopperScope(__scopeMenu);
    const [trigger2, setTrigger] = (0, import_react66.useState)(null);
    const [content, setContent] = (0, import_react66.useState)(null);
    const handleOpenChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onOpenChange);
    (0, import_react66.useEffect)(() => {
      if (parentMenuContext.open === false)
        handleOpenChange(false);
      return () => handleOpenChange(false);
    }, [
      parentMenuContext.open,
      handleOpenChange
    ]);
    return /* @__PURE__ */ (0, import_react66.createElement)($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe9, popperScope, /* @__PURE__ */ (0, import_react66.createElement)($6cc32821e9371a1c$var$MenuProvider, {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content,
      onContentChange: setContent
    }, /* @__PURE__ */ (0, import_react66.createElement)($6cc32821e9371a1c$var$MenuSubProvider, {
      scope: __scopeMenu,
      contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
      triggerId: $1746a345f3d73bb7$export$f680877a34711e37(),
      trigger: trigger2,
      onTriggerChange: setTrigger
    }, children)));
  };
  var $6cc32821e9371a1c$var$SUB_TRIGGER_NAME = "MenuSubTrigger";
  var $6cc32821e9371a1c$export$5fbbb3ba7297405f = /* @__PURE__ */ (0, import_react66.forwardRef)((props, forwardedRef) => {
    const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);
    const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);
    const subContext = $6cc32821e9371a1c$var$useMenuSubContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);
    const contentContext = $6cc32821e9371a1c$var$useMenuContentContext($6cc32821e9371a1c$var$SUB_TRIGGER_NAME, props.__scopeMenu);
    const openTimerRef = (0, import_react66.useRef)(null);
    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;
    const scope = {
      __scopeMenu: props.__scopeMenu
    };
    const clearOpenTimer = (0, import_react66.useCallback)(() => {
      if (openTimerRef.current)
        window.clearTimeout(openTimerRef.current);
      openTimerRef.current = null;
    }, []);
    (0, import_react66.useEffect)(
      () => clearOpenTimer,
      [
        clearOpenTimer
      ]
    );
    (0, import_react66.useEffect)(() => {
      const pointerGraceTimer = pointerGraceTimerRef.current;
      return () => {
        window.clearTimeout(pointerGraceTimer);
        onPointerGraceIntentChange(null);
      };
    }, [
      pointerGraceTimerRef,
      onPointerGraceIntentChange
    ]);
    return /* @__PURE__ */ (0, import_react66.createElement)($6cc32821e9371a1c$export$9fa5ebd18bee4d43, _extends({
      asChild: true
    }, scope), /* @__PURE__ */ (0, import_react66.createElement)($6cc32821e9371a1c$var$MenuItemImpl, _extends({
      id: subContext.triggerId,
      "aria-haspopup": "menu",
      "aria-expanded": context.open,
      "aria-controls": subContext.contentId,
      "data-state": $6cc32821e9371a1c$var$getOpenState(context.open)
    }, props, {
      ref: $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, subContext.onTriggerChange),
      onClick: (event) => {
        var _props$onClick;
        (_props$onClick = props.onClick) === null || _props$onClick === void 0 || _props$onClick.call(props, event);
        if (props.disabled || event.defaultPrevented)
          return;
        event.currentTarget.focus();
        if (!context.open)
          context.onOpenChange(true);
      },
      onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $6cc32821e9371a1c$var$whenMouse((event) => {
        contentContext.onItemEnter(event);
        if (event.defaultPrevented)
          return;
        if (!props.disabled && !context.open && !openTimerRef.current) {
          contentContext.onPointerGraceIntentChange(null);
          openTimerRef.current = window.setTimeout(() => {
            context.onOpenChange(true);
            clearOpenTimer();
          }, 100);
        }
      })),
      onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerLeave, $6cc32821e9371a1c$var$whenMouse((event) => {
        var _context$content;
        clearOpenTimer();
        const contentRect = (_context$content = context.content) === null || _context$content === void 0 ? void 0 : _context$content.getBoundingClientRect();
        if (contentRect) {
          var _context$content2;
          const side = (_context$content2 = context.content) === null || _context$content2 === void 0 ? void 0 : _context$content2.dataset.side;
          const rightSide = side === "right";
          const bleed = rightSide ? -5 : 5;
          const contentNearEdge = contentRect[rightSide ? "left" : "right"];
          const contentFarEdge = contentRect[rightSide ? "right" : "left"];
          contentContext.onPointerGraceIntentChange({
            area: [
              // consistently within polygon bounds
              {
                x: event.clientX + bleed,
                y: event.clientY
              },
              {
                x: contentNearEdge,
                y: contentRect.top
              },
              {
                x: contentFarEdge,
                y: contentRect.top
              },
              {
                x: contentFarEdge,
                y: contentRect.bottom
              },
              {
                x: contentNearEdge,
                y: contentRect.bottom
              }
            ],
            side
          });
          window.clearTimeout(pointerGraceTimerRef.current);
          pointerGraceTimerRef.current = window.setTimeout(
            () => contentContext.onPointerGraceIntentChange(null),
            300
          );
        } else {
          contentContext.onTriggerLeave(event);
          if (event.defaultPrevented)
            return;
          contentContext.onPointerGraceIntentChange(null);
        }
      })),
      onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
        const isTypingAhead = contentContext.searchRef.current !== "";
        if (props.disabled || isTypingAhead && event.key === " ")
          return;
        if ($6cc32821e9371a1c$var$SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {
          var _context$content3;
          context.onOpenChange(true);
          (_context$content3 = context.content) === null || _context$content3 === void 0 || _context$content3.focus();
          event.preventDefault();
        }
      })
    })));
  });
  var $6cc32821e9371a1c$var$SUB_CONTENT_NAME = "MenuSubContent";
  var $6cc32821e9371a1c$export$e7142ab31822bde6 = /* @__PURE__ */ (0, import_react66.forwardRef)((props, forwardedRef) => {
    const portalContext = $6cc32821e9371a1c$var$usePortalContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
    const _a5 = props, { forceMount = portalContext.forceMount } = _a5, subContentProps = __objRest(_a5, ["forceMount"]);
    const context = $6cc32821e9371a1c$var$useMenuContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
    const rootContext = $6cc32821e9371a1c$var$useMenuRootContext($6cc32821e9371a1c$var$CONTENT_NAME, props.__scopeMenu);
    const subContext = $6cc32821e9371a1c$var$useMenuSubContext($6cc32821e9371a1c$var$SUB_CONTENT_NAME, props.__scopeMenu);
    const ref = (0, import_react66.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
    return /* @__PURE__ */ (0, import_react66.createElement)($6cc32821e9371a1c$var$Collection.Provider, {
      scope: props.__scopeMenu
    }, /* @__PURE__ */ (0, import_react66.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
      present: forceMount || context.open
    }, /* @__PURE__ */ (0, import_react66.createElement)($6cc32821e9371a1c$var$Collection.Slot, {
      scope: props.__scopeMenu
    }, /* @__PURE__ */ (0, import_react66.createElement)($6cc32821e9371a1c$var$MenuContentImpl, _extends({
      id: subContext.contentId,
      "aria-labelledby": subContext.triggerId
    }, subContentProps, {
      ref: composedRefs,
      align: "start",
      side: rootContext.dir === "rtl" ? "left" : "right",
      disableOutsidePointerEvents: false,
      disableOutsideScroll: false,
      trapFocus: false,
      onOpenAutoFocus: (event) => {
        var _ref$current;
        if (rootContext.isUsingKeyboardRef.current)
          (_ref$current = ref.current) === null || _ref$current === void 0 || _ref$current.focus();
        event.preventDefault();
      },
      onCloseAutoFocus: (event) => event.preventDefault(),
      onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocusOutside, (event) => {
        if (event.target !== subContext.trigger)
          context.onOpenChange(false);
      }),
      onEscapeKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onEscapeKeyDown, (event) => {
        rootContext.onClose();
        event.preventDefault();
      }),
      onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
        const isKeyDownInside = event.currentTarget.contains(event.target);
        const isCloseKey = $6cc32821e9371a1c$var$SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);
        if (isKeyDownInside && isCloseKey) {
          var _subContext$trigger;
          context.onOpenChange(false);
          (_subContext$trigger = subContext.trigger) === null || _subContext$trigger === void 0 || _subContext$trigger.focus();
          event.preventDefault();
        }
      })
    })))));
  });
  function $6cc32821e9371a1c$var$getOpenState(open) {
    return open ? "open" : "closed";
  }
  function $6cc32821e9371a1c$var$isIndeterminate(checked) {
    return checked === "indeterminate";
  }
  function $6cc32821e9371a1c$var$getCheckedState(checked) {
    return $6cc32821e9371a1c$var$isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
  }
  function $6cc32821e9371a1c$var$focusFirst(candidates) {
    const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
    for (const candidate of candidates) {
      if (candidate === PREVIOUSLY_FOCUSED_ELEMENT)
        return;
      candidate.focus();
      if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT)
        return;
    }
  }
  function $6cc32821e9371a1c$var$wrapArray(array2, startIndex) {
    return array2.map(
      (_, index2) => array2[(startIndex + index2) % array2.length]
    );
  }
  function $6cc32821e9371a1c$var$getNextMatch(values, search, currentMatch) {
    const isRepeated = search.length > 1 && Array.from(search).every(
      (char) => char === search[0]
    );
    const normalizedSearch = isRepeated ? search[0] : search;
    const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
    let wrappedValues = $6cc32821e9371a1c$var$wrapArray(values, Math.max(currentMatchIndex, 0));
    const excludeCurrentMatch = normalizedSearch.length === 1;
    if (excludeCurrentMatch)
      wrappedValues = wrappedValues.filter(
        (v3) => v3 !== currentMatch
      );
    const nextMatch = wrappedValues.find(
      (value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase())
    );
    return nextMatch !== currentMatch ? nextMatch : void 0;
  }
  function $6cc32821e9371a1c$var$isPointInPolygon(point2, polygon) {
    const { x: x3, y: y3 } = point2;
    let inside = false;
    for (let i3 = 0, j = polygon.length - 1; i3 < polygon.length; j = i3++) {
      const xi = polygon[i3].x;
      const yi = polygon[i3].y;
      const xj = polygon[j].x;
      const yj = polygon[j].y;
      const intersect = yi > y3 !== yj > y3 && x3 < (xj - xi) * (y3 - yi) / (yj - yi) + xi;
      if (intersect)
        inside = !inside;
    }
    return inside;
  }
  function $6cc32821e9371a1c$var$isPointerInGraceArea(event, area) {
    if (!area)
      return false;
    const cursorPos = {
      x: event.clientX,
      y: event.clientY
    };
    return $6cc32821e9371a1c$var$isPointInPolygon(cursorPos, area);
  }
  function $6cc32821e9371a1c$var$whenMouse(handler) {
    return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
  }
  var $6cc32821e9371a1c$export$be92b6f5f03c0fe9 = $6cc32821e9371a1c$export$d9b273488cd8ce6f;
  var $6cc32821e9371a1c$export$b688253958b8dfe7 = $6cc32821e9371a1c$export$9fa5ebd18bee4d43;
  var $6cc32821e9371a1c$export$602eac185826482c = $6cc32821e9371a1c$export$793392f970497feb;
  var $6cc32821e9371a1c$export$7c6e2c02157bb7d2 = $6cc32821e9371a1c$export$479f0f2f71193efe;
  var $6cc32821e9371a1c$export$eb2fcfdbd7ba97d4 = $6cc32821e9371a1c$export$22a631d1f72787bb;
  var $6cc32821e9371a1c$export$6d08773d2e66f8f2 = $6cc32821e9371a1c$export$2ce376c2cc3355c8;
  var $6cc32821e9371a1c$export$16ce288f89fa631c = $6cc32821e9371a1c$export$f6f243521332502d;
  var $6cc32821e9371a1c$export$c3468e2714d175fa = $6cc32821e9371a1c$export$a2593e23056970a3;
  var $6cc32821e9371a1c$export$d7a01e11500dfb6f = $6cc32821e9371a1c$export$71bdb9d1e2909932;
  var $6cc32821e9371a1c$export$2ea8a7a591ac5eac = $6cc32821e9371a1c$export$5fbbb3ba7297405f;
  var $6cc32821e9371a1c$export$6d4de93b380beddf = $6cc32821e9371a1c$export$e7142ab31822bde6;

  // ../../../node_modules/@radix-ui/react-dropdown-menu/dist/index.module.js
  var $d08ef79370b62062$var$DROPDOWN_MENU_NAME = "DropdownMenu";
  var [$d08ef79370b62062$var$createDropdownMenuContext, $d08ef79370b62062$export$c0623cd925aeb687] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($d08ef79370b62062$var$DROPDOWN_MENU_NAME, [
    $6cc32821e9371a1c$export$4027731b685e72eb
  ]);
  var $d08ef79370b62062$var$useMenuScope = $6cc32821e9371a1c$export$4027731b685e72eb();
  var [$d08ef79370b62062$var$DropdownMenuProvider, $d08ef79370b62062$var$useDropdownMenuContext] = $d08ef79370b62062$var$createDropdownMenuContext($d08ef79370b62062$var$DROPDOWN_MENU_NAME);
  var $d08ef79370b62062$export$e44a253a59704894 = (props) => {
    const { __scopeDropdownMenu, children, dir, open: openProp, defaultOpen, onOpenChange, modal = true } = props;
    const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
    const triggerRef = (0, import_react67.useRef)(null);
    const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    return /* @__PURE__ */ (0, import_react67.createElement)($d08ef79370b62062$var$DropdownMenuProvider, {
      scope: __scopeDropdownMenu,
      triggerId: $1746a345f3d73bb7$export$f680877a34711e37(),
      triggerRef,
      contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: (0, import_react67.useCallback)(
        () => setOpen(
          (prevOpen) => !prevOpen
        ),
        [
          setOpen
        ]
      ),
      modal
    }, /* @__PURE__ */ (0, import_react67.createElement)($6cc32821e9371a1c$export$be92b6f5f03c0fe9, _extends({}, menuScope, {
      open,
      onOpenChange: setOpen,
      dir,
      modal
    }), children));
  };
  var $d08ef79370b62062$var$TRIGGER_NAME = "DropdownMenuTrigger";
  var $d08ef79370b62062$export$d2469213b3befba9 = /* @__PURE__ */ (0, import_react67.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeDropdownMenu, disabled = false } = _a5, triggerProps = __objRest(_a5, ["__scopeDropdownMenu", "disabled"]);
    const context = $d08ef79370b62062$var$useDropdownMenuContext($d08ef79370b62062$var$TRIGGER_NAME, __scopeDropdownMenu);
    const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ (0, import_react67.createElement)($6cc32821e9371a1c$export$b688253958b8dfe7, _extends({
      asChild: true
    }, menuScope), /* @__PURE__ */ (0, import_react67.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
      type: "button",
      id: context.triggerId,
      "aria-haspopup": "menu",
      "aria-expanded": context.open,
      "aria-controls": context.open ? context.contentId : void 0,
      "data-state": context.open ? "open" : "closed",
      "data-disabled": disabled ? "" : void 0,
      disabled
    }, triggerProps, {
      ref: $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, context.triggerRef),
      onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDown, (event) => {
        if (!disabled && event.button === 0 && event.ctrlKey === false) {
          context.onOpenToggle();
          if (!context.open)
            event.preventDefault();
        }
      }),
      onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
        if (disabled)
          return;
        if ([
          "Enter",
          " "
        ].includes(event.key))
          context.onOpenToggle();
        if (event.key === "ArrowDown")
          context.onOpenChange(true);
        if ([
          "Enter",
          " ",
          "ArrowDown"
        ].includes(event.key))
          event.preventDefault();
      })
    })));
  });
  var $d08ef79370b62062$export$cd369b4d4d54efc9 = (props) => {
    const _a5 = props, { __scopeDropdownMenu } = _a5, portalProps = __objRest(_a5, ["__scopeDropdownMenu"]);
    const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ (0, import_react67.createElement)($6cc32821e9371a1c$export$602eac185826482c, _extends({}, menuScope, portalProps));
  };
  var $d08ef79370b62062$var$CONTENT_NAME = "DropdownMenuContent";
  var $d08ef79370b62062$export$6e76d93a37c01248 = /* @__PURE__ */ (0, import_react67.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeDropdownMenu } = _a5, contentProps = __objRest(_a5, ["__scopeDropdownMenu"]);
    const context = $d08ef79370b62062$var$useDropdownMenuContext($d08ef79370b62062$var$CONTENT_NAME, __scopeDropdownMenu);
    const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
    const hasInteractedOutsideRef = (0, import_react67.useRef)(false);
    return /* @__PURE__ */ (0, import_react67.createElement)($6cc32821e9371a1c$export$7c6e2c02157bb7d2, _extends({
      id: context.contentId,
      "aria-labelledby": context.triggerId
    }, menuScope, contentProps, {
      ref: forwardedRef,
      onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event) => {
        var _context$triggerRef$c;
        if (!hasInteractedOutsideRef.current)
          (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();
        hasInteractedOutsideRef.current = false;
        event.preventDefault();
      }),
      onInteractOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onInteractOutside, (event) => {
        const originalEvent = event.detail.originalEvent;
        const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
        const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
        if (!context.modal || isRightClick)
          hasInteractedOutsideRef.current = true;
      }),
      style: __spreadProps(__spreadValues({}, props.style), {
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      })
    }));
  });
  var $d08ef79370b62062$export$246bebaba3a2f70e = /* @__PURE__ */ (0, import_react67.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeDropdownMenu } = _a5, groupProps = __objRest(_a5, ["__scopeDropdownMenu"]);
    const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ (0, import_react67.createElement)($6cc32821e9371a1c$export$eb2fcfdbd7ba97d4, _extends({}, menuScope, groupProps, {
      ref: forwardedRef
    }));
  });
  var $d08ef79370b62062$export$ed97964d1871885d = /* @__PURE__ */ (0, import_react67.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeDropdownMenu } = _a5, itemProps = __objRest(_a5, ["__scopeDropdownMenu"]);
    const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ (0, import_react67.createElement)($6cc32821e9371a1c$export$6d08773d2e66f8f2, _extends({}, menuScope, itemProps, {
      ref: forwardedRef
    }));
  });
  var $d08ef79370b62062$export$53a69729da201fa9 = /* @__PURE__ */ (0, import_react67.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeDropdownMenu } = _a5, checkboxItemProps = __objRest(_a5, ["__scopeDropdownMenu"]);
    const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ (0, import_react67.createElement)($6cc32821e9371a1c$export$16ce288f89fa631c, _extends({}, menuScope, checkboxItemProps, {
      ref: forwardedRef
    }));
  });
  var $d08ef79370b62062$export$42355ae145153fb6 = /* @__PURE__ */ (0, import_react67.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeDropdownMenu } = _a5, itemIndicatorProps = __objRest(_a5, ["__scopeDropdownMenu"]);
    const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ (0, import_react67.createElement)($6cc32821e9371a1c$export$c3468e2714d175fa, _extends({}, menuScope, itemIndicatorProps, {
      ref: forwardedRef
    }));
  });
  var $d08ef79370b62062$export$2f307d81a64f5442 = (props) => {
    const { __scopeDropdownMenu, children, open: openProp, onOpenChange, defaultOpen } = props;
    const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
    const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    return /* @__PURE__ */ (0, import_react67.createElement)($6cc32821e9371a1c$export$d7a01e11500dfb6f, _extends({}, menuScope, {
      open,
      onOpenChange: setOpen
    }), children);
  };
  var $d08ef79370b62062$export$21dcb7ec56f874cf = /* @__PURE__ */ (0, import_react67.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeDropdownMenu } = _a5, subTriggerProps = __objRest(_a5, ["__scopeDropdownMenu"]);
    const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ (0, import_react67.createElement)($6cc32821e9371a1c$export$2ea8a7a591ac5eac, _extends({}, menuScope, subTriggerProps, {
      ref: forwardedRef
    }));
  });
  var $d08ef79370b62062$export$f34ec8bc2482cc5f = /* @__PURE__ */ (0, import_react67.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeDropdownMenu } = _a5, subContentProps = __objRest(_a5, ["__scopeDropdownMenu"]);
    const menuScope = $d08ef79370b62062$var$useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ (0, import_react67.createElement)($6cc32821e9371a1c$export$6d4de93b380beddf, _extends({}, menuScope, subContentProps, {
      ref: forwardedRef,
      style: __spreadProps(__spreadValues({}, props.style), {
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      })
    }));
  });
  var $d08ef79370b62062$export$be92b6f5f03c0fe9 = $d08ef79370b62062$export$e44a253a59704894;
  var $d08ef79370b62062$export$41fb9f06171c75f4 = $d08ef79370b62062$export$d2469213b3befba9;
  var $d08ef79370b62062$export$602eac185826482c = $d08ef79370b62062$export$cd369b4d4d54efc9;
  var $d08ef79370b62062$export$7c6e2c02157bb7d2 = $d08ef79370b62062$export$6e76d93a37c01248;
  var $d08ef79370b62062$export$eb2fcfdbd7ba97d4 = $d08ef79370b62062$export$246bebaba3a2f70e;
  var $d08ef79370b62062$export$6d08773d2e66f8f2 = $d08ef79370b62062$export$ed97964d1871885d;
  var $d08ef79370b62062$export$16ce288f89fa631c = $d08ef79370b62062$export$53a69729da201fa9;
  var $d08ef79370b62062$export$c3468e2714d175fa = $d08ef79370b62062$export$42355ae145153fb6;
  var $d08ef79370b62062$export$d7a01e11500dfb6f = $d08ef79370b62062$export$2f307d81a64f5442;
  var $d08ef79370b62062$export$2ea8a7a591ac5eac = $d08ef79370b62062$export$21dcb7ec56f874cf;
  var $d08ef79370b62062$export$6d4de93b380beddf = $d08ef79370b62062$export$f34ec8bc2482cc5f;

  // ../../../packages/ui/src/lib/hooks/useMenuIsOpen.ts
  var import_react68 = __toESM(require_react());

  // ../../../packages/ui/src/lib/hooks/useEventsProvider.tsx
  var React44 = __toESM(require_react());
  var import_jsx_runtime62 = __toESM(require_jsx_runtime());
  var defaultEventHandler = () => void 0;
  var EventsContext = React44.createContext({});
  function EventsProvider({ onEvent, children }) {
    return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(EventsContext.Provider, { value: onEvent != null ? onEvent : defaultEventHandler, children });
  }
  function useEvents() {
    return React44.useContext(EventsContext);
  }

  // ../../../packages/ui/src/lib/hooks/useMenuIsOpen.ts
  function useMenuIsOpen(id, cb) {
    const app = useApp();
    const rIsOpen = (0, import_react68.useRef)(false);
    const trackEvent = useEvents();
    const onOpenChange = (0, import_react68.useCallback)(
      (isOpen2) => {
        rIsOpen.current = isOpen2;
        app.batch(() => {
          if (isOpen2) {
            app.complete();
            app.addOpenMenu(id);
          } else {
            app.deleteOpenMenu(id);
            app.openMenus.forEach((menuId) => {
              if (menuId.startsWith(id)) {
                app.deleteOpenMenu(menuId);
              }
            });
          }
          cb == null ? void 0 : cb(isOpen2);
        });
      },
      [app, id, cb]
    );
    (0, import_react68.useEffect)(() => {
      if (rIsOpen.current) {
        trackEvent("open-menu", { source: "unknown", id });
        app.addOpenMenu(id);
      }
      return () => {
        if (rIsOpen.current) {
          app.deleteOpenMenu(id);
          app.openMenus.forEach((menuId) => {
            if (menuId.startsWith(id)) {
              trackEvent("close-menu", { source: "unknown", id });
              app.deleteOpenMenu(menuId);
            }
          });
          rIsOpen.current = false;
        }
      };
    }, [app, id, trackEvent]);
    const isOpen = useValue("is menu open", () => app.openMenus.includes(id), [app, id]);
    return [isOpen, onOpenChange];
  }

  // ../../../packages/ui/src/lib/components/primitives/DropdownMenu.tsx
  var import_jsx_runtime63 = __toESM(require_jsx_runtime());
  function Root({
    id,
    children,
    modal = false
  }) {
    const [open, onOpenChange] = useMenuIsOpen(id);
    return /* @__PURE__ */ (0, import_jsx_runtime63.jsx)($d08ef79370b62062$export$be92b6f5f03c0fe9, { open, dir: "ltr", modal, onOpenChange, children });
  }
  function Trigger({ children, "data-wd": dataWd }) {
    return /* @__PURE__ */ (0, import_jsx_runtime63.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, { dir: "ltr", "data-wd": dataWd, asChild: true, children });
  }
  function Content({
    side = "bottom",
    align = "start",
    sideOffset = 8,
    alignOffset = 8,
    children
  }) {
    const container = useContainer();
    return /* @__PURE__ */ (0, import_jsx_runtime63.jsx)($d08ef79370b62062$export$602eac185826482c, { dir: "ltr", container, children: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(
      $d08ef79370b62062$export$7c6e2c02157bb7d2,
      {
        className: "tlui-menu",
        align,
        sideOffset,
        side,
        alignOffset,
        collisionPadding: 4,
        children
      }
    ) });
  }
  function Sub({ id, children }) {
    const [open, onOpenChange] = useMenuIsOpen(id);
    return /* @__PURE__ */ (0, import_jsx_runtime63.jsx)($d08ef79370b62062$export$d7a01e11500dfb6f, { open, onOpenChange, children });
  }
  function SubTrigger({
    label,
    "data-wd": dataWd,
    "data-direction": dataDirection
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime63.jsx)($d08ef79370b62062$export$2ea8a7a591ac5eac, { dir: "ltr", "data-direction": dataDirection, "data-wd": dataWd, asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(
      Button,
      {
        className: "tlui-menu__button tlui-menu__submenu__trigger",
        label,
        icon: "chevron-right"
      }
    ) });
  }
  function SubContent({
    alignOffset = 0,
    sideOffset = 5,
    children
  }) {
    const container = useContainer();
    return /* @__PURE__ */ (0, import_jsx_runtime63.jsx)($d08ef79370b62062$export$602eac185826482c, { container, dir: "ltr", children: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(
      $d08ef79370b62062$export$6d4de93b380beddf,
      {
        className: "tlui-menu tlui-menu__submenu__content",
        alignOffset,
        sideOffset,
        collisionPadding: 4,
        children
      }
    ) });
  }
  function Group({
    children,
    size = "medium"
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime63.jsx)($d08ef79370b62062$export$eb2fcfdbd7ba97d4, { dir: "ltr", className: "tlui-menu__group", "data-size": size, children });
  }
  function Item(_a5) {
    var _b2 = _a5, { noClose } = _b2, props = __objRest(_b2, ["noClose"]);
    return /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(
      $d08ef79370b62062$export$6d08773d2e66f8f2,
      {
        dir: "ltr",
        asChild: true,
        onClick: noClose || props.isChecked !== void 0 ? preventDefault : void 0,
        children: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(Button, __spreadValues({ className: "tlui-menu__button" }, props))
      }
    );
  }
  function CheckboxItem(_a5) {
    var _b2 = _a5, { children, onSelect } = _b2, rest = __objRest(_b2, ["children", "onSelect"]);
    return /* @__PURE__ */ (0, import_jsx_runtime63.jsxs)(
      $d08ef79370b62062$export$16ce288f89fa631c,
      __spreadProps(__spreadValues({
        dir: "ltr",
        className: "tlui-button tlui-menu__button tlui-menu__checkbox-item",
        onSelect: (e2) => {
          onSelect == null ? void 0 : onSelect(e2);
          preventDefault(e2);
        }
      }, rest), {
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(
            "div",
            {
              className: "tlui-menu__checkbox-item__check",
              style: {
                transformOrigin: "75% center",
                transform: `scale(${rest.checked ? 1 : 0.5})`,
                opacity: rest.checked ? 1 : 0.5
              },
              children: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(Icon, { small: true, icon: rest.checked ? "check" : "checkbox-empty" })
            }
          ),
          children
        ]
      })
    );
  }
  function RadioItem(_a5) {
    var _b2 = _a5, { children, onSelect } = _b2, rest = __objRest(_b2, ["children", "onSelect"]);
    return /* @__PURE__ */ (0, import_jsx_runtime63.jsxs)(
      $d08ef79370b62062$export$16ce288f89fa631c,
      __spreadProps(__spreadValues({
        dir: "ltr",
        className: "tlui-button tlui-menu__button tlui-menu__checkbox-item",
        onSelect: (e2) => {
          onSelect == null ? void 0 : onSelect(e2);
          preventDefault(e2);
        }
      }, rest), {
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime63.jsx)($d08ef79370b62062$export$c3468e2714d175fa, { dir: "ltr", className: "tlui-menu__checkbox-item__check", children: /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(Icon, { icon: "check" }) }),
          children
        ]
      })
    );
  }

  // ../../../node_modules/@radix-ui/react-toast/dist/index.module.js
  var import_react70 = __toESM(require_react());
  var import_react_dom5 = __toESM(require_react_dom());

  // ../../../node_modules/@radix-ui/react-visually-hidden/dist/index.module.js
  var import_react69 = __toESM(require_react());
  var $ea1ef594cf570d83$export$439d29a4e110a164 = /* @__PURE__ */ (0, import_react69.forwardRef)((props, forwardedRef) => {
    return /* @__PURE__ */ (0, import_react69.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({}, props, {
      ref: forwardedRef,
      style: __spreadValues({
        // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal"
      }, props.style)
    }));
  });

  // ../../../node_modules/@radix-ui/react-toast/dist/index.module.js
  var $054eb8030ebde76e$var$PROVIDER_NAME = "ToastProvider";
  var [$054eb8030ebde76e$var$Collection, $054eb8030ebde76e$var$useCollection, $054eb8030ebde76e$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2("Toast");
  var [$054eb8030ebde76e$var$createToastContext, $054eb8030ebde76e$export$8a359da18fbc9073] = $c512c27ab02ef895$export$50c7b4e9d9f19c1("Toast", [
    $054eb8030ebde76e$var$createCollectionScope
  ]);
  var [$054eb8030ebde76e$var$ToastProviderProvider, $054eb8030ebde76e$var$useToastProviderContext] = $054eb8030ebde76e$var$createToastContext($054eb8030ebde76e$var$PROVIDER_NAME);
  var $054eb8030ebde76e$export$f5d03d415824e0e = (props) => {
    const { __scopeToast, label = "Notification", duration = 5e3, swipeDirection = "right", swipeThreshold = 50, children } = props;
    const [viewport, setViewport] = (0, import_react70.useState)(null);
    const [toastCount, setToastCount] = (0, import_react70.useState)(0);
    const isFocusedToastEscapeKeyDownRef = (0, import_react70.useRef)(false);
    const isClosePausedRef = (0, import_react70.useRef)(false);
    return /* @__PURE__ */ (0, import_react70.createElement)($054eb8030ebde76e$var$Collection.Provider, {
      scope: __scopeToast
    }, /* @__PURE__ */ (0, import_react70.createElement)($054eb8030ebde76e$var$ToastProviderProvider, {
      scope: __scopeToast,
      label,
      duration,
      swipeDirection,
      swipeThreshold,
      toastCount,
      viewport,
      onViewportChange: setViewport,
      onToastAdd: (0, import_react70.useCallback)(
        () => setToastCount(
          (prevCount) => prevCount + 1
        ),
        []
      ),
      onToastRemove: (0, import_react70.useCallback)(
        () => setToastCount(
          (prevCount) => prevCount - 1
        ),
        []
      ),
      isFocusedToastEscapeKeyDownRef,
      isClosePausedRef
    }, children));
  };
  $054eb8030ebde76e$export$f5d03d415824e0e.propTypes = {
    label(props) {
      if (props.label && typeof props.label === "string" && !props.label.trim()) {
        const error = `Invalid prop \`label\` supplied to \`${$054eb8030ebde76e$var$PROVIDER_NAME}\`. Expected non-empty \`string\`.`;
        return new Error(error);
      }
      return null;
    }
  };
  var $054eb8030ebde76e$var$VIEWPORT_NAME = "ToastViewport";
  var $054eb8030ebde76e$var$VIEWPORT_DEFAULT_HOTKEY = [
    "F8"
  ];
  var $054eb8030ebde76e$var$VIEWPORT_PAUSE = "toast.viewportPause";
  var $054eb8030ebde76e$var$VIEWPORT_RESUME = "toast.viewportResume";
  var $054eb8030ebde76e$export$6192c2425ecfd989 = /* @__PURE__ */ (0, import_react70.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeToast, hotkey = $054eb8030ebde76e$var$VIEWPORT_DEFAULT_HOTKEY, label = "Notifications ({hotkey})" } = _a5, viewportProps = __objRest(_a5, ["__scopeToast", "hotkey", "label"]);
    const context = $054eb8030ebde76e$var$useToastProviderContext($054eb8030ebde76e$var$VIEWPORT_NAME, __scopeToast);
    const getItems = $054eb8030ebde76e$var$useCollection(__scopeToast);
    const wrapperRef = (0, import_react70.useRef)(null);
    const headFocusProxyRef = (0, import_react70.useRef)(null);
    const tailFocusProxyRef = (0, import_react70.useRef)(null);
    const ref = (0, import_react70.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref, context.onViewportChange);
    const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    const hasToasts = context.toastCount > 0;
    (0, import_react70.useEffect)(() => {
      const handleKeyDown = (event) => {
        var _ref$current;
        const isHotkeyPressed = hotkey.every(
          (key) => event[key] || event.code === key
        );
        if (isHotkeyPressed)
          (_ref$current = ref.current) === null || _ref$current === void 0 || _ref$current.focus();
      };
      document.addEventListener("keydown", handleKeyDown);
      return () => document.removeEventListener("keydown", handleKeyDown);
    }, [
      hotkey
    ]);
    (0, import_react70.useEffect)(() => {
      const wrapper = wrapperRef.current;
      const viewport = ref.current;
      if (hasToasts && wrapper && viewport) {
        const handlePause = () => {
          if (!context.isClosePausedRef.current) {
            const pauseEvent = new CustomEvent($054eb8030ebde76e$var$VIEWPORT_PAUSE);
            viewport.dispatchEvent(pauseEvent);
            context.isClosePausedRef.current = true;
          }
        };
        const handleResume = () => {
          if (context.isClosePausedRef.current) {
            const resumeEvent = new CustomEvent($054eb8030ebde76e$var$VIEWPORT_RESUME);
            viewport.dispatchEvent(resumeEvent);
            context.isClosePausedRef.current = false;
          }
        };
        const handleFocusOutResume = (event) => {
          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);
          if (isFocusMovingOutside)
            handleResume();
        };
        const handlePointerLeaveResume = () => {
          const isFocusInside = wrapper.contains(document.activeElement);
          if (!isFocusInside)
            handleResume();
        };
        wrapper.addEventListener("focusin", handlePause);
        wrapper.addEventListener("focusout", handleFocusOutResume);
        wrapper.addEventListener("pointermove", handlePause);
        wrapper.addEventListener("pointerleave", handlePointerLeaveResume);
        window.addEventListener("blur", handlePause);
        window.addEventListener("focus", handleResume);
        return () => {
          wrapper.removeEventListener("focusin", handlePause);
          wrapper.removeEventListener("focusout", handleFocusOutResume);
          wrapper.removeEventListener("pointermove", handlePause);
          wrapper.removeEventListener("pointerleave", handlePointerLeaveResume);
          window.removeEventListener("blur", handlePause);
          window.removeEventListener("focus", handleResume);
        };
      }
    }, [
      hasToasts,
      context.isClosePausedRef
    ]);
    const getSortedTabbableCandidates = (0, import_react70.useCallback)(({ tabbingDirection }) => {
      const toastItems = getItems();
      const tabbableCandidates = toastItems.map((toastItem) => {
        const toastNode = toastItem.ref.current;
        const toastTabbableCandidates = [
          toastNode,
          ...$054eb8030ebde76e$var$getTabbableCandidates(toastNode)
        ];
        return tabbingDirection === "forwards" ? toastTabbableCandidates : toastTabbableCandidates.reverse();
      });
      return (tabbingDirection === "forwards" ? tabbableCandidates.reverse() : tabbableCandidates).flat();
    }, [
      getItems
    ]);
    (0, import_react70.useEffect)(() => {
      const viewport = ref.current;
      if (viewport) {
        const handleKeyDown = (event) => {
          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
          const isTabKey = event.key === "Tab" && !isMetaKey;
          if (isTabKey) {
            const focusedElement = document.activeElement;
            const isTabbingBackwards = event.shiftKey;
            const targetIsViewport = event.target === viewport;
            if (targetIsViewport && isTabbingBackwards) {
              var _headFocusProxyRef$cu;
              (_headFocusProxyRef$cu = headFocusProxyRef.current) === null || _headFocusProxyRef$cu === void 0 || _headFocusProxyRef$cu.focus();
              return;
            }
            const tabbingDirection = isTabbingBackwards ? "backwards" : "forwards";
            const sortedCandidates = getSortedTabbableCandidates({
              tabbingDirection
            });
            const index2 = sortedCandidates.findIndex(
              (candidate) => candidate === focusedElement
            );
            if ($054eb8030ebde76e$var$focusFirst(sortedCandidates.slice(index2 + 1)))
              event.preventDefault();
            else {
              var _headFocusProxyRef$cu2, _tailFocusProxyRef$cu;
              isTabbingBackwards ? (_headFocusProxyRef$cu2 = headFocusProxyRef.current) === null || _headFocusProxyRef$cu2 === void 0 || _headFocusProxyRef$cu2.focus() : (_tailFocusProxyRef$cu = tailFocusProxyRef.current) === null || _tailFocusProxyRef$cu === void 0 || _tailFocusProxyRef$cu.focus();
            }
          }
        };
        viewport.addEventListener("keydown", handleKeyDown);
        return () => viewport.removeEventListener("keydown", handleKeyDown);
      }
    }, [
      getItems,
      getSortedTabbableCandidates
    ]);
    return /* @__PURE__ */ (0, import_react70.createElement)($5cb92bef7577960e$export$aecb2ddcb55c95be, {
      ref: wrapperRef,
      role: "region",
      "aria-label": label.replace("{hotkey}", hotkeyLabel),
      tabIndex: -1,
      style: {
        pointerEvents: hasToasts ? void 0 : "none"
      }
    }, hasToasts && /* @__PURE__ */ (0, import_react70.createElement)($054eb8030ebde76e$var$FocusProxy, {
      ref: headFocusProxyRef,
      onFocusFromOutsideViewport: () => {
        const tabbableCandidates = getSortedTabbableCandidates({
          tabbingDirection: "forwards"
        });
        $054eb8030ebde76e$var$focusFirst(tabbableCandidates);
      }
    }), /* @__PURE__ */ (0, import_react70.createElement)($054eb8030ebde76e$var$Collection.Slot, {
      scope: __scopeToast
    }, /* @__PURE__ */ (0, import_react70.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.ol, _extends({
      tabIndex: -1
    }, viewportProps, {
      ref: composedRefs
    }))), hasToasts && /* @__PURE__ */ (0, import_react70.createElement)($054eb8030ebde76e$var$FocusProxy, {
      ref: tailFocusProxyRef,
      onFocusFromOutsideViewport: () => {
        const tabbableCandidates = getSortedTabbableCandidates({
          tabbingDirection: "backwards"
        });
        $054eb8030ebde76e$var$focusFirst(tabbableCandidates);
      }
    }));
  });
  var $054eb8030ebde76e$var$FOCUS_PROXY_NAME = "ToastFocusProxy";
  var $054eb8030ebde76e$var$FocusProxy = /* @__PURE__ */ (0, import_react70.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeToast, onFocusFromOutsideViewport } = _a5, proxyProps = __objRest(_a5, ["__scopeToast", "onFocusFromOutsideViewport"]);
    const context = $054eb8030ebde76e$var$useToastProviderContext($054eb8030ebde76e$var$FOCUS_PROXY_NAME, __scopeToast);
    return /* @__PURE__ */ (0, import_react70.createElement)($ea1ef594cf570d83$export$439d29a4e110a164, _extends({
      "aria-hidden": true,
      tabIndex: 0
    }, proxyProps, {
      ref: forwardedRef,
      style: {
        position: "fixed"
      },
      onFocus: (event) => {
        var _context$viewport;
        const prevFocusedElement = event.relatedTarget;
        const isFocusFromOutsideViewport = !((_context$viewport = context.viewport) !== null && _context$viewport !== void 0 && _context$viewport.contains(prevFocusedElement));
        if (isFocusFromOutsideViewport)
          onFocusFromOutsideViewport();
      }
    }));
  });
  var $054eb8030ebde76e$var$TOAST_NAME = "Toast";
  var $054eb8030ebde76e$var$TOAST_SWIPE_START = "toast.swipeStart";
  var $054eb8030ebde76e$var$TOAST_SWIPE_MOVE = "toast.swipeMove";
  var $054eb8030ebde76e$var$TOAST_SWIPE_CANCEL = "toast.swipeCancel";
  var $054eb8030ebde76e$var$TOAST_SWIPE_END = "toast.swipeEnd";
  var $054eb8030ebde76e$export$8d8dc7d5f743331b = /* @__PURE__ */ (0, import_react70.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { forceMount, open: openProp, defaultOpen, onOpenChange } = _a5, toastProps = __objRest(_a5, ["forceMount", "open", "defaultOpen", "onOpenChange"]);
    const [open = true, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    return /* @__PURE__ */ (0, import_react70.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
      present: forceMount || open
    }, /* @__PURE__ */ (0, import_react70.createElement)($054eb8030ebde76e$var$ToastImpl, _extends({
      open
    }, toastProps, {
      ref: forwardedRef,
      onClose: () => setOpen(false),
      onPause: $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(props.onPause),
      onResume: $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(props.onResume),
      onSwipeStart: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onSwipeStart, (event) => {
        event.currentTarget.setAttribute("data-swipe", "start");
      }),
      onSwipeMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onSwipeMove, (event) => {
        const { x: x3, y: y3 } = event.detail.delta;
        event.currentTarget.setAttribute("data-swipe", "move");
        event.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${x3}px`);
        event.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${y3}px`);
      }),
      onSwipeCancel: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onSwipeCancel, (event) => {
        event.currentTarget.setAttribute("data-swipe", "cancel");
        event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
        event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
        event.currentTarget.style.removeProperty("--radix-toast-swipe-end-x");
        event.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
      }),
      onSwipeEnd: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onSwipeEnd, (event) => {
        const { x: x3, y: y3 } = event.detail.delta;
        event.currentTarget.setAttribute("data-swipe", "end");
        event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
        event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
        event.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${x3}px`);
        event.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${y3}px`);
        setOpen(false);
      })
    })));
  });
  var [$054eb8030ebde76e$var$ToastInteractiveProvider, $054eb8030ebde76e$var$useToastInteractiveContext] = $054eb8030ebde76e$var$createToastContext($054eb8030ebde76e$var$TOAST_NAME, {
    onClose() {
    }
  });
  var $054eb8030ebde76e$var$ToastImpl = /* @__PURE__ */ (0, import_react70.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeToast, type = "foreground", duration: durationProp, open, onClose, onEscapeKeyDown, onPause, onResume, onSwipeStart, onSwipeMove, onSwipeCancel, onSwipeEnd } = _a5, toastProps = __objRest(_a5, ["__scopeToast", "type", "duration", "open", "onClose", "onEscapeKeyDown", "onPause", "onResume", "onSwipeStart", "onSwipeMove", "onSwipeCancel", "onSwipeEnd"]);
    const context = $054eb8030ebde76e$var$useToastProviderContext($054eb8030ebde76e$var$TOAST_NAME, __scopeToast);
    const [node1, setNode] = (0, import_react70.useState)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
      forwardedRef,
      (node) => setNode(node)
    );
    const pointerStartRef = (0, import_react70.useRef)(null);
    const swipeDeltaRef = (0, import_react70.useRef)(null);
    const duration1 = durationProp || context.duration;
    const closeTimerStartTimeRef = (0, import_react70.useRef)(0);
    const closeTimerRemainingTimeRef = (0, import_react70.useRef)(duration1);
    const closeTimerRef = (0, import_react70.useRef)(0);
    const { onToastAdd, onToastRemove } = context;
    const handleClose = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(() => {
      var _context$viewport2;
      const isFocusInToast = node1 === null || node1 === void 0 ? void 0 : node1.contains(document.activeElement);
      if (isFocusInToast)
        (_context$viewport2 = context.viewport) === null || _context$viewport2 === void 0 || _context$viewport2.focus();
      onClose();
    });
    const startTimer = (0, import_react70.useCallback)((duration) => {
      if (!duration || duration === Infinity)
        return;
      window.clearTimeout(closeTimerRef.current);
      closeTimerStartTimeRef.current = new Date().getTime();
      closeTimerRef.current = window.setTimeout(handleClose, duration);
    }, [
      handleClose
    ]);
    (0, import_react70.useEffect)(() => {
      const viewport = context.viewport;
      if (viewport) {
        const handleResume = () => {
          startTimer(closeTimerRemainingTimeRef.current);
          onResume === null || onResume === void 0 || onResume();
        };
        const handlePause = () => {
          const elapsedTime = new Date().getTime() - closeTimerStartTimeRef.current;
          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;
          window.clearTimeout(closeTimerRef.current);
          onPause === null || onPause === void 0 || onPause();
        };
        viewport.addEventListener($054eb8030ebde76e$var$VIEWPORT_PAUSE, handlePause);
        viewport.addEventListener($054eb8030ebde76e$var$VIEWPORT_RESUME, handleResume);
        return () => {
          viewport.removeEventListener($054eb8030ebde76e$var$VIEWPORT_PAUSE, handlePause);
          viewport.removeEventListener($054eb8030ebde76e$var$VIEWPORT_RESUME, handleResume);
        };
      }
    }, [
      context.viewport,
      duration1,
      onPause,
      onResume,
      startTimer
    ]);
    (0, import_react70.useEffect)(() => {
      if (open && !context.isClosePausedRef.current)
        startTimer(duration1);
    }, [
      open,
      duration1,
      context.isClosePausedRef,
      startTimer
    ]);
    (0, import_react70.useEffect)(() => {
      onToastAdd();
      return () => onToastRemove();
    }, [
      onToastAdd,
      onToastRemove
    ]);
    const announceTextContent = (0, import_react70.useMemo)(() => {
      return node1 ? $054eb8030ebde76e$var$getAnnounceTextContent(node1) : null;
    }, [
      node1
    ]);
    if (!context.viewport)
      return null;
    return /* @__PURE__ */ (0, import_react70.createElement)(import_react70.Fragment, null, announceTextContent && /* @__PURE__ */ (0, import_react70.createElement)($054eb8030ebde76e$var$ToastAnnounce, {
      __scopeToast,
      role: "status",
      "aria-live": type === "foreground" ? "assertive" : "polite",
      "aria-atomic": true
    }, announceTextContent), /* @__PURE__ */ (0, import_react70.createElement)($054eb8030ebde76e$var$ToastInteractiveProvider, {
      scope: __scopeToast,
      onClose: handleClose
    }, /* @__PURE__ */ (0, import_react_dom5.createPortal)(/* @__PURE__ */ (0, import_react70.createElement)($054eb8030ebde76e$var$Collection.ItemSlot, {
      scope: __scopeToast
    }, /* @__PURE__ */ (0, import_react70.createElement)($5cb92bef7577960e$export$be92b6f5f03c0fe9, {
      asChild: true,
      onEscapeKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(onEscapeKeyDown, () => {
        if (!context.isFocusedToastEscapeKeyDownRef.current)
          handleClose();
        context.isFocusedToastEscapeKeyDownRef.current = false;
      })
    }, /* @__PURE__ */ (0, import_react70.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.li, _extends({
      // Ensure toasts are announced as status list or status when focused
      role: "status",
      "aria-live": "off",
      "aria-atomic": true,
      tabIndex: 0,
      "data-state": open ? "open" : "closed",
      "data-swipe-direction": context.swipeDirection
    }, toastProps, {
      ref: composedRefs,
      style: __spreadValues({
        userSelect: "none",
        touchAction: "none"
      }, props.style),
      onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
        if (event.key !== "Escape")
          return;
        onEscapeKeyDown === null || onEscapeKeyDown === void 0 || onEscapeKeyDown(event.nativeEvent);
        if (!event.nativeEvent.defaultPrevented) {
          context.isFocusedToastEscapeKeyDownRef.current = true;
          handleClose();
        }
      }),
      onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDown, (event) => {
        if (event.button !== 0)
          return;
        pointerStartRef.current = {
          x: event.clientX,
          y: event.clientY
        };
      }),
      onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, (event) => {
        if (!pointerStartRef.current)
          return;
        const x3 = event.clientX - pointerStartRef.current.x;
        const y3 = event.clientY - pointerStartRef.current.y;
        const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);
        const isHorizontalSwipe = [
          "left",
          "right"
        ].includes(context.swipeDirection);
        const clamp3 = [
          "left",
          "up"
        ].includes(context.swipeDirection) ? Math.min : Math.max;
        const clampedX = isHorizontalSwipe ? clamp3(0, x3) : 0;
        const clampedY = !isHorizontalSwipe ? clamp3(0, y3) : 0;
        const moveStartBuffer = event.pointerType === "touch" ? 10 : 2;
        const delta = {
          x: clampedX,
          y: clampedY
        };
        const eventDetail = {
          originalEvent: event,
          delta
        };
        if (hasSwipeMoveStarted) {
          swipeDeltaRef.current = delta;
          $054eb8030ebde76e$var$handleAndDispatchCustomEvent($054eb8030ebde76e$var$TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {
            discrete: false
          });
        } else if ($054eb8030ebde76e$var$isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {
          swipeDeltaRef.current = delta;
          $054eb8030ebde76e$var$handleAndDispatchCustomEvent($054eb8030ebde76e$var$TOAST_SWIPE_START, onSwipeStart, eventDetail, {
            discrete: false
          });
          event.target.setPointerCapture(event.pointerId);
        } else if (Math.abs(x3) > moveStartBuffer || Math.abs(y3) > moveStartBuffer)
          pointerStartRef.current = null;
      }),
      onPointerUp: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerUp, (event1) => {
        const delta = swipeDeltaRef.current;
        const target = event1.target;
        if (target.hasPointerCapture(event1.pointerId))
          target.releasePointerCapture(event1.pointerId);
        swipeDeltaRef.current = null;
        pointerStartRef.current = null;
        if (delta) {
          const toast = event1.currentTarget;
          const eventDetail = {
            originalEvent: event1,
            delta
          };
          if ($054eb8030ebde76e$var$isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold))
            $054eb8030ebde76e$var$handleAndDispatchCustomEvent($054eb8030ebde76e$var$TOAST_SWIPE_END, onSwipeEnd, eventDetail, {
              discrete: true
            });
          else
            $054eb8030ebde76e$var$handleAndDispatchCustomEvent($054eb8030ebde76e$var$TOAST_SWIPE_CANCEL, onSwipeCancel, eventDetail, {
              discrete: true
            });
          toast.addEventListener(
            "click",
            (event) => event.preventDefault(),
            {
              once: true
            }
          );
        }
      })
    })))), context.viewport)));
  });
  $054eb8030ebde76e$var$ToastImpl.propTypes = {
    type(props) {
      if (props.type && ![
        "foreground",
        "background"
      ].includes(props.type)) {
        const error = `Invalid prop \`type\` supplied to \`${$054eb8030ebde76e$var$TOAST_NAME}\`. Expected \`foreground | background\`.`;
        return new Error(error);
      }
      return null;
    }
  };
  var $054eb8030ebde76e$var$ToastAnnounce = (props) => {
    const _a5 = props, { __scopeToast, children } = _a5, announceProps = __objRest(_a5, ["__scopeToast", "children"]);
    const context = $054eb8030ebde76e$var$useToastProviderContext($054eb8030ebde76e$var$TOAST_NAME, __scopeToast);
    const [renderAnnounceText, setRenderAnnounceText] = (0, import_react70.useState)(false);
    const [isAnnounced, setIsAnnounced] = (0, import_react70.useState)(false);
    $054eb8030ebde76e$var$useNextFrame(
      () => setRenderAnnounceText(true)
    );
    (0, import_react70.useEffect)(() => {
      const timer = window.setTimeout(
        () => setIsAnnounced(true),
        1e3
      );
      return () => window.clearTimeout(timer);
    }, []);
    return isAnnounced ? null : /* @__PURE__ */ (0, import_react70.createElement)($f1701beae083dbae$export$602eac185826482c, {
      asChild: true
    }, /* @__PURE__ */ (0, import_react70.createElement)($ea1ef594cf570d83$export$439d29a4e110a164, announceProps, renderAnnounceText && /* @__PURE__ */ (0, import_react70.createElement)(import_react70.Fragment, null, context.label, " ", children)));
  };
  var $054eb8030ebde76e$export$16d42d7c29b95a4 = /* @__PURE__ */ (0, import_react70.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeToast } = _a5, titleProps = __objRest(_a5, ["__scopeToast"]);
    return /* @__PURE__ */ (0, import_react70.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, titleProps, {
      ref: forwardedRef
    }));
  });
  var $054eb8030ebde76e$export$ecddd96c53621d9a = /* @__PURE__ */ (0, import_react70.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeToast } = _a5, descriptionProps = __objRest(_a5, ["__scopeToast"]);
    return /* @__PURE__ */ (0, import_react70.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, descriptionProps, {
      ref: forwardedRef
    }));
  });
  var $054eb8030ebde76e$var$ACTION_NAME = "ToastAction";
  var $054eb8030ebde76e$export$3019feecfda683d2 = /* @__PURE__ */ (0, import_react70.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { altText } = _a5, actionProps = __objRest(_a5, ["altText"]);
    if (!altText)
      return null;
    return /* @__PURE__ */ (0, import_react70.createElement)($054eb8030ebde76e$var$ToastAnnounceExclude, {
      altText,
      asChild: true
    }, /* @__PURE__ */ (0, import_react70.createElement)($054eb8030ebde76e$export$811e70f61c205839, _extends({}, actionProps, {
      ref: forwardedRef
    })));
  });
  $054eb8030ebde76e$export$3019feecfda683d2.propTypes = {
    altText(props) {
      if (!props.altText)
        return new Error(`Missing prop \`altText\` expected on \`${$054eb8030ebde76e$var$ACTION_NAME}\``);
      return null;
    }
  };
  var $054eb8030ebde76e$var$CLOSE_NAME = "ToastClose";
  var $054eb8030ebde76e$export$811e70f61c205839 = /* @__PURE__ */ (0, import_react70.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeToast } = _a5, closeProps = __objRest(_a5, ["__scopeToast"]);
    const interactiveContext = $054eb8030ebde76e$var$useToastInteractiveContext($054eb8030ebde76e$var$CLOSE_NAME, __scopeToast);
    return /* @__PURE__ */ (0, import_react70.createElement)($054eb8030ebde76e$var$ToastAnnounceExclude, {
      asChild: true
    }, /* @__PURE__ */ (0, import_react70.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
      type: "button"
    }, closeProps, {
      ref: forwardedRef,
      onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, interactiveContext.onClose)
    })));
  });
  var $054eb8030ebde76e$var$ToastAnnounceExclude = /* @__PURE__ */ (0, import_react70.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeToast, altText } = _a5, announceExcludeProps = __objRest(_a5, ["__scopeToast", "altText"]);
    return /* @__PURE__ */ (0, import_react70.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": altText || void 0
    }, announceExcludeProps, {
      ref: forwardedRef
    }));
  });
  function $054eb8030ebde76e$var$getAnnounceTextContent(container) {
    const textContent = [];
    const childNodes = Array.from(container.childNodes);
    childNodes.forEach((node) => {
      if (node.nodeType === node.TEXT_NODE && node.textContent)
        textContent.push(node.textContent);
      if ($054eb8030ebde76e$var$isHTMLElement(node)) {
        const isHidden = node.ariaHidden || node.hidden || node.style.display === "none";
        const isExcluded = node.dataset.radixToastAnnounceExclude === "";
        if (!isHidden) {
          if (isExcluded) {
            const altText = node.dataset.radixToastAnnounceAlt;
            if (altText)
              textContent.push(altText);
          } else
            textContent.push(...$054eb8030ebde76e$var$getAnnounceTextContent(node));
        }
      }
    });
    return textContent;
  }
  function $054eb8030ebde76e$var$handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
    const currentTarget = detail.originalEvent.currentTarget;
    const event = new CustomEvent(name, {
      bubbles: true,
      cancelable: true,
      detail
    });
    if (handler)
      currentTarget.addEventListener(name, handler, {
        once: true
      });
    if (discrete)
      $8927f6f2acc4f386$export$6d1a0317bde7de7f(currentTarget, event);
    else
      currentTarget.dispatchEvent(event);
  }
  var $054eb8030ebde76e$var$isDeltaInDirection = (delta, direction, threshold = 0) => {
    const deltaX = Math.abs(delta.x);
    const deltaY = Math.abs(delta.y);
    const isDeltaX = deltaX > deltaY;
    if (direction === "left" || direction === "right")
      return isDeltaX && deltaX > threshold;
    else
      return !isDeltaX && deltaY > threshold;
  };
  function $054eb8030ebde76e$var$useNextFrame(callback = () => {
  }) {
    const fn = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(callback);
    $9f79659886946c16$export$e5c5a5f917a5871c(() => {
      let raf1 = 0;
      let raf2 = 0;
      raf1 = window.requestAnimationFrame(
        () => raf2 = window.requestAnimationFrame(fn)
      );
      return () => {
        window.cancelAnimationFrame(raf1);
        window.cancelAnimationFrame(raf2);
      };
    }, [
      fn
    ]);
  }
  function $054eb8030ebde76e$var$isHTMLElement(node) {
    return node.nodeType === node.ELEMENT_NODE;
  }
  function $054eb8030ebde76e$var$getTabbableCandidates(container) {
    const nodes = [];
    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
      acceptNode: (node) => {
        const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
        if (node.disabled || node.hidden || isHiddenInput)
          return NodeFilter.FILTER_SKIP;
        return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
      }
    });
    while (walker.nextNode())
      nodes.push(walker.currentNode);
    return nodes;
  }
  function $054eb8030ebde76e$var$focusFirst(candidates) {
    const previouslyFocusedElement = document.activeElement;
    return candidates.some((candidate) => {
      if (candidate === previouslyFocusedElement)
        return true;
      candidate.focus();
      return document.activeElement !== previouslyFocusedElement;
    });
  }
  var $054eb8030ebde76e$export$be92b6f5f03c0fe9 = $054eb8030ebde76e$export$8d8dc7d5f743331b;
  var $054eb8030ebde76e$export$f99233281efd08a0 = $054eb8030ebde76e$export$16d42d7c29b95a4;
  var $054eb8030ebde76e$export$393edc798c47379d = $054eb8030ebde76e$export$ecddd96c53621d9a;
  var $054eb8030ebde76e$export$e19cd5f9376f8cee = $054eb8030ebde76e$export$3019feecfda683d2;
  var $054eb8030ebde76e$export$f39c2d165cd861fe = $054eb8030ebde76e$export$811e70f61c205839;

  // ../../../packages/ui/src/lib/TldrawUi.tsx
  var import_classnames20 = __toESM(require_classnames());
  var import_react109 = __toESM(require_react());

  // ../../../packages/ui/src/lib/icon-types.ts
  var TLUiIconTypes = [
    "align-bottom-center",
    "align-bottom-left",
    "align-bottom-right",
    "align-bottom",
    "align-center-center",
    "align-center-horizontal",
    "align-center-left",
    "align-center-right",
    "align-center-vertical",
    "align-left",
    "align-right",
    "align-top-center",
    "align-top-left",
    "align-top-right",
    "align-top",
    "arrow-left",
    "arrowhead-arrow",
    "arrowhead-bar",
    "arrowhead-diamond",
    "arrowhead-dot",
    "arrowhead-none",
    "arrowhead-square",
    "arrowhead-triangle-inverted",
    "arrowhead-triangle",
    "aspect-ratio",
    "avatar",
    "blob",
    "bring-forward",
    "bring-to-front",
    "check",
    "checkbox-checked",
    "checkbox-empty",
    "chevron-down",
    "chevron-left",
    "chevron-right",
    "chevron-up",
    "chevrons-ne",
    "chevrons-sw",
    "clipboard-copied",
    "clipboard-copy",
    "code",
    "collab",
    "color",
    "comment",
    "cross-2",
    "cross",
    "dash-dashed",
    "dash-dotted",
    "dash-draw",
    "dash-solid",
    "discord",
    "distribute-horizontal",
    "distribute-vertical",
    "dot",
    "dots-horizontal",
    "dots-vertical",
    "drag-handle-dots",
    "duplicate",
    "edit",
    "external-link",
    "file",
    "fill-none",
    "fill-pattern",
    "fill-semi",
    "fill-solid",
    "follow",
    "following",
    "font-draw",
    "font-mono",
    "font-sans",
    "font-serif",
    "geo-arrow-down",
    "geo-arrow-left",
    "geo-arrow-right",
    "geo-arrow-up",
    "geo-check-box",
    "geo-diamond",
    "geo-ellipse",
    "geo-hexagon",
    "geo-octagon",
    "geo-oval",
    "geo-pentagon",
    "geo-rectangle",
    "geo-rhombus-2",
    "geo-rhombus",
    "geo-star",
    "geo-trapezoid",
    "geo-triangle",
    "geo-x-box",
    "github",
    "group",
    "hidden",
    "image",
    "info-circle",
    "leading",
    "link",
    "lock-small",
    "lock",
    "menu",
    "minus",
    "mixed",
    "pack",
    "page",
    "plus",
    "question-mark-circle",
    "question-mark",
    "redo",
    "reset-zoom",
    "rotate-ccw",
    "rotate-cw",
    "ruler",
    "search",
    "send-backward",
    "send-to-back",
    "settings-horizontal",
    "settings-vertical-1",
    "settings-vertical",
    "share-1",
    "share-2",
    "size-extra-large",
    "size-large",
    "size-medium",
    "size-small",
    "spline-cubic",
    "spline-line",
    "stack-horizontal",
    "stack-vertical",
    "stretch-horizontal",
    "stretch-vertical",
    "text-align-center",
    "text-align-justify",
    "text-align-left",
    "text-align-right",
    "tool-arrow",
    "tool-embed",
    "tool-eraser",
    "tool-frame",
    "tool-hand",
    "tool-highlighter",
    "tool-line",
    "tool-media",
    "tool-note",
    "tool-pencil",
    "tool-pointer",
    "tool-text",
    "trash",
    "triangle-down",
    "triangle-up",
    "twitter",
    "undo",
    "ungroup",
    "unlock-small",
    "unlock",
    "visible",
    "warning-triangle",
    "zoom-in",
    "zoom-out"
  ];

  // ../../../packages/ui/src/lib/assetUrls.ts
  var defaultUiAssetUrls = __spreadProps(__spreadValues({}, defaultEditorAssetUrls), {
    icons: Object.fromEntries(
      TLUiIconTypes.map((name) => [name, `/icons/icon/${name}.svg`])
    ),
    translations: Object.fromEntries(
      LANGUAGES2.map((lang) => [lang.locale, `/translations/${lang.locale}.json`])
    ),
    embedIcons: Object.fromEntries(
      EMBED_DEFINITIONS.map((def) => [def.type, `/embed-icons/${def.type}.png`])
    )
  });

  // ../../../packages/ui/src/lib/hooks/useActions.tsx
  var React46 = __toESM(require_react());

  // ../../../packages/ui/src/lib/components/EditLinkDialog.tsx
  var import_react71 = __toESM(require_react());

  // ../../../packages/ui/src/lib/components/primitives/Input.tsx
  var import_classnames14 = __toESM(require_classnames());
  var React45 = __toESM(require_react());
  var import_jsx_runtime64 = __toESM(require_jsx_runtime());
  var Input = React45.forwardRef(function Input2({
    className,
    label,
    icon,
    iconLeft,
    autoselect = false,
    autofocus = false,
    defaultValue,
    placeholder,
    onComplete,
    onValueChange,
    onCancel,
    shouldManuallyMaintainScrollPositionWhenFocused = false,
    children,
    value
  }, ref) {
    const rInputRef = React45.useRef(null);
    React45.useImperativeHandle(ref, () => rInputRef.current);
    const msg2 = useTranslation();
    const rInitialValue = React45.useRef(defaultValue != null ? defaultValue : "");
    const rCurrentValue = React45.useRef(defaultValue != null ? defaultValue : "");
    const [isFocused, setIsFocused] = React45.useState(false);
    const handleFocus = React45.useCallback(
      (e2) => {
        setIsFocused(true);
        const elm = e2.currentTarget;
        rCurrentValue.current = elm.value;
        requestAnimationFrame(() => {
          if (autoselect) {
            elm.select();
          }
        });
      },
      [autoselect]
    );
    const handleChange = React45.useCallback(
      (e2) => {
        const value2 = e2.currentTarget.value;
        rCurrentValue.current = value2;
        onValueChange == null ? void 0 : onValueChange(value2);
      },
      [onValueChange]
    );
    const handleKeyUp = React45.useCallback(
      (e2) => {
        switch (e2.key) {
          case "Enter": {
            e2.currentTarget.blur();
            e2.stopPropagation();
            onComplete == null ? void 0 : onComplete(e2.currentTarget.value);
            break;
          }
          case "Escape": {
            e2.currentTarget.value = rInitialValue.current;
            e2.currentTarget.blur();
            e2.stopPropagation();
            onCancel == null ? void 0 : onCancel(e2.currentTarget.value);
            break;
          }
        }
      },
      [onComplete, onCancel]
    );
    const handleBlur = React45.useCallback(() => setIsFocused(false), []);
    React45.useEffect(() => {
      const visualViewport = window.visualViewport;
      if (isFocused && shouldManuallyMaintainScrollPositionWhenFocused && visualViewport) {
        const onViewportChange = () => {
          var _a5;
          (_a5 = rInputRef.current) == null ? void 0 : _a5.scrollIntoView({ block: "center" });
        };
        visualViewport.addEventListener("resize", onViewportChange);
        visualViewport.addEventListener("scroll", onViewportChange);
        requestAnimationFrame(() => {
          var _a5;
          (_a5 = rInputRef.current) == null ? void 0 : _a5.scrollIntoView({ block: "center" });
        });
        return () => {
          visualViewport.removeEventListener("resize", onViewportChange);
          visualViewport.removeEventListener("scroll", onViewportChange);
        };
      }
    }, [isFocused, shouldManuallyMaintainScrollPositionWhenFocused]);
    return /* @__PURE__ */ (0, import_jsx_runtime64.jsxs)("div", { draggable: false, className: "tlui-input__wrapper", children: [
      children,
      label && /* @__PURE__ */ (0, import_jsx_runtime64.jsx)("label", { children: msg2(label) }),
      iconLeft && /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(Icon, { icon: iconLeft, className: "tlui-icon-left", small: true }),
      /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(
        "input",
        {
          ref: rInputRef,
          className: (0, import_classnames14.default)("tlui-input", className),
          type: "text",
          defaultValue,
          onKeyUp: handleKeyUp,
          onChange: handleChange,
          onFocus: handleFocus,
          onBlur: handleBlur,
          autoFocus: autofocus,
          placeholder,
          value
        }
      ),
      icon && /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(Icon, { icon, small: !!label })
    ] });
  });

  // ../../../packages/ui/src/lib/components/EditLinkDialog.tsx
  var import_jsx_runtime65 = __toESM(require_jsx_runtime());
  var validUrlRegex = new RegExp(
    /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:[/?#]\S*)?$/i
  );
  function valiateUrl(url) {
    if (validUrlRegex.test(url))
      return true;
    if (validUrlRegex.test("https://" + url))
      return "needs protocol";
    return false;
  }
  var EditLinkDialog = track(function EditLink({ onClose }) {
    const app = useApp();
    const msg2 = useTranslation();
    const selectedShape = app.onlySelectedShape;
    const [validState, setValid] = (0, import_react71.useState)(valiateUrl(selectedShape == null ? void 0 : selectedShape.props.url));
    const rInitialValue = (0, import_react71.useRef)(selectedShape == null ? void 0 : selectedShape.props.url);
    const rValue = (0, import_react71.useRef)(selectedShape == null ? void 0 : selectedShape.props.url);
    const [urlValue, setUrlValue] = (0, import_react71.useState)(
      validState ? validState === "needs protocol" ? "https://" + (selectedShape == null ? void 0 : selectedShape.props.url) : selectedShape == null ? void 0 : selectedShape.props.url : "https://"
    );
    const handleChange = (0, import_react71.useCallback)((rawValue) => {
      const value = rawValue.replace(/https?:\/\/(https?:\/\/)/, (_match, arg1) => {
        return arg1;
      });
      setUrlValue(value);
      const validStateUrl = valiateUrl(value.trim());
      setValid((s3) => s3 === validStateUrl ? s3 : validStateUrl);
      if (validStateUrl) {
        rValue.current = value;
      }
    }, []);
    const handleClear = (0, import_react71.useCallback)(() => {
      app.setProp("url", "", false);
      onClose();
    }, [app, onClose]);
    const handleComplete = (0, import_react71.useCallback)(
      (value) => {
        value = value.trim();
        const validState2 = valiateUrl(value);
        const shape = app.selectedShapes[0];
        if (shape) {
          const current = shape.props.url;
          const next = validState2 ? validState2 === "needs protocol" ? "https://" + value : value : shape.type === "bookmark" ? rInitialValue.current : "";
          if (current !== void 0 && current !== next) {
            app.setProp("url", next, false);
          }
        }
        onClose();
      },
      [app, onClose]
    );
    const handleCancel = (0, import_react71.useCallback)(() => {
      onClose();
    }, [onClose]);
    if (!selectedShape) {
      onClose();
      return null;
    }
    const isRemoving = rInitialValue.current && !validState;
    return /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(import_jsx_runtime65.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(Header, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(Title, { children: msg2("edit-link-dialog.title") }),
        /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(CloseButton, {})
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(Body, { children: /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)("div", { className: "tlui-edit-link-dialog", children: [
        /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(
          Input,
          {
            className: "tlui-edit-link-dialog__input",
            label: "edit-link-dialog.url",
            autofocus: true,
            value: urlValue,
            onValueChange: handleChange,
            onComplete: handleComplete,
            onCancel: handleCancel
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime65.jsx)("div", { children: validState ? msg2("edit-link-dialog.detail") : msg2("edit-link-dialog.invalid-url") })
      ] }) }),
      /* @__PURE__ */ (0, import_jsx_runtime65.jsxs)(Footer, { className: "tlui-dialog__footer__actions", children: [
        /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(Button, { onClick: handleCancel, onTouchEnd: handleCancel, children: msg2("edit-link-dialog.cancel") }),
        isRemoving ? /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(Button, { type: "danger", onTouchEnd: handleClear, onClick: handleClear, children: msg2("edit-link-dialog.clear") }) : /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(
          Button,
          {
            type: "primary",
            disabled: !validState,
            onTouchEnd: () => handleComplete(rValue.current),
            onClick: () => handleComplete(rValue.current),
            children: msg2("edit-link-dialog.save")
          }
        )
      ] })
    ] });
  });

  // ../../../packages/ui/src/lib/components/EmbedDialog.tsx
  var import_react72 = __toESM(require_react());
  var import_jsx_runtime66 = __toESM(require_jsx_runtime());
  var EmbedDialog = track(function EmbedDialog2({ onClose }) {
    const app = useApp();
    const msg2 = useTranslation();
    const assetUrls = useAssetUrls();
    const [embedDefinition, setEmbedDefinition] = (0, import_react72.useState)(null);
    const [url, setUrl] = (0, import_react72.useState)("");
    const [embedInfoForUrl, setEmbedInfoForUrl] = (0, import_react72.useState)(null);
    const [showError, setShowError] = (0, import_react72.useState)(false);
    const rShowErrorTimeout = (0, import_react72.useRef)(-1);
    return /* @__PURE__ */ (0, import_jsx_runtime66.jsxs)(import_jsx_runtime66.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime66.jsxs)(Header, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(Title, { children: embedDefinition ? `${msg2("embed-dialog.title")} \u2014 ${embedDefinition.title}` : msg2("embed-dialog.title") }),
        /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(CloseButton, {})
      ] }),
      embedDefinition ? /* @__PURE__ */ (0, import_jsx_runtime66.jsxs)(import_jsx_runtime66.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime66.jsxs)(Body, { className: "tlui-embed-dialog__enter", children: [
          /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(
            Input,
            {
              className: "tlui-embed-dialog__input",
              label: "embed-dialog.url",
              placeholder: "http://example.com",
              autofocus: true,
              onValueChange: (value) => {
                setUrl(value);
                const embedInfo = getEmbedInfo(value);
                setEmbedInfoForUrl(
                  embedInfo && embedInfo.definition.type === embedDefinition.type ? embedInfo : null
                );
                setShowError(false);
                clearTimeout(rShowErrorTimeout.current);
                rShowErrorTimeout.current = setTimeout(() => setShowError(!embedInfo), 320);
              }
            }
          ),
          url === "" ? /* @__PURE__ */ (0, import_jsx_runtime66.jsxs)("div", { className: "tlui-embed-dialog__instruction", children: [
            /* @__PURE__ */ (0, import_jsx_runtime66.jsx)("span", { children: msg2("embed-dialog.instruction") }),
            " ",
            embedDefinition.instructionLink && /* @__PURE__ */ (0, import_jsx_runtime66.jsxs)(
              "a",
              {
                target: "_blank",
                rel: "noopener noreferrer",
                href: embedDefinition.instructionLink,
                className: "tlui-embed-dialog__instruction__link",
                children: [
                  "Learn more.",
                  /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(Icon, { icon: "external-link", small: true })
                ]
              }
            )
          ] }) : /* @__PURE__ */ (0, import_jsx_runtime66.jsx)("div", { className: "tlui-embed-dialog__warning", children: showError ? msg2("embed-dialog.invalid-url") : "\xA0" })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime66.jsxs)(Footer, { className: "tlui-dialog__footer__actions", children: [
          /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(
            Button,
            {
              onClick: () => {
                setEmbedDefinition(null);
                setEmbedInfoForUrl(null);
                setUrl("");
              },
              label: "embed-dialog.back"
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime66.jsx)("div", { className: "tlui-embed__spacer" }),
          /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(Button, { label: "embed-dialog.cancel", onClick: onClose }),
          /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(
            Button,
            {
              type: "primary",
              disabled: !embedInfoForUrl,
              label: "embed-dialog.create",
              onClick: () => {
                if (!embedInfoForUrl)
                  return;
                createEmbedShapeAtPoint(app, url, app.viewportPageCenter, {
                  width: embedInfoForUrl.definition.width,
                  height: embedInfoForUrl.definition.height,
                  doesResize: embedInfoForUrl.definition.doesResize
                });
                onClose();
              }
            }
          )
        ] })
      ] }) : /* @__PURE__ */ (0, import_jsx_runtime66.jsxs)(import_jsx_runtime66.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(Body, { className: "tlui-embed-dialog__list", children: EMBED_DEFINITIONS.map((def) => {
          return /* @__PURE__ */ (0, import_jsx_runtime66.jsxs)(
            "button",
            {
              className: "tlui-embed-dialog__item",
              onClick: () => setEmbedDefinition(def),
              children: [
                /* @__PURE__ */ (0, import_jsx_runtime66.jsx)("div", { className: "tlui-embed-dialog__item__image", children: /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(
                  "div",
                  {
                    className: "tlui-embed-dialog__item__image__img",
                    style: {
                      backgroundImage: `url(${assetUrls.embedIcons[def.type]})`
                    }
                  }
                ) }),
                /* @__PURE__ */ (0, import_jsx_runtime66.jsx)("div", { className: "tlui-embed-dialog__item__title", children: def.title })
              ]
            },
            def.type
          );
        }) }),
        /* @__PURE__ */ (0, import_jsx_runtime66.jsx)("div", { className: "tlui-dialog__scrim" })
      ] })
    ] });
  });

  // ../../../packages/ui/src/lib/hooks/useClipboardEvents.ts
  var import_lz_string = __toESM(require_lz_string());
  var import_react73 = __toESM(require_react());

  // ../../../packages/ui/src/lib/hooks/clipboard/pasteExcalidrawContent.ts
  function pasteExcalidrawContent(app, clipboard, point2) {
    return __async(this, null, function* () {
      var _a5, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
      const { elements, files } = clipboard;
      const tldrawContent = {
        shapes: [],
        rootShapeIds: [],
        assets: [],
        schema: app.store.schema.serialize()
      };
      const groupShapeIdToChildren = /* @__PURE__ */ new Map();
      const rotatedElements = /* @__PURE__ */ new Map();
      const { currentPageId } = app;
      const excElementIdsToTldrawShapeIds = /* @__PURE__ */ new Map();
      const rootShapeIds = [];
      const skipIds = /* @__PURE__ */ new Set();
      elements.forEach((element) => {
        excElementIdsToTldrawShapeIds.set(element.id, app.createShapeId());
        if (element.boundElements !== null) {
          for (const boundElement of element.boundElements) {
            if (boundElement.type === "text") {
              skipIds.add(boundElement.id);
            }
          }
        }
      });
      let index2 = "a1";
      for (const element of elements) {
        if (skipIds.has(element.id)) {
          continue;
        }
        const id = excElementIdsToTldrawShapeIds.get(element.id);
        const base = {
          id,
          typeName: "shape",
          parentId: currentPageId,
          index: index2,
          x: element.x,
          y: element.y,
          rotation: 0,
          isLocked: element.locked
        };
        if (element.angle !== 0) {
          rotatedElements.set(id, element.angle);
        }
        if (element.groupIds && element.groupIds.length > 0) {
          if (groupShapeIdToChildren.has(element.groupIds[0])) {
            (_a5 = groupShapeIdToChildren.get(element.groupIds[0])) == null ? void 0 : _a5.push(id);
          } else {
            groupShapeIdToChildren.set(element.groupIds[0], [id]);
          }
        } else {
          rootShapeIds.push(id);
        }
        switch (element.type) {
          case "rectangle":
          case "ellipse":
          case "diamond": {
            let text = "";
            let align = "middle";
            if (element.boundElements !== null) {
              for (const boundElement of element.boundElements) {
                if (boundElement.type === "text") {
                  const labelElement = elements.find((elm) => elm.id === boundElement.id);
                  if (labelElement) {
                    text = labelElement.text;
                    align = textAlignToAlignTypes[labelElement.textAlign];
                  }
                }
              }
            }
            const colorToUse = element.backgroundColor === "transparent" ? element.strokeColor : element.backgroundColor;
            tldrawContent.shapes.push(__spreadProps(__spreadValues({}, base), {
              type: "geo",
              props: {
                geo: element.type,
                opacity: getOpacity(element.opacity),
                url: (_b2 = element.link) != null ? _b2 : "",
                w: element.width,
                h: element.height,
                size: (_c = strokeWidthsToSizes[element.strokeWidth]) != null ? _c : "draw",
                color: (_d = colorsToColors[colorToUse]) != null ? _d : "black",
                text,
                align,
                dash: getDash(element),
                fill: getFill(element)
              }
            }));
            break;
          }
          case "freedraw": {
            tldrawContent.shapes.push(__spreadProps(__spreadValues({}, base), {
              type: "draw",
              props: {
                dash: getDash(element),
                size: strokeWidthsToSizes[element.strokeWidth],
                opacity: getOpacity(element.opacity),
                color: (_e = colorsToColors[element.strokeColor]) != null ? _e : "black",
                segments: [
                  {
                    type: "free",
                    points: element.points.map(([x3, y3, z2 = 0.5]) => ({
                      x: x3,
                      y: y3,
                      z: z2
                    }))
                  }
                ]
              }
            }));
            break;
          }
          case "line": {
            const start = element.points[0];
            const end = element.points[element.points.length - 1];
            const indices = getIndices(element.points.length);
            tldrawContent.shapes.push(__spreadProps(__spreadValues({}, base), {
              type: "line",
              props: {
                dash: getDash(element),
                size: strokeWidthsToSizes[element.strokeWidth],
                opacity: getOpacity(element.opacity),
                color: (_f = colorsToColors[element.strokeColor]) != null ? _f : "black",
                spline: element.roundness ? "cubic" : "line",
                handles: __spreadValues({
                  start: {
                    id: "start",
                    type: "vertex",
                    index: indices[0],
                    x: start[0],
                    y: start[1]
                  },
                  end: {
                    id: "end",
                    type: "vertex",
                    index: indices[indices.length - 1],
                    x: end[0],
                    y: end[1]
                  }
                }, Object.fromEntries(
                  element.points.slice(1, -1).map(([x3, y3], i3) => {
                    const id2 = uniqueId();
                    return [
                      id2,
                      {
                        id: id2,
                        type: "vertex",
                        index: indices[i3 + 1],
                        x: x3,
                        y: y3
                      }
                    ];
                  })
                ))
              }
            }));
            break;
          }
          case "arrow": {
            let text = "";
            if (element.boundElements !== null) {
              for (const boundElement of element.boundElements) {
                if (boundElement.type === "text") {
                  const labelElement = elements.find((elm) => elm.id === boundElement.id);
                  if (labelElement) {
                    text = labelElement.text;
                  }
                }
              }
            }
            const start = element.points[0];
            const end = element.points[element.points.length - 1];
            const startTargetId = excElementIdsToTldrawShapeIds.get((_g = element.startBinding) == null ? void 0 : _g.elementId);
            const endTargetId = excElementIdsToTldrawShapeIds.get((_h = element.endBinding) == null ? void 0 : _h.elementId);
            tldrawContent.shapes.push(__spreadProps(__spreadValues({}, base), {
              type: "arrow",
              props: {
                text,
                bend: getBend(element, start, end),
                dash: getDash(element),
                opacity: getOpacity(element.opacity),
                size: (_i = strokeWidthsToSizes[element.strokeWidth]) != null ? _i : "m",
                color: (_j = colorsToColors[element.strokeColor]) != null ? _j : "black",
                start: startTargetId ? {
                  type: "binding",
                  boundShapeId: startTargetId,
                  normalizedAnchor: { x: 0.5, y: 0.5 },
                  isExact: false
                } : {
                  type: "point",
                  x: start[0],
                  y: start[1]
                },
                end: endTargetId ? {
                  type: "binding",
                  boundShapeId: endTargetId,
                  normalizedAnchor: { x: 0.5, y: 0.5 },
                  isExact: false
                } : {
                  type: "point",
                  x: end[0],
                  y: end[1]
                },
                arrowheadEnd: (_k = arrowheadsToArrowheadTypes[element.endArrowhead]) != null ? _k : "none",
                arrowheadStart: (_l = arrowheadsToArrowheadTypes[element.startArrowhead]) != null ? _l : "none"
              }
            }));
            break;
          }
          case "text": {
            const { size, scale } = getFontSizeAndScale(element.fontSize);
            tldrawContent.shapes.push(__spreadProps(__spreadValues({}, base), {
              type: "text",
              props: {
                size,
                scale,
                font: (_m = fontFamilyToFontType[element.fontFamily]) != null ? _m : "draw",
                opacity: getOpacity(element.opacity),
                color: (_n = colorsToColors[element.strokeColor]) != null ? _n : "black",
                text: element.text,
                align: textAlignToAlignTypes[element.textAlign]
              }
            }));
            break;
          }
          case "image": {
            const file = files[element.fileId];
            if (!file)
              break;
            const assetId = TLAsset.createId();
            tldrawContent.assets.push({
              id: assetId,
              typeName: "asset",
              type: "image",
              props: {
                w: element.width,
                h: element.height,
                name: (_o = element.id) != null ? _o : "Untitled",
                isAnimated: false,
                mimeType: file.mimeType,
                src: file.dataURL
              }
            });
            tldrawContent.shapes.push(__spreadProps(__spreadValues({}, base), {
              type: "image",
              props: {
                opacity: getOpacity(element.opacity),
                w: element.width,
                h: element.height,
                assetId
              }
            }));
          }
        }
        index2 = getIndexAbove(index2);
      }
      const p3 = point2 != null ? point2 : app.inputs.shiftKey ? app.inputs.currentPagePoint : void 0;
      app.mark("paste");
      app.putContent(tldrawContent, {
        point: p3,
        select: false,
        preserveIds: true
      });
      for (const groupedShapeIds of groupShapeIdToChildren.values()) {
        if (groupedShapeIds.length > 1) {
          app.groupShapes(groupedShapeIds);
          const groupShape = app.getShapeById(groupedShapeIds[0]);
          if ((groupShape == null ? void 0 : groupShape.parentId) && isShapeId(groupShape.parentId)) {
            rootShapeIds.push(groupShape.parentId);
          }
        }
      }
      for (const [id, angle] of rotatedElements) {
        app.select(id);
        app.rotateShapesBy([id], angle);
      }
      const rootShapes = compact(rootShapeIds.map((id) => app.getShapeById(id)));
      const bounds = Box2d.Common(rootShapes.map((s3) => app.getPageBounds(s3)));
      const viewPortCenter = app.viewportPageBounds.center;
      app.updateShapes(
        rootShapes.map((s3) => {
          var _a6, _b3;
          const delta = {
            x: ((_a6 = s3.x) != null ? _a6 : 0) - (bounds.x + bounds.w / 2),
            y: ((_b3 = s3.y) != null ? _b3 : 0) - (bounds.y + bounds.h / 2)
          };
          return {
            id: s3.id,
            type: s3.type,
            x: viewPortCenter.x + delta.x,
            y: viewPortCenter.y + delta.y
          };
        })
      );
      app.setSelectedIds(rootShapeIds);
    });
  }
  var getOpacity = (opacity) => {
    const t4 = opacity / 100;
    if (t4 < 0.2) {
      return "0.1";
    } else if (t4 < 0.4) {
      return "0.25";
    } else if (t4 < 0.6) {
      return "0.5";
    } else if (t4 < 0.8) {
      return "0.75";
    }
    return "1";
  };
  var strokeWidthsToSizes = {
    1: "s",
    2: "m",
    3: "l",
    4: "xl"
  };
  var fontSizesToSizes = {
    16: "s",
    20: "m",
    28: "l",
    36: "xl"
  };
  function getFontSizeAndScale(fontSize) {
    const size = fontSizesToSizes[fontSize];
    if (size) {
      return { size, scale: 1 };
    }
    if (fontSize < 16) {
      return { size: "s", scale: fontSize / 16 };
    }
    if (fontSize > 36) {
      return { size: "xl", scale: fontSize / 36 };
    }
    return { size: "m", scale: 1 };
  }
  var fontFamilyToFontType = {
    1: "draw",
    2: "sans",
    3: "mono"
  };
  var colorsToColors = {
    "#ffffff": "grey",
    // Strokes
    "#000000": "black",
    "#343a40": "black",
    "#495057": "grey",
    "#c92a2a": "red",
    "#a61e4d": "light-red",
    "#862e9c": "violet",
    "#5f3dc4": "light-violet",
    "#364fc7": "blue",
    "#1864ab": "light-blue",
    "#0b7285": "light-green",
    "#087f5b": "light-green",
    "#2b8a3e": "green",
    "#5c940d": "light-green",
    "#e67700": "yellow",
    "#d9480f": "orange",
    // Backgrounds
    "#ced4da": "grey",
    "#868e96": "grey",
    "#fa5252": "light-red",
    "#e64980": "red",
    "#be4bdb": "light-violet",
    "#7950f2": "violet",
    "#4c6ef5": "blue",
    "#228be6": "light-blue",
    "#15aabf": "light-green",
    "#12b886": "green",
    "#40c057": "green",
    "#82c91e": "light-green",
    "#fab005": "yellow",
    "#fd7e14": "orange",
    "#212529": "grey"
  };
  var strokeStylesToStrokeTypes = {
    solid: "draw",
    dashed: "dashed",
    dotted: "dotted"
  };
  var fillStylesToFillType = {
    "cross-hatch": "pattern",
    hachure: "pattern",
    solid: "solid"
  };
  var textAlignToAlignTypes = {
    left: "start",
    center: "middle",
    right: "end"
  };
  var arrowheadsToArrowheadTypes = {
    arrow: "arrow",
    dot: "dot",
    triangle: "triangle",
    bar: "pipe"
  };
  function getBend(element, startPoint, endPoint) {
    let bend = 0;
    if (element.points.length > 2) {
      const start = new Vec2d(startPoint[0], startPoint[1]);
      const end = new Vec2d(endPoint[0], endPoint[1]);
      const handle = new Vec2d(element.points[1][0], element.points[1][1]);
      const delta = Vec2d.Sub(end, start);
      const v3 = Vec2d.Per(delta);
      const med = Vec2d.Med(end, start);
      const A2 = Vec2d.Sub(med, v3);
      const B = Vec2d.Add(med, v3);
      const point2 = Vec2d.NearestPointOnLineSegment(A2, B, handle, false);
      bend = Vec2d.Dist(point2, med);
      if (Vec2d.Clockwise(point2, end, med))
        bend *= -1;
    }
    return bend;
  }
  var getDash = (element) => {
    var _a5;
    let dash = (_a5 = strokeStylesToStrokeTypes[element.strokeStyle]) != null ? _a5 : "draw";
    if (dash === "draw" && element.roughness === 0) {
      dash = "solid";
    }
    return dash;
  };
  var getFill = (element) => {
    var _a5;
    if (element.backgroundColor === "transparent") {
      return "none";
    }
    return (_a5 = fillStylesToFillType[element.fillStyle]) != null ? _a5 : "solid";
  };

  // ../../../packages/ui/src/lib/hooks/clipboard/pasteFiles.ts
  function pasteFiles(app, urls, point2) {
    return __async(this, null, function* () {
      const p3 = point2 != null ? point2 : app.inputs.shiftKey ? app.inputs.currentPagePoint : app.viewportPageCenter;
      const blobs = yield Promise.all(urls.map((url) => __async(this, null, function* () {
        return yield (yield fetch(url)).blob();
      })));
      const files = blobs.map(
        (blob) => new File([blob], "tldrawFile", {
          type: blob.type
        })
      );
      app.mark("paste");
      yield createShapesFromFiles(app, files, p3, false);
      urls.forEach((url) => URL.revokeObjectURL(url));
    });
  }

  // ../../../packages/ui/src/lib/hooks/clipboard/pastePlainText.ts
  var rtlRegex = /[\u0590-\u05FF\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;
  function replaceTabsWithSpaces(text) {
    return text.replace(/\t/g, INDENT);
  }
  function stripCommonMinimumIndentation(text) {
    const lines = text.split("\n");
    while (lines[0].trim().length === 0) {
      lines.shift();
    }
    let minIndentation = Infinity;
    for (const line of lines) {
      if (line.trim().length > 0) {
        const indentation = line.length - line.trimStart().length;
        minIndentation = Math.min(minIndentation, indentation);
      }
    }
    return lines.map((line) => line.slice(minIndentation)).join("\n");
  }
  function stripTrailingWhitespace(text) {
    return text.replace(/[ \t]+$/gm, "").replace(/\n+$/, "");
  }
  function pastePlainText(app, text, point2) {
    return __async(this, null, function* () {
      const p3 = point2 != null ? point2 : app.inputs.shiftKey ? app.inputs.currentPagePoint : app.viewportPageCenter;
      const defaultProps = app.getShapeUtilByDef(TLTextShapeDef).defaultProps();
      const textToPaste = stripTrailingWhitespace(
        stripCommonMinimumIndentation(replaceTabsWithSpaces(text))
      );
      let w3;
      let h3;
      let autoSize;
      let align = "middle";
      const isMultiLine = textToPaste.split("\n").length > 1;
      const isRtl = rtlRegex.test(textToPaste);
      if (isMultiLine) {
        align = isMultiLine ? isRtl ? "end" : "start" : "middle";
      }
      const rawSize = app.textMeasure.measureText(__spreadProps(__spreadValues({}, TEXT_PROPS), {
        text: textToPaste,
        fontFamily: FONT_FAMILIES[defaultProps.font],
        fontSize: FONT_SIZES[defaultProps.size],
        width: "fit-content"
      }));
      const minWidth = Math.min(
        isMultiLine ? app.viewportPageBounds.width * 0.9 : 920,
        Math.max(200, app.viewportPageBounds.width * 0.9)
      );
      if (rawSize.w > minWidth) {
        const shrunkSize = app.textMeasure.measureText(__spreadProps(__spreadValues({}, TEXT_PROPS), {
          text: textToPaste,
          fontFamily: FONT_FAMILIES[defaultProps.font],
          fontSize: FONT_SIZES[defaultProps.size],
          width: minWidth + "px"
        }));
        w3 = shrunkSize.w;
        h3 = shrunkSize.h;
        autoSize = false;
        align = isRtl ? "end" : "start";
      } else {
        w3 = rawSize.w;
        h3 = rawSize.h;
        autoSize = true;
      }
      if (p3.y - h3 / 2 < app.viewportPageBounds.minY + 40) {
        p3.y = app.viewportPageBounds.minY + 40 + h3 / 2;
      }
      app.mark("paste");
      app.createShapes([
        {
          id: createShapeId(),
          type: "text",
          x: p3.x - w3 / 2,
          y: p3.y - h3 / 2,
          props: {
            text: textToPaste,
            // if the text has more than one line, align it to the left
            align,
            autoSize,
            w: w3
          }
        }
      ]);
    });
  }

  // ../../../packages/ui/src/lib/hooks/clipboard/pasteSvgText.ts
  function pasteSvgText(app, text, point2) {
    return __async(this, null, function* () {
      const p3 = point2 != null ? point2 : app.inputs.shiftKey ? app.inputs.currentPagePoint : app.viewportPageCenter;
      app.mark("paste");
      return yield createAssetShapeAtPoint(app, text, p3);
    });
  }

  // ../../../packages/ui/src/lib/hooks/clipboard/pasteTldrawContent.ts
  function pasteTldrawContent(app, clipboard, point2) {
    const p3 = point2 != null ? point2 : app.inputs.shiftKey ? app.inputs.currentPagePoint : void 0;
    app.mark("paste");
    app.putContent(clipboard, {
      point: p3,
      select: true
    });
  }

  // ../../../packages/ui/src/lib/hooks/clipboard/pasteUrl.ts
  function pasteUrl(app, url, point2) {
    return __async(this, null, function* () {
      var _a5;
      const p3 = point2 != null ? point2 : app.inputs.shiftKey ? app.inputs.currentPagePoint : app.viewportPageCenter;
      try {
        const resp = yield fetch(url);
        if ((_a5 = resp.headers.get("content-type")) == null ? void 0 : _a5.match(/^image\//)) {
          app.mark("paste");
          pasteFiles(app, [url]);
          return;
        }
      } catch (err) {
        if (err.message !== "Failed to fetch") {
          console.error(err);
        }
      }
      app.mark("paste");
      const embedInfo = getEmbedInfo(url);
      if (embedInfo) {
        return yield createEmbedShapeAtPoint(app, embedInfo.url, p3, embedInfo.definition);
      }
      return yield createBookmarkShapeAtPoint(app, url, p3);
    });
  }

  // ../../../packages/ui/src/lib/hooks/useAppIsFocused.ts
  function useAppIsFocused() {
    const app = useApp();
    return useValue("app.isFocused", () => app.isFocused, [app]);
  }

  // ../../../packages/ui/src/lib/hooks/useClipboardEvents.ts
  var INPUTS2 = ["input", "select", "textarea"];
  function disallowClipboardEvents(app) {
    const { activeElement } = document;
    return app.isMenuOpen || activeElement && (activeElement.getAttribute("contenteditable") || INPUTS2.indexOf(activeElement.tagName.toLowerCase()) > -1);
  }
  function blobAsString2(blob) {
    return __async(this, null, function* () {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.addEventListener("loadend", () => {
          const text = reader.result;
          resolve(text);
        });
        reader.addEventListener("error", () => {
          reject(reader.error);
        });
        reader.readAsText(blob);
      });
    });
  }
  function stripHtml(html) {
    const doc = document.implementation.createHTMLDocument("");
    doc.documentElement.innerHTML = html.trim();
    return doc.body.textContent || doc.body.innerText || "";
  }
  var isFile = (item) => {
    return item.types.find((i3) => i3.match(/^image\//));
  };
  var handleText = (app, data, point2) => {
    const validUrlList = getValidHttpURLList(data);
    if (validUrlList) {
      for (const url of validUrlList) {
        pasteUrl(app, url, point2);
      }
    } else if (isValidHttpURL(data)) {
      pasteUrl(app, data, point2);
    } else if (isSvgText(data)) {
      pasteSvgText(app, data, point2);
    } else {
      pastePlainText(app, data, point2);
    }
  };
  var handlePasteFromEventClipboardData = (app, clipboardData, point2) => __async(void 0, null, function* () {
    if (app.editingId !== null)
      return;
    if (!clipboardData) {
      throw Error("No clipboard data");
    }
    const things = [];
    for (const item of Object.values(clipboardData.items)) {
      switch (item.kind) {
        case "file": {
          things.push({
            type: "file",
            source: new Promise((r3) => r3(item.getAsFile()))
          });
          break;
        }
        case "string": {
          if (item.type === "text/html") {
            things.push({
              type: "html",
              source: new Promise((r3) => item.getAsString(r3))
            });
          } else if (item.type === "text/plain") {
            things.push({
              type: "text",
              source: new Promise((r3) => item.getAsString(r3))
            });
          } else {
            things.push({ type: item.type, source: new Promise((r3) => item.getAsString(r3)) });
          }
          break;
        }
      }
    }
    handleClipboardThings(app, things, point2);
  });
  var handlePasteFromClipboardApi = (app, clipboardItems, point2) => __async(void 0, null, function* () {
    const things = [];
    for (const item of clipboardItems) {
      if (isFile(item)) {
        for (const type of item.types) {
          if (type.match(/^image\//)) {
            things.push({ type: "blob", source: item.getType(type) });
          }
        }
      }
      if (item.types.includes("text/html")) {
        things.push({
          type: "html",
          source: new Promise(
            (r3) => item.getType("text/html").then((blob) => blobAsString2(blob).then(r3))
          )
        });
      }
      if (item.types.includes("text/uri-list")) {
        things.push({
          type: "url",
          source: new Promise(
            (r3) => item.getType("text/uri-list").then((blob) => blobAsString2(blob).then(r3))
          )
        });
      }
      if (item.types.includes("text/plain")) {
        things.push({
          type: "text",
          source: new Promise(
            (r3) => item.getType("text/plain").then((blob) => blobAsString2(blob).then(r3))
          )
        });
      }
    }
    return yield handleClipboardThings(app, things, point2);
  });
  function handleClipboardThings(app, things, point2) {
    return __async(this, null, function* () {
      const files = things.filter(
        (t4) => (t4.type === "file" || t4.type === "blob") && t4.source !== null
      );
      if (files.length) {
        const fileBlobs = yield Promise.all(files.map((t4) => t4.source));
        const urls = fileBlobs.filter(Boolean).map(
          (blob) => URL.createObjectURL(blob)
        );
        return yield pasteFiles(app, urls, point2);
      }
      const results = yield Promise.all(
        things.filter((t4) => t4.type !== "file").map(
          (t4) => new Promise((r3) => {
            const thing = t4;
            if (thing.type === "file") {
              r3({ type: "error", data: null, reason: "unexpected file" });
              return;
            }
            thing.source.then((text) => {
              var _a5;
              const tldrawHtmlComment = (_a5 = text.match(/<tldraw[^>]*>(.*)<\/tldraw>/)) == null ? void 0 : _a5[1];
              if (tldrawHtmlComment) {
                try {
                  const jsonComment = (0, import_lz_string.decompressFromBase64)(tldrawHtmlComment);
                  if (jsonComment === null) {
                    r3({
                      type: "error",
                      data: jsonComment,
                      reason: `found tldraw data comment but could not parse base64`
                    });
                    return;
                  } else {
                    const json = JSON.parse(jsonComment);
                    if (json.type !== "application/tldraw") {
                      r3({
                        type: "error",
                        data: json,
                        reason: `found tldraw data comment but JSON was of a different type: ${json.type}`
                      });
                    }
                    if (typeof json.data === "string") {
                      r3({
                        type: "error",
                        data: json,
                        reason: "found tldraw json but data was a string instead of a TLClipboardModel object"
                      });
                      return;
                    }
                    r3({ type: "tldraw", data: json.data });
                    return;
                  }
                } catch (e2) {
                  r3({
                    type: "error",
                    data: tldrawHtmlComment,
                    reason: "found tldraw json but data was a string instead of a TLClipboardModel object"
                  });
                  return;
                }
              } else {
                if (thing.type === "html") {
                  r3({ type: "text", data: text, subtype: "html" });
                  return;
                }
                if (thing.type === "url") {
                  r3({ type: "text", data: text, subtype: "url" });
                  return;
                }
                try {
                  const json = JSON.parse(text);
                  if (json.type === "excalidraw/clipboard") {
                    r3({ type: "excalidraw", data: json });
                    return;
                  } else {
                    r3({ type: "text", data: text, subtype: "json" });
                    return;
                  }
                } catch (e2) {
                  r3({ type: "text", data: text, subtype: "text" });
                  return;
                }
              }
              r3({ type: "error", data: text, reason: "unhandled case" });
            });
          })
        )
      );
      for (const result of results) {
        if (result.type === "tldraw") {
          pasteTldrawContent(app, result.data, point2);
          return;
        }
      }
      for (const result of results) {
        if (result.type === "excalidraw") {
          pasteExcalidrawContent(app, result.data, point2);
          return;
        }
      }
      for (const result of results) {
        if (result.type === "text" && result.subtype === "html") {
          const rootNode = new DOMParser().parseFromString(result.data, "text/html");
          const bodyNode = rootNode.querySelector("body");
          const isHtmlSingleLink = bodyNode && Array.from(bodyNode.children).filter((el) => el.nodeType === 1).length === 1 && bodyNode.firstElementChild && bodyNode.firstElementChild.tagName === "A" && bodyNode.firstElementChild.hasAttribute("href") && bodyNode.firstElementChild.getAttribute("href") !== "";
          if (isHtmlSingleLink) {
            const href = bodyNode.firstElementChild.getAttribute("href");
            handleText(app, href, point2);
            return;
          }
          if (!results.some((r3) => r3.type === "text" && r3.subtype !== "html") && result.data.trim()) {
            handleText(app, stripHtml(result.data), point2);
            return;
          }
        }
      }
      for (const result of results) {
        if (result.type === "text" && result.subtype === "url") {
          pasteUrl(app, result.data, point2);
          return;
        }
      }
      for (const result of results) {
        if (result.type === "text" && result.subtype === "text" && result.data.trim()) {
          handleText(app, result.data, point2);
          return;
        }
      }
    });
  }
  var handleNativeOrMenuCopy = (app) => {
    var _a5;
    const content = app.getContent();
    if (!content) {
      window.navigator.clipboard.writeText("");
      return;
    }
    const stringifiedClipboard = (0, import_lz_string.compressToBase64)(
      JSON.stringify({
        type: "application/tldraw",
        kind: "content",
        data: content
      })
    );
    if (typeof (window == null ? void 0 : window.navigator) !== "undefined") {
      const textItems = content.shapes.map((shape) => {
        if (TLTextShapeDef.is(shape) || TLGeoShapeDef.is(shape) || TLArrowShapeDef.is(shape)) {
          return shape.props.text;
        }
        if (TLBookmarkShapeDef.is(shape) || TLEmbedShapeDef.is(shape)) {
          return shape.props.url;
        }
        return null;
      }).filter(isNonNull);
      if ((_a5 = navigator.clipboard) == null ? void 0 : _a5.write) {
        const htmlBlob = new Blob([`<tldraw>${stringifiedClipboard}</tldraw>`], {
          type: "text/html"
        });
        let textContent = textItems.join(" ");
        if (textContent === "") {
          textContent = " ";
        }
        navigator.clipboard.write([
          new ClipboardItem({
            "text/html": htmlBlob,
            // What is this second blob used for?
            "text/plain": new Blob([textContent], { type: "text/plain" })
          })
        ]);
      } else if (navigator.clipboard.writeText) {
        navigator.clipboard.writeText(`<tldraw>${stringifiedClipboard}</tldraw>`);
      }
    }
  };
  function useMenuClipboardEvents(source) {
    const app = useApp();
    const trackEvent = useEvents();
    const copy = (0, import_react73.useCallback)(
      function onCopy() {
        if (app.selectedIds.length === 0)
          return;
        handleNativeOrMenuCopy(app);
        trackEvent("copy", { source });
      },
      [app, trackEvent, source]
    );
    const cut = (0, import_react73.useCallback)(
      function onCut() {
        if (app.selectedIds.length === 0)
          return;
        handleNativeOrMenuCopy(app);
        app.deleteShapes();
        trackEvent("cut", { source });
      },
      [app, trackEvent, source]
    );
    const paste = (0, import_react73.useCallback)(
      function onPaste(data, point2) {
        return __async(this, null, function* () {
          if (app.editingId !== null || disallowClipboardEvents(app))
            return;
          if (Array.isArray(data) && data[0] instanceof ClipboardItem) {
            handlePasteFromClipboardApi(app, data, point2);
            trackEvent("paste", { source: "menu" });
          } else {
            navigator.clipboard.read().then((clipboardItems) => {
              paste(clipboardItems, app.inputs.currentPagePoint);
            });
          }
        });
      },
      [app, trackEvent]
    );
    return {
      copy,
      cut,
      paste
    };
  }
  function useNativeClipboardEvents() {
    const app = useApp();
    const trackEvent = useEvents();
    const appIsFocused = useAppIsFocused();
    (0, import_react73.useEffect)(() => {
      if (!appIsFocused)
        return;
      const copy = () => {
        if (app.selectedIds.length === 0 || app.editingId !== null || disallowClipboardEvents(app))
          return;
        handleNativeOrMenuCopy(app);
        trackEvent("copy", { source: "kbd" });
      };
      function cut() {
        if (app.selectedIds.length === 0 || app.editingId !== null || disallowClipboardEvents(app))
          return;
        handleNativeOrMenuCopy(app);
        app.deleteShapes();
        trackEvent("cut", { source: "kbd" });
      }
      let disablingMiddleClickPaste = false;
      const pointerUpHandler = (e2) => {
        if (e2.button === 1) {
          disablingMiddleClickPaste = true;
          requestAnimationFrame(() => {
            disablingMiddleClickPaste = false;
          });
        }
      };
      const paste = (event) => {
        if (disablingMiddleClickPaste) {
          event.stopPropagation();
          return;
        }
        if (app.editingId !== null || disallowClipboardEvents(app))
          return;
        if (event.clipboardData && !app.inputs.shiftKey) {
          handlePasteFromEventClipboardData(app, event.clipboardData);
        } else {
          navigator.clipboard.read().then((clipboardItems) => {
            if (Array.isArray(clipboardItems) && clipboardItems[0] instanceof ClipboardItem) {
              handlePasteFromClipboardApi(app, clipboardItems, app.inputs.currentPagePoint);
            }
          });
        }
        trackEvent("paste", { source: "kbd" });
      };
      document.addEventListener("copy", copy);
      document.addEventListener("cut", cut);
      document.addEventListener("paste", paste);
      document.addEventListener("pointerup", pointerUpHandler);
      return () => {
        document.removeEventListener("copy", copy);
        document.removeEventListener("cut", cut);
        document.removeEventListener("paste", paste);
        document.removeEventListener("pointerup", pointerUpHandler);
      };
    }, [app, trackEvent, appIsFocused]);
  }

  // ../../../packages/ui/src/lib/hooks/useCopyAs.ts
  var import_react75 = __toESM(require_react());

  // ../../../packages/ui/src/lib/hooks/useToastsProvider.tsx
  var import_react74 = __toESM(require_react());
  var import_jsx_runtime67 = __toESM(require_jsx_runtime());
  var ToastsContext = (0, import_react74.createContext)({});
  function ToastsProvider({ children }) {
    const [toasts, setToasts] = (0, import_react74.useState)([]);
    const addToast = (0, import_react74.useCallback)((toast) => {
      var _a5;
      const id = (_a5 = toast.id) != null ? _a5 : uniqueId();
      setToasts((d3) => [...d3.filter((m3) => m3.id !== toast.id), __spreadProps(__spreadValues({}, toast), { id })]);
      return id;
    }, []);
    const removeToast = (0, import_react74.useCallback)((id) => {
      setToasts((d3) => d3.filter((m3) => m3.id !== id));
      return id;
    }, []);
    const clearToasts = (0, import_react74.useCallback)(() => {
      setToasts(() => []);
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime67.jsx)(ToastsContext.Provider, { value: { toasts, addToast, removeToast, clearToasts }, children });
  }
  function useToasts() {
    const ctx = (0, import_react74.useContext)(ToastsContext);
    if (!ctx) {
      throw new Error("useToasts must be used within a ToastsProvider");
    }
    return ctx;
  }

  // ../../../packages/ui/src/lib/hooks/useCopyAs.ts
  function useCopyAs() {
    const app = useApp();
    const { addToast } = useToasts();
    const msg2 = useTranslation();
    return (0, import_react75.useCallback)(
      // it's important that this function itself isn't async - we need to
      // create the relevant `ClipboardItem`s synchronously to make sure
      // safari knows that the user _wants_ to copy:
      // https://bugs.webkit.org/show_bug.cgi?id=222262
      //
      // this is fine for navigator.clipboard.write, but for fallbacks it's a
      // little awkward.
      function copyAs(ids = app.selectedIds, format = "svg") {
        if (ids.length === 0) {
          ids = [...app.shapeIds];
        }
        if (ids.length === 0) {
          return;
        }
        switch (format) {
          case "svg": {
            if (window.navigator.clipboard) {
              if (window.navigator.clipboard.write) {
                window.navigator.clipboard.write([
                  new ClipboardItem({
                    "text/plain": getExportedSvgBlob(app, ids)
                  })
                ]);
              } else {
                fallbackWriteTextAsync(
                  () => __async(this, null, function* () {
                    return getSvgAsString(yield getExportSvgElement(app, ids));
                  })
                );
              }
            }
            break;
          }
          case "jpeg":
          case "png": {
            const mimeType = format === "jpeg" ? "image/jpeg" : "image/png";
            const blobPromise = getExportedImageBlob(app, ids, format).then((blob) => {
              if (blob) {
                if (window.navigator.clipboard) {
                  return blob;
                }
                throw new Error("Copy not supported");
              } else {
                addToast({
                  id: "copy-fail",
                  icon: "warning-triangle",
                  title: msg2("toast.error.copy-fail.title"),
                  description: msg2("toast.error.copy-fail.desc")
                });
                throw new Error("Copy not possible");
              }
            });
            window.navigator.clipboard.write([
              new ClipboardItem({
                // Note: This needs to use the promise based approach for safari/ios to not bail on a permissions error.
                [mimeType]: blobPromise
              })
            ]).catch((err) => {
              if (!err.toString().match(/^TypeError: DOMString not supported/)) {
                console.error(err);
              }
              blobPromise.then((blob) => {
                window.navigator.clipboard.write([
                  new ClipboardItem({
                    // Note: This needs to use the promise based approach for safari/ios to not bail on a permissions error.
                    [mimeType]: blob
                  })
                ]);
              });
            });
            break;
          }
          case "json": {
            const data = app.getContent(ids);
            if (window.navigator.clipboard) {
              const jsonStr = JSON.stringify(data);
              if (window.navigator.clipboard.write) {
                window.navigator.clipboard.write([
                  new ClipboardItem({
                    "text/plain": new Blob([jsonStr], { type: "text/plain" })
                  })
                ]);
              } else {
                fallbackWriteTextAsync(() => __async(this, null, function* () {
                  return jsonStr;
                }));
              }
            }
            break;
          }
          default:
            throw new Error(`Copy type ${format} not supported.`);
        }
      },
      [app, addToast, msg2]
    );
  }
  function getExportSvgElement(app, ids) {
    return __async(this, null, function* () {
      const svg = yield app.getSvg(ids, {
        scale: 1,
        background: app.instanceState.exportBackground
      });
      if (!svg)
        throw new Error("Could not construct SVG.");
      return svg;
    });
  }
  function getExportedSvgBlob(app, ids) {
    return __async(this, null, function* () {
      return new Blob([getSvgAsString(yield getExportSvgElement(app, ids))], {
        type: "text/plain"
      });
    });
  }
  function getExportedImageBlob(app, ids, format) {
    return __async(this, null, function* () {
      return yield getSvgAsImage(yield getExportSvgElement(app, ids), {
        type: format,
        quality: 1,
        scale: 2
      });
    });
  }
  function fallbackWriteTextAsync(getText) {
    return __async(this, null, function* () {
      navigator.clipboard.writeText(yield getText());
    });
  }

  // ../../../packages/ui/src/lib/hooks/useDialogsProvider.tsx
  var import_react76 = __toESM(require_react());
  var import_jsx_runtime68 = __toESM(require_jsx_runtime());
  var DialogsContext = (0, import_react76.createContext)({});
  function DialogsProvider({ children }) {
    const app = useApp();
    const trackEvent = useEvents();
    const [dialogs, setDialogs] = (0, import_react76.useState)([]);
    const addDialog = (0, import_react76.useCallback)(
      (dialog) => {
        var _a5;
        const id = (_a5 = dialog.id) != null ? _a5 : uniqueId();
        setDialogs((d3) => {
          return [...d3.filter((m3) => m3.id !== dialog.id), __spreadProps(__spreadValues({}, dialog), { id })];
        });
        trackEvent("open-menu", { source: "dialog", id });
        app.addOpenMenu(id);
        return id;
      },
      [app, trackEvent]
    );
    const updateDialog = (0, import_react76.useCallback)(
      (id, newDialogData) => {
        setDialogs(
          (d3) => d3.map((m3) => {
            if (m3.id === id) {
              return __spreadValues(__spreadValues({}, m3), newDialogData);
            }
            return m3;
          })
        );
        trackEvent("open-menu", { source: "dialog", id });
        app.addOpenMenu(id);
        return id;
      },
      [app, trackEvent]
    );
    const removeDialog = (0, import_react76.useCallback)(
      (id) => {
        setDialogs(
          (d3) => d3.filter((m3) => {
            var _a5;
            if (m3.id === id) {
              (_a5 = m3.onClose) == null ? void 0 : _a5.call(m3);
              return false;
            }
            return true;
          })
        );
        trackEvent("close-menu", { source: "dialog", id });
        app.deleteOpenMenu(id);
        return id;
      },
      [app, trackEvent]
    );
    const clearDialogs = (0, import_react76.useCallback)(() => {
      setDialogs((d3) => {
        d3.forEach((m3) => {
          var _a5;
          (_a5 = m3.onClose) == null ? void 0 : _a5.call(m3);
          trackEvent("close-menu", { source: "dialog", id: m3.id });
          app.deleteOpenMenu(m3.id);
        });
        return [];
      });
    }, [app, trackEvent]);
    return /* @__PURE__ */ (0, import_jsx_runtime68.jsx)(
      DialogsContext.Provider,
      {
        value: { dialogs, addDialog, removeDialog, clearDialogs, updateDialog },
        children
      }
    );
  }
  function useDialogs() {
    const ctx = (0, import_react76.useContext)(DialogsContext);
    if (!ctx) {
      throw new Error("useDialogs must be used within a DialogsProvider");
    }
    return ctx;
  }

  // ../../../packages/ui/src/lib/hooks/useExportAs.ts
  var import_react77 = __toESM(require_react());
  function useExportAs() {
    const app = useApp();
    const { addToast } = useToasts();
    const msg2 = useTranslation();
    return (0, import_react77.useCallback)(
      function exportAs() {
        return __async(this, arguments, function* (ids = app.selectedIds, format = "png") {
          var _a5;
          if (ids.length === 0) {
            ids = [...app.shapeIds];
          }
          if (ids.length === 0) {
            return;
          }
          const svg = yield app.getSvg(ids, {
            scale: 1,
            background: app.instanceState.exportBackground
          });
          if (!svg)
            throw new Error("Could not construct SVG.");
          let name = "shapes";
          if (ids.length === 1) {
            const first = app.getShapeById(ids[0]);
            if (first.type === "frame") {
              name = (_a5 = first.props.name) != null ? _a5 : "frame";
            } else {
              name = first.id.replace(/:/, "_");
            }
          }
          switch (format) {
            case "svg": {
              const dataURL = yield getSvgAsDataUrl(svg);
              downloadDataURLAsFile(dataURL, `${name || "shapes"}.svg`);
              return;
            }
            case "webp":
            case "png": {
              const image = yield getSvgAsImage(svg, {
                type: format,
                quality: 1,
                scale: 2
              });
              if (!image) {
                addToast({
                  id: "export-fail",
                  // icon: 'error',
                  title: msg2("toast.error.export-fail.title"),
                  description: msg2("toast.error.export-fail.desc")
                });
                return;
              }
              const dataURL = URL.createObjectURL(image);
              downloadDataURLAsFile(dataURL, `${name || "shapes"}.${format}`);
              URL.revokeObjectURL(dataURL);
              return;
            }
            case "json": {
              const data = app.getContent(ids);
              const dataURL = URL.createObjectURL(
                new Blob([JSON.stringify(data, null, 4)], { type: "application/json" })
              );
              downloadDataURLAsFile(dataURL, `${name || "shapes"}.json`);
              URL.revokeObjectURL(dataURL);
              return;
            }
            default:
              throw new Error(`Export type ${format} not supported.`);
          }
        });
      },
      [app, addToast, msg2]
    );
  }

  // ../../../packages/ui/src/lib/hooks/useInsertMedia.ts
  var import_react78 = __toESM(require_react());
  function useInsertMedia() {
    const app = useApp();
    const inputRef = (0, import_react78.useRef)();
    (0, import_react78.useEffect)(() => {
      const input = window.document.createElement("input");
      input.type = "file";
      input.accept = ACCEPTED_ASSET_TYPE;
      input.multiple = true;
      inputRef.current = input;
      function onchange(e2) {
        return __async(this, null, function* () {
          const fileList = e2.target.files;
          if (!fileList || fileList.length === 0)
            return;
          yield createShapesFromFiles(app, Array.from(fileList), app.viewportPageBounds.center, false);
          input.value = "";
        });
      }
      input.addEventListener("change", onchange);
      return () => {
        inputRef.current = void 0;
        input.removeEventListener("change", onchange);
      };
    }, [app]);
    return (0, import_react78.useCallback)(() => {
      var _a5;
      (_a5 = inputRef.current) == null ? void 0 : _a5.click();
    }, [inputRef]);
  }

  // ../../../packages/ui/src/lib/hooks/usePrint.ts
  var import_react79 = __toESM(require_react());
  function usePrint() {
    const app = useApp();
    const prevPrintEl = (0, import_react79.useRef)(null);
    const prevStyleEl = (0, import_react79.useRef)(null);
    return (0, import_react79.useCallback)(
      function printSelectionOrPages() {
        return __async(this, null, function* () {
          const el = document.createElement("div");
          const style = document.createElement("style");
          const clearElements = (printEl, styleEl) => {
            if (printEl)
              printEl.innerHTML = "";
            if (styleEl && document.head.contains(styleEl))
              document.head.removeChild(styleEl);
            if (printEl && document.body.contains(printEl)) {
              document.body.removeChild(printEl);
            }
          };
          clearElements(prevPrintEl.current, prevStyleEl.current);
          prevPrintEl.current = el;
          prevStyleEl.current = style;
          const className = `tl-print-surface-${uniqueId()}`;
          el.className = className;
          const enableMargins = false;
          const allowAllPages = false;
          style.innerHTML = `
			.${className} {
				display: none;
			}

			.${className} svg {
				max-width: 100%;
				height: 100%;
				display: block;
			}

			@media print {				  
				html, body {
					min-height: 100%;
					height: 100%;
					margin: 0;
				}

				body {
					position: relative;
				}

				body > * {
					display: none;
				}

				.${className} {
					display: block !important;
					background: white;
					min-height: 100%;
					height: 100%;
					max-width: 100%;
				}

				.${className}__item {
					padding: 10mm;
					display: flex;
					min-height: 100%;
					flex-direction: column;
					page-break-after: always;
					position: relative;
					overflow: hidden;
					height: 100%;
				}

				.${className}__item__main {
					flex: 1;
					display: flex;
					align-items: center;
					justify-content: center;
					max-height: 100%;
				}

				.${className}__item__header {
					display: none;
				}

				.${className}__item__footer {
					display: none;
					text-align: right;
				}

				.${className}__item__footer__hide {
					display: none;
				}

				${!enableMargins ? "" : `
					/**
					 * Note: Safari doesn't support removing the page margins to remove them all!
					 */
					@page {
						margin:0;
					}

					.${className} .${className}__item__header {
						display: block;
					}

					.${className} .${className}__item__footer {
						display: block;
					}
				`}
			}

		`;
          const beforePrintHandler = () => {
            document.head.appendChild(style);
            document.body.appendChild(el);
          };
          const afterPrintHandler = () => {
            app.once("change-history", () => {
              clearElements(el, style);
            });
          };
          window.addEventListener("beforeprint", beforePrintHandler);
          window.addEventListener("afterprint", afterPrintHandler);
          function addPageToPrint(title, footer, svg) {
            try {
              el.innerHTML += `<div class="${className}__item">
        <div class="${className}__item__header">
          ${title.replace(/</g, "&lt;").replace(/>/g, "&gt;")}
        </div>
        <div class="${className}__item__main">
          ${svg.outerHTML}
        </div>
        <div class="${className}__item__footer ${className}__item__footer__${footer ? "" : "hide"}">
          ${footer != null ? footer : ""}
        </div>
      </div>`;
            } catch (e2) {
              console.error(e2);
            }
          }
          function triggerPrint() {
            if (app.isChromeForIos) {
              beforePrintHandler();
              window.print();
            } else if (app.isSafari) {
              beforePrintHandler();
              document.execCommand("print", false);
            } else {
              window.print();
            }
          }
          const { pages, currentPageId, selectedIds } = app;
          const preserveAspectRatio = "xMidYMid meet";
          const svgOpts = {
            scale: 1,
            background: false,
            darkMode: false,
            preserveAspectRatio
          };
          if (app.selectedIds.length > 0) {
            const svg = yield app.getSvg(selectedIds, svgOpts);
            if (svg) {
              const page = pages.find((p3) => p3.id === currentPageId);
              addPageToPrint(`tldraw \u2014 ${page == null ? void 0 : page.name}`, null, svg);
              triggerPrint();
            }
          } else {
            if (allowAllPages) {
              for (let i3 = 0; i3 < pages.length; i3++) {
                const page = pages[i3];
                const svg = yield app.getSvg(app.getSortedChildIds(page.id), svgOpts);
                if (svg) {
                  addPageToPrint(`tldraw \u2014 ${page.name}`, `${i3}/${pages.length}`, svg);
                }
              }
              triggerPrint();
            } else {
              const page = app.currentPage;
              const svg = yield app.getSvg(app.getSortedChildIds(page.id), svgOpts);
              if (svg) {
                addPageToPrint(`tldraw \u2014 ${page.name}`, null, svg);
                triggerPrint();
              }
            }
          }
          window.removeEventListener("beforeprint", beforePrintHandler);
          window.removeEventListener("afterprint", afterPrintHandler);
        });
      },
      [app]
    );
  }

  // ../../../packages/ui/src/lib/hooks/useActions.tsx
  var import_jsx_runtime69 = __toESM(require_jsx_runtime());
  var ActionsContext = React46.createContext({});
  function makeActions(actions) {
    return Object.fromEntries(actions.map((action) => [action.id, action]));
  }
  function ActionsProvider({ overrides, children }) {
    const app = useApp();
    const { addDialog, clearDialogs } = useDialogs();
    const { clearToasts } = useToasts();
    const insertMedia = useInsertMedia();
    const printSelectionOrPages = usePrint();
    const { cut, copy } = useMenuClipboardEvents("unknown");
    const copyAs = useCopyAs();
    const exportAs = useExportAs();
    const trackEvent = useEvents();
    const actions = React46.useMemo(() => {
      const actions2 = makeActions([
        {
          id: "edit-link",
          label: "action.edit-link",
          icon: "link",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("edit-link", { source });
            app.mark("edit-link");
            addDialog({ component: EditLinkDialog });
          }
        },
        {
          id: "insert-embed",
          label: "action.insert-embed",
          readonlyOk: false,
          kbd: "$i",
          onSelect(source) {
            trackEvent("insert-embed", { source });
            addDialog({ component: EmbedDialog });
          }
        },
        {
          id: "insert-media",
          label: "action.insert-media",
          kbd: "$u",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("insert-media", { source });
            insertMedia();
          }
        },
        {
          id: "undo",
          label: "action.undo",
          icon: "undo",
          kbd: "$z",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("undo", { source });
            app.undo();
          }
        },
        {
          id: "redo",
          label: "action.redo",
          icon: "redo",
          kbd: "$!z",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("redo", { source });
            app.redo();
          }
        },
        {
          id: "export-as-svg",
          label: "action.export-as-svg",
          menuLabel: "action.export-as-svg.short",
          contextMenuLabel: "action.export-as-svg.short",
          readonlyOk: true,
          onSelect(source) {
            trackEvent("export-as", { format: "svg", source });
            exportAs(app.selectedIds, "svg");
          }
        },
        {
          id: "export-as-png",
          label: "action.export-as-png",
          menuLabel: "action.export-as-png.short",
          contextMenuLabel: "action.export-as-png.short",
          readonlyOk: true,
          onSelect(source) {
            trackEvent("export-as", { format: "png", source });
            exportAs(app.selectedIds, "png");
          }
        },
        {
          id: "export-as-json",
          label: "action.export-as-json",
          menuLabel: "action.export-as-json.short",
          contextMenuLabel: "action.export-as-json.short",
          readonlyOk: true,
          onSelect(source) {
            trackEvent("export-as", { format: "json", source });
            exportAs(app.selectedIds, "json");
          }
        },
        {
          id: "copy-as-svg",
          label: "action.copy-as-svg",
          menuLabel: "action.copy-as-svg.short",
          contextMenuLabel: "action.copy-as-svg.short",
          kbd: "$!c",
          readonlyOk: true,
          onSelect(source) {
            trackEvent("copy-as", { format: "svg", source });
            copyAs(app.selectedIds, "svg");
          }
        },
        {
          id: "copy-as-png",
          label: "action.copy-as-png",
          menuLabel: "action.copy-as-png.short",
          contextMenuLabel: "action.copy-as-png.short",
          readonlyOk: true,
          onSelect(source) {
            trackEvent("copy-as", { format: "png", source });
            copyAs(app.selectedIds, "png");
          }
        },
        {
          id: "copy-as-json",
          label: "action.copy-as-json",
          menuLabel: "action.copy-as-json.short",
          contextMenuLabel: "action.copy-as-json.short",
          readonlyOk: true,
          onSelect(source) {
            trackEvent("copy-as", { format: "json", source });
            copyAs(app.selectedIds, "json");
          }
        },
        {
          id: "toggle-auto-size",
          label: "action.toggle-auto-size",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("toggle-auto-size", { source });
            app.mark();
            app.updateShapes(
              app.selectedShapes.filter((shape) => shape && shape.type === "text" && shape.props.autoSize === false).map((shape) => {
                return {
                  id: shape.id,
                  type: shape.type,
                  props: __spreadProps(__spreadValues({}, shape.props), {
                    w: 8,
                    autoSize: true
                  })
                };
              })
            );
          }
        },
        {
          id: "open-embed-link",
          label: "action.open-embed-link",
          readonlyOk: true,
          onSelect(source) {
            trackEvent("open-embed-link", { source });
            const ids = app.selectedIds;
            const warnMsg = "No embed shapes selected";
            if (ids.length !== 1) {
              console.error(warnMsg);
              return;
            }
            const shape = app.getShapeById(ids[0]);
            if (!shape || !TLEmbedShapeDef.is(shape)) {
              console.error(warnMsg);
              return;
            }
            openWindow(shape.props.url, "_blank");
          }
        },
        {
          id: "convert-to-bookmark",
          label: "action.convert-to-bookmark",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("convert-to-bookmark", { source });
            const ids = app.selectedIds;
            const shapes = ids.map((id) => app.getShapeById(id));
            const createList = [];
            const deleteList = [];
            for (const shape of shapes) {
              if (!shape || !TLEmbedShapeDef.is(shape) || !shape.props.url)
                continue;
              const newPos = new Vec2d(shape.x, shape.y);
              newPos.rot(-shape.rotation);
              newPos.add(
                new Vec2d(
                  shape.props.w / 2 - DEFAULT_BOOKMARK_WIDTH / 2,
                  shape.props.h / 2 - DEFAULT_BOOKMARK_HEIGHT / 2
                )
              );
              newPos.rot(shape.rotation);
              createList.push({
                id: app.createShapeId(),
                type: "bookmark",
                rotation: shape.rotation,
                x: newPos.x,
                y: newPos.y,
                props: {
                  url: shape.props.url,
                  opacity: "1"
                }
              });
              deleteList.push(shape.id);
            }
            app.mark("convert shapes to bookmark");
            app.deleteShapes(deleteList);
            app.createShapes(createList);
          }
        },
        {
          id: "convert-to-embed",
          label: "action.convert-to-embed",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("convert-to-embed", { source });
            const ids = app.selectedIds;
            const shapes = compact(ids.map((id) => app.getShapeById(id)));
            const createList = [];
            const deleteList = [];
            for (const shape of shapes) {
              if (!TLBookmarkShapeDef.is(shape))
                continue;
              const { url } = shape.props;
              const embedInfo = getEmbedInfo(shape.props.url);
              if (!embedInfo)
                continue;
              if (!embedInfo.definition)
                continue;
              const { width, height, doesResize } = embedInfo.definition;
              const newPos = new Vec2d(shape.x, shape.y);
              newPos.rot(-shape.rotation);
              newPos.add(new Vec2d(shape.props.w / 2 - width / 2, shape.props.h / 2 - height / 2));
              newPos.rot(shape.rotation);
              createList.push({
                id: app.createShapeId(),
                type: "embed",
                x: newPos.x,
                y: newPos.y,
                rotation: shape.rotation,
                props: {
                  url,
                  w: width,
                  h: height,
                  doesResize
                }
              });
              deleteList.push(shape.id);
            }
            app.mark("convert shapes to embed");
            app.deleteShapes(deleteList);
            app.createShapes(createList);
          }
        },
        {
          id: "duplicate",
          kbd: "$d",
          label: "action.duplicate",
          icon: "duplicate",
          readonlyOk: false,
          onSelect(source) {
            if (app.currentToolId !== "select")
              return;
            trackEvent("duplicate-shapes", { source });
            const ids = app.selectedIds;
            const commonBounds = Box2d.Common(compact(ids.map((id) => app.getPageBoundsById(id))));
            const offset = app.canMoveCamera ? {
              x: commonBounds.width + 10,
              y: 0
            } : {
              x: 16 / app.zoomLevel,
              y: 16 / app.zoomLevel
            };
            app.mark("duplicate shapes");
            app.duplicateShapes(ids, offset);
          }
        },
        {
          id: "ungroup",
          label: "action.ungroup",
          kbd: "$!g",
          icon: "ungroup",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("ungroup-shapes", { source });
            app.mark("ungroup");
            app.ungroupShapes(app.selectedIds);
          }
        },
        {
          id: "group",
          label: "action.group",
          kbd: "$g",
          icon: "group",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("group-shapes", { source });
            if (app.selectedShapes.length === 1 && app.selectedShapes[0].type === "group") {
              app.mark("ungroup");
              app.ungroupShapes(app.selectedIds);
            } else {
              app.mark("group");
              app.groupShapes(app.selectedIds);
            }
          }
        },
        {
          id: "align-left",
          label: "action.align-left",
          kbd: "?A",
          icon: "align-left",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("align-shapes", { operation: "left", source });
            app.mark("align left");
            app.alignShapes("left", app.selectedIds);
          }
        },
        {
          id: "align-center-horizontal",
          label: "action.align-center-horizontal",
          contextMenuLabel: "action.align-center-horizontal.short",
          kbd: "?H",
          icon: "align-center-horizontal",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("align-shapes", { operation: "center-horizontal", source });
            app.mark("align center horizontal");
            app.alignShapes("center-horizontal", app.selectedIds);
          }
        },
        {
          id: "align-right",
          label: "action.align-right",
          kbd: "?D",
          icon: "align-right",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("align-shapes", { operation: "right", source });
            app.mark("align right");
            app.alignShapes("right", app.selectedIds);
          }
        },
        {
          id: "align-center-vertical",
          label: "action.align-center-vertical",
          contextMenuLabel: "action.align-center-vertical.short",
          kbd: "?V",
          icon: "align-center-vertical",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("align-shapes", { operation: "center-vertical", source });
            app.mark("align center vertical");
            app.alignShapes("center-vertical", app.selectedIds);
          }
        },
        {
          id: "align-top",
          label: "action.align-top",
          icon: "align-top",
          kbd: "?W",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("align-shapes", { operation: "top", source });
            app.mark("align top");
            app.alignShapes("top", app.selectedIds);
          }
        },
        {
          id: "align-bottom",
          label: "action.align-bottom",
          icon: "align-bottom",
          kbd: "?S",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("align-shapes", { operation: "bottom", source });
            app.mark("align bottom");
            app.alignShapes("bottom", app.selectedIds);
          }
        },
        {
          id: "distribute-horizontal",
          label: "action.distribute-horizontal",
          contextMenuLabel: "action.distribute-horizontal.short",
          icon: "distribute-horizontal",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("distribute-shapes", { operation: "horizontal", source });
            app.mark("distribute horizontal");
            app.distributeShapes("horizontal", app.selectedIds);
          }
        },
        {
          id: "distribute-vertical",
          label: "action.distribute-vertical",
          contextMenuLabel: "action.distribute-vertical.short",
          icon: "distribute-vertical",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("distribute-shapes", { operation: "vertical", source });
            app.mark("distribute vertical");
            app.distributeShapes("vertical", app.selectedIds);
          }
        },
        {
          id: "stretch-horizontal",
          label: "action.stretch-horizontal",
          contextMenuLabel: "action.stretch-horizontal.short",
          icon: "stretch-horizontal",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("stretch-shapes", { operation: "horizontal", source });
            app.mark("stretch horizontal");
            app.stretchShapes("horizontal", app.selectedIds);
          }
        },
        {
          id: "stretch-vertical",
          label: "action.stretch-vertical",
          contextMenuLabel: "action.stretch-vertical.short",
          icon: "stretch-vertical",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("stretch-shapes", { operation: "vertical", source });
            app.mark("stretch vertical");
            app.stretchShapes("vertical", app.selectedIds);
          }
        },
        {
          id: "flip-horizontal",
          label: "action.flip-horizontal",
          contextMenuLabel: "action.flip-horizontal.short",
          kbd: "!h",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("flip-shapes", { operation: "horizontal", source });
            app.mark("flip horizontal");
            app.flipShapes("horizontal", app.selectedIds);
          }
        },
        {
          id: "flip-vertical",
          label: "action.flip-vertical",
          contextMenuLabel: "action.flip-vertical.short",
          kbd: "!v",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("flip-shapes", { operation: "vertical", source });
            app.mark("flip vertical");
            app.flipShapes("vertical", app.selectedIds);
          }
        },
        {
          id: "pack",
          label: "action.pack",
          icon: "pack",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("pack-shapes", { source });
            app.mark("pack");
            app.packShapes(app.selectedIds);
          }
        },
        {
          id: "stack-vertical",
          label: "action.stack-vertical",
          contextMenuLabel: "action.stack-vertical.short",
          icon: "stack-vertical",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("stack-shapes", { operation: "vertical", source });
            app.mark("stack-vertical");
            app.stackShapes("vertical", app.selectedIds);
          }
        },
        {
          id: "stack-horizontal",
          label: "action.stack-horizontal",
          contextMenuLabel: "action.stack-horizontal.short",
          icon: "stack-horizontal",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("stack-shapes", { operation: "horizontal", source });
            app.mark("stack-horizontal");
            app.stackShapes("horizontal", app.selectedIds);
          }
        },
        {
          id: "bring-to-front",
          label: "action.bring-to-front",
          kbd: "]",
          icon: "bring-to-front",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("reorder-shapes", { operation: "toFront", source });
            app.mark("bring to front");
            app.bringToFront();
          }
        },
        {
          id: "bring-forward",
          label: "action.bring-forward",
          icon: "bring-forward",
          kbd: "?]",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("reorder-shapes", { operation: "forward", source });
            app.mark("bring forward");
            app.bringForward();
          }
        },
        {
          id: "send-backward",
          label: "action.send-backward",
          icon: "send-backward",
          kbd: "?[",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("reorder-shapes", { operation: "backward", source });
            app.mark("send backward");
            app.sendBackward();
          }
        },
        {
          id: "send-to-back",
          label: "action.send-to-back",
          icon: "send-to-back",
          kbd: "[",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("reorder-shapes", { operation: "toBack", source });
            app.mark("send to back");
            app.sendToBack();
          }
        },
        {
          id: "cut",
          label: "action.cut",
          kbd: "$x",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("cut", { source });
            app.mark("cut");
            cut();
          }
        },
        {
          id: "copy",
          label: "action.copy",
          kbd: "$c",
          readonlyOk: true,
          onSelect(source) {
            trackEvent("copy", { source });
            copy();
          }
        },
        {
          id: "paste",
          label: "action.paste",
          kbd: "$v",
          readonlyOk: false,
          onSelect() {
          }
        },
        {
          id: "select-all",
          label: "action.select-all",
          kbd: "$a",
          readonlyOk: true,
          onSelect(source) {
            trackEvent("select-all-shapes", { source });
            if (app.currentToolId !== "select") {
              app.cancel();
              app.setSelectedTool("select");
            }
            app.mark("select all kbd");
            app.selectAll();
          }
        },
        {
          id: "select-none",
          label: "action.select-none",
          readonlyOk: true,
          onSelect(source) {
            trackEvent("select-none-shapes", { source });
            app.mark("select none");
            app.selectNone();
          }
        },
        {
          id: "delete",
          label: "action.delete",
          kbd: "\u232B",
          icon: "trash",
          readonlyOk: false,
          onSelect(source) {
            if (app.currentToolId !== "select")
              return;
            trackEvent("delete-shapes", { source });
            app.mark("delete");
            app.deleteShapes();
          }
        },
        {
          id: "rotate-cw",
          label: "action.rotate-cw",
          icon: "rotate-cw",
          readonlyOk: false,
          onSelect(source) {
            if (app.selectedIds.length === 0)
              return;
            trackEvent("rotate-cw", { source });
            app.mark("rotate-cw");
            const offset = app.selectionRotation % (TAU / 2);
            const dontUseOffset = approximately(offset, 0) || approximately(offset, TAU / 2);
            app.rotateShapesBy(app.selectedIds, TAU / 2 - (dontUseOffset ? 0 : offset));
          }
        },
        {
          id: "rotate-ccw",
          label: "action.rotate-ccw",
          icon: "rotate-ccw",
          readonlyOk: false,
          onSelect(source) {
            if (app.selectedIds.length === 0)
              return;
            trackEvent("rotate-ccw", { source });
            app.mark("rotate-ccw");
            const offset = app.selectionRotation % (TAU / 2);
            const offsetCloseToZero = approximately(offset, 0);
            app.rotateShapesBy(app.selectedIds, offsetCloseToZero ? -(TAU / 2) : -offset);
          }
        },
        {
          id: "zoom-in",
          label: "action.zoom-in",
          kbd: "$=",
          readonlyOk: true,
          onSelect(source) {
            trackEvent("zoom-in", { source });
            app.zoomIn(app.viewportScreenCenter, { duration: ANIMATION_MEDIUM_MS });
          }
        },
        {
          id: "zoom-out",
          label: "action.zoom-out",
          kbd: "$-",
          readonlyOk: true,
          onSelect(source) {
            trackEvent("zoom-out", { source });
            app.zoomOut(app.viewportScreenCenter, { duration: ANIMATION_MEDIUM_MS });
          }
        },
        {
          id: "zoom-to-100",
          label: "action.zoom-to-100",
          icon: "reset-zoom",
          kbd: "!0",
          readonlyOk: true,
          onSelect(source) {
            trackEvent("reset-zoom", { source });
            app.resetZoom(app.viewportScreenCenter, { duration: ANIMATION_MEDIUM_MS });
          }
        },
        {
          id: "zoom-to-fit",
          label: "action.zoom-to-fit",
          kbd: "!1",
          readonlyOk: true,
          onSelect(source) {
            trackEvent("zoom-to-fit", { source });
            app.zoomToFit({ duration: ANIMATION_MEDIUM_MS });
          }
        },
        {
          id: "zoom-to-selection",
          label: "action.zoom-to-selection",
          kbd: "!2",
          readonlyOk: true,
          onSelect(source) {
            trackEvent("zoom-to-selection", { source });
            app.zoomToSelection({ duration: ANIMATION_MEDIUM_MS });
          }
        },
        {
          id: "toggle-snap-mode",
          label: "action.toggle-snap-mode",
          menuLabel: "action.toggle-snap-mode.menu",
          readonlyOk: false,
          onSelect(source) {
            trackEvent("toggle-snap-mode", { source });
            app.setSnapMode(!app.isSnapMode);
          },
          checkbox: true
        },
        {
          id: "toggle-dark-mode",
          label: "action.toggle-dark-mode",
          menuLabel: "action.toggle-dark-mode.menu",
          kbd: "$/",
          readonlyOk: true,
          onSelect(source) {
            trackEvent("toggle-dark-mode", { source });
            app.setDarkMode(!app.isDarkMode);
          },
          checkbox: true
        },
        {
          id: "toggle-transparent",
          label: "action.toggle-transparent",
          menuLabel: "action.toggle-transparent.menu",
          contextMenuLabel: "action.toggle-transparent.context-menu",
          readonlyOk: true,
          onSelect(source) {
            trackEvent("toggle-transparent", { source });
            app.updateInstanceState(
              {
                exportBackground: !app.instanceState.exportBackground
              },
              true
            );
          },
          checkbox: true
        },
        {
          id: "toggle-tool-lock",
          label: "action.toggle-tool-lock",
          menuLabel: "action.toggle-tool-lock.menu",
          readonlyOk: false,
          kbd: "q",
          onSelect(source) {
            trackEvent("toggle-tool-lock", { source });
            app.setToolLocked(!app.isToolLocked);
          },
          checkbox: true
        },
        {
          id: "toggle-focus-mode",
          label: "action.toggle-focus-mode",
          menuLabel: "action.toggle-focus-mode.menu",
          readonlyOk: true,
          kbd: "$.",
          checkbox: true,
          onSelect(source) {
            requestAnimationFrame(() => {
              app.batch(() => {
                trackEvent("toggle-focus-mode", { source });
                clearDialogs();
                clearToasts();
                app.setFocusMode(!app.isFocusMode);
              });
            });
          }
        },
        {
          id: "toggle-grid",
          label: "action.toggle-grid",
          menuLabel: "action.toggle-grid.menu",
          readonlyOk: true,
          kbd: "$'",
          onSelect(source) {
            trackEvent("toggle-grid-mode", { source });
            app.setGridMode(!app.isGridMode);
          },
          checkbox: true
        },
        {
          id: "toggle-debug-mode",
          label: "action.toggle-debug-mode",
          menuLabel: "action.toggle-debug-mode.menu",
          readonlyOk: true,
          onSelect(source) {
            trackEvent("toggle-debug-mode", { source });
            app.updateInstanceState(
              {
                isDebugMode: !app.instanceState.isDebugMode
              },
              true
            );
          },
          checkbox: true
        },
        {
          id: "print",
          label: "action.print",
          kbd: "$p",
          readonlyOk: true,
          onSelect(source) {
            trackEvent("print", { source });
            printSelectionOrPages();
          }
        },
        {
          id: "exit-pen-mode",
          label: "action.exit-pen-mode",
          icon: "cross-2",
          readonlyOk: true,
          onSelect(source) {
            trackEvent("exit-pen-mode", { source });
            app.setPenMode(false);
          }
        },
        {
          id: "stop-following",
          label: "action.stop-following",
          icon: "cross-2",
          readonlyOk: true,
          onSelect(source) {
            trackEvent("stop-following", { source });
            app.stopFollowingUser();
          }
        },
        {
          id: "back-to-content",
          label: "action.back-to-content",
          icon: "arrow-left",
          readonlyOk: true,
          onSelect(source) {
            trackEvent("zoom-to-content", { source });
            app.zoomToContent();
          }
        }
      ]);
      if (overrides) {
        return overrides(app, actions2, void 0);
      }
      return actions2;
    }, [
      trackEvent,
      overrides,
      app,
      addDialog,
      insertMedia,
      exportAs,
      copyAs,
      cut,
      copy,
      clearDialogs,
      clearToasts,
      printSelectionOrPages
    ]);
    return /* @__PURE__ */ (0, import_jsx_runtime69.jsx)(ActionsContext.Provider, { value: asActions(actions), children });
  }
  function useActions() {
    const ctx = React46.useContext(ActionsContext);
    if (!ctx) {
      throw new Error("useTools must be used within a ToolProvider");
    }
    return ctx;
  }
  function asActions(actions) {
    return actions;
  }

  // ../../../packages/ui/src/lib/hooks/useActionsMenuSchema.tsx
  var import_react81 = __toESM(require_react());

  // ../../../packages/ui/src/lib/hooks/menuHelpers.ts
  function compactMenuItems(arr) {
    return arr.filter((i3) => i3 !== void 0 && i3 !== null && i3 !== false);
  }
  function menuGroup(id, ...children) {
    const childItems = compactMenuItems(children);
    if (childItems.length === 0)
      return null;
    return {
      id,
      type: "group",
      checkbox: childItems.every((child) => child.type === "item" && child.actionItem.checkbox),
      disabled: childItems.every((child) => child.disabled),
      readonlyOk: childItems.some((child) => child.readonlyOk),
      children: childItems
    };
  }
  function menuSubmenu(id, label, ...children) {
    const childItems = compactMenuItems(children);
    if (childItems.length === 0)
      return null;
    return {
      id,
      type: "submenu",
      label,
      children: childItems,
      disabled: childItems.every((child) => child.disabled),
      readonlyOk: childItems.some((child) => child.readonlyOk)
    };
  }
  function menuCustom(id, opts = {}) {
    const { readonlyOk = true, disabled = false } = opts;
    return {
      id,
      type: "custom",
      disabled,
      readonlyOk
    };
  }
  function menuItem(actionItem, opts = {}) {
    if (!actionItem) {
      throw Error("No action item provided to menuItem");
    }
    if (!actionItem.label) {
      throw Error("Trying to create menu item for action item that doesn't have a label");
    }
    const { checked = false, disabled = false } = opts;
    return {
      id: actionItem.id,
      type: "item",
      actionItem,
      disabled,
      checked,
      readonlyOk: actionItem.readonlyOk
    };
  }
  function shapesWithUnboundArrows(app) {
    const { selectedIds } = app;
    const selectedShapes = selectedIds.map((id) => {
      return app.getShapeById(id);
    });
    return selectedShapes.filter((shape) => {
      if (!shape)
        return false;
      if (TLArrowShapeDef.is(shape) && shape.props.start.type === "binding") {
        return false;
      }
      if (TLArrowShapeDef.is(shape) && shape.props.end.type === "binding") {
        return false;
      }
      return true;
    });
  }
  var useThreeStackableItems = () => {
    const app = useApp();
    return useValue("threeStackableItems", () => shapesWithUnboundArrows(app).length > 2, [app]);
  };
  var useAllowGroup = () => {
    const app = useApp();
    return useValue("allowGroup", () => shapesWithUnboundArrows(app).length > 1, [app]);
  };
  var useAllowUngroup = () => {
    const app = useApp();
    return useValue(
      "allowUngroup",
      () => app.selectedIds.some((id) => {
        var _a5;
        return ((_a5 = app.getShapeById(id)) == null ? void 0 : _a5.type) === "group";
      }),
      []
    );
  };
  var showMenuPaste = typeof window !== "undefined" && "navigator" in window && Boolean(navigator.clipboard) && Boolean(navigator.clipboard.read);

  // ../../../packages/ui/src/lib/hooks/useBreakpoint.tsx
  var import_react80 = __toESM(require_react());

  // ../../../packages/ui/src/lib/constants.ts
  var PORTRAIT_BREAKPOINTS = [0, 380, 420, 460, 580, 640, 840, 1023];

  // ../../../packages/ui/src/lib/hooks/useBreakpoint.tsx
  var import_jsx_runtime70 = __toESM(require_jsx_runtime());
  var BreakpointContext = import_react80.default.createContext(0);
  function BreakPointProvider({ children }) {
    const app = useApp();
    const breakpoint = useValue(
      "breakpoint",
      () => {
        const { width } = app.viewportScreenBounds;
        const breakpoints = PORTRAIT_BREAKPOINTS;
        for (let i3 = 0; i3 < breakpoints.length - 1; i3++) {
          if (width > breakpoints[i3] && width <= breakpoints[i3 + 1]) {
            return i3;
          }
        }
        return breakpoints.length;
      },
      [app]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime70.jsx)(BreakpointContext.Provider, { value: breakpoint, children });
  }
  function useBreakpoint() {
    let breakpoint = (0, import_react80.useContext)(BreakpointContext);
    const layoutQuery = new URL(window.location.href).searchParams.get("layout");
    if (layoutQuery === "desktop") {
      breakpoint = 7;
    } else if (layoutQuery === "mobile") {
      breakpoint = 1;
    }
    return breakpoint;
  }

  // ../../../packages/ui/src/lib/hooks/useHasLinkShapeSelected.ts
  function useHasLinkShapeSelected() {
    const app = useApp();
    return useValue(
      "hasLinkShapeSelected",
      () => {
        const { selectedShapes } = app;
        return selectedShapes.length === 1 && "url" in selectedShapes[0].props && selectedShapes[0].type !== "embed";
      },
      [app]
    );
  }

  // ../../../packages/ui/src/lib/hooks/useActionsMenuSchema.tsx
  var import_jsx_runtime71 = __toESM(require_jsx_runtime());
  var ActionsMenuSchemaContext = import_react81.default.createContext({});
  var ActionsMenuSchemaProvider = track(function ActionsMenuSchemaProvider2({
    overrides,
    children
  }) {
    const app = useApp();
    const actions = useActions();
    const selectedCount = app.selectedIds.length;
    const oneSelected = selectedCount > 0;
    const twoSelected = selectedCount > 1;
    const threeSelected = selectedCount > 2;
    const threeStackableItems = useThreeStackableItems();
    const allowGroup = useAllowGroup();
    const allowUngroup = useAllowUngroup();
    const showEditLink = useHasLinkShapeSelected();
    const breakpoint = useBreakpoint();
    const isZoomedTo100 = app.zoomLevel === 1;
    const actionMenuSchema = (0, import_react81.useMemo)(() => {
      const results = [
        menuItem(actions["align-left"], { disabled: !twoSelected }),
        menuItem(actions["align-center-horizontal"], { disabled: !twoSelected }),
        menuItem(actions["align-right"], { disabled: !twoSelected }),
        menuItem(actions["stretch-horizontal"], { disabled: !twoSelected }),
        menuItem(actions["align-top"], { disabled: !twoSelected }),
        menuItem(actions["align-center-vertical"], { disabled: !twoSelected }),
        menuItem(actions["align-bottom"], { disabled: !twoSelected }),
        menuItem(actions["stretch-vertical"], { disabled: !twoSelected }),
        menuItem(actions["distribute-horizontal"], { disabled: !threeSelected }),
        menuItem(actions["distribute-vertical"], { disabled: !threeSelected }),
        menuItem(actions["stack-horizontal"], { disabled: !threeStackableItems }),
        menuItem(actions["stack-vertical"], { disabled: !threeStackableItems }),
        menuItem(actions["send-to-back"], { disabled: !oneSelected }),
        menuItem(actions["send-backward"], { disabled: !oneSelected }),
        menuItem(actions["bring-forward"], { disabled: !oneSelected }),
        menuItem(actions["bring-to-front"], { disabled: !oneSelected }),
        breakpoint < 5 ? menuItem(actions["zoom-to-100"], { disabled: !!isZoomedTo100 }) : menuItem(actions["rotate-ccw"], { disabled: !oneSelected }),
        menuItem(actions["rotate-cw"], { disabled: !oneSelected }),
        menuItem(actions["edit-link"], { disabled: !showEditLink }),
        allowGroup ? menuItem(actions["group"], { disabled: !twoSelected }) : allowUngroup ? menuItem(actions["ungroup"]) : menuItem(actions["group"], { disabled: !twoSelected })
      ];
      if (overrides) {
        return overrides(app, results, { actions, oneSelected, twoSelected, threeSelected });
      }
      return results;
    }, [
      app,
      isZoomedTo100,
      allowGroup,
      overrides,
      actions,
      oneSelected,
      twoSelected,
      threeSelected,
      threeStackableItems,
      allowUngroup,
      showEditLink,
      breakpoint
    ]);
    return /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(ActionsMenuSchemaContext.Provider, { value: actionMenuSchema, children });
  });
  function useActionsMenuSchema() {
    const ctx = import_react81.default.useContext(ActionsMenuSchemaContext);
    if (!ctx) {
      throw new Error("useActionsMenuSchema must be used inside of a ActionsMenuSchemaProvider.");
    }
    return ctx;
  }

  // ../../../packages/ui/src/lib/hooks/useContextMenuSchema.tsx
  var import_react82 = __toESM(require_react());

  // ../../../packages/ui/src/lib/hooks/useOnlyFlippableShape.ts
  function useOnlyFlippableShape() {
    const app = useApp();
    return useValue(
      "onlyFlippableShape",
      () => {
        const { selectedShapes } = app;
        return selectedShapes.length === 1 && selectedShapes.every((shape) => shape.type === "group" || isShapeWithHandles(shape));
      },
      [app]
    );
  }

  // ../../../packages/ui/src/lib/hooks/useShowAutoSizeToggle.ts
  function useShowAutoSizeToggle() {
    const app = useApp();
    return useValue(
      "showAutoSizeToggle",
      () => {
        const { selectedShapes } = app;
        return selectedShapes.length === 1 && selectedShapes[0].type === "text" && selectedShapes[0].props.autoSize === false;
      },
      [app]
    );
  }

  // ../../../packages/ui/src/lib/hooks/useContextMenuSchema.tsx
  var import_jsx_runtime72 = __toESM(require_jsx_runtime());
  var ContextMenuSchemaContext = import_react82.default.createContext({});
  var ContextMenuSchemaProvider = track(function ContextMenuSchemaProvider2({
    overrides,
    children
  }) {
    var _a5;
    const app = useApp();
    const actions = useActions();
    const showAutoSizeToggle = useShowAutoSizeToggle();
    const onlyFlippableShapeSelected = useOnlyFlippableShape();
    const selectedCount = app.selectedIds.length;
    const oneSelected = selectedCount > 0;
    const oneEmbedSelected = useValue(
      "oneEmbedSelected",
      () => {
        if (app.selectedIds.length !== 1)
          return false;
        return app.selectedIds.some((selectedId) => {
          const shape = app.getShapeById(selectedId);
          return shape && TLEmbedShapeDef.is(shape) && shape.props.url;
        });
      },
      []
    );
    const oneEmbeddableBookmarkSelected = useValue(
      "oneEmbeddableBookmarkSelected",
      () => {
        if (app.selectedIds.length !== 1)
          return false;
        return app.selectedIds.some((selectedId) => {
          const shape = app.getShapeById(selectedId);
          return shape && TLBookmarkShapeDef.is(shape) && getEmbedInfo(shape.props.url);
        });
      },
      []
    );
    const twoSelected = selectedCount > 1;
    const threeSelected = selectedCount > 2;
    const threeStackableItems = useThreeStackableItems();
    const atLeastOneShapeOnPage = useValue("atLeastOneShapeOnPage", () => app.shapeIds.size > 0, []);
    const isTransparentBg = useValue("isTransparentBg", () => app.instanceState.exportBackground, []);
    const allowGroup = useAllowGroup();
    const allowUngroup = useAllowUngroup();
    const hasClipboardWrite = Boolean((_a5 = window.navigator.clipboard) == null ? void 0 : _a5.write);
    const showEditLink = useHasLinkShapeSelected();
    const contextMenuSchema = (0, import_react82.useMemo)(() => {
      let contextMenuSchema2 = compactMenuItems([
        menuGroup(
          "selection",
          oneEmbedSelected && menuItem(actions["open-embed-link"]),
          oneEmbedSelected && menuItem(actions["convert-to-bookmark"]),
          oneEmbeddableBookmarkSelected && menuItem(actions["convert-to-embed"]),
          showAutoSizeToggle && menuItem(actions["toggle-auto-size"]),
          showEditLink && menuItem(actions["edit-link"]),
          oneSelected && menuItem(actions["duplicate"]),
          allowGroup && menuItem(actions["group"]),
          allowUngroup && menuItem(actions["ungroup"])
        ),
        menuGroup(
          "modify",
          (twoSelected || onlyFlippableShapeSelected) && menuSubmenu(
            "arrange",
            "context-menu.arrange",
            twoSelected && menuGroup(
              "align",
              menuItem(actions["align-left"]),
              menuItem(actions["align-center-horizontal"]),
              menuItem(actions["align-right"]),
              menuItem(actions["align-top"]),
              menuItem(actions["align-center-vertical"]),
              menuItem(actions["align-bottom"])
            ),
            threeSelected && menuGroup(
              "distribute",
              menuItem(actions["distribute-horizontal"]),
              menuItem(actions["distribute-vertical"])
            ),
            twoSelected && menuGroup(
              "stretch",
              menuItem(actions["stretch-horizontal"]),
              menuItem(actions["stretch-vertical"])
            ),
            onlyFlippableShapeSelected && menuGroup(
              "flip",
              menuItem(actions["flip-horizontal"]),
              menuItem(actions["flip-vertical"])
            ),
            twoSelected && menuGroup(
              "order",
              menuItem(actions["pack"], { disabled: !twoSelected }),
              threeStackableItems && menuItem(actions["stack-vertical"]),
              threeStackableItems && menuItem(actions["stack-horizontal"])
            )
          ),
          oneSelected && menuSubmenu(
            "reorder",
            "context-menu.reorder",
            menuGroup(
              "reorder",
              menuItem(actions["bring-to-front"]),
              menuItem(actions["bring-forward"]),
              menuItem(actions["send-backward"]),
              menuItem(actions["send-to-back"])
            )
          ),
          oneSelected && menuCustom("MOVE_TO_PAGE_MENU", { readonlyOk: false })
        ),
        menuGroup(
          "clipboard-group",
          oneSelected && menuItem(actions["cut"]),
          oneSelected && menuItem(actions["copy"]),
          showMenuPaste && menuCustom("MENU_PASTE", { readonlyOk: false })
        ),
        atLeastOneShapeOnPage && menuGroup(
          "conversions",
          menuSubmenu(
            "copy-as",
            "context-menu.copy-as",
            menuGroup(
              "copy-as-group",
              menuItem(actions["copy-as-svg"]),
              hasClipboardWrite && menuItem(actions["copy-as-png"]),
              menuItem(actions["copy-as-json"])
            ),
            menuGroup(
              "export-bg",
              menuItem(actions["toggle-transparent"], { checked: !isTransparentBg })
            )
          ),
          menuSubmenu(
            "export-as",
            "context-menu.export-as",
            menuGroup(
              "export-as-group",
              menuItem(actions["export-as-svg"]),
              menuItem(actions["export-as-png"]),
              menuItem(actions["export-as-json"])
            ),
            menuGroup(
              "export-bg,",
              menuItem(actions["toggle-transparent"], { checked: !isTransparentBg })
            )
          )
        ),
        atLeastOneShapeOnPage && menuGroup(
          "set-selection-group",
          menuItem(actions["select-all"]),
          oneSelected && menuItem(actions["select-none"])
        ),
        oneSelected && menuGroup("delete-group", menuItem(actions["delete"]))
      ]);
      if (overrides) {
        contextMenuSchema2 = overrides(app, contextMenuSchema2, {
          actions,
          oneSelected,
          twoSelected,
          threeSelected,
          showAutoSizeToggle,
          showUngroup: allowUngroup,
          onlyFlippableShapeSelected
        });
      }
      return contextMenuSchema2;
    }, [
      app,
      overrides,
      actions,
      oneSelected,
      twoSelected,
      threeSelected,
      showAutoSizeToggle,
      onlyFlippableShapeSelected,
      atLeastOneShapeOnPage,
      threeStackableItems,
      allowGroup,
      allowUngroup,
      hasClipboardWrite,
      showEditLink,
      oneEmbedSelected,
      oneEmbeddableBookmarkSelected,
      isTransparentBg
    ]);
    return /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(ContextMenuSchemaContext.Provider, { value: contextMenuSchema, children });
  });
  function useContextMenuSchema() {
    const ctx = import_react82.default.useContext(ContextMenuSchemaContext);
    if (!ctx) {
      throw new Error("useContextMenuSchema must be used inside of a ContextMenuSchemaProvider.");
    }
    return ctx;
  }

  // ../../../packages/ui/src/lib/hooks/useHelpMenuSchema.tsx
  var import_react84 = __toESM(require_react());

  // ../../../packages/ui/src/lib/hooks/useKeyboardShortcutsSchema.tsx
  var import_react83 = __toESM(require_react());

  // ../../../packages/ui/src/lib/hooks/useTools.tsx
  var React50 = __toESM(require_react());
  var import_jsx_runtime73 = __toESM(require_jsx_runtime());
  var ToolsContext = React50.createContext({});
  function ToolsProvider({ overrides, children }) {
    const app = useApp();
    const trackEvent = useEvents();
    const { addDialog } = useDialogs();
    const insertMedia = useInsertMedia();
    const tools = React50.useMemo(() => {
      const tools2 = makeTools([
        {
          id: "select",
          label: "tool.select",
          icon: "tool-pointer",
          kbd: "v",
          readonlyOk: true,
          onSelect(source) {
            app.setSelectedTool("select");
            trackEvent("select-tool", { source, id: "select" });
          }
        },
        {
          id: "hand",
          label: "tool.hand",
          icon: "tool-hand",
          kbd: "h",
          readonlyOk: true,
          onSelect(source) {
            app.setSelectedTool("hand");
            trackEvent("select-tool", { source, id: "hand" });
          }
        },
        {
          id: "eraser",
          label: "tool.eraser",
          icon: "tool-eraser",
          kbd: "e",
          readonlyOk: false,
          onSelect(source) {
            app.setSelectedTool("eraser");
            trackEvent("select-tool", { source, id: "eraser" });
          }
        },
        {
          id: "draw",
          label: "tool.draw",
          readonlyOk: false,
          icon: "tool-pencil",
          kbd: "d,b,x",
          onSelect(source) {
            app.setSelectedTool("draw");
            trackEvent("select-tool", { source, id: "draw" });
          }
        },
        ...[...TL_GEO_TYPES].map((id) => ({
          id,
          label: `tool.${id}`,
          readonlyOk: false,
          meta: {
            geo: id
          },
          kbd: id === "rectangle" ? "r" : id === "ellipse" ? "o" : void 0,
          icon: "geo-" + id,
          onSelect(source) {
            app.batch(() => {
              app.updateInstanceState(
                { propsForNextShape: __spreadProps(__spreadValues({}, app.instanceState.propsForNextShape), { geo: id }) },
                true
              );
              app.setSelectedTool("geo");
              trackEvent("select-tool", { source, id: `geo-${id}` });
            });
          }
        })),
        {
          id: "arrow",
          label: "tool.arrow",
          readonlyOk: false,
          icon: "tool-arrow",
          kbd: "a",
          onSelect(source) {
            app.setSelectedTool("arrow");
            trackEvent("select-tool", { source, id: "arrow" });
          }
        },
        {
          id: "line",
          label: "tool.line",
          readonlyOk: false,
          icon: "tool-line",
          kbd: "l",
          onSelect(source) {
            app.setSelectedTool("line");
            trackEvent("select-tool", { source, id: "line" });
          }
        },
        {
          id: "frame",
          label: "tool.frame",
          readonlyOk: false,
          icon: "tool-frame",
          kbd: "f",
          onSelect(source) {
            app.setSelectedTool("frame");
            trackEvent("select-tool", { source, id: "frame" });
          }
        },
        {
          id: "text",
          label: "tool.text",
          readonlyOk: false,
          icon: "tool-text",
          kbd: "t",
          onSelect(source) {
            app.setSelectedTool("text");
            trackEvent("select-tool", { source, id: "text" });
          }
        },
        {
          id: "asset",
          label: "tool.asset",
          readonlyOk: false,
          icon: "tool-media",
          kbd: "$u",
          onSelect(source) {
            insertMedia();
            trackEvent("select-tool", { source, id: "media" });
          }
        },
        {
          id: "note",
          label: "tool.note",
          readonlyOk: false,
          icon: "tool-note",
          kbd: "n",
          onSelect(source) {
            app.setSelectedTool("note");
            trackEvent("select-tool", { source, id: "note" });
          }
        },
        {
          id: "embed",
          label: "tool.embed",
          readonlyOk: false,
          icon: "tool-embed",
          onSelect(source) {
            addDialog({ component: EmbedDialog });
            trackEvent("select-tool", { source, id: "embed" });
          }
        }
      ]);
      if (overrides) {
        return overrides(app, tools2, { insertMedia });
      }
      return tools2;
    }, [app, trackEvent, overrides, insertMedia, addDialog]);
    return /* @__PURE__ */ (0, import_jsx_runtime73.jsx)(ToolsContext.Provider, { value: tools, children });
  }
  function makeTools(tools) {
    return Object.fromEntries(tools.map((t4) => [t4.id, t4]));
  }
  function useTools() {
    const ctx = React50.useContext(ToolsContext);
    if (!ctx) {
      throw new Error("useTools must be used within a ToolProvider");
    }
    return ctx;
  }

  // ../../../packages/ui/src/lib/hooks/useKeyboardShortcutsSchema.tsx
  var import_jsx_runtime74 = __toESM(require_jsx_runtime());
  var KeyboardShortcutsSchemaContext = import_react83.default.createContext(
    {}
  );
  var KeyboardShortcutsSchemaProvider = track(function KeyboardShortcutsSchemaProvider2({
    overrides,
    children
  }) {
    const app = useApp();
    const tools = useTools();
    const actions = useActions();
    const keyboardShortcutsSchema = (0, import_react83.useMemo)(() => {
      const keyboardShortcutsSchema2 = compact([
        menuGroup(
          "shortcuts-dialog.tools",
          menuItem(actions["toggle-tool-lock"]),
          menuItem(tools["select"]),
          menuItem(tools["draw"]),
          menuItem(tools["eraser"]),
          menuItem(tools["hand"]),
          menuItem(tools["rectangle"]),
          menuItem(tools["ellipse"]),
          menuItem(tools["arrow"]),
          menuItem(tools["line"]),
          menuItem(tools["text"]),
          menuItem(tools["frame"]),
          menuItem(tools["note"])
        ),
        menuGroup(
          "shortcuts-dialog.file",
          menuItem(actions["insert-media"]),
          menuItem(actions["print"])
        ),
        menuGroup(
          "shortcuts-dialog.preferences",
          menuItem(actions["toggle-dark-mode"]),
          menuItem(actions["toggle-focus-mode"]),
          menuItem(actions["toggle-grid"])
        ),
        menuGroup(
          "shortcuts-dialog.edit",
          menuItem(actions["undo"]),
          menuItem(actions["redo"]),
          menuItem(actions["cut"]),
          menuItem(actions["copy"]),
          menuItem(actions["paste"]),
          menuItem(actions["select-all"]),
          menuItem(actions["delete"]),
          menuItem(actions["duplicate"]),
          menuItem(actions["export-as-svg"]),
          menuItem(actions["export-as-png"])
        ),
        menuGroup(
          "shortcuts-dialog.view",
          menuItem(actions["zoom-in"]),
          menuItem(actions["zoom-out"]),
          menuItem(actions["zoom-to-100"]),
          menuItem(actions["zoom-to-fit"]),
          menuItem(actions["zoom-to-selection"])
        ),
        menuGroup(
          "shortcuts-dialog.transform",
          menuItem(actions["bring-to-front"]),
          menuItem(actions["bring-forward"]),
          menuItem(actions["send-backward"]),
          menuItem(actions["send-to-back"]),
          menuItem(actions["group"]),
          menuItem(actions["ungroup"]),
          menuItem(actions["flip-horizontal"]),
          menuItem(actions["flip-vertical"]),
          menuItem(actions["align-top"]),
          menuItem(actions["align-center-vertical"]),
          menuItem(actions["align-bottom"]),
          menuItem(actions["align-left"]),
          menuItem(actions["align-center-horizontal"]),
          menuItem(actions["align-right"])
        )
      ]);
      if (overrides) {
        return overrides(app, keyboardShortcutsSchema2, { tools, actions });
      }
      return keyboardShortcutsSchema2;
    }, [app, overrides, actions, tools]);
    return /* @__PURE__ */ (0, import_jsx_runtime74.jsx)(KeyboardShortcutsSchemaContext.Provider, { value: keyboardShortcutsSchema, children });
  });
  function useKeyboardShortcutsSchema() {
    const ctx = import_react83.default.useContext(KeyboardShortcutsSchemaContext);
    if (!ctx) {
      throw new Error("Shortcuts must be used inside of a ShortcutsProvider.");
    }
    return ctx;
  }

  // ../../../packages/ui/src/lib/hooks/useReadonly.ts
  function useReadonly() {
    const app = useApp();
    return useValue("isReadOnlyMode", () => app.isReadOnly, [app]);
  }

  // ../../../packages/ui/src/lib/components/KeyboardShortcutsDialog.tsx
  var import_jsx_runtime75 = __toESM(require_jsx_runtime());
  var KeyboardShortcutsDialog = () => {
    const msg2 = useTranslation();
    const isReadonly = useReadonly();
    const shortcutsItems = useKeyboardShortcutsSchema();
    function getKeyboardShortcutItem(item) {
      if (isReadonly && !item.readonlyOk)
        return null;
      switch (item.type) {
        case "group": {
          return /* @__PURE__ */ (0, import_jsx_runtime75.jsxs)("div", { className: "tlui-shortcuts-dialog__group", children: [
            /* @__PURE__ */ (0, import_jsx_runtime75.jsx)("h2", { className: "tlui-shortcuts-dialog__group__title", children: msg2(item.id) }),
            /* @__PURE__ */ (0, import_jsx_runtime75.jsx)("div", { className: "tlui-shortcuts-dialog__group__content", children: item.children.filter((item2) => item2.type === "item" && item2.actionItem.kbd).map(getKeyboardShortcutItem) })
          ] }, item.id);
        }
        case "item": {
          const { id, label, shortcutsLabel, kbd: kbd2 } = item.actionItem;
          return /* @__PURE__ */ (0, import_jsx_runtime75.jsxs)("div", { className: "tlui-shortcuts-dialog__key-pair", children: [
            /* @__PURE__ */ (0, import_jsx_runtime75.jsx)("div", { className: "tlui-shortcuts-dialog__key-pair__key", children: msg2(shortcutsLabel != null ? shortcutsLabel : label) }),
            /* @__PURE__ */ (0, import_jsx_runtime75.jsx)("div", { className: "tlui-shortcuts-dialog__key-pair__value", children: /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(Kbd, { children: kbd2 }) })
          ] }, id);
        }
      }
    }
    return /* @__PURE__ */ (0, import_jsx_runtime75.jsxs)(import_jsx_runtime75.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime75.jsxs)(Header, { className: "tlui-shortcuts-dialog__header", children: [
        /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(Title, { children: msg2("shortcuts-dialog.title") }),
        /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(CloseButton, {})
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(Body, { className: "tlui-shortcuts-dialog__body", children: shortcutsItems.map(getKeyboardShortcutItem) }),
      /* @__PURE__ */ (0, import_jsx_runtime75.jsx)("div", { className: "tlui-dialog__scrim" })
    ] });
  };

  // ../../../packages/ui/src/lib/hooks/useTranslation/useLanguages.tsx
  function useLanguages() {
    const app = useApp();
    return { languages: LANGUAGES2, currentLanguage: app.user.locale };
  }

  // ../../../packages/ui/src/lib/hooks/useHelpMenuSchema.tsx
  var import_jsx_runtime76 = __toESM(require_jsx_runtime());
  var HelpMenuSchemaContext = import_react84.default.createContext({});
  var HelpMenuSchemaProvider = track(function HelpMenuSchemaProvider2({
    overrides,
    children
  }) {
    const app = useApp();
    const actions = useActions();
    const selectedCount = app.selectedIds.length;
    const oneSelected = selectedCount > 0;
    const twoSelected = selectedCount > 1;
    const threeSelected = selectedCount > 2;
    const { languages, currentLanguage } = useLanguages();
    const { addDialog } = useDialogs();
    const helpMenuSchema = (0, import_react84.useMemo)(() => {
      const helpMenuSchema2 = compact([
        menuGroup(
          "top",
          menuCustom("LANGUAGE_MENU", { readonlyOk: true }),
          menuItem({
            id: "keyboard-shortcuts",
            label: "help-menu.keyboard-shortcuts",
            readonlyOk: true,
            onSelect() {
              addDialog({ component: KeyboardShortcutsDialog });
            }
          })
        )
      ]);
      if (overrides) {
        return overrides(app, helpMenuSchema2, {
          actions,
          currentLanguage,
          languages,
          oneSelected,
          twoSelected,
          threeSelected
        });
      }
      return helpMenuSchema2;
    }, [
      app,
      overrides,
      languages,
      actions,
      oneSelected,
      twoSelected,
      threeSelected,
      currentLanguage,
      addDialog
    ]);
    return /* @__PURE__ */ (0, import_jsx_runtime76.jsx)(HelpMenuSchemaContext.Provider, { value: helpMenuSchema, children });
  });
  function useHelpMenuSchema() {
    const ctx = import_react84.default.useContext(HelpMenuSchemaContext);
    if (!ctx) {
      throw new Error("useHelpMenuSchema must be used inside of a helpMenuSchemaProvider.");
    }
    return ctx;
  }

  // ../../../packages/ui/src/lib/hooks/useMenuSchema.tsx
  var import_react85 = __toESM(require_react());

  // ../../../packages/ui/src/lib/hooks/useCanRedo.ts
  function useCanRedo() {
    const app = useApp();
    return useValue("useCanRedo", () => app.canRedo, [app]);
  }

  // ../../../packages/ui/src/lib/hooks/useCanUndo.ts
  function useCanUndo() {
    const app = useApp();
    return useValue("useCanUndo", () => app.canUndo, [app]);
  }

  // ../../../packages/ui/src/lib/hooks/useMenuSchema.tsx
  var import_jsx_runtime77 = __toESM(require_jsx_runtime());
  var MenuSchemaContext = import_react85.default.createContext({});
  function MenuSchemaProvider({ overrides, children }) {
    var _a5;
    const app = useApp();
    const actions = useActions();
    const breakpoint = useBreakpoint();
    const isMobile = breakpoint < 5;
    const isDarkMode = useValue("isDarkMode", () => app.userDocumentSettings.isDarkMode, [app]);
    const isGridMode = useValue("isGridMode", () => app.userDocumentSettings.isGridMode, [app]);
    const isSnapMode = useValue("isSnapMode", () => app.userDocumentSettings.isSnapMode, [app]);
    const isToolLock = useValue("isToolLock", () => app.instanceState.isToolLocked, [app]);
    const isFocusMode = useValue("isFocusMode", () => app.instanceState.isFocusMode, [app]);
    const isDebugMode = useValue("isDebugMode", () => app.instanceState.isDebugMode, [app]);
    const exportBackground = useValue("exportBackground", () => app.instanceState.exportBackground, [
      app
    ]);
    const emptyPage = useValue("emptyPage", () => app.shapeIds.size === 0, [app]);
    const selectedCount = useValue("selectedCount", () => app.selectedIds.length, [app]);
    const noneSelected = selectedCount === 0;
    const oneSelected = selectedCount > 0;
    const twoSelected = selectedCount > 1;
    const threeSelected = selectedCount > 2;
    const hasClipboardWrite = Boolean((_a5 = window.navigator.clipboard) == null ? void 0 : _a5.write);
    const showEditLink = useHasLinkShapeSelected();
    const showAutoSizeToggle = useShowAutoSizeToggle();
    const allowGroup = useAllowGroup();
    const allowUngroup = useAllowUngroup();
    const canUndo = useCanUndo();
    const canRedo = useCanRedo();
    const isZoomedTo100 = useValue("isZoomedTo100", () => app.zoomLevel === 1, [app]);
    const menuSchema = (0, import_react85.useMemo)(() => {
      const menuSchema2 = compact([
        menuGroup(
          "menu",
          menuSubmenu(
            "file",
            "menu.file",
            menuGroup("print", menuItem(actions["print"], { disabled: emptyPage }))
          ),
          menuSubmenu(
            "edit",
            "menu.edit",
            menuGroup(
              "undo-actions",
              menuItem(actions["undo"], { disabled: !canUndo }),
              menuItem(actions["redo"], { disabled: !canRedo })
            ),
            menuGroup(
              "clipboard-actions",
              menuItem(actions["cut"], { disabled: noneSelected }),
              menuItem(actions["copy"], { disabled: noneSelected }),
              {
                id: "MENU_PASTE",
                type: "custom",
                disabled: !showMenuPaste,
                readonlyOk: false
              }
            ),
            menuGroup(
              "conversions",
              menuSubmenu(
                "copy-as",
                "menu.copy-as",
                menuGroup(
                  "copy-as-group",
                  menuItem(actions["copy-as-svg"], { disabled: emptyPage }),
                  menuItem(actions["copy-as-png"], { disabled: emptyPage || !hasClipboardWrite }),
                  menuItem(actions["copy-as-json"], { disabled: emptyPage })
                ),
                menuGroup(
                  "export-bg",
                  menuItem(actions["toggle-transparent"], { checked: !exportBackground })
                )
              ),
              menuSubmenu(
                "export-as",
                "menu.export-as",
                menuGroup(
                  "export-as-group",
                  menuItem(actions["export-as-svg"], { disabled: emptyPage }),
                  menuItem(actions["export-as-png"], { disabled: emptyPage }),
                  menuItem(actions["export-as-json"], { disabled: emptyPage })
                ),
                menuGroup(
                  "export-bg",
                  menuItem(actions["toggle-transparent"], { checked: !exportBackground })
                )
              )
            ),
            menuGroup(
              "set-selection-group",
              menuItem(actions["select-all"], { disabled: emptyPage }),
              menuItem(actions["select-none"], { disabled: !oneSelected })
            ),
            menuGroup(
              "selection",
              showAutoSizeToggle && menuItem(actions["toggle-auto-size"]),
              showEditLink && menuItem(actions["edit-link"]),
              menuItem(actions["duplicate"], { disabled: !oneSelected }),
              allowGroup && menuItem(actions["group"]),
              allowUngroup && menuItem(actions["ungroup"])
            ),
            menuGroup("delete-group", menuItem(actions["delete"], { disabled: !oneSelected }))
          ),
          menuSubmenu(
            "view",
            "menu.view",
            menuGroup(
              "view-actions",
              menuItem(actions["zoom-in"]),
              menuItem(actions["zoom-out"]),
              menuItem(actions["zoom-to-100"], { disabled: isZoomedTo100 }),
              menuItem(actions["zoom-to-fit"], { disabled: emptyPage }),
              menuItem(actions["zoom-to-selection"], { disabled: emptyPage || !oneSelected })
            )
          )
        ),
        menuGroup("extras", menuItem(actions["insert-embed"]), menuItem(actions["insert-media"])),
        menuGroup(
          "preferences",
          menuSubmenu(
            "preferences",
            "menu.preferences",
            menuGroup(
              "preferences-actions",
              menuItem(actions["toggle-snap-mode"], { checked: isSnapMode }),
              menuItem(actions["toggle-tool-lock"], { checked: isToolLock }),
              menuItem(actions["toggle-grid"], { checked: isGridMode }),
              menuItem(actions["toggle-dark-mode"], { checked: isDarkMode }),
              menuItem(actions["toggle-focus-mode"], { checked: isFocusMode }),
              menuItem(actions["toggle-debug-mode"], { checked: isDebugMode })
            )
          ),
          isMobile && menuCustom("LANGUAGE_MENU", { readonlyOk: true })
        )
      ]);
      if (overrides) {
        return overrides(app, menuSchema2, {
          actions,
          noneSelected,
          oneSelected,
          twoSelected,
          threeSelected
        });
      }
      return menuSchema2;
    }, [
      app,
      overrides,
      actions,
      oneSelected,
      twoSelected,
      threeSelected,
      emptyPage,
      isMobile,
      allowGroup,
      allowUngroup,
      showEditLink,
      hasClipboardWrite,
      showAutoSizeToggle,
      noneSelected,
      canUndo,
      canRedo,
      isDarkMode,
      isGridMode,
      isSnapMode,
      isToolLock,
      isFocusMode,
      exportBackground,
      isDebugMode,
      isZoomedTo100
    ]);
    return /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(MenuSchemaContext.Provider, { value: menuSchema, children });
  }
  function useMenuSchema() {
    const ctx = import_react85.default.useContext(MenuSchemaContext);
    if (!ctx) {
      throw new Error("useMenuSchema must be used inside of a MenuSchemaProvider.");
    }
    return ctx;
  }

  // ../../../packages/ui/src/lib/hooks/useToolbarSchema.tsx
  var import_react86 = __toESM(require_react());
  var import_jsx_runtime78 = __toESM(require_jsx_runtime());
  function toolbarItem(toolItem) {
    return {
      id: toolItem.id,
      type: "item",
      readonlyOk: toolItem.readonlyOk,
      toolItem
    };
  }
  var ToolbarSchemaContext = import_react86.default.createContext([]);
  function ToolbarSchemaProvider({ overrides, children }) {
    const app = useApp();
    const tools = useTools();
    const toolbarSchema = import_react86.default.useMemo(() => {
      const schema = [
        toolbarItem(tools.select),
        toolbarItem(tools.hand),
        toolbarItem(tools.draw),
        toolbarItem(tools.eraser),
        toolbarItem(tools.arrow),
        toolbarItem(tools.text),
        toolbarItem(tools.note),
        toolbarItem(tools.asset),
        toolbarItem(tools["rectangle"]),
        toolbarItem(tools["ellipse"]),
        toolbarItem(tools["diamond"]),
        toolbarItem(tools["triangle"]),
        toolbarItem(tools["trapezoid"]),
        toolbarItem(tools["rhombus"]),
        toolbarItem(tools["pentagon"]),
        toolbarItem(tools["hexagon"]),
        toolbarItem(tools["octagon"]),
        toolbarItem(tools["star"]),
        toolbarItem(tools["oval"]),
        toolbarItem(tools["x-box"]),
        toolbarItem(tools["arrow-right"]),
        toolbarItem(tools["arrow-left"]),
        toolbarItem(tools["arrow-up"]),
        toolbarItem(tools["arrow-down"]),
        toolbarItem(tools.line),
        toolbarItem(tools.frame),
        toolbarItem(tools.embed)
      ];
      if (overrides) {
        return overrides(app, schema, { tools });
      }
      return schema;
    }, [app, overrides, tools]);
    return /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(ToolbarSchemaContext.Provider, { value: toolbarSchema, children });
  }
  function useToolbarSchema() {
    const ctx = import_react86.default.useContext(ToolbarSchemaContext);
    if (!ctx) {
      throw new Error("useToolbarSchema must be used within a ToolbarSchemaProvider");
    }
    return ctx;
  }

  // ../../../packages/ui/src/lib/overrides.ts
  var import_react87 = __toESM(require_react());
  function useDefaultHelpers() {
    const { addToast, removeToast, clearToasts } = useToasts();
    const { addDialog, clearDialogs, removeDialog, updateDialog } = useDialogs();
    const breakpoint = useBreakpoint();
    const isMobile = breakpoint < 5;
    const msg2 = useTranslation();
    return (0, import_react87.useMemo)(
      () => ({
        addToast,
        removeToast,
        clearToasts,
        addDialog,
        clearDialogs,
        removeDialog,
        updateDialog,
        msg: msg2,
        isMobile
      }),
      [
        addDialog,
        addToast,
        clearDialogs,
        clearToasts,
        msg2,
        removeDialog,
        removeToast,
        updateDialog,
        isMobile
      ]
    );
  }
  function mergeOverrides(overrides, defaultHelpers) {
    const mergedTranslations = {};
    for (const override of overrides) {
      if (override.translations) {
        for (const [key, value] of objectMapEntries(override.translations)) {
          let strings = mergedTranslations[key];
          if (!strings) {
            strings = mergedTranslations[key] = {};
          }
          Object.assign(strings, value);
        }
      }
    }
    return {
      actionsMenu: (app, schema, helpers) => {
        for (const override of overrides) {
          if (override.actionsMenu) {
            schema = override.actionsMenu(app, schema, __spreadValues(__spreadValues({}, defaultHelpers), helpers));
          }
        }
        return schema;
      },
      actions: (app, schema) => {
        for (const override of overrides) {
          if (override.actions) {
            schema = override.actions(app, schema, defaultHelpers);
          }
        }
        return schema;
      },
      contextMenu: (app, schema, helpers) => {
        for (const override of overrides) {
          if (override.contextMenu) {
            schema = override.contextMenu(app, schema, __spreadValues(__spreadValues({}, defaultHelpers), helpers));
          }
        }
        return schema;
      },
      helpMenu: (app, schema, helpers) => {
        for (const override of overrides) {
          if (override.helpMenu) {
            schema = override.helpMenu(app, schema, __spreadValues(__spreadValues({}, defaultHelpers), helpers));
          }
        }
        return schema;
      },
      menu: (app, schema, helpers) => {
        for (const override of overrides) {
          if (override.menu) {
            schema = override.menu(app, schema, __spreadValues(__spreadValues({}, defaultHelpers), helpers));
          }
        }
        return schema;
      },
      toolbar: (app, schema, helpers) => {
        for (const override of overrides) {
          if (override.toolbar) {
            schema = override.toolbar(app, schema, __spreadValues(__spreadValues({}, defaultHelpers), helpers));
          }
        }
        return schema;
      },
      keyboardShortcutsMenu: (app, schema, helpers) => {
        for (const override of overrides) {
          if (override.keyboardShortcutsMenu) {
            schema = override.keyboardShortcutsMenu(app, schema, __spreadValues(__spreadValues({}, defaultHelpers), helpers));
          }
        }
        return schema;
      },
      tools: (app, schema, helpers) => {
        for (const override of overrides) {
          if (override.tools) {
            schema = override.tools(app, schema, __spreadValues(__spreadValues({}, defaultHelpers), helpers));
          }
        }
        return schema;
      },
      translations: mergedTranslations
    };
  }
  function useShallowArrayEquality(array2) {
    return (0, import_react87.useMemo)(() => array2, array2);
  }
  function useMergedTranslationOverrides(overrides) {
    const overridesArray = useShallowArrayEquality(
      overrides == null ? [] : Array.isArray(overrides) ? overrides : [overrides]
    );
    return (0, import_react87.useMemo)(() => {
      const mergedTranslations = {};
      for (const override of overridesArray) {
        if (override.translations) {
          for (const [key, value] of objectMapEntries(override.translations)) {
            let strings = mergedTranslations[key];
            if (!strings) {
              strings = mergedTranslations[key] = {};
            }
            Object.assign(strings, value);
          }
        }
      }
      return mergedTranslations;
    }, [overridesArray]);
  }
  function useMergedOverrides(overrides) {
    const defaultHelpers = useDefaultHelpers();
    const overridesArray = useShallowArrayEquality(
      overrides == null ? [] : Array.isArray(overrides) ? overrides : [overrides]
    );
    return (0, import_react87.useMemo)(
      () => mergeOverrides(overridesArray, defaultHelpers),
      [overridesArray, defaultHelpers]
    );
  }

  // ../../../packages/ui/src/lib/TldrawUiContextProvider.tsx
  var import_jsx_runtime79 = __toESM(require_jsx_runtime());
  function TldrawUiContextProvider({
    overrides,
    assetUrls,
    onUiEvent,
    children
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(AssetUrlsProvider, { assetUrls: assetUrls != null ? assetUrls : defaultUiAssetUrls, children: /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(TranslationProvider, { overrides: useMergedTranslationOverrides(overrides), children: /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(EventsProvider, { onEvent: onUiEvent, children: /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(ToastsProvider, { children: /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(DialogsProvider, { children: /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(BreakPointProvider, { children: /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(InternalProviders, { overrides, children }) }) }) }) }) }) });
  }
  function InternalProviders({
    overrides,
    children
  }) {
    const mergedOverrides = useMergedOverrides(overrides);
    return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(ActionsProvider, { overrides: mergedOverrides.actions, children: /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(ToolsProvider, { overrides: mergedOverrides.tools, children: /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(ToolbarSchemaProvider, { overrides: mergedOverrides.toolbar, children: /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(ActionsMenuSchemaProvider, { overrides: mergedOverrides.actionsMenu, children: /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(KeyboardShortcutsSchemaProvider, { overrides: mergedOverrides.keyboardShortcutsMenu, children: /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(ContextMenuSchemaProvider, { overrides: mergedOverrides.contextMenu, children: /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(HelpMenuSchemaProvider, { overrides: mergedOverrides.helpMenu, children: /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(MenuSchemaProvider, { overrides: mergedOverrides.menu, children }) }) }) }) }) }) }) });
  }

  // ../../../packages/ui/src/lib/components/BackToContent.tsx
  var import_react88 = __toESM(require_react());
  var import_jsx_runtime80 = __toESM(require_jsx_runtime());
  function BackToContent() {
    const app = useApp();
    const actions = useActions();
    const action = actions["back-to-content"];
    const [showBackToContent, setShowBackToContent] = (0, import_react88.useState)(false);
    (0, import_react88.useEffect)(() => {
      let showBackToContentPrev = false;
      const interval = setInterval(() => {
        const { renderingShapes } = app;
        const visibleShapes = renderingShapes.filter((s3) => s3.isInViewport);
        const showBackToContentNow = visibleShapes.length === 0 && app.shapesArray.length > 0;
        if (showBackToContentPrev !== showBackToContentNow) {
          setShowBackToContent(showBackToContentNow);
          showBackToContentPrev = showBackToContentNow;
        }
      }, 1e3);
      return () => {
        clearInterval(interval);
      };
    }, [app]);
    if (!showBackToContent)
      return null;
    return /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(
      Button,
      {
        iconLeft: action.icon,
        label: action.label,
        onClick: () => {
          action.onSelect("helper-buttons");
          setShowBackToContent(false);
        }
      }
    );
  }

  // ../../../packages/ui/src/lib/components/DebugPanel.tsx
  var React55 = __toESM(require_react());
  var import_jsx_runtime81 = __toESM(require_jsx_runtime());
  var t3 = 0;
  function createNShapes(app, n3) {
    const shapesToCreate = Array(n3);
    const cols = Math.floor(Math.sqrt(n3));
    for (let i3 = 0; i3 < n3; i3++) {
      t3++;
      shapesToCreate[i3] = {
        id: app.createShapeId("box" + t3),
        type: "geo",
        x: i3 % cols * 132,
        y: Math.floor(i3 / cols) * 132
      };
    }
    app.batch(() => {
      app.createShapes(shapesToCreate).setSelectedIds(shapesToCreate.map((s3) => s3.id));
    });
  }
  var DebugPanel = React55.memo(function DebugPanel2({
    renderDebugMenuItems
  }) {
    const msg2 = useTranslation();
    return /* @__PURE__ */ (0, import_jsx_runtime81.jsxs)("div", { className: "tlui-debug-panel", children: [
      /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(CurrentState, {}),
      /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(ShapeCount, {}),
      /* @__PURE__ */ (0, import_jsx_runtime81.jsxs)(Root, { id: "debug", children: [
        /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(Trigger, { children: /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(Button, { icon: "dots-horizontal", title: msg2("debug-panel.more") }) }),
        /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(Content, { side: "top", align: "end", alignOffset: 0, children: /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(DebugMenuContent, { renderDebugMenuItems }) })
      ] })
    ] });
  });
  var CurrentState = track(function CurrentState2() {
    const app = useApp();
    return /* @__PURE__ */ (0, import_jsx_runtime81.jsx)("div", { className: "tlui-debug-panel__current-state", children: app.root.path.value });
  });
  var ShapeCount = function ShapeCount2() {
    const app = useApp();
    const count = useValue("rendering shapes count", () => app.renderingShapes.length, [app]);
    return /* @__PURE__ */ (0, import_jsx_runtime81.jsxs)("div", { children: [
      count,
      " Shapes"
    ] });
  };
  function DebugMenuContent({
    renderDebugMenuItems
  }) {
    const app = useApp();
    const { addToast } = useToasts();
    const { addDialog } = useDialogs();
    const [error, setError] = React55.useState(false);
    return /* @__PURE__ */ (0, import_jsx_runtime81.jsxs)(import_jsx_runtime81.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime81.jsxs)(Group, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(
          Item,
          {
            onClick: () => {
              addToast({
                id: uniqueId(),
                title: "Something happened",
                description: "Hey, attend to this thing over here. It might be important!"
                // icon?: string
                // title?: string
                // description?: string
                // actions?: TLToastAction[]
              });
            },
            children: /* @__PURE__ */ (0, import_jsx_runtime81.jsx)("span", { children: "Show toast" })
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(
          Item,
          {
            onClick: () => {
              addDialog({
                component: ({ onClose }) => /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(
                  ExampleDialog,
                  {
                    displayDontShowAgain: true,
                    onCancel: () => {
                      onClose();
                    },
                    onContinue: () => {
                      onClose();
                    }
                  }
                ),
                onClose: () => {
                }
              });
            },
            children: /* @__PURE__ */ (0, import_jsx_runtime81.jsx)("span", { children: "Show dialog" })
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(Item, { onClick: () => createNShapes(app, 100), children: /* @__PURE__ */ (0, import_jsx_runtime81.jsx)("span", { children: "Create 100 shapes" }) }),
        /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(
          Item,
          {
            onClick: () => {
              function countDescendants({ children }) {
                let count = 0;
                if (!children.length)
                  return 0;
                for (const el of [...children]) {
                  count++;
                  count += countDescendants(el);
                }
                return count;
              }
              const { selectedShapes } = app;
              const shapes = selectedShapes.length === 0 ? app.renderingShapes : selectedShapes;
              const elms = shapes.map(
                (shape) => document.getElementById(shape.id).parentElement
              );
              let descendants = elms.length;
              for (const elm of elms) {
                descendants += countDescendants(elm);
              }
              window.alert(`Shapes ${shapes.length}, DOM nodes:${descendants}`);
            },
            children: /* @__PURE__ */ (0, import_jsx_runtime81.jsx)("span", { children: "Count shapes and nodes" })
          }
        ),
        (() => {
          if (error)
            throw Error("oh no!");
        })(),
        /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(
          Item,
          {
            onClick: () => {
              setError(true);
            },
            children: /* @__PURE__ */ (0, import_jsx_runtime81.jsx)("span", { children: "Throw error" })
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(
          Item,
          {
            onClick: () => {
              hardResetApp();
            },
            children: /* @__PURE__ */ (0, import_jsx_runtime81.jsx)("span", { children: "Hard reset" })
          }
        )
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime81.jsxs)(Group, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(
          Item,
          {
            onClick: () => {
              debugFlags.peopleMenu.set(!debugFlags.peopleMenu.value);
              window.location.reload();
            },
            children: /* @__PURE__ */ (0, import_jsx_runtime81.jsx)("span", { children: "Toggle people menu" })
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(
          Item,
          {
            onClick: () => {
              app.setReadOnly(!app.isReadOnly);
            },
            children: /* @__PURE__ */ (0, import_jsx_runtime81.jsx)("span", { children: "Toggle read-only" })
          }
        )
      ] }),
      renderDebugMenuItems == null ? void 0 : renderDebugMenuItems()
    ] });
  }
  function ExampleDialog({
    title = "title",
    body = "hello hello hello",
    cancel = "Cancel",
    confirm = "Continue",
    displayDontShowAgain = false,
    onCancel,
    onContinue
  }) {
    const [dontShowAgain, setDontShowAgain] = React55.useState(false);
    return /* @__PURE__ */ (0, import_jsx_runtime81.jsxs)(import_jsx_runtime81.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime81.jsxs)(Header, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(Title, { children: title }),
        /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(CloseButton, {})
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(Body, { style: { maxWidth: 350 }, children: body }),
      /* @__PURE__ */ (0, import_jsx_runtime81.jsxs)(Footer, { className: "tlui-dialog__footer__actions", children: [
        displayDontShowAgain && /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(
          Button,
          {
            onClick: () => setDontShowAgain(!dontShowAgain),
            iconLeft: dontShowAgain ? "checkbox-checked" : "checkbox-empty",
            style: { marginRight: "auto" },
            children: `Don't show again`
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(Button, { onClick: onCancel, children: cancel }),
        /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(Button, { type: "primary", onClick: () => __async(this, null, function* () {
          return onContinue();
        }), children: confirm })
      ] })
    ] });
  }

  // ../../../packages/ui/src/lib/components/Dialogs.tsx
  var import_react89 = __toESM(require_react());
  var import_jsx_runtime82 = __toESM(require_jsx_runtime());
  var Dialog = ({ id, component: ModalContent, onClose }) => {
    const { removeDialog } = useDialogs();
    const container = useContainer();
    const handleOpenChange = (0, import_react89.useCallback)(
      (isOpen) => {
        if (!isOpen) {
          if (onClose) {
            try {
              onClose();
            } catch (err) {
              console.warn(err);
            }
          }
          removeDialog(id);
        }
      },
      [id, onClose, removeDialog]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime82.jsx)($5d3850c4d0b4e6c7$export$be92b6f5f03c0fe9, { onOpenChange: handleOpenChange, defaultOpen: true, children: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)($5d3850c4d0b4e6c7$export$602eac185826482c, { container, children: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)($5d3850c4d0b4e6c7$export$c6fdb837b070b4ff, { dir: "ltr", className: "tlui-dialog__overlay", children: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)($5d3850c4d0b4e6c7$export$7c6e2c02157bb7d2, { dir: "ltr", className: "tlui-dialog__content", children: /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(ModalContent, { onClose: () => handleOpenChange(false) }) }) }) }) });
  };
  function _Dialogs() {
    const { dialogs } = useDialogs();
    return /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(import_jsx_runtime82.Fragment, { children: dialogs.map((dialog) => /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(Dialog, __spreadValues({}, dialog), dialog.id)) });
  }
  var Dialogs = import_react89.default.memo(_Dialogs);

  // ../../../packages/ui/src/lib/components/HelpMenu.tsx
  var React57 = __toESM(require_react());

  // ../../../packages/ui/src/lib/components/LanguageMenu.tsx
  var import_react90 = __toESM(require_react());
  var import_jsx_runtime83 = __toESM(require_jsx_runtime());
  function LanguageMenu() {
    const app = useApp();
    const { languages, currentLanguage } = useLanguages();
    const handleLanguageSelect = (0, import_react90.useCallback)(
      (locale) => {
        app.updateUser({ locale });
      },
      [app]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime83.jsxs)(Sub, { id: "help menu language", children: [
      /* @__PURE__ */ (0, import_jsx_runtime83.jsx)(SubTrigger, { label: "menu.language", "data-direction": "left" }),
      /* @__PURE__ */ (0, import_jsx_runtime83.jsx)(SubContent, { sideOffset: -4, children: /* @__PURE__ */ (0, import_jsx_runtime83.jsx)(Group, { children: languages.map(({ locale, label }) => /* @__PURE__ */ (0, import_jsx_runtime83.jsx)(
        RadioItem,
        {
          title: locale,
          checked: locale === currentLanguage,
          onSelect: () => handleLanguageSelect(locale),
          children: /* @__PURE__ */ (0, import_jsx_runtime83.jsx)("span", { children: label })
        },
        locale
      )) }) })
    ] });
  }

  // ../../../packages/ui/src/lib/components/HelpMenu.tsx
  var import_jsx_runtime84 = __toESM(require_jsx_runtime());
  var HelpMenu = React57.memo(function HelpMenu2() {
    const container = useContainer();
    const msg2 = useTranslation();
    const [isOpen, onOpenChange] = useMenuIsOpen("help menu");
    return /* @__PURE__ */ (0, import_jsx_runtime84.jsx)("div", { className: "tlui-help-menu", children: /* @__PURE__ */ (0, import_jsx_runtime84.jsxs)($d08ef79370b62062$export$be92b6f5f03c0fe9, { dir: "ltr", open: isOpen, onOpenChange, modal: false, children: [
      /* @__PURE__ */ (0, import_jsx_runtime84.jsx)(
        $d08ef79370b62062$export$41fb9f06171c75f4,
        {
          className: "tlui-button tlui-help-menu__button",
          dir: "ltr",
          title: msg2("help-menu.title"),
          children: /* @__PURE__ */ (0, import_jsx_runtime84.jsx)(Icon, { icon: "question-mark" })
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime84.jsx)($d08ef79370b62062$export$602eac185826482c, { container, dir: "ltr", children: /* @__PURE__ */ (0, import_jsx_runtime84.jsx)(
        $d08ef79370b62062$export$7c6e2c02157bb7d2,
        {
          className: "tlui-menu",
          side: "top",
          sideOffset: 8,
          align: "end",
          alignOffset: 0,
          collisionPadding: 4,
          children: /* @__PURE__ */ (0, import_jsx_runtime84.jsx)(HelpMenuContent, {})
        }
      ) })
    ] }) });
  });
  function HelpMenuContent() {
    const menuSchema = useHelpMenuSchema();
    const isReadonly = useReadonly();
    function getHelpMenuItem(item) {
      if (isReadonly && !item.readonlyOk)
        return null;
      switch (item.type) {
        case "custom": {
          if (item.id === "LANGUAGE_MENU") {
            return /* @__PURE__ */ (0, import_jsx_runtime84.jsx)(LanguageMenu, {}, "item");
          }
          break;
        }
        case "group": {
          return /* @__PURE__ */ (0, import_jsx_runtime84.jsx)(Group, { size: "small", children: item.children.map(getHelpMenuItem) }, item.id);
        }
        case "submenu": {
          return /* @__PURE__ */ (0, import_jsx_runtime84.jsxs)(Sub, { id: `help menu ${item.id}`, children: [
            /* @__PURE__ */ (0, import_jsx_runtime84.jsx)(SubTrigger, { label: item.label }),
            /* @__PURE__ */ (0, import_jsx_runtime84.jsx)(SubContent, { children: item.children.map(getHelpMenuItem) })
          ] }, item.id);
        }
        case "item": {
          const { id, kbd: kbd2, label, onSelect, icon } = item.actionItem;
          return /* @__PURE__ */ (0, import_jsx_runtime84.jsx)(
            Item,
            {
              kbd: kbd2,
              label,
              onClick: () => onSelect("help-menu"),
              iconLeft: icon
            },
            id
          );
        }
      }
    }
    return /* @__PURE__ */ (0, import_jsx_runtime84.jsx)(import_jsx_runtime84.Fragment, { children: menuSchema.map(getHelpMenuItem) });
  }

  // ../../../node_modules/@radix-ui/react-popover/dist/index.module.js
  var import_react92 = __toESM(require_react());

  // ../../../node_modules/@radix-ui/react-popover/node_modules/@radix-ui/react-popper/dist/index.module.js
  var import_react91 = __toESM(require_react());
  var $cf1ac5d9fe0e8206$var$POPPER_NAME2 = "Popper";
  var [$cf1ac5d9fe0e8206$var$createPopperContext2, $cf1ac5d9fe0e8206$export$722aac194ae9232] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cf1ac5d9fe0e8206$var$POPPER_NAME2);
  var [$cf1ac5d9fe0e8206$var$PopperProvider2, $cf1ac5d9fe0e8206$var$usePopperContext2] = $cf1ac5d9fe0e8206$var$createPopperContext2($cf1ac5d9fe0e8206$var$POPPER_NAME2);
  var $cf1ac5d9fe0e8206$export$badac9ada3a0bdf92 = (props) => {
    const { __scopePopper, children } = props;
    const [anchor, setAnchor] = (0, import_react91.useState)(null);
    return /* @__PURE__ */ (0, import_react91.createElement)($cf1ac5d9fe0e8206$var$PopperProvider2, {
      scope: __scopePopper,
      anchor,
      onAnchorChange: setAnchor
    }, children);
  };
  var $cf1ac5d9fe0e8206$var$ANCHOR_NAME2 = "PopperAnchor";
  var $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d2 = /* @__PURE__ */ (0, import_react91.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopePopper, virtualRef } = _a5, anchorProps = __objRest(_a5, ["__scopePopper", "virtualRef"]);
    const context = $cf1ac5d9fe0e8206$var$usePopperContext2($cf1ac5d9fe0e8206$var$ANCHOR_NAME2, __scopePopper);
    const ref = (0, import_react91.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
    (0, import_react91.useEffect)(() => {
      context.onAnchorChange((virtualRef === null || virtualRef === void 0 ? void 0 : virtualRef.current) || ref.current);
    });
    return virtualRef ? null : /* @__PURE__ */ (0, import_react91.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, anchorProps, {
      ref: composedRefs
    }));
  });
  var $cf1ac5d9fe0e8206$var$CONTENT_NAME2 = "PopperContent";
  var [$cf1ac5d9fe0e8206$var$PopperContentProvider2, $cf1ac5d9fe0e8206$var$useContentContext2] = $cf1ac5d9fe0e8206$var$createPopperContext2($cf1ac5d9fe0e8206$var$CONTENT_NAME2);
  var [$cf1ac5d9fe0e8206$var$PositionContextProvider2, $cf1ac5d9fe0e8206$var$usePositionContext2] = $cf1ac5d9fe0e8206$var$createPopperContext2($cf1ac5d9fe0e8206$var$CONTENT_NAME2, {
    hasParent: false,
    positionUpdateFns: /* @__PURE__ */ new Set()
  });
  var $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc2 = /* @__PURE__ */ (0, import_react91.forwardRef)((props, forwardedRef) => {
    var _arrowSize$width, _arrowSize$height, _middlewareData$arrow, _middlewareData$arrow2, _middlewareData$arrow3, _middlewareData$hide, _middlewareData$trans, _middlewareData$trans2;
    const _a5 = props, { __scopePopper, side = "bottom", sideOffset = 0, align = "center", alignOffset = 0, arrowPadding = 0, collisionBoundary = [], collisionPadding: collisionPaddingProp = 0, sticky = "partial", hideWhenDetached = false, avoidCollisions = true, onPlaced } = _a5, contentProps = __objRest(_a5, ["__scopePopper", "side", "sideOffset", "align", "alignOffset", "arrowPadding", "collisionBoundary", "collisionPadding", "sticky", "hideWhenDetached", "avoidCollisions", "onPlaced"]);
    const context = $cf1ac5d9fe0e8206$var$usePopperContext2($cf1ac5d9fe0e8206$var$CONTENT_NAME2, __scopePopper);
    const [content, setContent] = (0, import_react91.useState)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
      forwardedRef,
      (node) => setContent(node)
    );
    const [arrow2, setArrow] = (0, import_react91.useState)(null);
    const arrowSize = $db6c3485150b8e66$export$1ab7ae714698c4b8(arrow2);
    const arrowWidth = (_arrowSize$width = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.width) !== null && _arrowSize$width !== void 0 ? _arrowSize$width : 0;
    const arrowHeight = (_arrowSize$height = arrowSize === null || arrowSize === void 0 ? void 0 : arrowSize.height) !== null && _arrowSize$height !== void 0 ? _arrowSize$height : 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : __spreadValues({
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }, collisionPaddingProp);
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [
      collisionBoundary
    ];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter($cf1ac5d9fe0e8206$var$isNotNull2),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { reference, floating, strategy, x: x3, y: y3, placement, middlewareData, update } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: N,
      middleware: [
        T({
          mainAxis: sideOffset + arrowHeight,
          alignmentAxis: alignOffset
        }),
        avoidCollisions ? D(__spreadValues({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? L() : void 0
        }, detectOverflowOptions)) : void 0,
        avoidCollisions ? b(__spreadValues({}, detectOverflowOptions)) : void 0,
        k(__spreadProps(__spreadValues({}, detectOverflowOptions), {
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        })),
        arrow2 ? arrow({
          element: arrow2,
          padding: arrowPadding
        }) : void 0,
        $cf1ac5d9fe0e8206$var$transformOrigin2({
          arrowWidth,
          arrowHeight
        }),
        hideWhenDetached ? P({
          strategy: "referenceHidden"
        }) : void 0
      ].filter($cf1ac5d9fe0e8206$var$isDefined2)
    });
    $9f79659886946c16$export$e5c5a5f917a5871c(() => {
      reference(context.anchor);
    }, [
      reference,
      context.anchor
    ]);
    const isPlaced = x3 !== null && y3 !== null;
    const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement2(placement);
    const handlePlaced = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onPlaced);
    $9f79659886946c16$export$e5c5a5f917a5871c(() => {
      if (isPlaced)
        handlePlaced === null || handlePlaced === void 0 || handlePlaced();
    }, [
      isPlaced,
      handlePlaced
    ]);
    const arrowX = (_middlewareData$arrow = middlewareData.arrow) === null || _middlewareData$arrow === void 0 ? void 0 : _middlewareData$arrow.x;
    const arrowY = (_middlewareData$arrow2 = middlewareData.arrow) === null || _middlewareData$arrow2 === void 0 ? void 0 : _middlewareData$arrow2.y;
    const cannotCenterArrow = ((_middlewareData$arrow3 = middlewareData.arrow) === null || _middlewareData$arrow3 === void 0 ? void 0 : _middlewareData$arrow3.centerOffset) !== 0;
    const [contentZIndex, setContentZIndex] = (0, import_react91.useState)();
    $9f79659886946c16$export$e5c5a5f917a5871c(() => {
      if (content)
        setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [
      content
    ]);
    const { hasParent, positionUpdateFns } = $cf1ac5d9fe0e8206$var$usePositionContext2($cf1ac5d9fe0e8206$var$CONTENT_NAME2, __scopePopper);
    const isRoot = !hasParent;
    (0, import_react91.useLayoutEffect)(() => {
      if (!isRoot) {
        positionUpdateFns.add(update);
        return () => {
          positionUpdateFns.delete(update);
        };
      }
    }, [
      isRoot,
      positionUpdateFns,
      update
    ]);
    $9f79659886946c16$export$e5c5a5f917a5871c(() => {
      if (isRoot && isPlaced)
        Array.from(positionUpdateFns).reverse().forEach(
          (fn) => requestAnimationFrame(fn)
        );
    }, [
      isRoot,
      isPlaced,
      positionUpdateFns
    ]);
    const commonProps = __spreadProps(__spreadValues({
      "data-side": placedSide,
      "data-align": placedAlign
    }, contentProps), {
      ref: composedRefs,
      style: __spreadProps(__spreadValues({}, contentProps.style), {
        // if the PopperContent hasn't been placed yet (not all measurements done)
        // we prevent animations so that users's animation don't kick in too early referring wrong sides
        animation: !isPlaced ? "none" : void 0,
        // hide the content if using the hide middleware and should be hidden
        opacity: (_middlewareData$hide = middlewareData.hide) !== null && _middlewareData$hide !== void 0 && _middlewareData$hide.referenceHidden ? 0 : void 0
      })
    });
    return /* @__PURE__ */ (0, import_react91.createElement)("div", {
      ref: floating,
      "data-radix-popper-content-wrapper": "",
      style: {
        position: strategy,
        left: 0,
        top: 0,
        transform: isPlaced ? `translate3d(${Math.round(x3)}px, ${Math.round(y3)}px, 0)` : "translate3d(0, -200%, 0)",
        // keep off the page when measuring
        minWidth: "max-content",
        zIndex: contentZIndex,
        ["--radix-popper-transform-origin"]: [
          (_middlewareData$trans = middlewareData.transformOrigin) === null || _middlewareData$trans === void 0 ? void 0 : _middlewareData$trans.x,
          (_middlewareData$trans2 = middlewareData.transformOrigin) === null || _middlewareData$trans2 === void 0 ? void 0 : _middlewareData$trans2.y
        ].join(" ")
      },
      dir: props.dir
    }, /* @__PURE__ */ (0, import_react91.createElement)($cf1ac5d9fe0e8206$var$PopperContentProvider2, {
      scope: __scopePopper,
      placedSide,
      onArrowChange: setArrow,
      arrowX,
      arrowY,
      shouldHideArrow: cannotCenterArrow
    }, isRoot ? /* @__PURE__ */ (0, import_react91.createElement)($cf1ac5d9fe0e8206$var$PositionContextProvider2, {
      scope: __scopePopper,
      hasParent: true,
      positionUpdateFns
    }, /* @__PURE__ */ (0, import_react91.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, commonProps)) : /* @__PURE__ */ (0, import_react91.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.div, commonProps)));
  });
  function $cf1ac5d9fe0e8206$var$isDefined2(value) {
    return value !== void 0;
  }
  function $cf1ac5d9fe0e8206$var$isNotNull2(value) {
    return value !== null;
  }
  var $cf1ac5d9fe0e8206$var$transformOrigin2 = (options) => ({
    name: "transformOrigin",
    options,
    fn(data) {
      var _middlewareData$arrow4, _middlewareData$arrow5, _middlewareData$arrow6, _middlewareData$arrow7, _middlewareData$arrow8;
      const { placement, rects, middlewareData } = data;
      const cannotCenterArrow = ((_middlewareData$arrow4 = middlewareData.arrow) === null || _middlewareData$arrow4 === void 0 ? void 0 : _middlewareData$arrow4.centerOffset) !== 0;
      const isArrowHidden = cannotCenterArrow;
      const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
      const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
      const [placedSide, placedAlign] = $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement2(placement);
      const noArrowAlign = {
        start: "0%",
        center: "50%",
        end: "100%"
      }[placedAlign];
      const arrowXCenter = ((_middlewareData$arrow5 = (_middlewareData$arrow6 = middlewareData.arrow) === null || _middlewareData$arrow6 === void 0 ? void 0 : _middlewareData$arrow6.x) !== null && _middlewareData$arrow5 !== void 0 ? _middlewareData$arrow5 : 0) + arrowWidth / 2;
      const arrowYCenter = ((_middlewareData$arrow7 = (_middlewareData$arrow8 = middlewareData.arrow) === null || _middlewareData$arrow8 === void 0 ? void 0 : _middlewareData$arrow8.y) !== null && _middlewareData$arrow7 !== void 0 ? _middlewareData$arrow7 : 0) + arrowHeight / 2;
      let x3 = "";
      let y3 = "";
      if (placedSide === "bottom") {
        x3 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y3 = `${-arrowHeight}px`;
      } else if (placedSide === "top") {
        x3 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
        y3 = `${rects.floating.height + arrowHeight}px`;
      } else if (placedSide === "right") {
        x3 = `${-arrowHeight}px`;
        y3 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      } else if (placedSide === "left") {
        x3 = `${rects.floating.width + arrowHeight}px`;
        y3 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
      }
      return {
        data: {
          x: x3,
          y: y3
        }
      };
    }
  });
  function $cf1ac5d9fe0e8206$var$getSideAndAlignFromPlacement2(placement) {
    const [side, align = "center"] = placement.split("-");
    return [
      side,
      align
    ];
  }
  var $cf1ac5d9fe0e8206$export$be92b6f5f03c0fe92 = $cf1ac5d9fe0e8206$export$badac9ada3a0bdf92;
  var $cf1ac5d9fe0e8206$export$b688253958b8dfe72 = $cf1ac5d9fe0e8206$export$ecd4e1ccab6ed6d2;
  var $cf1ac5d9fe0e8206$export$7c6e2c02157bb7d22 = $cf1ac5d9fe0e8206$export$bc4ae5855d3c4fc2;

  // ../../../node_modules/@radix-ui/react-popover/dist/index.module.js
  var $cb5cc270b50c6fcd$var$POPOVER_NAME = "Popover";
  var [$cb5cc270b50c6fcd$var$createPopoverContext, $cb5cc270b50c6fcd$export$c8393c9e73286932] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($cb5cc270b50c6fcd$var$POPOVER_NAME, [
    $cf1ac5d9fe0e8206$export$722aac194ae9232
  ]);
  var $cb5cc270b50c6fcd$var$usePopperScope = $cf1ac5d9fe0e8206$export$722aac194ae9232();
  var [$cb5cc270b50c6fcd$var$PopoverProvider, $cb5cc270b50c6fcd$var$usePopoverContext] = $cb5cc270b50c6fcd$var$createPopoverContext($cb5cc270b50c6fcd$var$POPOVER_NAME);
  var $cb5cc270b50c6fcd$export$5b6b19405a83ff9d = (props) => {
    const { __scopePopover, children, open: openProp, defaultOpen, onOpenChange, modal = false } = props;
    const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
    const triggerRef = (0, import_react92.useRef)(null);
    const [hasCustomAnchor, setHasCustomAnchor] = (0, import_react92.useState)(false);
    const [open = false, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    return /* @__PURE__ */ (0, import_react92.createElement)($cf1ac5d9fe0e8206$export$be92b6f5f03c0fe92, popperScope, /* @__PURE__ */ (0, import_react92.createElement)($cb5cc270b50c6fcd$var$PopoverProvider, {
      scope: __scopePopover,
      contentId: $1746a345f3d73bb7$export$f680877a34711e37(),
      triggerRef,
      open,
      onOpenChange: setOpen,
      onOpenToggle: (0, import_react92.useCallback)(
        () => setOpen(
          (prevOpen) => !prevOpen
        ),
        [
          setOpen
        ]
      ),
      hasCustomAnchor,
      onCustomAnchorAdd: (0, import_react92.useCallback)(
        () => setHasCustomAnchor(true),
        []
      ),
      onCustomAnchorRemove: (0, import_react92.useCallback)(
        () => setHasCustomAnchor(false),
        []
      ),
      modal
    }, children));
  };
  var $cb5cc270b50c6fcd$var$TRIGGER_NAME = "PopoverTrigger";
  var $cb5cc270b50c6fcd$export$7dacb05d26466c3 = /* @__PURE__ */ (0, import_react92.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopePopover } = _a5, triggerProps = __objRest(_a5, ["__scopePopover"]);
    const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$TRIGGER_NAME, __scopePopover);
    const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
    const composedTriggerRef = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, context.triggerRef);
    const trigger2 = /* @__PURE__ */ (0, import_react92.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
      type: "button",
      "aria-haspopup": "dialog",
      "aria-expanded": context.open,
      "aria-controls": context.contentId,
      "data-state": $cb5cc270b50c6fcd$var$getState(context.open)
    }, triggerProps, {
      ref: composedTriggerRef,
      onClick: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onClick, context.onOpenToggle)
    }));
    return context.hasCustomAnchor ? trigger2 : /* @__PURE__ */ (0, import_react92.createElement)($cf1ac5d9fe0e8206$export$b688253958b8dfe72, _extends({
      asChild: true
    }, popperScope), trigger2);
  });
  var $cb5cc270b50c6fcd$var$PORTAL_NAME = "PopoverPortal";
  var [$cb5cc270b50c6fcd$var$PortalProvider, $cb5cc270b50c6fcd$var$usePortalContext] = $cb5cc270b50c6fcd$var$createPopoverContext($cb5cc270b50c6fcd$var$PORTAL_NAME, {
    forceMount: void 0
  });
  var $cb5cc270b50c6fcd$export$dd679ffb4362d2d4 = (props) => {
    const { __scopePopover, forceMount, children, container } = props;
    const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$PORTAL_NAME, __scopePopover);
    return /* @__PURE__ */ (0, import_react92.createElement)($cb5cc270b50c6fcd$var$PortalProvider, {
      scope: __scopePopover,
      forceMount
    }, /* @__PURE__ */ (0, import_react92.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
      present: forceMount || context.open
    }, /* @__PURE__ */ (0, import_react92.createElement)($f1701beae083dbae$export$602eac185826482c, {
      asChild: true,
      container
    }, children)));
  };
  var $cb5cc270b50c6fcd$var$CONTENT_NAME = "PopoverContent";
  var $cb5cc270b50c6fcd$export$d7e1f420b25549ff = /* @__PURE__ */ (0, import_react92.forwardRef)((props, forwardedRef) => {
    const portalContext = $cb5cc270b50c6fcd$var$usePortalContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
    const _a5 = props, { forceMount = portalContext.forceMount } = _a5, contentProps = __objRest(_a5, ["forceMount"]);
    const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
    return /* @__PURE__ */ (0, import_react92.createElement)($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
      present: forceMount || context.open
    }, context.modal ? /* @__PURE__ */ (0, import_react92.createElement)($cb5cc270b50c6fcd$var$PopoverContentModal, _extends({}, contentProps, {
      ref: forwardedRef
    })) : /* @__PURE__ */ (0, import_react92.createElement)($cb5cc270b50c6fcd$var$PopoverContentNonModal, _extends({}, contentProps, {
      ref: forwardedRef
    })));
  });
  var $cb5cc270b50c6fcd$var$PopoverContentModal = /* @__PURE__ */ (0, import_react92.forwardRef)((props, forwardedRef) => {
    const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
    const contentRef = (0, import_react92.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, contentRef);
    const isRightClickOutsideRef = (0, import_react92.useRef)(false);
    (0, import_react92.useEffect)(() => {
      const content = contentRef.current;
      if (content)
        return hideOthers(content);
    }, []);
    return /* @__PURE__ */ (0, import_react92.createElement)(Combination_default, {
      as: $5e63c961fc1ce211$export$8c6ed5c666ac1360,
      allowPinchZoom: true
    }, /* @__PURE__ */ (0, import_react92.createElement)($cb5cc270b50c6fcd$var$PopoverContentImpl, _extends({}, props, {
      ref: composedRefs,
      trapFocus: context.open,
      disableOutsidePointerEvents: true,
      onCloseAutoFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onCloseAutoFocus, (event) => {
        var _context$triggerRef$c;
        event.preventDefault();
        if (!isRightClickOutsideRef.current)
          (_context$triggerRef$c = context.triggerRef.current) === null || _context$triggerRef$c === void 0 || _context$triggerRef$c.focus();
      }),
      onPointerDownOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDownOutside, (event) => {
        const originalEvent = event.detail.originalEvent;
        const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
        const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
        isRightClickOutsideRef.current = isRightClick;
      }, {
        checkForDefaultPrevented: false
      }),
      onFocusOutside: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
        props.onFocusOutside,
        (event) => event.preventDefault(),
        {
          checkForDefaultPrevented: false
        }
      )
    })));
  });
  var $cb5cc270b50c6fcd$var$PopoverContentNonModal = /* @__PURE__ */ (0, import_react92.forwardRef)((props, forwardedRef) => {
    const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, props.__scopePopover);
    const hasInteractedOutsideRef = (0, import_react92.useRef)(false);
    const hasPointerDownOutsideRef = (0, import_react92.useRef)(false);
    return /* @__PURE__ */ (0, import_react92.createElement)($cb5cc270b50c6fcd$var$PopoverContentImpl, _extends({}, props, {
      ref: forwardedRef,
      trapFocus: false,
      disableOutsidePointerEvents: false,
      onCloseAutoFocus: (event) => {
        var _props$onCloseAutoFoc;
        (_props$onCloseAutoFoc = props.onCloseAutoFocus) === null || _props$onCloseAutoFoc === void 0 || _props$onCloseAutoFoc.call(props, event);
        if (!event.defaultPrevented) {
          var _context$triggerRef$c2;
          if (!hasInteractedOutsideRef.current)
            (_context$triggerRef$c2 = context.triggerRef.current) === null || _context$triggerRef$c2 === void 0 || _context$triggerRef$c2.focus();
          event.preventDefault();
        }
        hasInteractedOutsideRef.current = false;
        hasPointerDownOutsideRef.current = false;
      },
      onInteractOutside: (event) => {
        var _props$onInteractOuts, _context$triggerRef$c3;
        (_props$onInteractOuts = props.onInteractOutside) === null || _props$onInteractOuts === void 0 || _props$onInteractOuts.call(props, event);
        if (!event.defaultPrevented) {
          hasInteractedOutsideRef.current = true;
          if (event.detail.originalEvent.type === "pointerdown")
            hasPointerDownOutsideRef.current = true;
        }
        const target = event.target;
        const targetIsTrigger = (_context$triggerRef$c3 = context.triggerRef.current) === null || _context$triggerRef$c3 === void 0 ? void 0 : _context$triggerRef$c3.contains(target);
        if (targetIsTrigger)
          event.preventDefault();
        if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current)
          event.preventDefault();
      }
    }));
  });
  var $cb5cc270b50c6fcd$var$PopoverContentImpl = /* @__PURE__ */ (0, import_react92.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopePopover, trapFocus, onOpenAutoFocus, onCloseAutoFocus, disableOutsidePointerEvents, onEscapeKeyDown, onPointerDownOutside, onFocusOutside, onInteractOutside } = _a5, contentProps = __objRest(_a5, ["__scopePopover", "trapFocus", "onOpenAutoFocus", "onCloseAutoFocus", "disableOutsidePointerEvents", "onEscapeKeyDown", "onPointerDownOutside", "onFocusOutside", "onInteractOutside"]);
    const context = $cb5cc270b50c6fcd$var$usePopoverContext($cb5cc270b50c6fcd$var$CONTENT_NAME, __scopePopover);
    const popperScope = $cb5cc270b50c6fcd$var$usePopperScope(__scopePopover);
    $3db38b7d1fb3fe6a$export$b7ece24a22aeda8c();
    return /* @__PURE__ */ (0, import_react92.createElement)($d3863c46a17e8a28$export$20e40289641fbbb6, {
      asChild: true,
      loop: true,
      trapped: trapFocus,
      onMountAutoFocus: onOpenAutoFocus,
      onUnmountAutoFocus: onCloseAutoFocus
    }, /* @__PURE__ */ (0, import_react92.createElement)($5cb92bef7577960e$export$177fb62ff3ec1f22, {
      asChild: true,
      disableOutsidePointerEvents,
      onInteractOutside,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onDismiss: () => context.onOpenChange(false)
    }, /* @__PURE__ */ (0, import_react92.createElement)($cf1ac5d9fe0e8206$export$7c6e2c02157bb7d22, _extends({
      "data-state": $cb5cc270b50c6fcd$var$getState(context.open),
      role: "dialog",
      id: context.contentId
    }, popperScope, contentProps, {
      ref: forwardedRef,
      style: __spreadProps(__spreadValues({}, contentProps.style), {
        "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
        "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
        "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
      })
    }))));
  });
  function $cb5cc270b50c6fcd$var$getState(open) {
    return open ? "open" : "closed";
  }
  var $cb5cc270b50c6fcd$export$be92b6f5f03c0fe9 = $cb5cc270b50c6fcd$export$5b6b19405a83ff9d;
  var $cb5cc270b50c6fcd$export$41fb9f06171c75f4 = $cb5cc270b50c6fcd$export$7dacb05d26466c3;
  var $cb5cc270b50c6fcd$export$602eac185826482c = $cb5cc270b50c6fcd$export$dd679ffb4362d2d4;
  var $cb5cc270b50c6fcd$export$7c6e2c02157bb7d2 = $cb5cc270b50c6fcd$export$d7e1f420b25549ff;

  // ../../../packages/ui/src/lib/components/ActionsMenu.tsx
  var import_react93 = __toESM(require_react());

  // ../../../packages/ui/src/lib/components/primitives/Popover.tsx
  var import_jsx_runtime85 = __toESM(require_jsx_runtime());
  var Popover = ({ id, children, onOpenChange }) => {
    const [isOpen, handleOpenChange] = useMenuIsOpen(id, onOpenChange);
    return /* @__PURE__ */ (0, import_jsx_runtime85.jsx)($cb5cc270b50c6fcd$export$be92b6f5f03c0fe9, { onOpenChange: handleOpenChange, open: isOpen, children: /* @__PURE__ */ (0, import_jsx_runtime85.jsx)("div", { className: "tlui-popover", children }) });
  };
  var PopoverTrigger = ({ children, disabled, "data-wd": dataWd }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime85.jsx)($cb5cc270b50c6fcd$export$41fb9f06171c75f4, { "data-wd": dataWd, disabled, asChild: true, dir: "ltr", children });
  };
  var PopoverContent = ({ side, children, align = "center", sideOffset = 8, alignOffset = 0 }) => {
    const container = useContainer();
    return /* @__PURE__ */ (0, import_jsx_runtime85.jsx)($cb5cc270b50c6fcd$export$602eac185826482c, { dir: "ltr", container, children: /* @__PURE__ */ (0, import_jsx_runtime85.jsx)(
      $cb5cc270b50c6fcd$export$7c6e2c02157bb7d2,
      {
        className: "tlui-popover__content",
        side,
        sideOffset,
        align,
        alignOffset,
        dir: "ltr",
        children
      }
    ) });
  };

  // ../../../packages/ui/src/lib/components/ActionsMenu.tsx
  var import_jsx_runtime86 = __toESM(require_jsx_runtime());
  var ActionsMenu = (0, import_react93.memo)(function ActionsMenu2() {
    const msg2 = useTranslation();
    const container = useContainer();
    const menuSchema = useActionsMenuSchema();
    const isReadonly = useReadonly();
    function getActionMenuItem(item) {
      if (isReadonly && !item.readonlyOk)
        return null;
      switch (item.type) {
        case "item": {
          const { id, icon, label, kbd: kbd2, onSelect } = item.actionItem;
          return /* @__PURE__ */ (0, import_jsx_runtime86.jsx)(
            Button,
            {
              className: "tlui-button-grid__button",
              "data-wd": `menu-item.${item.id}`,
              icon,
              title: label ? kbd2 ? `${msg2(label)} ${kbdStr(kbd2)}` : `${msg2(label)}` : kbd2 ? `${kbdStr(kbd2)}` : "",
              onClick: () => onSelect("actions-menu"),
              disabled: item.disabled
            },
            id
          );
        }
      }
    }
    return /* @__PURE__ */ (0, import_jsx_runtime86.jsxs)(Popover, { id: "actions menu", children: [
      /* @__PURE__ */ (0, import_jsx_runtime86.jsx)(PopoverTrigger, { children: /* @__PURE__ */ (0, import_jsx_runtime86.jsx)(
        Button,
        {
          className: "tlui-menu__trigger",
          "data-wd": "main.action-menu",
          icon: "dots-vertical",
          title: msg2("actions-menu.title"),
          smallIcon: true
        }
      ) }),
      /* @__PURE__ */ (0, import_jsx_runtime86.jsx)($cb5cc270b50c6fcd$export$602eac185826482c, { dir: "ltr", container, children: /* @__PURE__ */ (0, import_jsx_runtime86.jsx)(
        $cb5cc270b50c6fcd$export$7c6e2c02157bb7d2,
        {
          className: "tlui-popover__content",
          side: "bottom",
          dir: "ltr",
          sideOffset: 6,
          children: /* @__PURE__ */ (0, import_jsx_runtime86.jsx)("div", { className: "tlui-actions-menu tlui-button-grid__four", children: menuSchema.map(getActionMenuItem) })
        }
      ) })
    ] });
  });

  // ../../../packages/ui/src/lib/components/DuplicateButton.tsx
  var import_jsx_runtime87 = __toESM(require_jsx_runtime());
  var DuplicateButton = track(function DuplicateButton2() {
    const app = useApp();
    const actions = useActions();
    const msg2 = useTranslation();
    const action = actions["duplicate"];
    const noSelected = app.selectedIds.length <= 0;
    return /* @__PURE__ */ (0, import_jsx_runtime87.jsx)(
      Button,
      {
        icon: action.icon,
        onClick: () => action.onSelect("quick-actions"),
        disabled: noSelected,
        title: `${msg2(action.label)} ${kbdStr(action.kbd)}`,
        smallIcon: true
      }
    );
  });

  // ../../../packages/ui/src/lib/components/Menu.tsx
  var React58 = __toESM(require_react());
  var import_jsx_runtime88 = __toESM(require_jsx_runtime());
  var Menu = React58.memo(function Menu2() {
    const msg2 = useTranslation();
    return /* @__PURE__ */ (0, import_jsx_runtime88.jsxs)(Root, { id: "main menu", children: [
      /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(Trigger, { children: /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(
        Button,
        {
          className: "tlui-menu__trigger",
          "data-wd": "main.menu",
          title: msg2("menu.title"),
          icon: "menu"
        }
      ) }),
      /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(Content, { alignOffset: 0, sideOffset: 6, children: /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(MenuContent, {}) })
    ] });
  });
  function MenuContent() {
    const app = useApp();
    const msg2 = useTranslation();
    const menuSchema = useMenuSchema();
    const breakpoint = useBreakpoint();
    const isReadonly = useReadonly();
    const { paste } = useMenuClipboardEvents("menu");
    function getMenuItem(app2, item, parent, depth) {
      switch (item.type) {
        case "custom": {
          if (isReadonly && !item.readonlyOk)
            return null;
          if (item.id === "LANGUAGE_MENU") {
            return /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(LanguageMenu, {}, "item");
          }
          if (item.id === "MENU_PASTE") {
            return /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(
              Item,
              {
                "data-wd": `menu-item.${item.id}`,
                kbd: "$v",
                label: "action.paste",
                disabled: item.disabled,
                onMouseDown: () => {
                  var _a5;
                  if (app2.isSafari && ((_a5 = navigator.clipboard) == null ? void 0 : _a5.read)) {
                    navigator.clipboard.read().then((clipboardItems) => {
                      paste(clipboardItems);
                    });
                  }
                },
                onClick: () => {
                  var _a5;
                  if (app2.isSafari) {
                  } else if ((_a5 = navigator.clipboard) == null ? void 0 : _a5.read) {
                    navigator.clipboard.read().then((clipboardItems) => {
                      paste(clipboardItems);
                    });
                  }
                },
                onPointerUp: preventDefault
              },
              item.id
            );
          }
          return null;
        }
        case "group": {
          if (isReadonly && !item.readonlyOk)
            return null;
          return /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(
            Group,
            {
              size: depth <= 1 ? "medium" : breakpoint < 3 || (parent == null ? void 0 : parent.type) === "submenu" && depth > 2 ? "tiny" : "medium",
              children: item.children.map((child) => getMenuItem(app2, child, item, depth + 1))
            },
            item.id
          );
        }
        case "submenu": {
          if (isReadonly && !item.readonlyOk)
            return null;
          return /* @__PURE__ */ (0, import_jsx_runtime88.jsxs)(Sub, { id: `main menu ${parent ? parent.id + " " : ""}${item.id}`, children: [
            /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(SubTrigger, { label: item.label, "data-wd": `menu-item.${item.id}` }),
            /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(SubContent, { sideOffset: -4, alignOffset: -1, children: item.children.map((child) => getMenuItem(app2, child, item, depth + 1)) })
          ] }, item.id);
        }
        case "item": {
          if (isReadonly && !item.readonlyOk)
            return null;
          const { id, checkbox, menuLabel, label, onSelect, kbd: kbd2 } = item.actionItem;
          const labelToUse = menuLabel != null ? menuLabel : label;
          const labelStr = labelToUse ? msg2(labelToUse) : void 0;
          if (checkbox) {
            return /* @__PURE__ */ (0, import_jsx_runtime88.jsxs)(
              CheckboxItem,
              {
                onSelect: () => onSelect("menu"),
                title: labelStr ? labelStr : "",
                checked: item.checked,
                disabled: item.disabled,
                children: [
                  labelStr && /* @__PURE__ */ (0, import_jsx_runtime88.jsx)("span", { children: labelStr }),
                  kbd2 && /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(Kbd, { children: kbd2 })
                ]
              },
              id
            );
          }
          return /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(
            Item,
            {
              "data-wd": `menu-item.${item.id}`,
              kbd: kbd2,
              label: labelToUse,
              onClick: () => onSelect("menu"),
              disabled: item.disabled
            },
            id
          );
        }
      }
    }
    return /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(import_jsx_runtime88.Fragment, { children: menuSchema.map((item) => getMenuItem(app, item, null, 0)) });
  }

  // ../../../packages/ui/src/lib/components/PageMenu/PageMenu.tsx
  var import_react96 = __toESM(require_react());

  // ../../../packages/ui/src/lib/components/PageMenu/PageItemInput.tsx
  var import_react94 = __toESM(require_react());
  var import_jsx_runtime89 = __toESM(require_jsx_runtime());
  var PageItemInput = function PageItemInput2({
    name,
    id,
    isCurrentPage
  }) {
    const app = useApp();
    const rInput = (0, import_react94.useRef)(null);
    const handleChange = (0, import_react94.useCallback)(
      (value) => {
        app.renamePage(id, value ? value : "New Page", true);
      },
      [app, id]
    );
    const handleComplete = (0, import_react94.useCallback)(
      (value) => {
        app.mark("rename page");
        app.renamePage(id, value || "New Page", false);
      },
      [app, id]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(
      Input,
      {
        className: "tlui-page-menu__item__input",
        ref: (el) => rInput.current = el,
        defaultValue: name,
        onValueChange: handleChange,
        onComplete: handleComplete,
        onCancel: handleComplete,
        shouldManuallyMaintainScrollPositionWhenFocused: true,
        autofocus: isCurrentPage,
        autoselect: true
      }
    );
  };

  // ../../../packages/ui/src/lib/components/PageMenu/PageItemSubmenu.tsx
  var import_react95 = __toESM(require_react());

  // ../../../packages/ui/src/lib/components/PageMenu/edit-pages-shared.ts
  var onMovePage = (app, id, from, to) => {
    let index2;
    const pages = app.pages;
    const below = from > to ? pages[to - 1] : pages[to];
    const above = from > to ? pages[to] : pages[to + 1];
    if (below && !above) {
      index2 = getIndexAbove(below.index);
    } else if (!below && above) {
      index2 = getIndexBelow(pages[0].index);
    } else {
      index2 = getIndexBetween(below.index, above.index);
    }
    if (index2 !== pages[from].index) {
      app.mark("moving page");
      app.updatePage({
        id,
        index: index2
      });
    }
  };

  // ../../../packages/ui/src/lib/components/PageMenu/PageItemSubmenu.tsx
  var import_jsx_runtime90 = __toESM(require_jsx_runtime());
  var PageItemSubmenu = track(function PageItemSubmenu2({
    index: index2,
    listSize,
    item,
    onRename
  }) {
    const app = useApp();
    const msg2 = useTranslation();
    const pages = app.pages;
    const onDuplicate = (0, import_react95.useCallback)(() => {
      app.mark("creating page");
      const newId = TLPage.createId();
      app.duplicatePage(item.id, newId);
    }, [app, item]);
    const onMoveUp = (0, import_react95.useCallback)(() => {
      onMovePage(app, item.id, index2, index2 - 1);
    }, [app, item, index2]);
    const onMoveDown = (0, import_react95.useCallback)(() => {
      onMovePage(app, item.id, index2, index2 + 1);
    }, [app, item, index2]);
    const onDelete = (0, import_react95.useCallback)(() => {
      app.mark("deleting page");
      app.deletePage(item.id);
    }, [app, item]);
    return /* @__PURE__ */ (0, import_jsx_runtime90.jsxs)(Root, { id: "page item submenu", children: [
      /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(Trigger, { children: /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(Button, { title: msg2("page-menu.submenu.title"), icon: "dots-vertical" }) }),
      /* @__PURE__ */ (0, import_jsx_runtime90.jsxs)(Content, { alignOffset: 0, children: [
        /* @__PURE__ */ (0, import_jsx_runtime90.jsxs)(Group, { children: [
          onRename && /* @__PURE__ */ (0, import_jsx_runtime90.jsx)($d08ef79370b62062$export$6d08773d2e66f8f2, { dir: "ltr", onSelect: onRename, asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(Button, { className: "tlui-menu__button", label: "page-menu.submenu.rename" }) }),
          /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(
            $d08ef79370b62062$export$6d08773d2e66f8f2,
            {
              dir: "ltr",
              onSelect: onDuplicate,
              disabled: pages.length >= MAX_PAGES,
              asChild: true,
              children: /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(Button, { className: "tlui-menu__button", label: "page-menu.submenu.duplicate-page" })
            }
          ),
          index2 > 0 && /* @__PURE__ */ (0, import_jsx_runtime90.jsx)($d08ef79370b62062$export$6d08773d2e66f8f2, { dir: "ltr", onSelect: onMoveUp, asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(Button, { className: "tlui-menu__button", label: "page-menu.submenu.move-up" }) }),
          index2 < listSize - 1 && /* @__PURE__ */ (0, import_jsx_runtime90.jsx)($d08ef79370b62062$export$6d08773d2e66f8f2, { dir: "ltr", onSelect: onMoveDown, asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(Button, { className: "tlui-menu__button", label: "page-menu.submenu.move-down" }) })
        ] }),
        listSize > 1 && /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(Group, { children: /* @__PURE__ */ (0, import_jsx_runtime90.jsx)($d08ef79370b62062$export$6d08773d2e66f8f2, { dir: "ltr", onSelect: onDelete, asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime90.jsx)(Button, { className: "tlui-menu__button", label: "page-menu.submenu.delete" }) }) })
      ] })
    ] });
  });

  // ../../../packages/ui/src/lib/components/PageMenu/PageMenu.tsx
  var import_jsx_runtime91 = __toESM(require_jsx_runtime());
  var PageMenu = function PageMenu2() {
    const app = useApp();
    const msg2 = useTranslation();
    const breakpoint = useBreakpoint();
    const ITEM_HEIGHT = breakpoint < 5 ? 36 : 40;
    const rSortableContainer = (0, import_react96.useRef)(null);
    const pages = useValue("pages", () => app.pages, [app]);
    const currentPage = useValue("currentPage", () => app.currentPage, [app]);
    const isReadonlyMode = useValue("isReadonlyMode", () => app.isReadOnly, [app]);
    const maxPageCountReached = useValue("maxPageCountReached", () => app.pages.length >= MAX_PAGES, [
      app
    ]);
    const isCoarsePointer = useValue("isCoarsePointer", () => app.isCoarsePointer, [app]);
    const [isEditing, setIsEditing] = (0, import_react96.useState)(false);
    const toggleEditing = (0, import_react96.useCallback)(() => {
      if (isReadonlyMode)
        return;
      setIsEditing((s3) => !s3);
    }, [isReadonlyMode]);
    const [isOpen, setIsOpen] = (0, import_react96.useState)(false);
    const handleOpenChange = (0, import_react96.useCallback)((isOpen2) => {
      setIsOpen(isOpen2);
      setIsEditing(false);
    }, []);
    const rMutables = (0, import_react96.useRef)({
      isPointing: false,
      status: "idle",
      pointing: null,
      startY: 0,
      startIndex: 0,
      dragIndex: 0
    });
    const [sortablePositionItems, setSortablePositionItems] = (0, import_react96.useState)(
      Object.fromEntries(
        pages.map((page, i3) => [page.id, { y: i3 * ITEM_HEIGHT, offsetY: 0, isSelected: false }])
      )
    );
    (0, import_react96.useLayoutEffect)(() => {
      setSortablePositionItems(
        Object.fromEntries(
          pages.map((page, i3) => [page.id, { y: i3 * ITEM_HEIGHT, offsetY: 0, isSelected: false }])
        )
      );
    }, [ITEM_HEIGHT, pages]);
    (0, import_react96.useEffect)(() => {
      if (!isOpen)
        return;
      requestAnimationFrame(() => {
        const elm = document.querySelector(
          `[data-wd="page-menu-item-${currentPage.id}"]`
        );
        if (elm) {
          const container = rSortableContainer.current;
          if (!container)
            return;
          const elmTopPosition = elm.offsetTop;
          const containerScrollTopPosition = container.scrollTop;
          if (elmTopPosition < containerScrollTopPosition) {
            container.scrollTo({ top: elmTopPosition });
          }
          const elmBottomPosition = elmTopPosition + ITEM_HEIGHT;
          const containerScrollBottomPosition = container.scrollTop + container.offsetHeight;
          if (elmBottomPosition > containerScrollBottomPosition) {
            container.scrollTo({ top: elmBottomPosition - container.offsetHeight });
          }
        }
      });
    }, [ITEM_HEIGHT, currentPage, isOpen]);
    const handlePointerDown = (0, import_react96.useCallback)(
      (e2) => {
        const { clientY, currentTarget } = e2;
        const {
          dataset: { id, index: index2 }
        } = currentTarget;
        if (!id || !index2)
          return;
        const mut = rMutables.current;
        e2.currentTarget.setPointerCapture(e2.pointerId);
        mut.status = "pointing";
        mut.pointing = { id, index: +index2 };
        const current = sortablePositionItems[id];
        const dragY = current.y;
        mut.startY = clientY;
        mut.startIndex = Math.max(0, Math.min(Math.round(dragY / ITEM_HEIGHT), pages.length - 1));
      },
      [ITEM_HEIGHT, pages.length, sortablePositionItems]
    );
    const handlePointerMove = (0, import_react96.useCallback)(
      (e2) => {
        const mut = rMutables.current;
        if (mut.status === "pointing") {
          const { clientY } = e2;
          const offset = clientY - mut.startY;
          if (Math.abs(offset) > 5) {
            mut.status = "dragging";
          }
        }
        if (mut.status === "dragging") {
          const { clientY } = e2;
          const offsetY = clientY - mut.startY;
          const current = sortablePositionItems[mut.pointing.id];
          const { startIndex, pointing } = mut;
          const dragY = current.y + offsetY;
          const dragIndex = Math.max(0, Math.min(Math.round(dragY / ITEM_HEIGHT), pages.length - 1));
          const next = __spreadValues({}, sortablePositionItems);
          next[pointing.id] = {
            y: current.y,
            offsetY,
            isSelected: true
          };
          if (dragIndex !== mut.dragIndex) {
            mut.dragIndex = dragIndex;
            for (let i3 = 0; i3 < pages.length; i3++) {
              const item = pages[i3];
              if (item.id === mut.pointing.id) {
                continue;
              }
              let { y: y3 } = next[item.id];
              if (dragIndex === startIndex) {
                y3 = i3 * ITEM_HEIGHT;
              } else if (dragIndex < startIndex) {
                if (dragIndex <= i3 && i3 < startIndex) {
                  y3 = (i3 + 1) * ITEM_HEIGHT;
                } else {
                  y3 = i3 * ITEM_HEIGHT;
                }
              } else if (dragIndex > startIndex) {
                if (dragIndex >= i3 && i3 > startIndex) {
                  y3 = (i3 - 1) * ITEM_HEIGHT;
                } else {
                  y3 = i3 * ITEM_HEIGHT;
                }
              }
              if (y3 !== next[item.id].y) {
                next[item.id] = { y: y3, offsetY: 0, isSelected: true };
              }
            }
          }
          setSortablePositionItems(next);
        }
      },
      [ITEM_HEIGHT, pages, sortablePositionItems]
    );
    const handlePointerUp = (0, import_react96.useCallback)(
      (e2) => {
        const mut = rMutables.current;
        if (mut.status === "dragging") {
          const { id, index: index2 } = mut.pointing;
          onMovePage(app, id, index2, mut.dragIndex);
        }
        e2.currentTarget.releasePointerCapture(e2.pointerId);
        mut.status = "idle";
      },
      [app]
    );
    const handleKeyDown = (0, import_react96.useCallback)(
      (e2) => {
        const mut = rMutables.current;
        if (e2.key === "Escape") {
          if (mut.status === "dragging") {
            setSortablePositionItems(
              Object.fromEntries(
                pages.map((page, i3) => [
                  page.id,
                  { y: i3 * ITEM_HEIGHT, offsetY: 0, isSelected: false }
                ])
              )
            );
          }
          mut.status = "idle";
        }
      },
      [ITEM_HEIGHT, pages]
    );
    const handleCreatePageClick = (0, import_react96.useCallback)(() => {
      if (isReadonlyMode)
        return;
      app.mark("creating page");
      const newPageId = TLPage.createId();
      app.createPage(msg2("page-menu.new-page-initial-name"), newPageId);
      setIsEditing(true);
    }, [app, msg2, isReadonlyMode]);
    return /* @__PURE__ */ (0, import_jsx_runtime91.jsxs)(Popover, { id: "page menu", onOpenChange: handleOpenChange, open: isOpen, children: [
      /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(PopoverTrigger, { children: /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
        Button,
        {
          className: "tlui-page-menu__trigger tlui-menu__trigger",
          "data-wd": "main.page-menu",
          icon: "chevron-down",
          title: currentPage.name,
          children: /* @__PURE__ */ (0, import_jsx_runtime91.jsx)("div", { className: "tlui-page-menu__name", children: currentPage.name })
        }
      ) }),
      /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(PopoverContent, { side: "bottom", align: "start", sideOffset: 6, children: /* @__PURE__ */ (0, import_jsx_runtime91.jsxs)("div", { className: "tlui-page-menu__wrapper", children: [
        /* @__PURE__ */ (0, import_jsx_runtime91.jsxs)("div", { className: "tlui-page-menu__header", children: [
          /* @__PURE__ */ (0, import_jsx_runtime91.jsx)("div", { className: "tlui-page-menu__header__title", children: msg2("page-menu.title") }),
          !isReadonlyMode && /* @__PURE__ */ (0, import_jsx_runtime91.jsxs)(import_jsx_runtime91.Fragment, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
              Button,
              {
                "data-wd": "page-menu.edit",
                title: msg2(isEditing ? "page-menu.edit-done" : "page-menu.edit-start"),
                icon: isEditing ? "check" : "edit",
                onClick: toggleEditing
              }
            ),
            /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
              Button,
              {
                "data-wd": "page-menu.create",
                icon: "plus",
                title: msg2(
                  maxPageCountReached ? "page-menu.max-page-count-reached" : "page-menu.create-new-page"
                ),
                disabled: maxPageCountReached,
                onClick: handleCreatePageClick
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
          "div",
          {
            className: "tlui-page-menu__list tlui-menu__group",
            style: { height: ITEM_HEIGHT * pages.length + 4 },
            ref: rSortableContainer,
            children: pages.map((page, index2) => {
              var _a5;
              const position = (_a5 = sortablePositionItems[page.id]) != null ? _a5 : {
                position: index2 * 40,
                offsetY: 0
              };
              return isEditing ? /* @__PURE__ */ (0, import_jsx_runtime91.jsxs)(
                "div",
                {
                  "data-wd": `page-menu-item-${page.id}`,
                  className: "tlui-page_menu__item__sortable",
                  style: {
                    zIndex: page.id === currentPage.id ? 888 : index2,
                    transform: `translate(0px, ${position.y + position.offsetY}px)`
                  },
                  children: [
                    /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                      Button,
                      {
                        tabIndex: -1,
                        className: "tlui-page_menu__item__sortable__handle",
                        icon: "drag-handle-dots",
                        onPointerDown: handlePointerDown,
                        onPointerUp: handlePointerUp,
                        onPointerMove: handlePointerMove,
                        onKeyDown: handleKeyDown,
                        "data-id": page.id,
                        "data-index": index2
                      }
                    ),
                    breakpoint < 5 && isCoarsePointer ? (
                      // sigh, this is a workaround for iOS Safari
                      // because the device and the radix popover seem
                      // to be fighting over scroll position. Nothing
                      // else seems to work!
                      /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                        Button,
                        {
                          className: "tlui-page-menu__item__button",
                          onClick: () => {
                            const name = window.prompt("Rename page", page.name);
                            if (name && name !== page.name) {
                              app.renamePage(page.id, name);
                            }
                          },
                          onDoubleClick: toggleEditing,
                          isChecked: page.id === currentPage.id,
                          children: /* @__PURE__ */ (0, import_jsx_runtime91.jsx)("span", { children: page.name })
                        }
                      )
                    ) : /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                      "div",
                      {
                        id: `page-menu-item-${page.id}`,
                        "data-wd": `page-menu-item-${page.id}`,
                        className: "tlui-page_menu__item__sortable__title",
                        style: { height: ITEM_HEIGHT },
                        children: /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                          PageItemInput,
                          {
                            id: page.id,
                            name: page.name,
                            isCurrentPage: page.id === currentPage.id
                          }
                        )
                      }
                    ),
                    !isReadonlyMode && /* @__PURE__ */ (0, import_jsx_runtime91.jsx)("div", { className: "tlui-page_menu__item__submenu", "data-isediting": isEditing, children: /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(PageItemSubmenu, { index: index2, item: page, listSize: pages.length }) })
                  ]
                },
                page.id + "_editing"
              ) : /* @__PURE__ */ (0, import_jsx_runtime91.jsxs)(
                "div",
                {
                  "data-wd": `page-menu-item-${page.id}`,
                  className: "tlui-page-menu__item",
                  children: [
                    /* @__PURE__ */ (0, import_jsx_runtime91.jsxs)(
                      Button,
                      {
                        className: "tlui-page-menu__item__button tlui-page-menu__item__button__checkbox",
                        onClick: () => app.setCurrentPageId(page.id),
                        onDoubleClick: toggleEditing,
                        isChecked: page.id === currentPage.id,
                        title: msg2("page-menu.go-to-page"),
                        children: [
                          /* @__PURE__ */ (0, import_jsx_runtime91.jsx)("div", { className: "tlui-page-menu__item__button__check", children: page.id === currentPage.id && /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(Icon, { icon: "check" }) }),
                          /* @__PURE__ */ (0, import_jsx_runtime91.jsx)("span", { children: page.name })
                        ]
                      }
                    ),
                    !isReadonlyMode && /* @__PURE__ */ (0, import_jsx_runtime91.jsx)("div", { className: "tlui-page_menu__item__submenu", children: /* @__PURE__ */ (0, import_jsx_runtime91.jsx)(
                      PageItemSubmenu,
                      {
                        index: index2,
                        item: page,
                        listSize: pages.length,
                        onRename: () => {
                          if (app.isIos) {
                            const name = window.prompt("Rename page", page.name);
                            if (name && name !== page.name) {
                              app.renamePage(page.id, name);
                            }
                          } else {
                            setIsEditing(true);
                            app.setCurrentPageId(page.id);
                          }
                        }
                      }
                    ) })
                  ]
                },
                page.id
              );
            })
          }
        )
      ] }) })
    ] });
  };

  // ../../../packages/ui/src/lib/components/RedoButton.tsx
  var import_react97 = __toESM(require_react());
  var import_jsx_runtime92 = __toESM(require_jsx_runtime());
  var RedoButton = (0, import_react97.memo)(function RedoButton2() {
    const msg2 = useTranslation();
    const canRedo = useCanRedo();
    const actions = useActions();
    const redo = actions["redo"];
    return /* @__PURE__ */ (0, import_jsx_runtime92.jsx)(
      Button,
      {
        "data-wd": "main.redo",
        icon: redo.icon,
        title: `${msg2(redo.label)} ${kbdStr(redo.kbd)}`,
        disabled: !canRedo,
        onClick: () => redo.onSelect("quick-actions"),
        smallIcon: true
      }
    );
  });

  // ../../../packages/ui/src/lib/components/TrashButton.tsx
  var import_jsx_runtime93 = __toESM(require_jsx_runtime());
  var TrashButton = track(function TrashButton2() {
    const app = useApp();
    const actions = useActions();
    const msg2 = useTranslation();
    const action = actions["delete"];
    const isReadonly = useReadonly();
    if (isReadonly)
      return null;
    const noSelected = app.selectedIds.length <= 0;
    return /* @__PURE__ */ (0, import_jsx_runtime93.jsx)(
      Button,
      {
        icon: action.icon,
        onClick: () => action.onSelect("quick-actions"),
        disabled: noSelected,
        title: `${msg2(action.label)} ${kbdStr(action.kbd)}`,
        smallIcon: true
      }
    );
  });

  // ../../../packages/ui/src/lib/components/UndoButton.tsx
  var import_react98 = __toESM(require_react());
  var import_jsx_runtime94 = __toESM(require_jsx_runtime());
  var UndoButton = (0, import_react98.memo)(function UndoButton2() {
    const msg2 = useTranslation();
    const canUndo = useCanUndo();
    const actions = useActions();
    const undo = actions["undo"];
    return /* @__PURE__ */ (0, import_jsx_runtime94.jsx)(
      Button,
      {
        "data-wd": "main.undo",
        icon: undo.icon,
        title: `${msg2(undo.label)} ${kbdStr(undo.kbd)}`,
        disabled: !canUndo,
        onClick: () => undo.onSelect("quick-actions"),
        smallIcon: true
      }
    );
  });

  // ../../../packages/ui/src/lib/components/MenuZone.tsx
  var import_jsx_runtime95 = __toESM(require_jsx_runtime());
  var MenuZone = track(function MenuZone2() {
    const app = useApp();
    const breakpoint = useBreakpoint();
    const isReadonly = useReadonly();
    const showQuickActions = !isReadonly && !app.isInAny("hand", "zoom", "eraser");
    return /* @__PURE__ */ (0, import_jsx_runtime95.jsx)("div", { className: "tlui-menu-zone", children: /* @__PURE__ */ (0, import_jsx_runtime95.jsxs)("div", { className: "tlui-menu-zone__controls", children: [
      /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(Menu, {}),
      /* @__PURE__ */ (0, import_jsx_runtime95.jsx)("div", { className: "tlui-menu-zone__divider" }),
      /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(PageMenu, {}),
      breakpoint >= 5 && showQuickActions && /* @__PURE__ */ (0, import_jsx_runtime95.jsxs)(import_jsx_runtime95.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime95.jsx)("div", { className: "tlui-menu-zone__divider" }),
        /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(UndoButton, {}),
        /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(RedoButton, {}),
        /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(TrashButton, {}),
        /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(DuplicateButton, {}),
        /* @__PURE__ */ (0, import_jsx_runtime95.jsx)(ActionsMenu, {})
      ] })
    ] }) });
  });

  // ../../../packages/ui/src/lib/components/NavigationZone/NavigationZone.tsx
  var import_react100 = __toESM(require_react());

  // ../../../packages/ui/src/lib/hooks/useLocalStorageState.ts
  var import_react99 = __toESM(require_react());
  function useLocalStorageState(key, defaultValue) {
    const [state, setState] = import_react99.default.useState(defaultValue);
    import_react99.default.useLayoutEffect(() => {
      const value = localStorage.getItem(key);
      if (value) {
        try {
          setState(JSON.parse(value));
        } catch (e2) {
          console.error(`Could not restore value ${key} from local storage.`);
        }
      }
    }, [key]);
    const updateValue = import_react99.default.useCallback(
      (setter) => {
        setState((s3) => {
          const value = typeof setter === "function" ? setter(s3) : setter;
          localStorage.setItem(key, JSON.stringify(value));
          return value;
        });
      },
      [key]
    );
    return [state, updateValue];
  }

  // ../../../packages/ui/src/lib/components/NavigationZone/Minimap.tsx
  var React60 = __toESM(require_react());

  // ../../../packages/ui/src/lib/components/NavigationZone/MinimapManager.ts
  var MinimapManager = class {
    constructor(app, dpr) {
      this.app = app;
      this.dpr = dpr;
      __publicField(this, "colors", {
        shapeFill: "rgba(144, 144, 144, .1)",
        selectFill: "#2f80ed",
        viewportFill: "rgba(144, 144, 144, .1)"
      });
      __publicField(this, "id", uniqueId());
      __publicField(this, "cvs", null);
      __publicField(this, "pageBounds", []);
      __publicField(this, "collaborators", []);
      __publicField(this, "canvasScreenBounds", new Box2d());
      __publicField(this, "canvasPageBounds", new Box2d());
      __publicField(this, "contentPageBounds", new Box2d());
      __publicField(this, "contentScreenBounds", new Box2d());
      __publicField(this, "originPagePoint", new Vec2d());
      __publicField(this, "originPageCenter", new Vec2d());
      __publicField(this, "isInViewport", false);
      __publicField(this, "debug", false);
      __publicField(this, "updateContentScreenBounds", () => {
        const { contentScreenBounds, contentPageBounds: content, canvasScreenBounds: canvas } = this;
        let { x: x3, y: y3, w: w3, h: h3 } = contentScreenBounds;
        if (content.w > content.h) {
          const sh = canvas.w / (content.w / content.h);
          if (sh > canvas.h) {
            x3 = (canvas.w - canvas.w * (canvas.h / sh)) / 2;
            y3 = 0;
            w3 = canvas.w * (canvas.h / sh);
            h3 = canvas.h;
          } else {
            x3 = 0;
            y3 = (canvas.h - sh) / 2;
            w3 = canvas.w;
            h3 = sh;
          }
        } else if (content.w < content.h) {
          const sw = canvas.h / (content.h / content.w);
          x3 = (canvas.w - sw) / 2;
          y3 = 0;
          w3 = sw;
          h3 = canvas.h;
        } else {
          x3 = canvas.h / 2;
          y3 = 0;
          w3 = canvas.h;
          h3 = canvas.h;
        }
        contentScreenBounds.set(x3, y3, w3, h3);
      });
      /** Get the canvas's true bounds converted to page bounds. */
      __publicField(this, "updateCanvasPageBounds", () => {
        const { canvasPageBounds, canvasScreenBounds, contentPageBounds, contentScreenBounds } = this;
        canvasPageBounds.set(
          0,
          0,
          contentPageBounds.width / (contentScreenBounds.width / canvasScreenBounds.width),
          contentPageBounds.height / (contentScreenBounds.height / canvasScreenBounds.height)
        );
        canvasPageBounds.center = contentPageBounds.center;
      });
      __publicField(this, "getScreenPoint", (x3, y3) => {
        const { canvasScreenBounds } = this;
        const screenX = (x3 - canvasScreenBounds.minX) * this.dpr;
        const screenY = (y3 - canvasScreenBounds.minY) * this.dpr;
        return { x: screenX, y: screenY };
      });
      __publicField(this, "getPagePoint", (x3, y3) => {
        const { contentPageBounds, contentScreenBounds, canvasPageBounds } = this;
        const { x: screenX, y: screenY } = this.getScreenPoint(x3, y3);
        return {
          x: canvasPageBounds.minX + screenX * contentPageBounds.width / contentScreenBounds.width,
          y: canvasPageBounds.minY + screenY * contentPageBounds.height / contentScreenBounds.height,
          z: 1
        };
      });
      __publicField(this, "minimapScreenPointToPagePoint", (x3, y3, shiftKey = false, clampToBounds = false) => {
        var _a5, _b2, _c, _d;
        const { app } = this;
        const { viewportPageBounds } = app;
        let { x: px, y: py } = this.getPagePoint(x3, y3);
        if (clampToBounds) {
          const shapesPageBounds = this.app.allShapesCommonBounds;
          const vpPageBounds = viewportPageBounds;
          const minX = ((_a5 = shapesPageBounds == null ? void 0 : shapesPageBounds.minX) != null ? _a5 : 0) - vpPageBounds.width / 2;
          const maxX = ((_b2 = shapesPageBounds == null ? void 0 : shapesPageBounds.maxX) != null ? _b2 : 0) + vpPageBounds.width / 2;
          const minY = ((_c = shapesPageBounds == null ? void 0 : shapesPageBounds.minY) != null ? _c : 0) - vpPageBounds.height / 2;
          const maxY = ((_d = shapesPageBounds == null ? void 0 : shapesPageBounds.maxY) != null ? _d : 0) + vpPageBounds.height / 2;
          const lx = Math.max(0, minX + vpPageBounds.width - px);
          const rx = Math.max(0, -(maxX - vpPageBounds.width - px));
          const ly = Math.max(0, minY + vpPageBounds.height - py);
          const ry = Math.max(0, -(maxY - vpPageBounds.height - py));
          const ql = Math.max(0, lx - rx);
          const qr = Math.max(0, rx - lx);
          const qt = Math.max(0, ly - ry);
          const qb = Math.max(0, ry - ly);
          if (ql && ql > qr) {
            px += ql / 2;
          } else if (qr) {
            px -= qr / 2;
          }
          if (qt && qt > qb) {
            py += qt / 2;
          } else if (qb) {
            py -= qb / 2;
          }
          px = clamp(px, minX, maxX);
          py = clamp(py, minY, maxY);
        }
        if (shiftKey) {
          const { originPagePoint } = this;
          const dx = Math.abs(px - originPagePoint.x);
          const dy = Math.abs(py - originPagePoint.y);
          if (dx > dy) {
            py = originPagePoint.y;
          } else {
            px = originPagePoint.x;
          }
        }
        return { x: px, y: py };
      });
      __publicField(this, "render", () => {
        const { cvs, pageBounds } = this;
        this.updateCanvasPageBounds();
        const { app, canvasScreenBounds, canvasPageBounds, contentPageBounds, contentScreenBounds } = this;
        const { width: cw, height: ch } = canvasScreenBounds;
        const { viewportPageBounds, selectedIds } = app;
        if (!cvs || !pageBounds) {
          return;
        }
        const ctx = cvs.getContext("2d");
        if (!ctx) {
          throw new Error("Minimap (shapes): Could not get context");
        }
        ctx.resetTransform();
        ctx.globalAlpha = 1;
        ctx.clearRect(0, 0, cw, ch);
        const sx = contentScreenBounds.width / contentPageBounds.width;
        const sy = contentScreenBounds.height / contentPageBounds.height;
        ctx.translate((cw - contentScreenBounds.width) / 2, (ch - contentScreenBounds.height) / 2);
        ctx.scale(sx, sy);
        ctx.translate(-contentPageBounds.minX, -contentPageBounds.minY);
        const rx = 8 / sx;
        const ry = 8 / sx;
        const ax = 1 / sx;
        const ay = 1 / sx;
        const bx = rx / 4;
        const by = ry / 4;
        const shapesPath = new Path2D();
        const selectedPath = new Path2D();
        const { shapeFill, selectFill, viewportFill } = this.colors;
        let pb;
        for (let i3 = 0, n3 = pageBounds.length; i3 < n3; i3++) {
          pb = pageBounds[i3];
          MinimapManager.roundedRect(
            selectedIds.includes(pb.id) ? selectedPath : shapesPath,
            pb.minX,
            pb.minY,
            pb.width,
            pb.height,
            clamp(rx, ax, pb.width / bx),
            clamp(ry, ay, pb.height / by)
          );
        }
        ctx.fillStyle = shapeFill;
        ctx.fill(shapesPath);
        ctx.fillStyle = selectFill;
        ctx.fill(selectedPath);
        if (this.debug) {
          const commonBounds = Box2d.Common(pageBounds);
          const { minX, minY, width, height } = commonBounds;
          ctx.strokeStyle = "green";
          ctx.lineWidth = 2 / sx;
          ctx.strokeRect(minX + 1 / sx, minY + 1 / sy, width - 2 / sx, height - 2 / sy);
        }
        {
          const { brush } = app;
          if (brush) {
            const { x: x3, y: y3, w: w3, h: h3 } = brush;
            ctx.beginPath();
            MinimapManager.sharpRect(ctx, x3, y3, w3, h3);
            ctx.closePath();
            ctx.fillStyle = viewportFill;
            ctx.fill();
          }
        }
        {
          const { minX, minY, width, height } = viewportPageBounds;
          ctx.beginPath();
          const rx2 = 12 / sx;
          const ry2 = 12 / sx;
          MinimapManager.roundedRect(
            ctx,
            minX,
            minY,
            width,
            height,
            Math.min(width / 4, rx2),
            Math.min(height / 4, ry2)
          );
          ctx.closePath();
          ctx.fillStyle = viewportFill;
          ctx.fill();
          if (this.debug) {
            ctx.strokeStyle = "orange";
            ctx.strokeRect(minX + 1 / sx, minY + 1 / sy, width - 2 / sx, height - 2 / sy);
          }
        }
        const px = 2.5 / sx;
        const py = 2.5 / sy;
        const { currentPageId } = app;
        let collaborator;
        for (let i3 = 0; i3 < this.collaborators.length; i3++) {
          collaborator = this.collaborators[i3];
          const instance = collaborator.lastUsedInstanceId ? app.store.get(collaborator.lastUsedInstanceId) : null;
          if ((instance == null ? void 0 : instance.currentPageId) !== currentPageId) {
            continue;
          }
          ctx.beginPath();
          ctx.ellipse(
            clamp(collaborator.cursor.x, canvasPageBounds.minX + px, canvasPageBounds.maxX - px),
            clamp(collaborator.cursor.y, canvasPageBounds.minY + py, canvasPageBounds.maxY - py),
            5 / sx,
            5 / sy,
            0,
            0,
            PI2
          );
          ctx.fillStyle = collaborator.color;
          ctx.fill();
        }
        if (this.debug) {
          ctx.lineWidth = 2 / sx;
          {
            const { minX, minY, width, height } = contentPageBounds;
            ctx.strokeStyle = "red";
            ctx.strokeRect(minX + 1 / sx, minY + 1 / sy, width - 2 / sx, height - 2 / sy);
          }
          {
            const { minX, minY, width, height } = canvasPageBounds;
            ctx.strokeStyle = "blue";
            ctx.strokeRect(minX + 1 / sx, minY + 1 / sy, width - 2 / sx, height - 2 / sy);
          }
        }
      });
    }
    setDpr(dpr) {
      this.dpr = +dpr.toFixed(2);
    }
    static roundedRect(ctx, x3, y3, width, height, rx, ry) {
      if (rx < 1 && ry < 1) {
        ctx.rect(x3, y3, width, height);
        return;
      }
      ctx.moveTo(x3 + rx, y3);
      ctx.lineTo(x3 + width - rx, y3);
      ctx.quadraticCurveTo(x3 + width, y3, x3 + width, y3 + ry);
      ctx.lineTo(x3 + width, y3 + height - ry);
      ctx.quadraticCurveTo(x3 + width, y3 + height, x3 + width - rx, y3 + height);
      ctx.lineTo(x3 + rx, y3 + height);
      ctx.quadraticCurveTo(x3, y3 + height, x3, y3 + height - ry);
      ctx.lineTo(x3, y3 + ry);
      ctx.quadraticCurveTo(x3, y3, x3 + rx, y3);
    }
    static sharpRect(ctx, x3, y3, width, height, _rx, _ry) {
      ctx.rect(x3, y3, width, height);
    }
  };

  // ../../../packages/ui/src/lib/components/NavigationZone/Minimap.tsx
  var import_jsx_runtime96 = __toESM(require_jsx_runtime());
  var COLLABORATOR_INACTIVITY_TIMEOUT2 = 1e4;
  var useActivePresences2 = () => {
    const app = useApp();
    const time = useAtom("time", Date.now());
    React60.useEffect(() => {
      const interval = setInterval(() => time.set(Date.now()), 1e3 * 5);
      return () => clearInterval(interval);
    }, [time]);
    return React60.useMemo(
      () => app.store.query.records("user_presence", () => ({
        lastActivityTimestamp: { gt: time.value - COLLABORATOR_INACTIVITY_TIMEOUT2 },
        userId: { neq: app.userId }
      })),
      [app, time]
    );
  };
  var Minimap = track(function Minimap2({
    shapeFill,
    selectFill,
    viewportFill
  }) {
    const app = useApp();
    const rCanvas = React60.useRef(null);
    const container = useContainer();
    const rPointing = React60.useRef(false);
    const minimap = React60.useMemo(() => new MinimapManager(app, app.devicePixelRatio), [app]);
    const isDarkMode = app.userDocumentSettings.isDarkMode;
    React60.useEffect(() => {
      const raf2 = requestAnimationFrame(() => {
        const style = getComputedStyle(container);
        minimap.colors = {
          shapeFill: style.getPropertyValue(shapeFill).trim(),
          selectFill: style.getPropertyValue(selectFill).trim(),
          viewportFill: style.getPropertyValue(viewportFill).trim()
        };
        minimap.render();
      });
      return () => {
        cancelAnimationFrame(raf2);
      };
    }, [container, selectFill, shapeFill, viewportFill, minimap, isDarkMode]);
    const onDoubleClick = React60.useCallback(
      (e2) => {
        if (!app.shapeIds.size)
          return;
        const { x: x3, y: y3 } = minimap.minimapScreenPointToPagePoint(e2.clientX, e2.clientY, false, false);
        const clampedPoint = minimap.minimapScreenPointToPagePoint(e2.clientX, e2.clientY, false, true);
        minimap.originPagePoint.setTo(clampedPoint);
        minimap.originPageCenter.setTo(app.viewportPageBounds.center);
        app.centerOnPoint(x3, y3, { duration: ANIMATION_MEDIUM_MS });
      },
      [app, minimap]
    );
    const onPointerDown = React60.useCallback(
      (e2) => {
        e2.currentTarget.setPointerCapture(e2.pointerId);
        if (!app.shapeIds.size)
          return;
        rPointing.current = true;
        minimap.isInViewport = false;
        const { x: x3, y: y3 } = minimap.minimapScreenPointToPagePoint(e2.clientX, e2.clientY, false, false);
        const clampedPoint = minimap.minimapScreenPointToPagePoint(e2.clientX, e2.clientY, false, true);
        const _vpPageBounds = app.viewportPageBounds;
        minimap.originPagePoint.setTo(clampedPoint);
        minimap.originPageCenter.setTo(_vpPageBounds.center);
        minimap.isInViewport = _vpPageBounds.containsPoint(clampedPoint);
        if (!minimap.isInViewport) {
          app.centerOnPoint(x3, y3, { duration: ANIMATION_MEDIUM_MS });
        }
      },
      [app, minimap]
    );
    const onPointerMove = React60.useCallback(
      (e2) => {
        if (rPointing.current) {
          const { x: x3, y: y3 } = minimap.minimapScreenPointToPagePoint(
            e2.clientX,
            e2.clientY,
            e2.shiftKey,
            true
          );
          if (minimap.isInViewport) {
            const delta = Vec2d.Sub({ x: x3, y: y3 }, minimap.originPagePoint);
            const center = Vec2d.Add(minimap.originPageCenter, delta);
            app.centerOnPoint(center.x, center.y);
            return;
          }
          app.centerOnPoint(x3, y3);
        }
        const pagePoint = minimap.getPagePoint(e2.clientX, e2.clientY);
        const screenPoint = app.pageToScreen(pagePoint.x, pagePoint.y);
        const info = __spreadProps(__spreadValues({
          type: "pointer",
          target: "canvas",
          name: "pointer_move"
        }, getPointerInfo2(e2)), {
          point: screenPoint,
          isPen: app.isPenMode
        });
        app.dispatch(info);
      },
      [app, minimap]
    );
    const onPointerUp = React60.useCallback((_e) => {
      rPointing.current = false;
    }, []);
    const onWheel = React60.useCallback(
      (e2) => {
        const offset = normalizeWheel(e2);
        app.dispatch({
          type: "wheel",
          name: "wheel",
          delta: offset,
          shiftKey: e2.shiftKey,
          altKey: e2.altKey,
          ctrlKey: e2.metaKey || e2.ctrlKey
        });
      },
      [app]
    );
    useQuickReactor(
      "update dpr",
      () => {
        const { devicePixelRatio } = app;
        minimap.setDpr(devicePixelRatio);
        const canvas = rCanvas.current;
        const rect = canvas.getBoundingClientRect();
        const width = rect.width * devicePixelRatio;
        const height = rect.height * devicePixelRatio;
        canvas.width = width;
        canvas.height = height;
        minimap.canvasScreenBounds.set(rect.x, rect.y, width, height);
        minimap.cvs = rCanvas.current;
      },
      [app, minimap]
    );
    const presences = useActivePresences2();
    useQuickReactor(
      "minimap render when pagebounds or collaborators changes",
      () => {
        const { devicePixelRatio, viewportPageBounds, allShapesCommonBounds } = app;
        devicePixelRatio;
        minimap.contentPageBounds = allShapesCommonBounds ? Box2d.Expand(allShapesCommonBounds, viewportPageBounds) : viewportPageBounds;
        minimap.updateContentScreenBounds();
        const allShapeBounds = [];
        app.shapeIds.forEach((id) => {
          let pageBounds = app.getPageBoundsById(id);
          const pageMask = app.getPageMaskById(id);
          if (pageMask) {
            const intersection = intersectPolygonPolygon(pageMask, pageBounds.corners);
            if (!intersection) {
              return;
            }
            pageBounds = Box2d.FromPoints(intersection);
          }
          if (pageBounds) {
            pageBounds.id = id;
            allShapeBounds.push(pageBounds);
          }
        });
        minimap.pageBounds = allShapeBounds;
        minimap.collaborators = presences.value;
        minimap.render();
      },
      [app, minimap]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime96.jsx)("div", { className: "tlui-minimap", children: /* @__PURE__ */ (0, import_jsx_runtime96.jsx)(
      "canvas",
      {
        ref: rCanvas,
        className: "tlui-minimap__canvas",
        onDoubleClick,
        onPointerMove,
        onPointerDown,
        onPointerUp,
        onWheel
      }
    ) });
  });
  function getPointerInfo2(e2) {
    ;
    e2.isKilled = true;
    return {
      point: {
        x: e2.clientX,
        y: e2.clientY,
        z: e2.pressure
      },
      shiftKey: e2.shiftKey,
      altKey: e2.altKey,
      ctrlKey: e2.metaKey || e2.ctrlKey,
      pointerId: e2.pointerId,
      button: e2.button,
      isPen: e2.pointerType === "pen"
    };
  }

  // ../../../packages/ui/src/lib/components/NavigationZone/ZoomMenu.tsx
  var React61 = __toESM(require_react());
  var import_jsx_runtime97 = __toESM(require_jsx_runtime());
  var ZoomMenu = track(function ZoomMenu2() {
    const app = useApp();
    const msg2 = useTranslation();
    const breakpoint = useBreakpoint();
    const zoom = app.zoomLevel;
    const hasShapes = app.shapeIds.size > 0;
    const hasSelected = app.selectedIds.length > 0;
    const isZoomedTo100 = app.zoomLevel === 1;
    const handleDoubleClick = React61.useCallback(() => {
      app.resetZoom(app.viewportScreenCenter, { duration: ANIMATION_MEDIUM_MS });
    }, [app]);
    return /* @__PURE__ */ (0, import_jsx_runtime97.jsxs)(Root, { id: "zoom", children: [
      /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(Trigger, { children: /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(
        Button,
        {
          title: `${msg2("navigation-zone.zoom")}`,
          "data-wd": "minimap.zoom-menu",
          className: breakpoint < 5 ? "tlui-zoom-menu__button" : "tlui-zoom-menu__button__pct",
          onDoubleClick: handleDoubleClick,
          icon: breakpoint < 4 ? "zoom-in" : void 0,
          children: breakpoint < 4 ? null : /* @__PURE__ */ (0, import_jsx_runtime97.jsxs)("span", { style: { flexGrow: 0, textAlign: "center" }, children: [
            Math.floor(zoom * 100),
            "%"
          ] })
        }
      ) }),
      /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(Content, { side: "top", align: "start", alignOffset: 0, children: /* @__PURE__ */ (0, import_jsx_runtime97.jsxs)(Group, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(ZoomMenuItem, { action: "zoom-in", "data-wd": "minimap.zoom-menu.zoom-in", noClose: true }),
        /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(ZoomMenuItem, { action: "zoom-out", "data-wd": "minimap.zoom-menu.zoom-out", noClose: true }),
        /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(
          ZoomMenuItem,
          {
            action: "zoom-to-100",
            "data-wd": "minimap.zoom-menu.zoom-to-100",
            noClose: true,
            disabled: isZoomedTo100
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(
          ZoomMenuItem,
          {
            action: "zoom-to-fit",
            disabled: !hasShapes,
            "data-wd": "minimap.zoom-menu.zoom-to-fit",
            noClose: true
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(
          ZoomMenuItem,
          {
            action: "zoom-to-selection",
            disabled: !hasSelected,
            "data-wd": "minimap.zoom-menu.zoom-to-selection",
            noClose: true
          }
        )
      ] }) })
    ] });
  });
  function ZoomMenuItem(props) {
    const { action, disabled = false, noClose = false } = props;
    const actions = useActions();
    return /* @__PURE__ */ (0, import_jsx_runtime97.jsx)(
      Item,
      {
        label: actions[action].label,
        kbd: actions[action].kbd,
        "data-wd": props["data-wd"],
        onClick: () => actions[action].onSelect("zoom-menu"),
        noClose,
        disabled
      }
    );
  }

  // ../../../packages/ui/src/lib/components/NavigationZone/NavigationZone.tsx
  var import_jsx_runtime98 = __toESM(require_jsx_runtime());
  var NavigationZone = (0, import_react100.memo)(function NavigationZone2() {
    const actions = useActions();
    const msg2 = useTranslation();
    const breakpoint = useBreakpoint();
    const [collapsed, setCollapsed] = useLocalStorageState("minimap", true);
    const toggleMinimap = (0, import_react100.useCallback)(() => {
      setCollapsed((s3) => !s3);
    }, [setCollapsed]);
    if (breakpoint < 4) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime98.jsxs)("div", { className: "tlui-navigation-zone", children: [
      /* @__PURE__ */ (0, import_jsx_runtime98.jsx)("div", { className: "tlui-navigation-zone__controls", children: breakpoint < 6 ? /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(ZoomMenu, {}) : collapsed ? /* @__PURE__ */ (0, import_jsx_runtime98.jsxs)(import_jsx_runtime98.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(ZoomMenu, {}),
        /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(
          Button,
          {
            title: msg2("navigation-zone.toggle-minimap"),
            className: "tlui-navigation-zone__toggle",
            "data-wd": "minimap.toggle",
            onClick: toggleMinimap,
            icon: collapsed ? "chevrons-ne" : "chevrons-sw"
          }
        )
      ] }) : /* @__PURE__ */ (0, import_jsx_runtime98.jsxs)(import_jsx_runtime98.Fragment, { children: [
        /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(
          Button,
          {
            icon: "minus",
            "data-wd": "minimap.zoom-out",
            title: `${msg2(actions["zoom-out"].label)} ${kbdStr(actions["zoom-out"].kbd)}`,
            onClick: () => actions["zoom-out"].onSelect("navigation-zone")
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(ZoomMenu, {}),
        /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(
          Button,
          {
            icon: "plus",
            "data-wd": "minimap.zoom-in",
            title: `${msg2(actions["zoom-in"].label)} ${kbdStr(actions["zoom-in"].kbd)}`,
            onClick: () => actions["zoom-in"].onSelect("navigation-zone")
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(
          Button,
          {
            title: msg2("navigation-zone.toggle-minimap"),
            className: "tlui-navigation-zone__toggle",
            onClick: toggleMinimap,
            icon: collapsed ? "chevrons-ne" : "chevrons-sw"
          }
        )
      ] }) }),
      breakpoint >= 6 && !collapsed && /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(
        Minimap,
        {
          viewportFill: "--color-muted-1",
          selectFill: "--color-selected",
          shapeFill: "--color-text-3"
        }
      )
    ] });
  });

  // ../../../packages/ui/src/lib/components/PenModeToggle.tsx
  var import_jsx_runtime99 = __toESM(require_jsx_runtime());
  var ExitPenMode = track(function ExitPenMode2() {
    const app = useApp();
    const isPenMode = app.isPenMode;
    const actions = useActions();
    if (!isPenMode)
      return null;
    const action = actions["exit-pen-mode"];
    return /* @__PURE__ */ (0, import_jsx_runtime99.jsx)(
      Button,
      {
        label: action.label,
        iconLeft: action.icon,
        onClick: () => action.onSelect("helper-buttons")
      }
    );
  });

  // ../../../packages/ui/src/lib/components/StopFollowing.tsx
  var import_jsx_runtime100 = __toESM(require_jsx_runtime());
  var StopFollowing = track(function ExitPenMode3() {
    const app = useApp();
    const actions = useActions();
    if (!app.instanceState.followingUserId) {
      return null;
    }
    const action = actions["stop-following"];
    return /* @__PURE__ */ (0, import_jsx_runtime100.jsx)(
      Button,
      {
        label: action.label,
        iconLeft: action.icon,
        onClick: () => action.onSelect("people-menu")
      }
    );
  });

  // ../../../packages/ui/src/lib/components/StylePanel/StylePanel.tsx
  var import_react105 = __toESM(require_react());

  // ../../../packages/ui/src/lib/components/primitives/ButtonPicker.tsx
  var import_classnames15 = __toESM(require_classnames());
  var React62 = __toESM(require_react());
  var import_react101 = __toESM(require_react());
  var import_jsx_runtime101 = __toESM(require_jsx_runtime());
  function _ButtonPicker(props) {
    const {
      items,
      title,
      styleType,
      value = null,
      onValueChange,
      columns = clamp(items.length, 2, 4)
    } = props;
    const app = useApp();
    const msg2 = useTranslation();
    const rPointing = (0, import_react101.useRef)(false);
    const {
      handleButtonClick,
      handleButtonPointerDown,
      handleButtonPointerEnter,
      handleButtonPointerUp
    } = React62.useMemo(() => {
      const handlePointerUp = () => {
        rPointing.current = false;
        window.removeEventListener("pointerup", handlePointerUp);
      };
      const handleButtonClick2 = (e2) => {
        const { id } = e2.currentTarget.dataset;
        if (value === id)
          return;
        app.mark("point picker item");
        onValueChange(items.find((i3) => i3.id === id), false);
      };
      const handleButtonPointerDown2 = (e2) => {
        const { id } = e2.currentTarget.dataset;
        app.mark("point picker item");
        onValueChange(items.find((i3) => i3.id === id), true);
        rPointing.current = true;
        window.addEventListener("pointerup", handlePointerUp);
      };
      const handleButtonPointerEnter2 = (e2) => {
        if (!rPointing.current)
          return;
        const { id } = e2.currentTarget.dataset;
        onValueChange(items.find((i3) => i3.id === id), true);
      };
      const handleButtonPointerUp2 = (e2) => {
        const { id } = e2.currentTarget.dataset;
        onValueChange(items.find((i3) => i3.id === id), false);
      };
      return {
        handleButtonClick: handleButtonClick2,
        handleButtonPointerDown: handleButtonPointerDown2,
        handleButtonPointerEnter: handleButtonPointerEnter2,
        handleButtonPointerUp: handleButtonPointerUp2
      };
    }, [app, value, onValueChange, items]);
    return /* @__PURE__ */ (0, import_jsx_runtime101.jsx)(
      "div",
      {
        className: (0, import_classnames15.default)("tlui-button-grid", {
          "tlui-button-grid__two": columns === 2,
          "tlui-button-grid__three": columns === 3,
          "tlui-button-grid__four": columns === 4
        }),
        children: items.map((item) => /* @__PURE__ */ (0, import_jsx_runtime101.jsx)(
          Button,
          {
            "data-id": item.id,
            "data-wd": `${props["data-wd"]}.${item.id}`,
            "aria-label": item.id,
            "data-state": value === item.id ? "hinted" : void 0,
            title: title + " \u2014 " + msg2(`${styleType}-style.${item.id}`),
            className: (0, import_classnames15.default)("tlui-button-grid__button"),
            style: item.type === "color" ? { color: `var(--palette-${item.id})` } : void 0,
            onPointerEnter: handleButtonPointerEnter,
            onPointerDown: handleButtonPointerDown,
            onPointerUp: handleButtonPointerUp,
            onClick: handleButtonClick,
            icon: item.icon
          },
          item.id
        ))
      }
    );
  }
  var ButtonPicker = React62.memo(_ButtonPicker);

  // ../../../node_modules/@radix-ui/react-slider/dist/index.module.js
  var import_react103 = __toESM(require_react());

  // ../../../node_modules/@radix-ui/number/dist/index.module.js
  function $ae6933e535247d3d$export$7d15b64cf5a3a4c4(value, [min2, max]) {
    return Math.min(max, Math.max(min2, value));
  }

  // ../../../node_modules/@radix-ui/react-use-previous/dist/index.module.js
  var import_react102 = __toESM(require_react());
  function $010c2913dbd2fe3d$export$5cae361ad82dce8b(value) {
    const ref = (0, import_react102.useRef)({
      value,
      previous: value
    });
    return (0, import_react102.useMemo)(() => {
      if (ref.current.value !== value) {
        ref.current.previous = ref.current.value;
        ref.current.value = value;
      }
      return ref.current.previous;
    }, [
      value
    ]);
  }

  // ../../../node_modules/@radix-ui/react-slider/dist/index.module.js
  var $faa2e61a3361514f$var$PAGE_KEYS = [
    "PageUp",
    "PageDown"
  ];
  var $faa2e61a3361514f$var$ARROW_KEYS = [
    "ArrowUp",
    "ArrowDown",
    "ArrowLeft",
    "ArrowRight"
  ];
  var $faa2e61a3361514f$var$BACK_KEYS = {
    "from-left": [
      "Home",
      "PageDown",
      "ArrowDown",
      "ArrowLeft"
    ],
    "from-right": [
      "Home",
      "PageDown",
      "ArrowDown",
      "ArrowRight"
    ],
    "from-bottom": [
      "Home",
      "PageDown",
      "ArrowDown",
      "ArrowLeft"
    ],
    "from-top": [
      "Home",
      "PageDown",
      "ArrowUp",
      "ArrowLeft"
    ]
  };
  var $faa2e61a3361514f$var$SLIDER_NAME = "Slider";
  var [$faa2e61a3361514f$var$Collection, $faa2e61a3361514f$var$useCollection, $faa2e61a3361514f$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($faa2e61a3361514f$var$SLIDER_NAME);
  var [$faa2e61a3361514f$var$createSliderContext, $faa2e61a3361514f$export$ef72632d7b901f97] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($faa2e61a3361514f$var$SLIDER_NAME, [
    $faa2e61a3361514f$var$createCollectionScope
  ]);
  var [$faa2e61a3361514f$var$SliderProvider, $faa2e61a3361514f$var$useSliderContext] = $faa2e61a3361514f$var$createSliderContext($faa2e61a3361514f$var$SLIDER_NAME);
  var $faa2e61a3361514f$export$472062a354075cee = /* @__PURE__ */ (0, import_react103.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { name, min: min2 = 0, max = 100, step = 1, orientation = "horizontal", disabled = false, minStepsBetweenThumbs = 0, defaultValue = [
      min2
    ], value: value1, onValueChange = () => {
    }, onValueCommit = () => {
    }, inverted = false } = _a5, sliderProps = __objRest(_a5, ["name", "min", "max", "step", "orientation", "disabled", "minStepsBetweenThumbs", "defaultValue", "value", "onValueChange", "onValueCommit", "inverted"]);
    const [slider, setSlider] = (0, import_react103.useState)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
      forwardedRef,
      (node) => setSlider(node)
    );
    const thumbRefs = (0, import_react103.useRef)(/* @__PURE__ */ new Set());
    const valueIndexToChangeRef = (0, import_react103.useRef)(0);
    const isHorizontal = orientation === "horizontal";
    const isFormControl = slider ? Boolean(slider.closest("form")) : true;
    const SliderOrientation = isHorizontal ? $faa2e61a3361514f$var$SliderHorizontal : $faa2e61a3361514f$var$SliderVertical;
    const [values = [], setValues] = $71cd76cc60e0454e$export$6f32135080cb4c3({
      prop: value1,
      defaultProp: defaultValue,
      onChange: (value) => {
        var _thumbs$valueIndexToC;
        const thumbs = [
          ...thumbRefs.current
        ];
        (_thumbs$valueIndexToC = thumbs[valueIndexToChangeRef.current]) === null || _thumbs$valueIndexToC === void 0 || _thumbs$valueIndexToC.focus();
        onValueChange(value);
      }
    });
    const valuesBeforeSlideStartRef = (0, import_react103.useRef)(values);
    function handleSlideStart(value) {
      const closestIndex = $faa2e61a3361514f$var$getClosestValueIndex(values, value);
      updateValues(value, closestIndex);
    }
    function handleSlideMove(value) {
      updateValues(value, valueIndexToChangeRef.current);
    }
    function handleSlideEnd() {
      const prevValue = valuesBeforeSlideStartRef.current[valueIndexToChangeRef.current];
      const nextValue = values[valueIndexToChangeRef.current];
      const hasChanged = nextValue !== prevValue;
      if (hasChanged)
        onValueCommit(values);
    }
    function updateValues(value, atIndex, { commit } = {
      commit: false
    }) {
      const decimalCount = $faa2e61a3361514f$var$getDecimalCount(step);
      const snapToStep = $faa2e61a3361514f$var$roundValue(Math.round((value - min2) / step) * step + min2, decimalCount);
      const nextValue = $ae6933e535247d3d$export$7d15b64cf5a3a4c4(snapToStep, [
        min2,
        max
      ]);
      setValues((prevValues = []) => {
        const nextValues = $faa2e61a3361514f$var$getNextSortedValues(prevValues, nextValue, atIndex);
        if ($faa2e61a3361514f$var$hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {
          valueIndexToChangeRef.current = nextValues.indexOf(nextValue);
          const hasChanged = String(nextValues) !== String(prevValues);
          if (hasChanged && commit)
            onValueCommit(nextValues);
          return hasChanged ? nextValues : prevValues;
        } else
          return prevValues;
      });
    }
    return /* @__PURE__ */ (0, import_react103.createElement)($faa2e61a3361514f$var$SliderProvider, {
      scope: props.__scopeSlider,
      disabled,
      min: min2,
      max,
      valueIndexToChangeRef,
      thumbs: thumbRefs.current,
      values,
      orientation
    }, /* @__PURE__ */ (0, import_react103.createElement)($faa2e61a3361514f$var$Collection.Provider, {
      scope: props.__scopeSlider
    }, /* @__PURE__ */ (0, import_react103.createElement)($faa2e61a3361514f$var$Collection.Slot, {
      scope: props.__scopeSlider
    }, /* @__PURE__ */ (0, import_react103.createElement)(SliderOrientation, _extends({
      "aria-disabled": disabled,
      "data-disabled": disabled ? "" : void 0
    }, sliderProps, {
      ref: composedRefs,
      onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(sliderProps.onPointerDown, () => {
        if (!disabled)
          valuesBeforeSlideStartRef.current = values;
      }),
      min: min2,
      max,
      inverted,
      onSlideStart: disabled ? void 0 : handleSlideStart,
      onSlideMove: disabled ? void 0 : handleSlideMove,
      onSlideEnd: disabled ? void 0 : handleSlideEnd,
      onHomeKeyDown: () => !disabled && updateValues(min2, 0, {
        commit: true
      }),
      onEndKeyDown: () => !disabled && updateValues(max, values.length - 1, {
        commit: true
      }),
      onStepKeyDown: ({ event, direction: stepDirection }) => {
        if (!disabled) {
          const isPageKey = $faa2e61a3361514f$var$PAGE_KEYS.includes(event.key);
          const isSkipKey = isPageKey || event.shiftKey && $faa2e61a3361514f$var$ARROW_KEYS.includes(event.key);
          const multiplier = isSkipKey ? 10 : 1;
          const atIndex = valueIndexToChangeRef.current;
          const value = values[atIndex];
          const stepInDirection = step * multiplier * stepDirection;
          updateValues(value + stepInDirection, atIndex, {
            commit: true
          });
        }
      }
    })))), isFormControl && values.map(
      (value, index2) => /* @__PURE__ */ (0, import_react103.createElement)($faa2e61a3361514f$var$BubbleInput, {
        key: index2,
        name: name ? name + (values.length > 1 ? "[]" : "") : void 0,
        value
      })
    ));
  });
  var [$faa2e61a3361514f$var$SliderOrientationProvider, $faa2e61a3361514f$var$useSliderOrientationContext] = $faa2e61a3361514f$var$createSliderContext($faa2e61a3361514f$var$SLIDER_NAME, {
    startEdge: "left",
    endEdge: "right",
    size: "width",
    direction: 1
  });
  var $faa2e61a3361514f$var$SliderHorizontal = /* @__PURE__ */ (0, import_react103.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { min: min2, max, dir, inverted, onSlideStart, onSlideMove, onSlideEnd, onStepKeyDown } = _a5, sliderProps = __objRest(_a5, ["min", "max", "dir", "inverted", "onSlideStart", "onSlideMove", "onSlideEnd", "onStepKeyDown"]);
    const [slider, setSlider] = (0, import_react103.useState)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
      forwardedRef,
      (node) => setSlider(node)
    );
    const rectRef = (0, import_react103.useRef)();
    const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
    const isDirectionLTR = direction === "ltr";
    const isSlidingFromLeft = isDirectionLTR && !inverted || !isDirectionLTR && inverted;
    function getValueFromPointer(pointerPosition) {
      const rect = rectRef.current || slider.getBoundingClientRect();
      const input = [
        0,
        rect.width
      ];
      const output = isSlidingFromLeft ? [
        min2,
        max
      ] : [
        max,
        min2
      ];
      const value = $faa2e61a3361514f$var$linearScale(input, output);
      rectRef.current = rect;
      return value(pointerPosition - rect.left);
    }
    return /* @__PURE__ */ (0, import_react103.createElement)($faa2e61a3361514f$var$SliderOrientationProvider, {
      scope: props.__scopeSlider,
      startEdge: isSlidingFromLeft ? "left" : "right",
      endEdge: isSlidingFromLeft ? "right" : "left",
      direction: isSlidingFromLeft ? 1 : -1,
      size: "width"
    }, /* @__PURE__ */ (0, import_react103.createElement)($faa2e61a3361514f$var$SliderImpl, _extends({
      dir: direction,
      "data-orientation": "horizontal"
    }, sliderProps, {
      ref: composedRefs,
      style: __spreadProps(__spreadValues({}, sliderProps.style), {
        ["--radix-slider-thumb-transform"]: "translateX(-50%)"
      }),
      onSlideStart: (event) => {
        const value = getValueFromPointer(event.clientX);
        onSlideStart === null || onSlideStart === void 0 || onSlideStart(value);
      },
      onSlideMove: (event) => {
        const value = getValueFromPointer(event.clientX);
        onSlideMove === null || onSlideMove === void 0 || onSlideMove(value);
      },
      onSlideEnd: () => {
        rectRef.current = void 0;
        onSlideEnd === null || onSlideEnd === void 0 || onSlideEnd();
      },
      onStepKeyDown: (event) => {
        const slideDirection = isSlidingFromLeft ? "from-left" : "from-right";
        const isBackKey = $faa2e61a3361514f$var$BACK_KEYS[slideDirection].includes(event.key);
        onStepKeyDown === null || onStepKeyDown === void 0 || onStepKeyDown({
          event,
          direction: isBackKey ? -1 : 1
        });
      }
    })));
  });
  var $faa2e61a3361514f$var$SliderVertical = /* @__PURE__ */ (0, import_react103.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { min: min2, max, inverted, onSlideStart, onSlideMove, onSlideEnd, onStepKeyDown } = _a5, sliderProps = __objRest(_a5, ["min", "max", "inverted", "onSlideStart", "onSlideMove", "onSlideEnd", "onStepKeyDown"]);
    const sliderRef = (0, import_react103.useRef)(null);
    const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, sliderRef);
    const rectRef = (0, import_react103.useRef)();
    const isSlidingFromBottom = !inverted;
    function getValueFromPointer(pointerPosition) {
      const rect = rectRef.current || sliderRef.current.getBoundingClientRect();
      const input = [
        0,
        rect.height
      ];
      const output = isSlidingFromBottom ? [
        max,
        min2
      ] : [
        min2,
        max
      ];
      const value = $faa2e61a3361514f$var$linearScale(input, output);
      rectRef.current = rect;
      return value(pointerPosition - rect.top);
    }
    return /* @__PURE__ */ (0, import_react103.createElement)($faa2e61a3361514f$var$SliderOrientationProvider, {
      scope: props.__scopeSlider,
      startEdge: isSlidingFromBottom ? "bottom" : "top",
      endEdge: isSlidingFromBottom ? "top" : "bottom",
      size: "height",
      direction: isSlidingFromBottom ? 1 : -1
    }, /* @__PURE__ */ (0, import_react103.createElement)($faa2e61a3361514f$var$SliderImpl, _extends({
      "data-orientation": "vertical"
    }, sliderProps, {
      ref,
      style: __spreadProps(__spreadValues({}, sliderProps.style), {
        ["--radix-slider-thumb-transform"]: "translateY(50%)"
      }),
      onSlideStart: (event) => {
        const value = getValueFromPointer(event.clientY);
        onSlideStart === null || onSlideStart === void 0 || onSlideStart(value);
      },
      onSlideMove: (event) => {
        const value = getValueFromPointer(event.clientY);
        onSlideMove === null || onSlideMove === void 0 || onSlideMove(value);
      },
      onSlideEnd: () => {
        rectRef.current = void 0;
        onSlideEnd === null || onSlideEnd === void 0 || onSlideEnd();
      },
      onStepKeyDown: (event) => {
        const slideDirection = isSlidingFromBottom ? "from-bottom" : "from-top";
        const isBackKey = $faa2e61a3361514f$var$BACK_KEYS[slideDirection].includes(event.key);
        onStepKeyDown === null || onStepKeyDown === void 0 || onStepKeyDown({
          event,
          direction: isBackKey ? -1 : 1
        });
      }
    })));
  });
  var $faa2e61a3361514f$var$SliderImpl = /* @__PURE__ */ (0, import_react103.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeSlider, onSlideStart, onSlideMove, onSlideEnd, onHomeKeyDown, onEndKeyDown, onStepKeyDown } = _a5, sliderProps = __objRest(_a5, ["__scopeSlider", "onSlideStart", "onSlideMove", "onSlideEnd", "onHomeKeyDown", "onEndKeyDown", "onStepKeyDown"]);
    const context = $faa2e61a3361514f$var$useSliderContext($faa2e61a3361514f$var$SLIDER_NAME, __scopeSlider);
    return /* @__PURE__ */ (0, import_react103.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({}, sliderProps, {
      ref: forwardedRef,
      onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
        if (event.key === "Home") {
          onHomeKeyDown(event);
          event.preventDefault();
        } else if (event.key === "End") {
          onEndKeyDown(event);
          event.preventDefault();
        } else if ($faa2e61a3361514f$var$PAGE_KEYS.concat($faa2e61a3361514f$var$ARROW_KEYS).includes(event.key)) {
          onStepKeyDown(event);
          event.preventDefault();
        }
      }),
      onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDown, (event) => {
        const target = event.target;
        target.setPointerCapture(event.pointerId);
        event.preventDefault();
        if (context.thumbs.has(target))
          target.focus();
        else
          onSlideStart(event);
      }),
      onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, (event) => {
        const target = event.target;
        if (target.hasPointerCapture(event.pointerId))
          onSlideMove(event);
      }),
      onPointerUp: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerUp, (event) => {
        const target = event.target;
        if (target.hasPointerCapture(event.pointerId)) {
          target.releasePointerCapture(event.pointerId);
          onSlideEnd(event);
        }
      })
    }));
  });
  var $faa2e61a3361514f$var$TRACK_NAME = "SliderTrack";
  var $faa2e61a3361514f$export$105594979f116971 = /* @__PURE__ */ (0, import_react103.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeSlider } = _a5, trackProps = __objRest(_a5, ["__scopeSlider"]);
    const context = $faa2e61a3361514f$var$useSliderContext($faa2e61a3361514f$var$TRACK_NAME, __scopeSlider);
    return /* @__PURE__ */ (0, import_react103.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({
      "data-disabled": context.disabled ? "" : void 0,
      "data-orientation": context.orientation
    }, trackProps, {
      ref: forwardedRef
    }));
  });
  var $faa2e61a3361514f$var$RANGE_NAME = "SliderRange";
  var $faa2e61a3361514f$export$a5cf38a7a000fe77 = /* @__PURE__ */ (0, import_react103.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeSlider } = _a5, rangeProps = __objRest(_a5, ["__scopeSlider"]);
    const context = $faa2e61a3361514f$var$useSliderContext($faa2e61a3361514f$var$RANGE_NAME, __scopeSlider);
    const orientation = $faa2e61a3361514f$var$useSliderOrientationContext($faa2e61a3361514f$var$RANGE_NAME, __scopeSlider);
    const ref = (0, import_react103.useRef)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(forwardedRef, ref);
    const valuesCount = context.values.length;
    const percentages = context.values.map(
      (value) => $faa2e61a3361514f$var$convertValueToPercentage(value, context.min, context.max)
    );
    const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;
    const offsetEnd = 100 - Math.max(...percentages);
    return /* @__PURE__ */ (0, import_react103.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({
      "data-orientation": context.orientation,
      "data-disabled": context.disabled ? "" : void 0
    }, rangeProps, {
      ref: composedRefs,
      style: __spreadProps(__spreadValues({}, props.style), {
        [orientation.startEdge]: offsetStart + "%",
        [orientation.endEdge]: offsetEnd + "%"
      })
    }));
  });
  var $faa2e61a3361514f$var$THUMB_NAME = "SliderThumb";
  var $faa2e61a3361514f$export$2c1b491743890dec = /* @__PURE__ */ (0, import_react103.forwardRef)((props, forwardedRef) => {
    const getItems = $faa2e61a3361514f$var$useCollection(props.__scopeSlider);
    const [thumb, setThumb] = (0, import_react103.useState)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
      forwardedRef,
      (node) => setThumb(node)
    );
    const index2 = (0, import_react103.useMemo)(
      () => thumb ? getItems().findIndex(
        (item) => item.ref.current === thumb
      ) : -1,
      [
        getItems,
        thumb
      ]
    );
    return /* @__PURE__ */ (0, import_react103.createElement)($faa2e61a3361514f$var$SliderThumbImpl, _extends({}, props, {
      ref: composedRefs,
      index: index2
    }));
  });
  var $faa2e61a3361514f$var$SliderThumbImpl = /* @__PURE__ */ (0, import_react103.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeSlider, index: index2 } = _a5, thumbProps = __objRest(_a5, ["__scopeSlider", "index"]);
    const context = $faa2e61a3361514f$var$useSliderContext($faa2e61a3361514f$var$THUMB_NAME, __scopeSlider);
    const orientation = $faa2e61a3361514f$var$useSliderOrientationContext($faa2e61a3361514f$var$THUMB_NAME, __scopeSlider);
    const [thumb, setThumb] = (0, import_react103.useState)(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(
      forwardedRef,
      (node) => setThumb(node)
    );
    const size = $db6c3485150b8e66$export$1ab7ae714698c4b8(thumb);
    const value = context.values[index2];
    const percent = value === void 0 ? 0 : $faa2e61a3361514f$var$convertValueToPercentage(value, context.min, context.max);
    const label = $faa2e61a3361514f$var$getLabel(index2, context.values.length);
    const orientationSize = size === null || size === void 0 ? void 0 : size[orientation.size];
    const thumbInBoundsOffset = orientationSize ? $faa2e61a3361514f$var$getThumbInBoundsOffset(orientationSize, percent, orientation.direction) : 0;
    (0, import_react103.useEffect)(() => {
      if (thumb) {
        context.thumbs.add(thumb);
        return () => {
          context.thumbs.delete(thumb);
        };
      }
    }, [
      thumb,
      context.thumbs
    ]);
    return /* @__PURE__ */ (0, import_react103.createElement)("span", {
      style: {
        transform: "var(--radix-slider-thumb-transform)",
        position: "absolute",
        [orientation.startEdge]: `calc(${percent}% + ${thumbInBoundsOffset}px)`
      }
    }, /* @__PURE__ */ (0, import_react103.createElement)($faa2e61a3361514f$var$Collection.ItemSlot, {
      scope: props.__scopeSlider
    }, /* @__PURE__ */ (0, import_react103.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({
      role: "slider",
      "aria-label": props["aria-label"] || label,
      "aria-valuemin": context.min,
      "aria-valuenow": value,
      "aria-valuemax": context.max,
      "aria-orientation": context.orientation,
      "data-orientation": context.orientation,
      "data-disabled": context.disabled ? "" : void 0,
      tabIndex: context.disabled ? void 0 : 0
    }, thumbProps, {
      ref: composedRefs,
      style: value === void 0 ? {
        display: "none"
      } : props.style,
      onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, () => {
        context.valueIndexToChangeRef.current = index2;
      })
    }))));
  });
  var $faa2e61a3361514f$var$BubbleInput = (props) => {
    const _a5 = props, { value } = _a5, inputProps = __objRest(_a5, ["value"]);
    const ref = (0, import_react103.useRef)(null);
    const prevValue = $010c2913dbd2fe3d$export$5cae361ad82dce8b(value);
    (0, import_react103.useEffect)(() => {
      const input = ref.current;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(inputProto, "value");
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const event = new Event("input", {
          bubbles: true
        });
        setValue.call(input, value);
        input.dispatchEvent(event);
      }
    }, [
      prevValue,
      value
    ]);
    return /* @__PURE__ */ (0, import_react103.createElement)("input", _extends({
      style: {
        display: "none"
      }
    }, inputProps, {
      ref,
      defaultValue: value
    }));
  };
  function $faa2e61a3361514f$var$getNextSortedValues(prevValues = [], nextValue, atIndex) {
    const nextValues = [
      ...prevValues
    ];
    nextValues[atIndex] = nextValue;
    return nextValues.sort(
      (a3, b3) => a3 - b3
    );
  }
  function $faa2e61a3361514f$var$convertValueToPercentage(value, min2, max) {
    const maxSteps = max - min2;
    const percentPerStep = 100 / maxSteps;
    return percentPerStep * (value - min2);
  }
  function $faa2e61a3361514f$var$getLabel(index2, totalValues) {
    if (totalValues > 2)
      return `Value ${index2 + 1} of ${totalValues}`;
    else if (totalValues === 2)
      return [
        "Minimum",
        "Maximum"
      ][index2];
    else
      return void 0;
  }
  function $faa2e61a3361514f$var$getClosestValueIndex(values, nextValue) {
    if (values.length === 1)
      return 0;
    const distances = values.map(
      (value) => Math.abs(value - nextValue)
    );
    const closestDistance = Math.min(...distances);
    return distances.indexOf(closestDistance);
  }
  function $faa2e61a3361514f$var$getThumbInBoundsOffset(width, left, direction) {
    const halfWidth = width / 2;
    const halfPercent = 50;
    const offset = $faa2e61a3361514f$var$linearScale([
      0,
      halfPercent
    ], [
      0,
      halfWidth
    ]);
    return (halfWidth - offset(left) * direction) * direction;
  }
  function $faa2e61a3361514f$var$getStepsBetweenValues(values) {
    return values.slice(0, -1).map(
      (value, index2) => values[index2 + 1] - value
    );
  }
  function $faa2e61a3361514f$var$hasMinStepsBetweenValues(values, minStepsBetweenValues) {
    if (minStepsBetweenValues > 0) {
      const stepsBetweenValues = $faa2e61a3361514f$var$getStepsBetweenValues(values);
      const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);
      return actualMinStepsBetweenValues >= minStepsBetweenValues;
    }
    return true;
  }
  function $faa2e61a3361514f$var$linearScale(input, output) {
    return (value) => {
      if (input[0] === input[1] || output[0] === output[1])
        return output[0];
      const ratio = (output[1] - output[0]) / (input[1] - input[0]);
      return output[0] + ratio * (value - input[0]);
    };
  }
  function $faa2e61a3361514f$var$getDecimalCount(value) {
    return (String(value).split(".")[1] || "").length;
  }
  function $faa2e61a3361514f$var$roundValue(value, decimalCount) {
    const rounder = Math.pow(10, decimalCount);
    return Math.round(value * rounder) / rounder;
  }
  var $faa2e61a3361514f$export$be92b6f5f03c0fe9 = $faa2e61a3361514f$export$472062a354075cee;
  var $faa2e61a3361514f$export$13921ac0cc260818 = $faa2e61a3361514f$export$105594979f116971;
  var $faa2e61a3361514f$export$9a58ef0d7ad3278c = $faa2e61a3361514f$export$a5cf38a7a000fe77;
  var $faa2e61a3361514f$export$6521433ed15a34db = $faa2e61a3361514f$export$2c1b491743890dec;

  // ../../../packages/ui/src/lib/components/primitives/Slider.tsx
  var import_react104 = __toESM(require_react());
  var import_jsx_runtime102 = __toESM(require_jsx_runtime());
  function Slider(props) {
    const { title, steps, value, label, onValueChange } = props;
    const app = useApp();
    const msg2 = useTranslation();
    const handleValueChange = (0, import_react104.useCallback)(
      (value2) => {
        onValueChange(value2[0], true);
      },
      [onValueChange]
    );
    const handlePointerDown = (0, import_react104.useCallback)(() => {
      app.mark("click slider");
    }, [app]);
    const handlePointerUp = (0, import_react104.useCallback)(() => {
      if (!value)
        return;
      onValueChange(value, false);
    }, [value, onValueChange]);
    return /* @__PURE__ */ (0, import_jsx_runtime102.jsx)("div", { className: "tlui-slider__container", children: /* @__PURE__ */ (0, import_jsx_runtime102.jsxs)(
      $faa2e61a3361514f$export$be92b6f5f03c0fe9,
      {
        "data-wd": props["data-wd"],
        className: "tlui-slider",
        "area-label": "Opacity",
        dir: "ltr",
        min: 0,
        max: steps,
        step: 1,
        value: value ? [value] : void 0,
        onPointerDown: handlePointerDown,
        onValueChange: handleValueChange,
        onPointerUp: handlePointerUp,
        title: title + " \u2014 " + msg2(label),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime102.jsx)($faa2e61a3361514f$export$13921ac0cc260818, { className: "tlui-slider__track", dir: "ltr", children: value !== null && /* @__PURE__ */ (0, import_jsx_runtime102.jsx)($faa2e61a3361514f$export$9a58ef0d7ad3278c, { className: "tlui-slider__range", dir: "ltr" }) }),
          value !== null && /* @__PURE__ */ (0, import_jsx_runtime102.jsx)($faa2e61a3361514f$export$6521433ed15a34db, { className: "tlui-slider__thumb", dir: "ltr" })
        ]
      }
    ) });
  }

  // ../../../packages/ui/src/lib/components/StylePanel/DoubleDropdownPicker.tsx
  var import_classnames16 = __toESM(require_classnames());
  var React63 = __toESM(require_react());
  var import_jsx_runtime103 = __toESM(require_jsx_runtime());
  var DoubleDropdownPicker = React63.memo(function DoubleDropdownPicker2({
    "data-wd": dataWd,
    label,
    labelA,
    labelB,
    itemsA,
    itemsB,
    styleTypeA,
    styleTypeB,
    valueA,
    valueB,
    onValueChange
  }) {
    const msg2 = useTranslation();
    const iconA = React63.useMemo(
      () => {
        var _a5, _b2;
        return (_b2 = (_a5 = itemsA.find((item) => item.id === valueA)) == null ? void 0 : _a5.icon) != null ? _b2 : "mixed";
      },
      [itemsA, valueA]
    );
    const iconB = React63.useMemo(
      () => {
        var _a5, _b2;
        return (_b2 = (_a5 = itemsB.find((item) => item.id === valueB)) == null ? void 0 : _a5.icon) != null ? _b2 : "mixed";
      },
      [itemsB, valueB]
    );
    if (valueA === void 0 && valueB === void 0)
      return null;
    const startWdPrefix = `${dataWd}.start`;
    const endWdPrefix = `${dataWd}.end`;
    return /* @__PURE__ */ (0, import_jsx_runtime103.jsxs)("div", { className: "tlui-style-panel__double-select-picker", children: [
      /* @__PURE__ */ (0, import_jsx_runtime103.jsx)("div", { title: msg2(label), className: "tlui-style-panel__double-select-picker-label", children: msg2(label) }),
      /* @__PURE__ */ (0, import_jsx_runtime103.jsxs)(Root, { id: `style panel ${styleTypeA}`, children: [
        /* @__PURE__ */ (0, import_jsx_runtime103.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(
          Button,
          {
            "data-wd": startWdPrefix,
            title: msg2(labelA) + " \u2014 " + (valueA === null ? msg2("style-panel.mixed") : msg2(`${styleTypeA}-style.${valueA}`)),
            icon: iconA,
            invertIcon: true,
            smallIcon: true
          }
        ) }),
        /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(Content, { side: "bottom", align: "end", sideOffset: 0, alignOffset: -2, children: /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(
          "div",
          {
            className: (0, import_classnames16.default)("tlui-button-grid", {
              "tlui-button-grid__two": itemsA.length < 4,
              "tlui-button-grid__four": itemsA.length >= 4
            }),
            children: itemsA.map((item) => {
              return /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(
                Item,
                {
                  className: "tlui-button-grid__button",
                  title: msg2(labelA) + " \u2014 " + msg2(`${styleTypeA}-style.${item.id}`),
                  "data-wd": `${startWdPrefix}.${item.id}`,
                  icon: item.icon,
                  onClick: () => onValueChange(item, false),
                  invertIcon: true
                },
                item.id
              );
            })
          }
        ) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime103.jsxs)(Root, { id: `style panel ${styleTypeB}`, children: [
        /* @__PURE__ */ (0, import_jsx_runtime103.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(
          Button,
          {
            "data-wd": endWdPrefix,
            title: msg2(labelB) + " \u2014 " + (valueB === null ? msg2("style-panel.mixed") : msg2(`${styleTypeB}-style.${valueB}`)),
            icon: iconB,
            smallIcon: true
          }
        ) }),
        /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(Content, { side: "bottom", align: "end", sideOffset: 0, alignOffset: -2, children: /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(
          "div",
          {
            className: (0, import_classnames16.default)("tlui-button-grid", {
              "tlui-button-grid__two": itemsA.length < 4,
              "tlui-button-grid__four": itemsA.length >= 4
            }),
            children: itemsB.map((item) => {
              return /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(
                Item,
                {
                  className: "tlui-button-grid__button",
                  title: msg2(labelB) + " \u2014 " + msg2(`${styleTypeB}-style.${item.id}`),
                  "data-wd": `${endWdPrefix}.${item.id}`,
                  icon: item.icon,
                  onClick: () => onValueChange(item, false)
                },
                item.id
              );
            })
          }
        ) })
      ] })
    ] });
  });

  // ../../../packages/ui/src/lib/components/StylePanel/DropdownPicker.tsx
  var import_classnames17 = __toESM(require_classnames());
  var React64 = __toESM(require_react());
  var import_jsx_runtime104 = __toESM(require_jsx_runtime());
  var DropdownPicker = React64.memo(function DropdownPicker2({
    id,
    items,
    styleType,
    label,
    value,
    onValueChange,
    "data-wd": dataWd
  }) {
    const msg2 = useTranslation();
    const icon = React64.useMemo(() => {
      var _a5;
      return (_a5 = items.find((item) => item.id === value)) == null ? void 0 : _a5.icon;
    }, [items, value]);
    return /* @__PURE__ */ (0, import_jsx_runtime104.jsxs)(Root, { id: `style panel ${id}`, children: [
      /* @__PURE__ */ (0, import_jsx_runtime104.jsx)($d08ef79370b62062$export$41fb9f06171c75f4, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime104.jsx)(
        Button,
        {
          "data-wd": dataWd,
          title: value === null ? msg2("style-panel.mixed") : msg2(`${styleType}-style.${value}`),
          label,
          icon: icon != null ? icon : "mixed"
        }
      ) }),
      /* @__PURE__ */ (0, import_jsx_runtime104.jsx)(Content, { side: "left", align: "center", alignOffset: 0, children: /* @__PURE__ */ (0, import_jsx_runtime104.jsx)(
        "div",
        {
          className: (0, import_classnames17.default)("tlui-button-grid", {
            "tlui-button-grid__two": items.length < 4,
            "tlui-button-grid__four": items.length >= 4
          }),
          children: items.map((item) => {
            return /* @__PURE__ */ (0, import_jsx_runtime104.jsx)(
              Item,
              {
                className: "tlui-button-grid__button",
                "data-wd": `${dataWd}.${item.id}`,
                title: msg2(`${styleType}-style.${item.id}`),
                icon: item.icon,
                onClick: () => onValueChange(item, false)
              },
              item.id
            );
          })
        }
      ) })
    ] });
  });

  // ../../../packages/ui/src/lib/components/StylePanel/StylePanel.tsx
  var import_jsx_runtime105 = __toESM(require_jsx_runtime());
  var StylePanel = function StylePanel2({ isMobile }) {
    const app = useApp();
    const props = useValue("props", () => app.props, [app]);
    const handlePointerOut = (0, import_react105.useCallback)(() => {
      if (!isMobile) {
        app.isChangingStyle = false;
      }
    }, [app, isMobile]);
    if (!props)
      return null;
    const { geo, arrowheadEnd, arrowheadStart, spline, font } = props;
    const hideGeo = geo === void 0;
    const hideArrowHeads = arrowheadEnd === void 0 && arrowheadStart === void 0;
    const hideSpline = spline === void 0;
    const hideText = font === void 0;
    return /* @__PURE__ */ (0, import_jsx_runtime105.jsxs)("div", { className: "tlui-style-panel", "data-ismobile": isMobile, onPointerLeave: handlePointerOut, children: [
      /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(CommonStylePickerSet, { props }),
      !hideText && /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(TextStylePickerSet, { props }),
      !(hideGeo && hideArrowHeads && hideSpline) && /* @__PURE__ */ (0, import_jsx_runtime105.jsxs)("div", { className: "tlui-style-panel__section", "aria-label": "style panel styles", children: [
        /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(GeoStylePickerSet, { props }),
        /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(ArrowheadStylePickerSet, { props }),
        /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(SplineStylePickerSet, { props })
      ] })
    ] });
  };
  var { styles } = App;
  function useStyleChangeCallback() {
    const app = useApp();
    return import_react105.default.useCallback(
      (item, squashing) => {
        app.batch(() => {
          app.setProp(item.type, item.id, false, squashing);
          app.isChangingStyle = true;
        });
      },
      [app]
    );
  }
  function CommonStylePickerSet({ props }) {
    const app = useApp();
    const msg2 = useTranslation();
    const handleValueChange = useStyleChangeCallback();
    const handleOpacityValueChange = import_react105.default.useCallback(
      (value, ephemeral) => {
        const item = styles.opacity[value];
        app.setProp(item.type, item.id, ephemeral);
        app.isChangingStyle = true;
      },
      [app]
    );
    const { color, fill, dash, size, opacity } = props;
    if (color === void 0 && fill === void 0 && dash === void 0 && size === void 0 && opacity === void 0) {
      return null;
    }
    const showPickers = fill || dash || size;
    const opacityIndex = styles.opacity.findIndex((s3) => s3.id === opacity);
    return /* @__PURE__ */ (0, import_jsx_runtime105.jsxs)(import_jsx_runtime105.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime105.jsxs)("div", { className: "tlui-style-panel__section__common", "aria-label": "style panel styles", children: [
        color === void 0 ? null : /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
          ButtonPicker,
          {
            title: msg2("style-panel.color"),
            styleType: "color",
            "data-wd": "style.color",
            items: styles.color,
            value: color,
            onValueChange: handleValueChange
          }
        ),
        opacity === void 0 ? null : /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
          Slider,
          {
            "data-wd": "style.opacity",
            value: opacityIndex >= 0 ? opacityIndex : styles.opacity.length - 1,
            label: opacity ? `opacity-style.${opacity}` : "style-panel.mixed",
            onValueChange: handleOpacityValueChange,
            steps: styles.opacity.length - 1,
            title: msg2("style-panel.opacity")
          }
        )
      ] }),
      showPickers && /* @__PURE__ */ (0, import_jsx_runtime105.jsxs)("div", { className: "tlui-style-panel__section", "aria-label": "style panel styles", children: [
        fill === void 0 ? null : /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
          ButtonPicker,
          {
            title: msg2("style-panel.fill"),
            styleType: "fill",
            "data-wd": "style.fill",
            items: styles.fill,
            value: fill,
            onValueChange: handleValueChange
          }
        ),
        dash === void 0 ? null : /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
          ButtonPicker,
          {
            title: msg2("style-panel.dash"),
            styleType: "dash",
            "data-wd": "style.dash",
            items: styles.dash,
            value: dash,
            onValueChange: handleValueChange
          }
        ),
        size === void 0 ? null : /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
          ButtonPicker,
          {
            title: msg2("style-panel.size"),
            styleType: "size",
            "data-wd": "style.size",
            items: styles.size,
            value: size,
            onValueChange: handleValueChange
          }
        )
      ] })
    ] });
  }
  function TextStylePickerSet({ props }) {
    const msg2 = useTranslation();
    const handleValueChange = useStyleChangeCallback();
    const { font, align } = props;
    if (font === void 0 && align === void 0) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime105.jsxs)("div", { className: "tlui-style-panel__section", "aria-label": "style panel text", children: [
      font === void 0 ? null : /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
        ButtonPicker,
        {
          title: msg2("style-panel.font"),
          styleType: "font",
          "data-wd": "font",
          items: styles.font,
          value: font,
          onValueChange: handleValueChange
        }
      ),
      align === void 0 ? null : /* @__PURE__ */ (0, import_jsx_runtime105.jsxs)("div", { className: "tlui-style-panel__row", children: [
        /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
          ButtonPicker,
          {
            title: msg2("style-panel.align"),
            styleType: "align",
            "data-wd": "align",
            items: styles.align,
            value: align,
            onValueChange: handleValueChange
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
          Button,
          {
            title: msg2("style-panel.position"),
            "data-wd": "position",
            icon: "align-center-center",
            disabled: true
          }
        )
      ] })
    ] });
  }
  function GeoStylePickerSet({ props }) {
    const handleValueChange = useStyleChangeCallback();
    const { geo } = props;
    if (geo === void 0) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
      DropdownPicker,
      {
        id: "geo",
        label: "style-panel.geo",
        styleType: "geo",
        "data-wd": "style-panel.geo",
        items: styles.geo,
        value: geo,
        onValueChange: handleValueChange
      }
    );
  }
  function SplineStylePickerSet({ props }) {
    const handleValueChange = useStyleChangeCallback();
    const { spline } = props;
    if (spline === void 0) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
      DropdownPicker,
      {
        id: "spline",
        label: "style-panel.spline",
        styleType: "spline",
        "data-wd": "style.spline",
        items: styles.spline,
        value: spline,
        onValueChange: handleValueChange
      }
    );
  }
  function ArrowheadStylePickerSet({ props }) {
    const handleValueChange = useStyleChangeCallback();
    const { arrowheadEnd, arrowheadStart } = props;
    if (arrowheadEnd === void 0 && arrowheadStart === void 0) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(
      DoubleDropdownPicker,
      {
        label: "style-panel.arrowheads",
        styleTypeA: "arrowheadStart",
        "data-wd": "style.arrowheads",
        itemsA: styles.arrowheadStart,
        valueA: arrowheadStart,
        styleTypeB: "arrowheadEnd",
        itemsB: styles.arrowheadEnd,
        valueB: arrowheadEnd,
        onValueChange: handleValueChange,
        labelA: "style-panel.arrowhead-start",
        labelB: "style-panel.arrowhead-end"
      }
    );
  }

  // ../../../packages/ui/src/lib/components/Toasts.tsx
  var React66 = __toESM(require_react());
  var import_jsx_runtime106 = __toESM(require_jsx_runtime());
  function Toast({ toast }) {
    var _a5, _b2;
    const { removeToast } = useToasts();
    const msg2 = useTranslation();
    const onOpenChange = (isOpen) => {
      if (!isOpen) {
        removeToast(toast.id);
      }
    };
    const hasActions = toast.actions && toast.actions.length > 0;
    return /* @__PURE__ */ (0, import_jsx_runtime106.jsxs)(
      $054eb8030ebde76e$export$be92b6f5f03c0fe9,
      {
        onOpenChange,
        className: "tlui-toast__container",
        duration: toast.keepOpen ? Infinity : 5e3,
        children: [
          toast.icon && /* @__PURE__ */ (0, import_jsx_runtime106.jsx)("div", { className: "tlui-toast__icon", children: /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(Icon, { icon: toast.icon }) }),
          /* @__PURE__ */ (0, import_jsx_runtime106.jsxs)("div", { className: "tlui-toast__main", children: [
            /* @__PURE__ */ (0, import_jsx_runtime106.jsxs)("div", { className: "tlui-toast__content", children: [
              /* @__PURE__ */ (0, import_jsx_runtime106.jsx)($054eb8030ebde76e$export$f99233281efd08a0, { className: "tlui-toast__title", children: toast.title }),
              /* @__PURE__ */ (0, import_jsx_runtime106.jsx)($054eb8030ebde76e$export$393edc798c47379d, { className: "tlui-toast__description", children: toast.description })
            ] }),
            toast.actions && /* @__PURE__ */ (0, import_jsx_runtime106.jsxs)("div", { className: "tlui-toast__actions", children: [
              toast.actions.map((action, i3) => /* @__PURE__ */ (0, import_jsx_runtime106.jsx)($054eb8030ebde76e$export$e19cd5f9376f8cee, { altText: action.label, asChild: true, onClick: action.onClick, children: /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(
                Button,
                {
                  className: action.type === "warn" ? "tlui-button__warning" : "tlui-button__primary",
                  children: action.label
                }
              ) }, i3)),
              hasActions && /* @__PURE__ */ (0, import_jsx_runtime106.jsx)($054eb8030ebde76e$export$f39c2d165cd861fe, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(Button, { className: "tlui-toast__close", style: { marginLeft: "auto" }, children: (_a5 = toast.closeLabel) != null ? _a5 : msg2("toast.close") }) })
            ] })
          ] }),
          !hasActions && /* @__PURE__ */ (0, import_jsx_runtime106.jsx)($054eb8030ebde76e$export$f39c2d165cd861fe, { asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(Button, { className: "tlui-toast__close", children: (_b2 = toast.closeLabel) != null ? _b2 : msg2("toast.close") }) })
        ]
      }
    );
  }
  function _Toasts() {
    const { toasts } = useToasts();
    return /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(import_jsx_runtime106.Fragment, { children: toasts.map((toast) => /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(Toast, { toast }, toast.id)) });
  }
  var Toasts = React66.memo(_Toasts);
  function ToastViewport() {
    const { toasts } = useToasts();
    const [hasToasts, setHasToasts] = React66.useState(false);
    React66.useEffect(() => {
      let cancelled = false;
      if (toasts.length) {
        setHasToasts(true);
      } else {
        setTimeout(() => {
          if (!cancelled) {
            setHasToasts(false);
          }
        }, 1e3);
      }
      return () => {
        cancelled = true;
      };
    }, [toasts.length, setHasToasts]);
    if (!hasToasts)
      return null;
    return /* @__PURE__ */ (0, import_jsx_runtime106.jsx)($054eb8030ebde76e$export$6192c2425ecfd989, { className: "tlui-toast__viewport" });
  }

  // ../../../packages/ui/src/lib/components/Toolbar/Toolbar.tsx
  var import_classnames19 = __toESM(require_classnames());
  var import_react107 = __toESM(require_react());

  // ../../../packages/ui/src/lib/components/MobileStylePanel.tsx
  var import_react106 = __toESM(require_react());
  var import_jsx_runtime107 = __toESM(require_jsx_runtime());
  function MobileStylePanel() {
    const app = useApp();
    const msg2 = useTranslation();
    const currentColor = useValue(
      "current color",
      () => {
        const { props } = app;
        return props ? props.color ? app.getCssColor(props.color) : null : "var(--color-muted-1)";
      },
      [app]
    );
    const disableStylePanel = useValue(
      "isHandOrEraserToolActive",
      () => app.isInAny("hand", "zoom", "eraser"),
      [app]
    );
    const handleStylesOpenChange = (0, import_react106.useCallback)(
      (isOpen) => {
        if (!isOpen) {
          app.isChangingStyle = false;
        }
      },
      [app]
    );
    return /* @__PURE__ */ (0, import_jsx_runtime107.jsxs)(Popover, { id: "style menu", onOpenChange: handleStylesOpenChange, children: [
      /* @__PURE__ */ (0, import_jsx_runtime107.jsx)(PopoverTrigger, { disabled: disableStylePanel, children: /* @__PURE__ */ (0, import_jsx_runtime107.jsx)(
        Button,
        {
          className: "tlui-toolbar__tools__button tlui-toolbar__styles__button tlui-popover__trigger",
          "data-wd": "mobile.styles",
          style: { color: currentColor != null ? currentColor : "var(--color-text)" },
          title: msg2("style-panel.title"),
          children: /* @__PURE__ */ (0, import_jsx_runtime107.jsx)(Icon, { icon: currentColor ? "blob" : "mixed" })
        }
      ) }),
      /* @__PURE__ */ (0, import_jsx_runtime107.jsx)(PopoverContent, { side: "top", align: "end", children: /* @__PURE__ */ (0, import_jsx_runtime107.jsx)(StylePanel, { isMobile: true }) })
    ] });
  }

  // ../../../packages/ui/src/lib/components/Toolbar/ToggleToolLockedButton.tsx
  var import_classnames18 = __toESM(require_classnames());
  var import_jsx_runtime108 = __toESM(require_jsx_runtime());
  var ToggleToolLockedButton = function ToggleToolLockedButton2({
    activeToolId
  }) {
    const app = useApp();
    const breakpoint = useBreakpoint();
    const msg2 = useTranslation();
    const isToolLocked = useValue("is tool locked", () => app.instanceState.isToolLocked, [app]);
    const isLockable = !(activeToolId === "select" || activeToolId === "hand" || activeToolId === "draw" || activeToolId === "eraser" || activeToolId === "text" || activeToolId === "zoom");
    if (!isLockable)
      return null;
    return /* @__PURE__ */ (0, import_jsx_runtime108.jsx)(
      Button,
      {
        title: msg2("action.toggle-tool-lock"),
        className: (0, import_classnames18.default)("tlui-toolbar__lock-button", {
          "tlui-toolbar__lock-button__mobile": breakpoint < 5
        }),
        icon: isToolLocked ? "lock" : "unlock",
        onClick: () => app.updateInstanceState({ isToolLocked: !isToolLocked }),
        smallIcon: true
      }
    );
  };

  // ../../../packages/ui/src/lib/components/Toolbar/Toolbar.tsx
  var import_jsx_runtime109 = __toESM(require_jsx_runtime());
  var Toolbar = function Toolbar2() {
    const app = useApp();
    const msg2 = useTranslation();
    const breakpoint = useBreakpoint();
    const rMostRecentlyActiveDropdownItem = import_react107.default.useRef(void 0);
    const isReadOnly = useReadonly();
    const toolbarItems = useToolbarSchema();
    const activeToolId = useValue("current tool id", () => app.currentToolId, [app]);
    const isHandTool = activeToolId === "hand";
    const geoState = useValue("geo", () => app.props ? app.props.geo : void 0, [app]);
    const showEditingTools = !isReadOnly;
    const showExtraActions = !(isReadOnly || isHandTool);
    const getTitle = (item) => item.label ? `${msg2(item.label)} ${item.kbd ? kbdStr(item.kbd) : ""}` : "";
    const activeToolbarItem = toolbarItems.find((item) => {
      return isActiveToolItem(item.toolItem, activeToolId, geoState);
    });
    const { itemsInPanel, itemsInDropdown, dropdownFirstItem } = import_react107.default.useMemo(() => {
      const itemsInPanel2 = [];
      const itemsInDropdown2 = [];
      let dropdownFirstItem2;
      const overflowIndex = Math.min(8, 5 + breakpoint);
      for (let i3 = 4; i3 < toolbarItems.length; i3++) {
        const item = toolbarItems[i3];
        if (i3 < overflowIndex) {
          itemsInPanel2.push(item);
        } else {
          if (item === activeToolbarItem) {
            dropdownFirstItem2 = item;
          }
          itemsInDropdown2.push(item);
        }
      }
      if (dropdownFirstItem2) {
      } else {
        if (!rMostRecentlyActiveDropdownItem.current) {
          rMostRecentlyActiveDropdownItem.current = itemsInDropdown2[0];
        }
        dropdownFirstItem2 = rMostRecentlyActiveDropdownItem.current;
        if (!itemsInDropdown2.includes(dropdownFirstItem2)) {
          dropdownFirstItem2 = itemsInDropdown2[0];
        }
      }
      rMostRecentlyActiveDropdownItem.current = dropdownFirstItem2;
      if (itemsInDropdown2.length <= 2) {
        itemsInPanel2.push(...itemsInDropdown2);
        itemsInDropdown2.length = 0;
      }
      return { itemsInPanel: itemsInPanel2, itemsInDropdown: itemsInDropdown2, dropdownFirstItem: dropdownFirstItem2 };
    }, [toolbarItems, activeToolbarItem, breakpoint]);
    return /* @__PURE__ */ (0, import_jsx_runtime109.jsx)("div", { className: "tlui-toolbar", children: /* @__PURE__ */ (0, import_jsx_runtime109.jsxs)("div", { className: "tlui-toolbar__inner", children: [
      /* @__PURE__ */ (0, import_jsx_runtime109.jsxs)("div", { className: "tlui-toolbar__left", children: [
        !isReadOnly && /* @__PURE__ */ (0, import_jsx_runtime109.jsxs)(
          "div",
          {
            className: (0, import_classnames19.default)("tlui-toolbar__extras", {
              "tlui-toolbar__extras__hidden": !showExtraActions
            }),
            children: [
              breakpoint < 5 && /* @__PURE__ */ (0, import_jsx_runtime109.jsxs)("div", { className: "tlui-toolbar__extras__controls", children: [
                /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(UndoButton, {}),
                /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(RedoButton, {}),
                /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(TrashButton, {}),
                /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(DuplicateButton, {}),
                /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(ActionsMenu, {})
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(ToggleToolLockedButton, { activeToolId })
            ]
          }
        ),
        /* @__PURE__ */ (0, import_jsx_runtime109.jsxs)(
          "div",
          {
            className: (0, import_classnames19.default)("tlui-toolbar__tools", {
              "tlui-toolbar__tools__mobile": breakpoint < 5
            }),
            children: [
              toolbarItems.slice(0, 2).map(({ toolItem }) => {
                return /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(
                  ToolbarButton,
                  {
                    item: toolItem,
                    title: getTitle(toolItem),
                    isSelected: isActiveToolItem(toolItem, activeToolId, geoState)
                  },
                  toolItem.id
                );
              }),
              showEditingTools && /* @__PURE__ */ (0, import_jsx_runtime109.jsxs)(import_jsx_runtime109.Fragment, { children: [
                /* @__PURE__ */ (0, import_jsx_runtime109.jsx)("div", { className: "tlui-toolbar__divider" }),
                toolbarItems.slice(2, 4).map(({ toolItem }) => /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(
                  ToolbarButton,
                  {
                    item: toolItem,
                    title: getTitle(toolItem),
                    isSelected: isActiveToolItem(toolItem, activeToolId, geoState)
                  },
                  toolItem.id
                )),
                /* @__PURE__ */ (0, import_jsx_runtime109.jsx)("div", { className: "tlui-toolbar__divider" }),
                itemsInPanel.map(({ toolItem }) => /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(
                  ToolbarButton,
                  {
                    item: toolItem,
                    title: getTitle(toolItem),
                    isSelected: isActiveToolItem(toolItem, activeToolId, geoState)
                  },
                  toolItem.id
                )),
                itemsInDropdown.length ? /* @__PURE__ */ (0, import_jsx_runtime109.jsxs)(import_jsx_runtime109.Fragment, { children: [
                  /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(
                    ToolbarButton,
                    {
                      item: dropdownFirstItem.toolItem,
                      title: getTitle(dropdownFirstItem.toolItem),
                      isSelected: isActiveToolItem(
                        dropdownFirstItem.toolItem,
                        activeToolId,
                        geoState
                      )
                    },
                    dropdownFirstItem.toolItem.id
                  ),
                  /* @__PURE__ */ (0, import_jsx_runtime109.jsxs)(Root, { id: "toolbar overflow", modal: false, children: [
                    /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(Trigger, { children: /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(
                      Button,
                      {
                        className: "tlui-toolbar__tools__button tlui-toolbar__overflow",
                        icon: "chevron-up",
                        "data-wd": "tools.more",
                        title: msg2("tool-panel.more")
                      }
                    ) }),
                    /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(Content, { side: "top", align: "center", children: /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(OverflowToolsContent, { toolbarItems: itemsInDropdown }) })
                  ] })
                ] }) : null
              ] })
            ]
          }
        )
      ] }),
      breakpoint < 5 && !isReadOnly && /* @__PURE__ */ (0, import_jsx_runtime109.jsx)("div", { className: "tlui-toolbar__tools", children: /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(MobileStylePanel, {}) })
    ] }) });
  };
  var OverflowToolsContent = track(function OverflowToolsContent2({
    toolbarItems
  }) {
    const msg2 = useTranslation();
    return /* @__PURE__ */ (0, import_jsx_runtime109.jsx)("div", { className: "tlui-button-grid__four tlui-button-grid__reverse", children: toolbarItems.map(({ toolItem: { id, meta, kbd: kbd2, label, onSelect, icon } }) => {
      var _a5;
      return /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(
        Item,
        {
          className: "tlui-button-grid__button",
          "data-wd": `tools.${id}`,
          "data-tool": id,
          "data-geo": (_a5 = meta == null ? void 0 : meta.geo) != null ? _a5 : "",
          "aria-label": label,
          onClick: () => onSelect("toolbar"),
          title: label ? `${msg2(label)} ${kbd2 ? kbdStr(kbd2) : ""}` : "",
          icon
        },
        id
      );
    }) });
  });
  function ToolbarButton({
    item,
    title,
    isSelected
  }) {
    var _a5, _b2;
    return /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(
      Button,
      {
        className: "tlui-toolbar__tools__button",
        "data-wd": `tools.${item.id}`,
        "data-tool": item.id,
        "data-geo": (_b2 = (_a5 = item.meta) == null ? void 0 : _a5.geo) != null ? _b2 : "",
        "aria-label": item.label,
        title,
        icon: item.icon,
        "data-state": isSelected ? "selected" : void 0,
        onClick: () => item.onSelect("toolbar"),
        onTouchStart: (e2) => {
          preventDefault(e2);
          item.onSelect("toolbar");
        }
      }
    );
  }
  var isActiveToolItem = (item, activeToolId, geoState) => {
    var _a5, _b2;
    return ((_a5 = item.meta) == null ? void 0 : _a5.geo) ? activeToolId === "geo" && geoState === ((_b2 = item.meta) == null ? void 0 : _b2.geo) : activeToolId === item.id;
  };

  // ../../../packages/ui/src/lib/hooks/useAppEvents.ts
  var import_react108 = __toESM(require_react());
  function useAppEvents() {
    const app = useApp();
    const { addToast } = useToasts();
    (0, import_react108.useEffect)(() => {
      function handleMaxShapes({ name, count }) {
        addToast({
          title: "Maximum Shapes Reached",
          description: `You've reached the maximum number of shapes allowed on ${name} (${count}). Please delete some shapes or move to a different page to continue.`
        });
      }
      app.addListener("max-shapes", handleMaxShapes);
      return () => {
        app.removeListener("max-shapes", handleMaxShapes);
      };
    }, [app, addToast]);
  }

  // ../../../packages/ui/src/lib/TldrawUi.tsx
  var import_jsx_runtime110 = __toESM(require_jsx_runtime());
  var TldrawUi = import_react109.default.memo(function TldrawUi2(_a5) {
    var _b2 = _a5, {
      shareZone,
      renderDebugMenuItems,
      children,
      hideUi
    } = _b2, rest = __objRest(_b2, [
      "shareZone",
      "renderDebugMenuItems",
      "children",
      "hideUi"
    ]);
    return /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(TldrawUiContextProvider, __spreadProps(__spreadValues({}, rest), { children: /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(
      TldrawUiInner,
      {
        hideUi,
        shareZone,
        renderDebugMenuItems,
        children
      }
    ) }));
  });
  var TldrawUiInner = import_react109.default.memo(function TldrawUiInner2(_a5) {
    var _b2 = _a5, {
      children,
      hideUi
    } = _b2, rest = __objRest(_b2, [
      "children",
      "hideUi"
    ]);
    return /* @__PURE__ */ (0, import_jsx_runtime110.jsxs)(import_jsx_runtime110.Fragment, { children: [
      children,
      hideUi ? null : /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(TldrawUiContent, __spreadValues({}, rest))
    ] });
  });
  var TldrawUiContent = import_react109.default.memo(function TldrawUI({
    shareZone,
    renderDebugMenuItems
  }) {
    const app = useApp();
    const msg2 = useTranslation();
    const breakpoint = useBreakpoint();
    const isReadonlyMode = useValue("isReadOnlyMode", () => app.isReadOnly, []);
    const isFocusMode = useValue("isFocusMode", () => app.instanceState.isFocusMode, []);
    const isDebugMode = useValue("isDebugMode", () => app.instanceState.isDebugMode, []);
    useNativeClipboardEvents();
    useAppEvents();
    const { "toggle-focus-mode": toggleFocus } = useActions();
    return /* @__PURE__ */ (0, import_jsx_runtime110.jsx)($054eb8030ebde76e$export$f5d03d415824e0e, { children: /* @__PURE__ */ (0, import_jsx_runtime110.jsxs)(
      "main",
      {
        "data-tldraw-area": "active-drawing",
        className: (0, import_classnames20.default)("tlui-layout", {
          "tlui-layout__mobile": breakpoint < 5
        }),
        children: [
          isFocusMode ? /* @__PURE__ */ (0, import_jsx_runtime110.jsx)("div", { className: "tlui-layout__top", children: /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(
            Button,
            {
              className: "tlui-focus-button",
              title: `${msg2("focus-mode.toggle-focus-mode")}`,
              icon: "dot",
              onClick: () => toggleFocus.onSelect("menu")
            }
          ) }) : /* @__PURE__ */ (0, import_jsx_runtime110.jsxs)(import_jsx_runtime110.Fragment, { children: [
            /* @__PURE__ */ (0, import_jsx_runtime110.jsxs)("div", { className: "tlui-layout__top", children: [
              /* @__PURE__ */ (0, import_jsx_runtime110.jsxs)("div", { className: "tlui-layout__top__left", children: [
                /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(MenuZone, {}),
                /* @__PURE__ */ (0, import_jsx_runtime110.jsxs)("div", { className: "tlui-helper-buttons", children: [
                  /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(ExitPenMode, {}),
                  /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(BackToContent, {}),
                  /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(StopFollowing, {})
                ] })
              ] }),
              /* @__PURE__ */ (0, import_jsx_runtime110.jsxs)("div", { className: "tlui-layout__top__right", children: [
                shareZone && /* @__PURE__ */ (0, import_jsx_runtime110.jsx)("div", { className: "tlui-share-zone", draggable: false, children: shareZone }),
                breakpoint >= 5 && !isReadonlyMode && /* @__PURE__ */ (0, import_jsx_runtime110.jsx)("div", { className: "tlui-style-panel__wrapper", children: /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(StylePanel, {}) })
              ] })
            ] }),
            /* @__PURE__ */ (0, import_jsx_runtime110.jsxs)("div", { className: "tlui-layout__bottom", children: [
              /* @__PURE__ */ (0, import_jsx_runtime110.jsxs)("div", { className: "tlui-layout__bottom__main", children: [
                /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(NavigationZone, {}),
                /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(Toolbar, {}),
                breakpoint >= 4 && /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(HelpMenu, {})
              ] }),
              isDebugMode && /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(DebugPanel, { renderDebugMenuItems: renderDebugMenuItems != null ? renderDebugMenuItems : null })
            ] })
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(Toasts, {}),
          /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(Dialogs, {}),
          /* @__PURE__ */ (0, import_jsx_runtime110.jsx)(ToastViewport, {})
        ]
      }
    ) });
  });

  // ../../../node_modules/@radix-ui/react-context-menu/dist/index.module.js
  var import_react110 = __toESM(require_react());
  var $1b0217ee4a91d156$var$CONTEXT_MENU_NAME = "ContextMenu";
  var [$1b0217ee4a91d156$var$createContextMenuContext, $1b0217ee4a91d156$export$1059331f43ddcc82] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($1b0217ee4a91d156$var$CONTEXT_MENU_NAME, [
    $6cc32821e9371a1c$export$4027731b685e72eb
  ]);
  var $1b0217ee4a91d156$var$useMenuScope = $6cc32821e9371a1c$export$4027731b685e72eb();
  var [$1b0217ee4a91d156$var$ContextMenuProvider, $1b0217ee4a91d156$var$useContextMenuContext] = $1b0217ee4a91d156$var$createContextMenuContext($1b0217ee4a91d156$var$CONTEXT_MENU_NAME);
  var $1b0217ee4a91d156$export$8dc6765e8be191c7 = (props) => {
    const { __scopeContextMenu, children, onOpenChange, dir, modal = true } = props;
    const [open1, setOpen] = (0, import_react110.useState)(false);
    const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
    const handleOpenChangeProp = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onOpenChange);
    const handleOpenChange = (0, import_react110.useCallback)((open) => {
      setOpen(open);
      handleOpenChangeProp(open);
    }, [
      handleOpenChangeProp
    ]);
    return /* @__PURE__ */ (0, import_react110.createElement)($1b0217ee4a91d156$var$ContextMenuProvider, {
      scope: __scopeContextMenu,
      open: open1,
      onOpenChange: handleOpenChange,
      modal
    }, /* @__PURE__ */ (0, import_react110.createElement)($6cc32821e9371a1c$export$be92b6f5f03c0fe9, _extends({}, menuScope, {
      dir,
      open: open1,
      onOpenChange: handleOpenChange,
      modal
    }), children));
  };
  var $1b0217ee4a91d156$var$TRIGGER_NAME = "ContextMenuTrigger";
  var $1b0217ee4a91d156$export$be6fc7b1d5b0beb9 = /* @__PURE__ */ (0, import_react110.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeContextMenu, disabled = false } = _a5, triggerProps = __objRest(_a5, ["__scopeContextMenu", "disabled"]);
    const context = $1b0217ee4a91d156$var$useContextMenuContext($1b0217ee4a91d156$var$TRIGGER_NAME, __scopeContextMenu);
    const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
    const pointRef = (0, import_react110.useRef)({
      x: 0,
      y: 0
    });
    const virtualRef = (0, import_react110.useRef)({
      getBoundingClientRect: () => DOMRect.fromRect(__spreadValues({
        width: 0,
        height: 0
      }, pointRef.current))
    });
    const longPressTimerRef = (0, import_react110.useRef)(0);
    const clearLongPress = (0, import_react110.useCallback)(
      () => window.clearTimeout(longPressTimerRef.current),
      []
    );
    const handleOpen = (event) => {
      pointRef.current = {
        x: event.clientX,
        y: event.clientY
      };
      context.onOpenChange(true);
    };
    (0, import_react110.useEffect)(
      () => clearLongPress,
      [
        clearLongPress
      ]
    );
    (0, import_react110.useEffect)(
      () => void (disabled && clearLongPress()),
      [
        disabled,
        clearLongPress
      ]
    );
    return /* @__PURE__ */ (0, import_react110.createElement)(import_react110.Fragment, null, /* @__PURE__ */ (0, import_react110.createElement)($6cc32821e9371a1c$export$b688253958b8dfe7, _extends({}, menuScope, {
      virtualRef
    })), /* @__PURE__ */ (0, import_react110.createElement)($8927f6f2acc4f386$export$250ffa63cdc0d034.span, _extends({
      "data-state": context.open ? "open" : "closed",
      "data-disabled": disabled ? "" : void 0
    }, triggerProps, {
      ref: forwardedRef,
      style: __spreadValues({
        WebkitTouchCallout: "none"
      }, props.style),
      onContextMenu: disabled ? props.onContextMenu : $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onContextMenu, (event) => {
        clearLongPress();
        handleOpen(event);
        event.preventDefault();
      }),
      onPointerDown: disabled ? props.onPointerDown : $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerDown, $1b0217ee4a91d156$var$whenTouchOrPen((event) => {
        clearLongPress();
        longPressTimerRef.current = window.setTimeout(
          () => handleOpen(event),
          700
        );
      })),
      onPointerMove: disabled ? props.onPointerMove : $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerMove, $1b0217ee4a91d156$var$whenTouchOrPen(clearLongPress)),
      onPointerCancel: disabled ? props.onPointerCancel : $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerCancel, $1b0217ee4a91d156$var$whenTouchOrPen(clearLongPress)),
      onPointerUp: disabled ? props.onPointerUp : $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onPointerUp, $1b0217ee4a91d156$var$whenTouchOrPen(clearLongPress))
    })));
  });
  var $1b0217ee4a91d156$export$14afd0be83e45060 = (props) => {
    const _a5 = props, { __scopeContextMenu } = _a5, portalProps = __objRest(_a5, ["__scopeContextMenu"]);
    const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
    return /* @__PURE__ */ (0, import_react110.createElement)($6cc32821e9371a1c$export$602eac185826482c, _extends({}, menuScope, portalProps));
  };
  var $1b0217ee4a91d156$var$CONTENT_NAME = "ContextMenuContent";
  var $1b0217ee4a91d156$export$572205900c9369e = /* @__PURE__ */ (0, import_react110.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeContextMenu } = _a5, contentProps = __objRest(_a5, ["__scopeContextMenu"]);
    const context = $1b0217ee4a91d156$var$useContextMenuContext($1b0217ee4a91d156$var$CONTENT_NAME, __scopeContextMenu);
    const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
    const hasInteractedOutsideRef = (0, import_react110.useRef)(false);
    return /* @__PURE__ */ (0, import_react110.createElement)($6cc32821e9371a1c$export$7c6e2c02157bb7d2, _extends({}, menuScope, contentProps, {
      ref: forwardedRef,
      side: "right",
      sideOffset: 2,
      align: "start",
      onCloseAutoFocus: (event) => {
        var _props$onCloseAutoFoc;
        (_props$onCloseAutoFoc = props.onCloseAutoFocus) === null || _props$onCloseAutoFoc === void 0 || _props$onCloseAutoFoc.call(props, event);
        if (!event.defaultPrevented && hasInteractedOutsideRef.current)
          event.preventDefault();
        hasInteractedOutsideRef.current = false;
      },
      onInteractOutside: (event) => {
        var _props$onInteractOuts;
        (_props$onInteractOuts = props.onInteractOutside) === null || _props$onInteractOuts === void 0 || _props$onInteractOuts.call(props, event);
        if (!event.defaultPrevented && !context.modal)
          hasInteractedOutsideRef.current = true;
      },
      style: __spreadProps(__spreadValues({}, props.style), {
        "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
      })
    }));
  });
  var $1b0217ee4a91d156$export$9860523b0fcdd664 = /* @__PURE__ */ (0, import_react110.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeContextMenu } = _a5, groupProps = __objRest(_a5, ["__scopeContextMenu"]);
    const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
    return /* @__PURE__ */ (0, import_react110.createElement)($6cc32821e9371a1c$export$eb2fcfdbd7ba97d4, _extends({}, menuScope, groupProps, {
      ref: forwardedRef
    }));
  });
  var $1b0217ee4a91d156$export$16a26dc176a49100 = /* @__PURE__ */ (0, import_react110.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeContextMenu } = _a5, itemProps = __objRest(_a5, ["__scopeContextMenu"]);
    const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
    return /* @__PURE__ */ (0, import_react110.createElement)($6cc32821e9371a1c$export$6d08773d2e66f8f2, _extends({}, menuScope, itemProps, {
      ref: forwardedRef
    }));
  });
  var $1b0217ee4a91d156$export$b6adbe51d5d8b7ec = /* @__PURE__ */ (0, import_react110.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeContextMenu } = _a5, checkboxItemProps = __objRest(_a5, ["__scopeContextMenu"]);
    const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
    return /* @__PURE__ */ (0, import_react110.createElement)($6cc32821e9371a1c$export$16ce288f89fa631c, _extends({}, menuScope, checkboxItemProps, {
      ref: forwardedRef
    }));
  });
  var $1b0217ee4a91d156$export$5bc21d1c00c4b201 = (props) => {
    const { __scopeContextMenu, children, onOpenChange, open: openProp, defaultOpen } = props;
    const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
    const [open, setOpen] = $71cd76cc60e0454e$export$6f32135080cb4c3({
      prop: openProp,
      defaultProp: defaultOpen,
      onChange: onOpenChange
    });
    return /* @__PURE__ */ (0, import_react110.createElement)($6cc32821e9371a1c$export$d7a01e11500dfb6f, _extends({}, menuScope, {
      open,
      onOpenChange: setOpen
    }), children);
  };
  var $1b0217ee4a91d156$export$30b2b5c64556d316 = /* @__PURE__ */ (0, import_react110.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeContextMenu } = _a5, triggerItemProps = __objRest(_a5, ["__scopeContextMenu"]);
    const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
    return /* @__PURE__ */ (0, import_react110.createElement)($6cc32821e9371a1c$export$2ea8a7a591ac5eac, _extends({}, menuScope, triggerItemProps, {
      ref: forwardedRef
    }));
  });
  var $1b0217ee4a91d156$export$2c967063bd2dc512 = /* @__PURE__ */ (0, import_react110.forwardRef)((props, forwardedRef) => {
    const _a5 = props, { __scopeContextMenu } = _a5, subContentProps = __objRest(_a5, ["__scopeContextMenu"]);
    const menuScope = $1b0217ee4a91d156$var$useMenuScope(__scopeContextMenu);
    return /* @__PURE__ */ (0, import_react110.createElement)($6cc32821e9371a1c$export$6d4de93b380beddf, _extends({}, menuScope, subContentProps, {
      ref: forwardedRef,
      style: __spreadProps(__spreadValues({}, props.style), {
        "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
      })
    }));
  });
  function $1b0217ee4a91d156$var$whenTouchOrPen(handler) {
    return (event) => event.pointerType !== "mouse" ? handler(event) : void 0;
  }
  var $1b0217ee4a91d156$export$be92b6f5f03c0fe9 = $1b0217ee4a91d156$export$8dc6765e8be191c7;
  var $1b0217ee4a91d156$export$41fb9f06171c75f4 = $1b0217ee4a91d156$export$be6fc7b1d5b0beb9;
  var $1b0217ee4a91d156$export$602eac185826482c = $1b0217ee4a91d156$export$14afd0be83e45060;
  var $1b0217ee4a91d156$export$7c6e2c02157bb7d2 = $1b0217ee4a91d156$export$572205900c9369e;
  var $1b0217ee4a91d156$export$eb2fcfdbd7ba97d4 = $1b0217ee4a91d156$export$9860523b0fcdd664;
  var $1b0217ee4a91d156$export$6d08773d2e66f8f2 = $1b0217ee4a91d156$export$16a26dc176a49100;
  var $1b0217ee4a91d156$export$16ce288f89fa631c = $1b0217ee4a91d156$export$b6adbe51d5d8b7ec;
  var $1b0217ee4a91d156$export$d7a01e11500dfb6f = $1b0217ee4a91d156$export$5bc21d1c00c4b201;
  var $1b0217ee4a91d156$export$2ea8a7a591ac5eac = $1b0217ee4a91d156$export$30b2b5c64556d316;
  var $1b0217ee4a91d156$export$6d4de93b380beddf = $1b0217ee4a91d156$export$2c967063bd2dc512;

  // ../../../packages/ui/src/lib/components/ContextMenu.tsx
  var import_classnames21 = __toESM(require_classnames());
  var React69 = __toESM(require_react());

  // ../../../packages/ui/src/lib/components/MoveToPageMenu.tsx
  var import_jsx_runtime111 = __toESM(require_jsx_runtime());
  var MoveToPageMenu = track(function MoveToPageMenu2() {
    const app = useApp();
    const container = useContainer();
    const pages = app.pages;
    const currentPageId = app.currentPageId;
    const msg2 = useTranslation();
    const { addToast } = useToasts();
    return /* @__PURE__ */ (0, import_jsx_runtime111.jsxs)($1b0217ee4a91d156$export$d7a01e11500dfb6f, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime111.jsx)($1b0217ee4a91d156$export$2ea8a7a591ac5eac, { dir: "ltr", asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(
        Button,
        {
          className: "tlui-menu__button",
          label: "context-menu.move-to-page",
          "data-wd": "menu-item.move-to-page",
          icon: "chevron-right"
        }
      ) }),
      /* @__PURE__ */ (0, import_jsx_runtime111.jsx)($1b0217ee4a91d156$export$602eac185826482c, { container, dir: "ltr", children: /* @__PURE__ */ (0, import_jsx_runtime111.jsxs)($1b0217ee4a91d156$export$6d4de93b380beddf, { className: "tlui-menu", sideOffset: -4, collisionPadding: 4, children: [
        /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(
          $1b0217ee4a91d156$export$eb2fcfdbd7ba97d4,
          {
            dir: "ltr",
            className: "tlui-menu__group",
            "data-wd": `menu-item.pages`,
            children: pages.map((page) => /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(
              $1b0217ee4a91d156$export$6d08773d2e66f8f2,
              {
                disabled: currentPageId === page.id,
                onSelect: () => {
                  app.mark("move_shapes_to_page");
                  app.moveShapesToPage(app.selectedIds, page.id);
                  const toPage = app.getPageById(page.id);
                  if (toPage) {
                    addToast({
                      title: "Changed Page",
                      description: `Moved to ${toPage.name}.`,
                      actions: [
                        {
                          label: "Go Back",
                          type: "primary",
                          onClick: () => {
                            app.mark("change-page");
                            app.setCurrentPageId(currentPageId);
                          }
                        }
                      ]
                    });
                  }
                },
                asChild: true,
                children: /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(
                  Button,
                  {
                    title: page.name,
                    className: "tlui-menu__button tlui-context-menu__move-to-page__name",
                    children: /* @__PURE__ */ (0, import_jsx_runtime111.jsx)("span", { children: page.name })
                  }
                )
              },
              page.id
            ))
          },
          "pages"
        ),
        /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(
          $1b0217ee4a91d156$export$eb2fcfdbd7ba97d4,
          {
            dir: "ltr",
            className: "tlui-menu__group",
            "data-wd": `menu-item.new-page`,
            children: /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(
              $1b0217ee4a91d156$export$6d08773d2e66f8f2,
              {
                onSelect: () => {
                  app.mark("move_shapes_to_page");
                  const newPageId = TLPage.createId();
                  const ids = app.selectedIds;
                  const oldPageId = app.currentPageId;
                  app.batch(() => {
                    app.createPage("Page 1", newPageId);
                    app.setCurrentPageId(oldPageId);
                    app.moveShapesToPage(ids, newPageId);
                  });
                },
                asChild: true,
                children: /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(
                  Button,
                  {
                    title: msg2("context.pages.new-page"),
                    className: "tlui-menu__button tlui-context-menu__move-to-page__name",
                    children: msg2("context.pages.new-page")
                  }
                )
              },
              "new-page"
            )
          },
          "new-page"
        )
      ] }) })
    ] });
  });

  // ../../../packages/ui/src/lib/components/ContextMenu.tsx
  var import_jsx_runtime112 = __toESM(require_jsx_runtime());
  var ContextMenu = function ContextMenu2({ children }) {
    const app = useApp();
    const contextMenuSchema = useContextMenuSchema();
    const [_, handleOpenChange] = useMenuIsOpen("context menu");
    const isReadonly = useReadonly();
    const noItemsToShow = contextMenuSchema.length === 0 || isReadonly && contextMenuSchema.every((item) => !item.readonlyOk);
    const selectToolActive = useValue("isSelectToolActive", () => app.currentToolId === "select", [
      app
    ]);
    const disabled = !selectToolActive || noItemsToShow;
    return /* @__PURE__ */ (0, import_jsx_runtime112.jsxs)($1b0217ee4a91d156$export$be92b6f5f03c0fe9, { dir: "ltr", onOpenChange: handleOpenChange, children: [
      /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(
        $1b0217ee4a91d156$export$41fb9f06171c75f4,
        {
          onContextMenu: disabled ? preventDefault : void 0,
          dir: "ltr",
          disabled,
          children
        }
      ),
      /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(ContextMenuContent, {})
    ] });
  };
  function ContextMenuContent() {
    const app = useApp();
    const msg2 = useTranslation();
    const menuSchema = useContextMenuSchema();
    const [_, handleSubOpenChange] = useMenuIsOpen("context menu sub");
    const isReadonly = useReadonly();
    const { paste } = useMenuClipboardEvents("context-menu");
    const breakpoint = useBreakpoint();
    const container = useContainer();
    const [disableClicks, setDisableClicks] = React69.useState(false);
    function getContextMenuItem(app2, item, parent, depth) {
      if (isReadonly && !item.readonlyOk)
        return null;
      switch (item.type) {
        case "custom": {
          switch (item.id) {
            case "MENU_PASTE": {
              return /* @__PURE__ */ (0, import_jsx_runtime112.jsx)($1b0217ee4a91d156$export$6d08773d2e66f8f2, { children: /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(
                Button,
                {
                  className: "tlui-menu__button",
                  "data-wd": `menu-item.${item.id}`,
                  kbd: "$v",
                  label: "action.paste",
                  disabled: item.disabled,
                  onClick: () => {
                    if (!app2.isSafari || app2.isSafari && app2.isIos) {
                      navigator.clipboard.read().then((clipboardItems) => {
                        paste(clipboardItems, app2.inputs.currentPagePoint);
                      });
                    }
                  },
                  onMouseDown: () => {
                    if (app2.isSafari && !app2.isIos) {
                      navigator.clipboard.read().then((clipboardItems) => {
                        paste(clipboardItems, app2.inputs.currentPagePoint);
                      });
                    }
                  }
                }
              ) }, item.id);
            }
            case "MOVE_TO_PAGE_MENU": {
              return /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(MoveToPageMenu, {}, item.id);
            }
          }
          break;
        }
        case "group": {
          return /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(
            $1b0217ee4a91d156$export$eb2fcfdbd7ba97d4,
            {
              dir: "ltr",
              className: (0, import_classnames21.default)("tlui-menu__group", {
                "tlui-menu__group__small": (parent == null ? void 0 : parent.type) === "submenu"
              }),
              "data-wd": `menu-item.${item.id}`,
              children: item.children.map((child) => getContextMenuItem(app2, child, item, depth + 1))
            },
            item.id
          );
        }
        case "submenu": {
          return /* @__PURE__ */ (0, import_jsx_runtime112.jsxs)($1b0217ee4a91d156$export$d7a01e11500dfb6f, { onOpenChange: handleSubOpenChange, children: [
            /* @__PURE__ */ (0, import_jsx_runtime112.jsx)($1b0217ee4a91d156$export$2ea8a7a591ac5eac, { dir: "ltr", disabled: item.disabled, asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(
              Button,
              {
                className: "tlui-menu__button",
                label: item.label,
                "data-wd": `menu-item.${item.id}`,
                icon: "chevron-right"
              }
            ) }),
            /* @__PURE__ */ (0, import_jsx_runtime112.jsx)($1b0217ee4a91d156$export$602eac185826482c, { container, dir: "ltr", children: /* @__PURE__ */ (0, import_jsx_runtime112.jsx)($1b0217ee4a91d156$export$6d4de93b380beddf, { className: "tlui-menu", sideOffset: -4, collisionPadding: 4, children: item.children.map((child) => getContextMenuItem(app2, child, item, depth + 1)) }) })
          ] }, item.id);
        }
        case "item": {
          if (isReadonly && !item.readonlyOk)
            return null;
          const { id, checkbox, contextMenuLabel, label, onSelect, kbd: kbd2, icon } = item.actionItem;
          const labelToUse = contextMenuLabel != null ? contextMenuLabel : label;
          const labelStr = labelToUse ? msg2(labelToUse) : void 0;
          if (checkbox) {
            return /* @__PURE__ */ (0, import_jsx_runtime112.jsxs)(
              $1b0217ee4a91d156$export$16ce288f89fa631c,
              {
                className: "tlui-button tlui-menu__button tlui-menu__checkbox-item",
                dir: "ltr",
                disabled: item.disabled,
                onSelect: (e2) => {
                  onSelect("context-menu");
                  preventDefault(e2);
                },
                title: labelStr ? labelStr : void 0,
                checked: item.checked,
                children: [
                  /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(
                    "div",
                    {
                      className: "tlui-menu__checkbox-item__check",
                      style: {
                        transformOrigin: "75% center",
                        transform: `scale(${item.checked ? 1 : 0.5})`,
                        opacity: item.checked ? 1 : 0.5
                      },
                      children: /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(Icon, { small: true, icon: item.checked ? "check" : "checkbox-empty" })
                    }
                  ),
                  labelStr && /* @__PURE__ */ (0, import_jsx_runtime112.jsx)("span", { children: labelStr }),
                  kbd2 && /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(Kbd, { children: kbd2 })
                ]
              },
              id
            );
          }
          return /* @__PURE__ */ (0, import_jsx_runtime112.jsx)($1b0217ee4a91d156$export$6d08773d2e66f8f2, { dir: "ltr", asChild: true, children: /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(
            Button,
            {
              className: "tlui-menu__button",
              "data-wd": `menu-item.${id}`,
              kbd: kbd2,
              label: labelToUse,
              disabled: item.disabled,
              iconLeft: breakpoint < 3 && depth > 2 ? icon : void 0,
              onClick: () => {
                if (disableClicks) {
                  setDisableClicks(false);
                } else {
                  onSelect("context-menu");
                }
              }
            }
          ) }, id);
        }
      }
    }
    return /* @__PURE__ */ (0, import_jsx_runtime112.jsx)($1b0217ee4a91d156$export$602eac185826482c, { dir: "ltr", container, children: /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(
      $1b0217ee4a91d156$export$7c6e2c02157bb7d2,
      {
        className: "tlui-menu scrollable",
        alignOffset: -4,
        collisionPadding: 4,
        onContextMenu: preventDefault,
        children: menuSchema.map((item) => getContextMenuItem(app, item, null, 0))
      }
    ) });
  }

  // ../../../packages/ui/src/lib/components/HTMLCanvas.tsx
  var React70 = __toESM(require_react());
  var import_jsx_runtime113 = __toESM(require_jsx_runtime());
  var HTMLCanvas = track(function HTMLCanvas2() {
    const app = useApp();
    const rCanvas = React70.useRef(null);
    const camera = app.camera;
    const shapes = app.shapesArray;
    if (rCanvas.current) {
      const cvs = rCanvas.current;
      const ctx = cvs.getContext("2d");
      ctx.resetTransform();
      ctx.clearRect(0, 0, cvs.width, cvs.height);
      const path = new Path2D();
      ctx.translate(camera.x, camera.y);
      for (const shape of shapes) {
        const bounds = app.getPageBounds(shape);
        path.rect(bounds.minX, bounds.minY, bounds.width, bounds.height);
      }
      ctx.fillStyle = "#cccccc";
      ctx.fill(path);
      for (const shape of shapes) {
        ctx.save();
        const corners = app.getPageCorners(shape);
        corners.forEach((corner) => dot(ctx, corner.x, corner.y, "red"));
        ctx.restore();
      }
    }
    return /* @__PURE__ */ (0, import_jsx_runtime113.jsx)(
      "canvas",
      {
        ref: rCanvas,
        width: app.viewportScreenBounds.width,
        height: app.viewportScreenBounds.height,
        style: { width: "100%", height: "100%" }
      }
    );
  });
  function dot(ctx, x3, y3, color = "#000") {
    ctx.save();
    ctx.beginPath();
    ctx.ellipse(x3, y3, 4, 4, 0, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.restore();
  }

  // ../../../packages/ui/src/lib/hooks/useHighDpiCanvas.ts
  var import_react111 = __toESM(require_react());

  // ../../../node_modules/hotkeys-js/dist/hotkeys.esm.js
  var isff = typeof navigator !== "undefined" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : false;
  function addEvent(object2, event, method, useCapture) {
    if (object2.addEventListener) {
      object2.addEventListener(event, method, useCapture);
    } else if (object2.attachEvent) {
      object2.attachEvent("on".concat(event), function() {
        method(window.event);
      });
    }
  }
  function getMods(modifier, key) {
    var mods = key.slice(0, key.length - 1);
    for (var i3 = 0; i3 < mods.length; i3++) {
      mods[i3] = modifier[mods[i3].toLowerCase()];
    }
    return mods;
  }
  function getKeys(key) {
    if (typeof key !== "string")
      key = "";
    key = key.replace(/\s/g, "");
    var keys = key.split(",");
    var index2 = keys.lastIndexOf("");
    for (; index2 >= 0; ) {
      keys[index2 - 1] += ",";
      keys.splice(index2, 1);
      index2 = keys.lastIndexOf("");
    }
    return keys;
  }
  function compareArray(a1, a22) {
    var arr1 = a1.length >= a22.length ? a1 : a22;
    var arr2 = a1.length >= a22.length ? a22 : a1;
    var isIndex = true;
    for (var i3 = 0; i3 < arr1.length; i3++) {
      if (arr2.indexOf(arr1[i3]) === -1)
        isIndex = false;
    }
    return isIndex;
  }
  var _keyMap = {
    backspace: 8,
    "\u232B": 8,
    tab: 9,
    clear: 12,
    enter: 13,
    "\u21A9": 13,
    return: 13,
    esc: 27,
    escape: 27,
    space: 32,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    del: 46,
    delete: 46,
    ins: 45,
    insert: 45,
    home: 36,
    end: 35,
    pageup: 33,
    pagedown: 34,
    capslock: 20,
    num_0: 96,
    num_1: 97,
    num_2: 98,
    num_3: 99,
    num_4: 100,
    num_5: 101,
    num_6: 102,
    num_7: 103,
    num_8: 104,
    num_9: 105,
    num_multiply: 106,
    num_add: 107,
    num_enter: 108,
    num_subtract: 109,
    num_decimal: 110,
    num_divide: 111,
    "\u21EA": 20,
    ",": 188,
    ".": 190,
    "/": 191,
    "`": 192,
    "-": isff ? 173 : 189,
    "=": isff ? 61 : 187,
    ";": isff ? 59 : 186,
    "'": 222,
    "[": 219,
    "]": 221,
    "\\": 220
  };
  var _modifier = {
    // shiftKey
    "\u21E7": 16,
    shift: 16,
    // altKey
    "\u2325": 18,
    alt: 18,
    option: 18,
    // ctrlKey
    "\u2303": 17,
    ctrl: 17,
    control: 17,
    // metaKey
    "\u2318": 91,
    cmd: 91,
    command: 91
  };
  var modifierMap = {
    16: "shiftKey",
    18: "altKey",
    17: "ctrlKey",
    91: "metaKey",
    shiftKey: 16,
    ctrlKey: 17,
    altKey: 18,
    metaKey: 91
  };
  var _mods = {
    16: false,
    18: false,
    17: false,
    91: false
  };
  var _handlers = {};
  for (k2 = 1; k2 < 20; k2++) {
    _keyMap["f".concat(k2)] = 111 + k2;
  }
  var k2;
  var _downKeys = [];
  var winListendFocus = false;
  var _scope = "all";
  var elementHasBindEvent = [];
  var code = function code2(x3) {
    return _keyMap[x3.toLowerCase()] || _modifier[x3.toLowerCase()] || x3.toUpperCase().charCodeAt(0);
  };
  var getKey = function getKey2(x3) {
    return Object.keys(_keyMap).find(function(k2) {
      return _keyMap[k2] === x3;
    });
  };
  var getModifier = function getModifier2(x3) {
    return Object.keys(_modifier).find(function(k2) {
      return _modifier[k2] === x3;
    });
  };
  function setScope(scope) {
    _scope = scope || "all";
  }
  function getScope() {
    return _scope || "all";
  }
  function getPressedKeyCodes() {
    return _downKeys.slice(0);
  }
  function getPressedKeyString() {
    return _downKeys.map(function(c3) {
      return getKey(c3) || getModifier(c3) || String.fromCharCode(c3);
    });
  }
  function filter(event) {
    var target = event.target || event.srcElement;
    var tagName = target.tagName;
    var flag = true;
    if (target.isContentEditable || (tagName === "INPUT" || tagName === "TEXTAREA" || tagName === "SELECT") && !target.readOnly) {
      flag = false;
    }
    return flag;
  }
  function isPressed(keyCode) {
    if (typeof keyCode === "string") {
      keyCode = code(keyCode);
    }
    return _downKeys.indexOf(keyCode) !== -1;
  }
  function deleteScope(scope, newScope) {
    var handlers;
    var i3;
    if (!scope)
      scope = getScope();
    for (var key in _handlers) {
      if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
        handlers = _handlers[key];
        for (i3 = 0; i3 < handlers.length; ) {
          if (handlers[i3].scope === scope)
            handlers.splice(i3, 1);
          else
            i3++;
        }
      }
    }
    if (getScope() === scope)
      setScope(newScope || "all");
  }
  function clearModifier(event) {
    var key = event.keyCode || event.which || event.charCode;
    var i3 = _downKeys.indexOf(key);
    if (i3 >= 0) {
      _downKeys.splice(i3, 1);
    }
    if (event.key && event.key.toLowerCase() === "meta") {
      _downKeys.splice(0, _downKeys.length);
    }
    if (key === 93 || key === 224)
      key = 91;
    if (key in _mods) {
      _mods[key] = false;
      for (var k2 in _modifier) {
        if (_modifier[k2] === key)
          hotkeys[k2] = false;
      }
    }
  }
  function unbind(keysInfo) {
    if (typeof keysInfo === "undefined") {
      Object.keys(_handlers).forEach(function(key) {
        return delete _handlers[key];
      });
    } else if (Array.isArray(keysInfo)) {
      keysInfo.forEach(function(info) {
        if (info.key)
          eachUnbind(info);
      });
    } else if (typeof keysInfo === "object") {
      if (keysInfo.key)
        eachUnbind(keysInfo);
    } else if (typeof keysInfo === "string") {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var scope = args[0], method = args[1];
      if (typeof scope === "function") {
        method = scope;
        scope = "";
      }
      eachUnbind({
        key: keysInfo,
        scope,
        method,
        splitKey: "+"
      });
    }
  }
  var eachUnbind = function eachUnbind2(_ref) {
    var key = _ref.key, scope = _ref.scope, method = _ref.method, _ref$splitKey = _ref.splitKey, splitKey = _ref$splitKey === void 0 ? "+" : _ref$splitKey;
    var multipleKeys = getKeys(key);
    multipleKeys.forEach(function(originKey) {
      var unbindKeys = originKey.split(splitKey);
      var len = unbindKeys.length;
      var lastKey = unbindKeys[len - 1];
      var keyCode = lastKey === "*" ? "*" : code(lastKey);
      if (!_handlers[keyCode])
        return;
      if (!scope)
        scope = getScope();
      var mods = len > 1 ? getMods(_modifier, unbindKeys) : [];
      _handlers[keyCode] = _handlers[keyCode].filter(function(record) {
        var isMatchingMethod = method ? record.method === method : true;
        return !(isMatchingMethod && record.scope === scope && compareArray(record.mods, mods));
      });
    });
  };
  function eventHandler(event, handler, scope, element) {
    if (handler.element !== element) {
      return;
    }
    var modifiersMatch;
    if (handler.scope === scope || handler.scope === "all") {
      modifiersMatch = handler.mods.length > 0;
      for (var y3 in _mods) {
        if (Object.prototype.hasOwnProperty.call(_mods, y3)) {
          if (!_mods[y3] && handler.mods.indexOf(+y3) > -1 || _mods[y3] && handler.mods.indexOf(+y3) === -1) {
            modifiersMatch = false;
          }
        }
      }
      if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === "*") {
        if (handler.method(event, handler) === false) {
          if (event.preventDefault)
            event.preventDefault();
          else
            event.returnValue = false;
          if (event.stopPropagation)
            event.stopPropagation();
          if (event.cancelBubble)
            event.cancelBubble = true;
        }
      }
    }
  }
  function dispatch(event, element) {
    var asterisk = _handlers["*"];
    var key = event.keyCode || event.which || event.charCode;
    if (!hotkeys.filter.call(this, event))
      return;
    if (key === 93 || key === 224)
      key = 91;
    if (_downKeys.indexOf(key) === -1 && key !== 229)
      _downKeys.push(key);
    ["ctrlKey", "altKey", "shiftKey", "metaKey"].forEach(function(keyName) {
      var keyNum = modifierMap[keyName];
      if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {
        _downKeys.push(keyNum);
      } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {
        _downKeys.splice(_downKeys.indexOf(keyNum), 1);
      } else if (keyName === "metaKey" && event[keyName] && _downKeys.length === 3) {
        if (!(event.ctrlKey || event.shiftKey || event.altKey)) {
          _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));
        }
      }
    });
    if (key in _mods) {
      _mods[key] = true;
      for (var k2 in _modifier) {
        if (_modifier[k2] === key)
          hotkeys[k2] = true;
      }
      if (!asterisk)
        return;
    }
    for (var e2 in _mods) {
      if (Object.prototype.hasOwnProperty.call(_mods, e2)) {
        _mods[e2] = event[modifierMap[e2]];
      }
    }
    if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState("AltGraph")) {
      if (_downKeys.indexOf(17) === -1) {
        _downKeys.push(17);
      }
      if (_downKeys.indexOf(18) === -1) {
        _downKeys.push(18);
      }
      _mods[17] = true;
      _mods[18] = true;
    }
    var scope = getScope();
    if (asterisk) {
      for (var i3 = 0; i3 < asterisk.length; i3++) {
        if (asterisk[i3].scope === scope && (event.type === "keydown" && asterisk[i3].keydown || event.type === "keyup" && asterisk[i3].keyup)) {
          eventHandler(event, asterisk[i3], scope, element);
        }
      }
    }
    if (!(key in _handlers))
      return;
    for (var _i = 0; _i < _handlers[key].length; _i++) {
      if (event.type === "keydown" && _handlers[key][_i].keydown || event.type === "keyup" && _handlers[key][_i].keyup) {
        if (_handlers[key][_i].key) {
          var record = _handlers[key][_i];
          var splitKey = record.splitKey;
          var keyShortcut = record.key.split(splitKey);
          var _downKeysCurrent = [];
          for (var a3 = 0; a3 < keyShortcut.length; a3++) {
            _downKeysCurrent.push(code(keyShortcut[a3]));
          }
          if (_downKeysCurrent.sort().join("") === _downKeys.sort().join("")) {
            eventHandler(event, record, scope, element);
          }
        }
      }
    }
  }
  function isElementBind(element) {
    return elementHasBindEvent.indexOf(element) > -1;
  }
  function hotkeys(key, option, method) {
    _downKeys = [];
    var keys = getKeys(key);
    var mods = [];
    var scope = "all";
    var element = document;
    var i3 = 0;
    var keyup = false;
    var keydown = true;
    var splitKey = "+";
    var capture = false;
    if (method === void 0 && typeof option === "function") {
      method = option;
    }
    if (Object.prototype.toString.call(option) === "[object Object]") {
      if (option.scope)
        scope = option.scope;
      if (option.element)
        element = option.element;
      if (option.keyup)
        keyup = option.keyup;
      if (option.keydown !== void 0)
        keydown = option.keydown;
      if (option.capture !== void 0)
        capture = option.capture;
      if (typeof option.splitKey === "string")
        splitKey = option.splitKey;
    }
    if (typeof option === "string")
      scope = option;
    for (; i3 < keys.length; i3++) {
      key = keys[i3].split(splitKey);
      mods = [];
      if (key.length > 1)
        mods = getMods(_modifier, key);
      key = key[key.length - 1];
      key = key === "*" ? "*" : code(key);
      if (!(key in _handlers))
        _handlers[key] = [];
      _handlers[key].push({
        keyup,
        keydown,
        scope,
        mods,
        shortcut: keys[i3],
        method,
        key: keys[i3],
        splitKey,
        element
      });
    }
    if (typeof element !== "undefined" && !isElementBind(element) && window) {
      elementHasBindEvent.push(element);
      addEvent(element, "keydown", function(e2) {
        dispatch(e2, element);
      }, capture);
      if (!winListendFocus) {
        winListendFocus = true;
        addEvent(window, "focus", function() {
          _downKeys = [];
        }, capture);
      }
      addEvent(element, "keyup", function(e2) {
        dispatch(e2, element);
        clearModifier(e2);
      }, capture);
    }
  }
  function trigger(shortcut) {
    var scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
    Object.keys(_handlers).forEach(function(key) {
      var dataList = _handlers[key].filter(function(item) {
        return item.scope === scope && item.shortcut === shortcut;
      });
      dataList.forEach(function(data) {
        if (data && data.method) {
          data.method();
        }
      });
    });
  }
  var _api = {
    getPressedKeyString,
    setScope,
    getScope,
    deleteScope,
    getPressedKeyCodes,
    isPressed,
    filter,
    trigger,
    unbind,
    keyMap: _keyMap,
    modifier: _modifier,
    modifierMap
  };
  for (a3 in _api) {
    if (Object.prototype.hasOwnProperty.call(_api, a3)) {
      hotkeys[a3] = _api[a3];
    }
  }
  var a3;
  if (typeof window !== "undefined") {
    _hotkeys = window.hotkeys;
    hotkeys.noConflict = function(deep) {
      if (deep && window.hotkeys === hotkeys) {
        window.hotkeys = _hotkeys;
      }
      return hotkeys;
    };
    window.hotkeys = hotkeys;
  }
  var _hotkeys;

  // ../../../packages/ui/src/lib/hooks/useKeyboardShortcuts.ts
  var import_react112 = __toESM(require_react());

  // src/utils/vscode.ts
  var vscode = acquireVsCodeApi();

  // src/utils/openUrl.ts
  function openUrl(url) {
    vscode.postMessage({
      type: "vscode:open-window",
      data: { url, target: "_blank" }
    });
  }

  // src/utils/links.ts
  var GITHUB_URL = "https://github.com/tldraw/tldraw";
  var linksMenuGroup = menuGroup(
    "links",
    menuItem({
      id: "github",
      label: "help-menu.github",
      readonlyOk: true,
      icon: "github",
      onSelect() {
        openUrl(GITHUB_URL);
      }
    }),
    menuItem({
      id: "twitter",
      label: "help-menu.twitter",
      icon: "twitter",
      readonlyOk: true,
      onSelect() {
        openUrl("https://twitter.com/tldraw");
      }
    }),
    menuItem({
      id: "discord",
      label: "help-menu.discord",
      icon: "discord",
      readonlyOk: true,
      onSelect() {
        openUrl("https://discord.gg/SBBEVCA4PG");
      }
    }),
    menuItem({
      id: "about",
      label: "help-menu.about",
      icon: "external-link",
      readonlyOk: true,
      onSelect() {
        openUrl("https://www.tldraw.dev");
      }
    })
  );
  var linksUiOverrides = {
    helpMenu(app, schema) {
      schema.push(linksMenuGroup);
      return schema;
    },
    menu(app, schema, { isMobile }) {
      if (isMobile) {
        schema.push(linksMenuGroup);
      }
      return schema;
    }
  };

  // ../../../packages/tlsync-client/src/lib/alerts.ts
  function showCantWriteToIndexDbAlert() {
    window.alert(
      `Oops! We could not save changes to your browser's storage. We now need to reload the page and try again.

Keep seeing this message?
\u2022 If you're using tldraw in a private or "incognito" window, try loading tldraw in a regular window or in a different browser.
\u2022 If your hard disk is full, try clearing up some space and then reload the page.`
    );
  }
  function showCantReadFromIndexDbAlert() {
    window.alert(
      `Oops! We could not access to your browser's storage\u2014and the app won't work correctly without that. We now need to reload the page and try again.

Keep seeing this message?
\u2022 If you're using tldraw in a private or "incognito" window, try loading tldraw in a regular window or in a different browser.`
    );
  }

  // ../../../node_modules/idb/build/wrap-idb-value.js
  var instanceOfAny = (object2, constructors) => constructors.some((c3) => object2 instanceof c3);
  var idbProxyableTypes;
  var cursorAdvanceMethods;
  function getIdbProxyableTypes() {
    return idbProxyableTypes || (idbProxyableTypes = [
      IDBDatabase,
      IDBObjectStore,
      IDBIndex,
      IDBCursor,
      IDBTransaction
    ]);
  }
  function getCursorAdvanceMethods() {
    return cursorAdvanceMethods || (cursorAdvanceMethods = [
      IDBCursor.prototype.advance,
      IDBCursor.prototype.continue,
      IDBCursor.prototype.continuePrimaryKey
    ]);
  }
  var cursorRequestMap = /* @__PURE__ */ new WeakMap();
  var transactionDoneMap = /* @__PURE__ */ new WeakMap();
  var transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();
  var transformCache = /* @__PURE__ */ new WeakMap();
  var reverseTransformCache = /* @__PURE__ */ new WeakMap();
  function promisifyRequest(request) {
    const promise = new Promise((resolve, reject) => {
      const unlisten = () => {
        request.removeEventListener("success", success);
        request.removeEventListener("error", error);
      };
      const success = () => {
        resolve(wrap(request.result));
        unlisten();
      };
      const error = () => {
        reject(request.error);
        unlisten();
      };
      request.addEventListener("success", success);
      request.addEventListener("error", error);
    });
    promise.then((value) => {
      if (value instanceof IDBCursor) {
        cursorRequestMap.set(value, request);
      }
    }).catch(() => {
    });
    reverseTransformCache.set(promise, request);
    return promise;
  }
  function cacheDonePromiseForTransaction(tx) {
    if (transactionDoneMap.has(tx))
      return;
    const done = new Promise((resolve, reject) => {
      const unlisten = () => {
        tx.removeEventListener("complete", complete);
        tx.removeEventListener("error", error);
        tx.removeEventListener("abort", error);
      };
      const complete = () => {
        resolve();
        unlisten();
      };
      const error = () => {
        reject(tx.error || new DOMException("AbortError", "AbortError"));
        unlisten();
      };
      tx.addEventListener("complete", complete);
      tx.addEventListener("error", error);
      tx.addEventListener("abort", error);
    });
    transactionDoneMap.set(tx, done);
  }
  var idbProxyTraps = {
    get(target, prop, receiver) {
      if (target instanceof IDBTransaction) {
        if (prop === "done")
          return transactionDoneMap.get(target);
        if (prop === "objectStoreNames") {
          return target.objectStoreNames || transactionStoreNamesMap.get(target);
        }
        if (prop === "store") {
          return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
        }
      }
      return wrap(target[prop]);
    },
    set(target, prop, value) {
      target[prop] = value;
      return true;
    },
    has(target, prop) {
      if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
        return true;
      }
      return prop in target;
    }
  };
  function replaceTraps(callback) {
    idbProxyTraps = callback(idbProxyTraps);
  }
  function wrapFunction(func) {
    if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
      return function(storeNames, ...args) {
        const tx = func.call(unwrap(this), storeNames, ...args);
        transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
        return wrap(tx);
      };
    }
    if (getCursorAdvanceMethods().includes(func)) {
      return function(...args) {
        func.apply(unwrap(this), args);
        return wrap(cursorRequestMap.get(this));
      };
    }
    return function(...args) {
      return wrap(func.apply(unwrap(this), args));
    };
  }
  function transformCachableValue(value) {
    if (typeof value === "function")
      return wrapFunction(value);
    if (value instanceof IDBTransaction)
      cacheDonePromiseForTransaction(value);
    if (instanceOfAny(value, getIdbProxyableTypes()))
      return new Proxy(value, idbProxyTraps);
    return value;
  }
  function wrap(value) {
    if (value instanceof IDBRequest)
      return promisifyRequest(value);
    if (transformCache.has(value))
      return transformCache.get(value);
    const newValue = transformCachableValue(value);
    if (newValue !== value) {
      transformCache.set(value, newValue);
      reverseTransformCache.set(newValue, value);
    }
    return newValue;
  }
  var unwrap = (value) => reverseTransformCache.get(value);

  // ../../../node_modules/idb/build/index.js
  function openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {
    const request = indexedDB.open(name, version);
    const openPromise = wrap(request);
    if (upgrade) {
      request.addEventListener("upgradeneeded", (event) => {
        upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);
      });
    }
    if (blocked) {
      request.addEventListener("blocked", (event) => blocked(
        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
        event.oldVersion,
        event.newVersion,
        event
      ));
    }
    openPromise.then((db) => {
      if (terminated)
        db.addEventListener("close", () => terminated());
      if (blocking) {
        db.addEventListener("versionchange", (event) => blocking(event.oldVersion, event.newVersion, event));
      }
    }).catch(() => {
    });
    return openPromise;
  }
  function deleteDB(name, { blocked } = {}) {
    const request = indexedDB.deleteDatabase(name);
    if (blocked) {
      request.addEventListener("blocked", (event) => blocked(
        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
        event.oldVersion,
        event
      ));
    }
    return wrap(request).then(() => void 0);
  }
  var readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
  var writeMethods = ["put", "add", "delete", "clear"];
  var cachedMethods = /* @__PURE__ */ new Map();
  function getMethod(target, prop) {
    if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
      return;
    }
    if (cachedMethods.get(prop))
      return cachedMethods.get(prop);
    const targetFuncName = prop.replace(/FromIndex$/, "");
    const useIndex = prop !== targetFuncName;
    const isWrite = writeMethods.includes(targetFuncName);
    if (
      // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
      !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
    ) {
      return;
    }
    const method = function(storeName, ...args) {
      return __async(this, null, function* () {
        const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
        let target2 = tx.store;
        if (useIndex)
          target2 = target2.index(args.shift());
        return (yield Promise.all([
          target2[targetFuncName](...args),
          isWrite && tx.done
        ]))[0];
      });
    };
    cachedMethods.set(prop, method);
    return method;
  }
  replaceTraps((oldTraps) => __spreadProps(__spreadValues({}, oldTraps), {
    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
  }));

  // ../../../packages/tlsync-client/src/lib/persistence-constants.ts
  var tabIdKey = "TLDRAW_TAB_ID_v2";
  var window2 = globalThis.window;
  function iOS() {
    if (!window2)
      return false;
    return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(
      window2.navigator.platform
    ) || // iPad on iOS 13 detection
    window2.navigator.userAgent.includes("Mac") && "ontouchend" in document;
  }
  var USER_DATA_KEY = "TLDRAW_USER_DATA_v2";
  var _a2;
  var globalUserData = atom(
    "globalUserData",
    (_a2 = JSON.parse((window2 == null ? void 0 : window2.localStorage.getItem(USER_DATA_KEY)) || "null")) != null ? _a2 : TLUser.create({})
  );
  react("set global user data", () => {
    if (window2) {
      window2.localStorage.setItem(USER_DATA_KEY, JSON.stringify(globalUserData.value));
    }
  });
  function subscribeToUserData(store) {
    const userId = globalUserData.value.id;
    return store.listen(({ changes }) => {
      for (const record of Object.values(changes.added)) {
        if (record.typeName === "user" && userId === record.id) {
          globalUserData.set(record);
        }
      }
      for (const [_, record] of Object.values(changes.updated)) {
        if (record.typeName === "user" && userId === record.id) {
          globalUserData.set(record);
        }
      }
    });
  }
  var defaultDocumentKey = "TLDRAW_DEFAULT_DOCUMENT_NAME_v2";
  var _a3;
  var DEFAULT_DOCUMENT_NAME = (_a3 = window2 == null ? void 0 : window2.localStorage.getItem(defaultDocumentKey)) != null ? _a3 : uniqueId();
  window2 == null ? void 0 : window2.localStorage.setItem(defaultDocumentKey, DEFAULT_DOCUMENT_NAME);
  var STORE_PREFIX = "TLDRAW_DOCUMENT_v2";
  var _a4, _b;
  var TAB_ID = (_b = (_a4 = window2 == null ? void 0 : window2[tabIdKey]) != null ? _a4 : window2 == null ? void 0 : window2.sessionStorage[tabIdKey]) != null ? _b : TLInstance.createId();
  if (window2) {
    window2[tabIdKey] = TAB_ID;
    if (iOS()) {
      window2.sessionStorage[tabIdKey] = TAB_ID;
    } else {
      delete window2.sessionStorage[tabIdKey];
    }
  }
  window2 == null ? void 0 : window2.addEventListener("beforeunload", () => {
    window2.sessionStorage[tabIdKey] = TAB_ID;
  });
  var dbNameIndexKey = "TLDRAW_DB_NAME_INDEX_v2";
  function getAllIndexDbNames() {
    var _a5;
    const result = (_a5 = JSON.parse((window2 == null ? void 0 : window2.localStorage.getItem(dbNameIndexKey)) || "[]")) != null ? _a5 : [];
    if (!Array.isArray(result)) {
      return [];
    }
    return result;
  }
  function addDbName(name) {
    const all = new Set(getAllIndexDbNames());
    all.add(name);
    window2 == null ? void 0 : window2.localStorage.setItem(dbNameIndexKey, JSON.stringify([...all]));
  }

  // ../../../packages/tlsync-client/src/lib/indexedDb.ts
  function withDb(storeId, cb) {
    return __async(this, null, function* () {
      addDbName(storeId);
      const db = yield openDB(storeId, 2, {
        upgrade(database) {
          if (!database.objectStoreNames.contains("records")) {
            database.createObjectStore("records");
          }
          database.createObjectStore("schema");
        }
      });
      try {
        return yield cb(db);
      } finally {
        db.close();
      }
    });
  }
  function loadDataFromStore(universalPersistenceKey, opts) {
    return __async(this, null, function* () {
      const storeId = STORE_PREFIX + universalPersistenceKey;
      if (!getAllIndexDbNames().includes(storeId))
        return void 0;
      return yield withDb(storeId, (db) => __async(this, null, function* () {
        var _a5;
        if ((_a5 = opts == null ? void 0 : opts.didCancel) == null ? void 0 : _a5.call(opts))
          return void 0;
        const tx = db.transaction(["records", "schema"], "readonly");
        const recordsStore = tx.objectStore("records");
        const schemaStore = tx.objectStore("schema");
        return {
          records: yield recordsStore.getAll(),
          schema: yield schemaStore.get("schema")
        };
      }));
    });
  }
  function storeChangesInIndexedDb(universalPersistenceKey, schema, changes, opts) {
    return __async(this, null, function* () {
      const storeId = STORE_PREFIX + universalPersistenceKey;
      yield withDb(storeId, (db) => __async(this, null, function* () {
        var _a5;
        const tx = db.transaction(["records", "schema"], "readwrite");
        const recordsStore = tx.objectStore("records");
        const schemaStore = tx.objectStore("schema");
        for (const [id, record] of Object.entries(changes.added)) {
          yield recordsStore.put(record, id);
        }
        for (const [_prev, updated] of Object.values(changes.updated)) {
          yield recordsStore.put(updated, updated.id);
        }
        for (const id of Object.keys(changes.removed)) {
          yield recordsStore.delete(id);
        }
        schemaStore.put(schema.serialize(), "schema");
        if ((_a5 = opts == null ? void 0 : opts.didCancel) == null ? void 0 : _a5.call(opts))
          return tx.abort();
        yield tx.done;
      }));
    });
  }
  function storeSnapshotInIndexedDb(universalPersistenceKey, schema, snapshot, opts) {
    return __async(this, null, function* () {
      const storeId = STORE_PREFIX + universalPersistenceKey;
      yield withDb(storeId, (db) => __async(this, null, function* () {
        var _a5;
        const tx = db.transaction(["records", "schema"], "readwrite");
        const recordsStore = tx.objectStore("records");
        const schemaStore = tx.objectStore("schema");
        yield recordsStore.clear();
        for (const [id, record] of Object.entries(snapshot)) {
          yield recordsStore.put(record, id);
        }
        schemaStore.put(schema.serialize(), "schema");
        if ((_a5 = opts == null ? void 0 : opts.didCancel) == null ? void 0 : _a5.call(opts))
          return tx.abort();
        yield tx.done;
      }));
    });
  }

  // ../../../packages/tlsync-client/src/lib/TLLocalSyncClient.ts
  var PERSIST_THROTTLE_MS = 350;
  var PERSIST_RETRY_THROTTLE_MS = 1e4;
  var msg = (msg2) => msg2;
  var BroadcastChannelMock = class {
    constructor(_name) {
      __publicField(this, "onmessage");
    }
    postMessage(_msg) {
    }
    close() {
    }
  };
  var BC = typeof BroadcastChannel === "undefined" ? BroadcastChannelMock : BroadcastChannel;
  var TLLocalSyncClient = class {
    constructor(store, {
      universalPersistenceKey,
      onLoad,
      onLoadError
    }, channel = new BC(`tldraw-tab-sync-${universalPersistenceKey}`)) {
      this.store = store;
      this.channel = channel;
      __publicField(this, "disposables", /* @__PURE__ */ new Set());
      __publicField(this, "diffQueue", []);
      __publicField(this, "didDispose", false);
      __publicField(this, "shouldDoFullDBWrite", true);
      __publicField(this, "isReloading", false);
      __publicField(this, "universalPersistenceKey");
      __publicField(this, "serializedSchema");
      __publicField(this, "isDebugging", false);
      __publicField(this, "initTime", Date.now());
      __publicField(this, "isPersisting", false);
      __publicField(this, "didLastWriteError", false);
      __publicField(this, "scheduledPersistTimeout", null);
      if (typeof window !== "undefined") {
        ;
        window.tlsync = this;
      }
      this.universalPersistenceKey = universalPersistenceKey;
      this.serializedSchema = this.store.schema.serialize();
      this.disposables.add(
        // Set up a subscription to changes from the store: When
        // the store changes (and if the change was made by the user)
        // then immediately send the diff to other tabs via postMessage
        // and schedule a persist.
        store.listen(({ changes, source }) => {
          this.debug("changes", changes, source);
          if (source === "user") {
            this.diffQueue.push(changes);
            this.channel.postMessage(
              msg({
                type: "diff",
                instanceId: this.store.props.instanceId,
                changes,
                schema: this.serializedSchema
              })
            );
            this.schedulePersist();
          }
        })
      );
      this.connect(onLoad, onLoadError);
    }
    debug(...args) {
      if (this.isDebugging) {
        console.debug(...args);
      }
    }
    connect(onLoad, onLoadError) {
      return __async(this, null, function* () {
        var _a5;
        this.debug("connecting");
        let data;
        try {
          data = yield loadDataFromStore(this.universalPersistenceKey);
        } catch (error) {
          onLoadError(error);
          showCantReadFromIndexDbAlert();
          if (typeof window !== "undefined") {
            window.location.reload();
          }
          return;
        }
        this.debug("loaded data from store", data, "didDispose", this.didDispose);
        if (this.didDispose)
          return;
        try {
          if (data) {
            const snapshot = Object.fromEntries(data.records.map((r3) => [r3.id, r3]));
            const migrationResult = this.store.schema.migrateStoreSnapshot(
              snapshot,
              (_a5 = data.schema) != null ? _a5 : this.store.schema.serializeEarliestVersion()
            );
            if (migrationResult.type === "error") {
              console.error("failed to migrate store", migrationResult);
              onLoadError(new Error(`Failed to migrate store: ${migrationResult.reason}`));
              return;
            }
            this.store.mergeRemoteChanges(() => {
              this.store.put(Object.values(migrationResult.value), "initialize");
            });
          }
          this.channel.onmessage = ({ data: data2 }) => {
            var _a6, _b2, _c;
            this.debug("got message", data2);
            const msg2 = data2;
            const comparison = compareSchemas(
              this.serializedSchema,
              (_a6 = msg2.schema) != null ? _a6 : this.store.schema.serializeEarliestVersion()
            );
            if (comparison === -1) {
              const timeSinceInit = Date.now() - this.initTime;
              if (timeSinceInit < 5e3) {
                onLoadError(new Error("Schema mismatch, please close other tabs and reload the page"));
                return;
              }
              this.debug("reloading");
              this.isReloading = true;
              (_c = (_b2 = window == null ? void 0 : window.location) == null ? void 0 : _b2.reload) == null ? void 0 : _c.call(_b2);
              return;
            } else if (comparison === 1) {
              this.debug("telling them to reload");
              this.channel.postMessage({ type: "announce", schema: this.serializedSchema });
              this.shouldDoFullDBWrite = true;
              this.persistIfNeeded();
              return;
            }
            if (msg2.type === "diff") {
              this.debug("applying diff");
              const doesDeleteInstance = hasOwnProperty(
                msg2.changes.removed,
                this.store.props.instanceId
              );
              transact(() => {
                this.store.mergeRemoteChanges(() => {
                  this.store.applyDiff(msg2.changes);
                });
                if (doesDeleteInstance) {
                  this.store.ensureStoreIsUsable();
                }
              });
            }
          };
          this.channel.postMessage({ type: "announce", schema: this.serializedSchema });
          this.disposables.add(() => {
            this.channel.close();
          });
          onLoad(this);
        } catch (e2) {
          this.debug("error loading data from store", e2);
          if (this.didDispose)
            return;
          onLoadError(e2);
          return;
        }
      });
    }
    close() {
      this.debug("closing");
      this.didDispose = true;
      this.disposables.forEach((d3) => d3());
    }
    /**
     * Schedule a persist. Persists don't happen immediately: they are throttled to avoid writing too
     * often, and will retry if failed.
     *
     * @internal
     */
    schedulePersist() {
      this.debug("schedulePersist", this.scheduledPersistTimeout);
      if (this.scheduledPersistTimeout)
        return;
      this.scheduledPersistTimeout = setTimeout(
        () => {
          this.scheduledPersistTimeout = null;
          this.persistIfNeeded();
        },
        this.didLastWriteError ? PERSIST_RETRY_THROTTLE_MS : PERSIST_THROTTLE_MS
      );
    }
    /**
     * Persist to indexeddb only under certain circumstances:
     *
     * - If we're not already persisting
     * - If we're not reloading the page
     * - And we have something to persist (a full db write scheduled or changes in the diff queue)
     *
     * @internal
     */
    persistIfNeeded() {
      this.debug("persistIfNeeded", {
        isPersisting: this.isPersisting,
        isReloading: this.isReloading,
        shouldDoFullDBWrite: this.shouldDoFullDBWrite,
        diffQueueLength: this.diffQueue.length,
        storeIsPossiblyCorrupt: this.store.isPossiblyCorrupted()
      });
      if (this.scheduledPersistTimeout) {
        clearTimeout(this.scheduledPersistTimeout);
        this.scheduledPersistTimeout = null;
      }
      if (this.isPersisting)
        return;
      if (this.isReloading)
        return;
      if (this.store.isPossiblyCorrupted())
        return;
      if (this.shouldDoFullDBWrite || this.diffQueue.length > 0) {
        this.doPersist();
      }
    }
    /**
     * Actually persist to indexeddb. If the write fails, then we'll retry with a full db write after
     * a short delay.
     */
    doPersist() {
      return __async(this, null, function* () {
        assert(!this.isPersisting, "persist already in progress");
        this.isPersisting = true;
        this.debug("doPersist start");
        const diffQueue = this.diffQueue;
        this.diffQueue = [];
        try {
          if (this.shouldDoFullDBWrite) {
            this.shouldDoFullDBWrite = false;
            yield storeSnapshotInIndexedDb(
              this.universalPersistenceKey,
              this.store.schema,
              this.store.serialize(),
              {
                didCancel: () => this.didDispose
              }
            );
          } else {
            const diffs = squashRecordDiffs(diffQueue);
            yield storeChangesInIndexedDb(this.universalPersistenceKey, this.store.schema, diffs);
          }
          this.didLastWriteError = false;
        } catch (e2) {
          this.shouldDoFullDBWrite = true;
          this.didLastWriteError = true;
          console.error("failed to store changes in indexed db", e2);
          showCantWriteToIndexDbAlert();
          if (typeof window !== "undefined") {
            window.location.reload();
          }
        }
        this.isPersisting = false;
        this.debug("doPersist end");
        this.schedulePersist();
      });
    }
  };

  // ../../../packages/tlsync-client/src/lib/hardReset.ts
  function hardReset() {
    return __async(this, arguments, function* ({ shouldReload = true } = {}) {
      sessionStorage.clear();
      yield Promise.all(getAllIndexDbNames().map((db) => deleteDB(db)));
      localStorage.clear();
      if (shouldReload) {
        window.location.reload();
      }
    });
  }
  if (typeof window !== "undefined") {
    if (false) {
      ;
      window.hardReset = hardReset;
    }
    ;
    window.__tldraw__hardReset = hardReset;
  }

  // ../../../packages/tlsync-client/src/lib/hooks/useLocalSyncClient.ts
  var import_react113 = __toESM(require_react());
  function useLocalSyncClient({
    universalPersistenceKey,
    instanceId,
    userId,
    config = TldrawEditorConfig.default
  }) {
    var _a5;
    const [state, setState] = (0, import_react113.useState)(null);
    (0, import_react113.useEffect)(() => {
      const id = uniqueId();
      setState({
        id,
        syncedStore: { status: "loading" }
      });
      const setSyncedStore = (syncedStore) => {
        setState((prev) => {
          if ((prev == null ? void 0 : prev.id) === id) {
            return { id, syncedStore };
          }
          return prev;
        });
      };
      const store = config.createStore({ userId, instanceId });
      const client = new TLLocalSyncClient(store, {
        universalPersistenceKey,
        onLoad() {
          setSyncedStore({ status: "synced", store });
        },
        onLoadError(err) {
          setSyncedStore({ status: "error", error: err });
        }
      });
      const userDataUnsubcribe = subscribeToUserData(store);
      return () => {
        setState((prevState) => (prevState == null ? void 0 : prevState.id) === id ? null : prevState);
        userDataUnsubcribe();
        client.close();
      };
    }, [instanceId, universalPersistenceKey, config, userId]);
    return (_a5 = state == null ? void 0 : state.syncedStore) != null ? _a5 : { status: "loading" };
  }

  // ../../../packages/assets/embed-icons/codepen.png
  var codepen_default = "./codepen-F75FYE3V.png";

  // ../../../packages/assets/embed-icons/codesandbox.png
  var codesandbox_default = "./codesandbox-XTXJ37KO.png";

  // ../../../packages/assets/embed-icons/excalidraw.png
  var excalidraw_default = "./excalidraw-XL4NHOJW.png";

  // ../../../packages/assets/embed-icons/felt.png
  var felt_default = "./felt-YAXTMYRP.png";

  // ../../../packages/assets/embed-icons/figma.png
  var figma_default = "./figma-YEX4AS3Y.png";

  // ../../../packages/assets/embed-icons/github_gist.png
  var github_gist_default = "./github_gist-J3DR2ZDJ.png";

  // ../../../packages/assets/embed-icons/google_calendar.png
  var google_calendar_default = "./google_calendar-VTOZMTEN.png";

  // ../../../packages/assets/embed-icons/google_maps.png
  var google_maps_default = "./google_maps-HALB726N.png";

  // ../../../packages/assets/embed-icons/google_slides.png
  var google_slides_default = "./google_slides-RNWJX3XY.png";

  // ../../../packages/assets/embed-icons/observable.png
  var observable_default = "./observable-ZMVDXS6P.png";

  // ../../../packages/assets/embed-icons/replit.png
  var replit_default = "./replit-AW7ECK7S.png";

  // ../../../packages/assets/embed-icons/scratch.png
  var scratch_default = "./scratch-OEIUFB7O.png";

  // ../../../packages/assets/embed-icons/spotify.png
  var spotify_default = "./spotify-NDV5KDHT.png";

  // ../../../packages/assets/embed-icons/tldraw.png
  var tldraw_default = "./tldraw-DTFBW7TG.png";

  // ../../../packages/assets/embed-icons/vimeo.png
  var vimeo_default = "./vimeo-XELEUQDY.png";

  // ../../../packages/assets/embed-icons/youtube.png
  var youtube_default = "./youtube-WXNPHK6F.png";

  // ../../../packages/assets/fonts/IBMPlexMono-Medium.woff2
  var IBMPlexMono_Medium_default = "data:font/woff2;base64,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";

  // ../../../packages/assets/fonts/IBMPlexSans-Medium.woff2
  var IBMPlexSans_Medium_default = "data:font/woff2;base64,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";

  // ../../../packages/assets/fonts/IBMPlexSerif-Medium.woff2
  var IBMPlexSerif_Medium_default = "data:font/woff2;base64,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";

  // ../../../packages/assets/fonts/Shantell_Sans-Normal-SemiBold.woff2
  var Shantell_Sans_Normal_SemiBold_default = "data:font/woff2;base64,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";

  // ../../../packages/assets/icons/icon/align-bottom-center.svg
  var align_bottom_center_default = "./align-bottom-center-CSBP6QTZ.svg";

  // ../../../packages/assets/icons/icon/align-bottom-left.svg
  var align_bottom_left_default = "./align-bottom-left-AHNIB445.svg";

  // ../../../packages/assets/icons/icon/align-bottom-right.svg
  var align_bottom_right_default = "./align-bottom-right-IHPBZBXI.svg";

  // ../../../packages/assets/icons/icon/align-bottom.svg
  var align_bottom_default = "./align-bottom-R257ONEK.svg";

  // ../../../packages/assets/icons/icon/align-center-center.svg
  var align_center_center_default = "./align-center-center-VCLNOO2W.svg";

  // ../../../packages/assets/icons/icon/align-center-horizontal.svg
  var align_center_horizontal_default = "./align-center-horizontal-5VHTDUMJ.svg";

  // ../../../packages/assets/icons/icon/align-center-left.svg
  var align_center_left_default = "./align-center-left-42VN7ECS.svg";

  // ../../../packages/assets/icons/icon/align-center-right.svg
  var align_center_right_default = "./align-center-right-4FGKFC5X.svg";

  // ../../../packages/assets/icons/icon/align-center-vertical.svg
  var align_center_vertical_default = "./align-center-vertical-GMWASLGB.svg";

  // ../../../packages/assets/icons/icon/align-left.svg
  var align_left_default = "./align-left-5HEFCE7W.svg";

  // ../../../packages/assets/icons/icon/align-right.svg
  var align_right_default = "./align-right-72DPSEA4.svg";

  // ../../../packages/assets/icons/icon/align-top-center.svg
  var align_top_center_default = "./align-top-center-GCY6SXO6.svg";

  // ../../../packages/assets/icons/icon/align-top-left.svg
  var align_top_left_default = "./align-top-left-QX3PPIRZ.svg";

  // ../../../packages/assets/icons/icon/align-top-right.svg
  var align_top_right_default = "./align-top-right-KZH6VKZS.svg";

  // ../../../packages/assets/icons/icon/align-top.svg
  var align_top_default = "./align-top-EGCVQVP7.svg";

  // ../../../packages/assets/icons/icon/arrow-left.svg
  var arrow_left_default = "./arrow-left-WXBKOZZ3.svg";

  // ../../../packages/assets/icons/icon/arrowhead-arrow.svg
  var arrowhead_arrow_default = "./arrowhead-arrow-HVXKBQ5X.svg";

  // ../../../packages/assets/icons/icon/arrowhead-bar.svg
  var arrowhead_bar_default = "./arrowhead-bar-3CTU5K5M.svg";

  // ../../../packages/assets/icons/icon/arrowhead-diamond.svg
  var arrowhead_diamond_default = "./arrowhead-diamond-NK2JB2H3.svg";

  // ../../../packages/assets/icons/icon/arrowhead-dot.svg
  var arrowhead_dot_default = "./arrowhead-dot-EZWTRDT6.svg";

  // ../../../packages/assets/icons/icon/arrowhead-none.svg
  var arrowhead_none_default = "./arrowhead-none-V2X57KDJ.svg";

  // ../../../packages/assets/icons/icon/arrowhead-square.svg
  var arrowhead_square_default = "./arrowhead-square-YRMYHYGM.svg";

  // ../../../packages/assets/icons/icon/arrowhead-triangle-inverted.svg
  var arrowhead_triangle_inverted_default = "./arrowhead-triangle-inverted-K4DOKJE3.svg";

  // ../../../packages/assets/icons/icon/arrowhead-triangle.svg
  var arrowhead_triangle_default = "./arrowhead-triangle-KBOFPZWU.svg";

  // ../../../packages/assets/icons/icon/aspect-ratio.svg
  var aspect_ratio_default = "./aspect-ratio-TLDHMBOA.svg";

  // ../../../packages/assets/icons/icon/avatar.svg
  var avatar_default = "./avatar-SR2HBC7K.svg";

  // ../../../packages/assets/icons/icon/blob.svg
  var blob_default = "./blob-SNMNIYW3.svg";

  // ../../../packages/assets/icons/icon/bring-forward.svg
  var bring_forward_default = "./bring-forward-ORK5HVGK.svg";

  // ../../../packages/assets/icons/icon/bring-to-front.svg
  var bring_to_front_default = "./bring-to-front-6GSLYX2K.svg";

  // ../../../packages/assets/icons/icon/check.svg
  var check_default = "./check-MJKLH5SR.svg";

  // ../../../packages/assets/icons/icon/checkbox-checked.svg
  var checkbox_checked_default = "./checkbox-checked-5PBUY3Y7.svg";

  // ../../../packages/assets/icons/icon/checkbox-empty.svg
  var checkbox_empty_default = "./checkbox-empty-TQVZAZ6A.svg";

  // ../../../packages/assets/icons/icon/chevron-down.svg
  var chevron_down_default = "./chevron-down-AEDWWYCO.svg";

  // ../../../packages/assets/icons/icon/chevron-left.svg
  var chevron_left_default = "./chevron-left-YCK4SACI.svg";

  // ../../../packages/assets/icons/icon/chevron-right.svg
  var chevron_right_default = "./chevron-right-EFDMDQQM.svg";

  // ../../../packages/assets/icons/icon/chevron-up.svg
  var chevron_up_default = "./chevron-up-Y35TAHPL.svg";

  // ../../../packages/assets/icons/icon/chevrons-ne.svg
  var chevrons_ne_default = "./chevrons-ne-S5YHLDEF.svg";

  // ../../../packages/assets/icons/icon/chevrons-sw.svg
  var chevrons_sw_default = "./chevrons-sw-AS5SQCAQ.svg";

  // ../../../packages/assets/icons/icon/clipboard-copied.svg
  var clipboard_copied_default = "./clipboard-copied-NRCIIFUH.svg";

  // ../../../packages/assets/icons/icon/clipboard-copy.svg
  var clipboard_copy_default = "./clipboard-copy-IDTLWT5R.svg";

  // ../../../packages/assets/icons/icon/code.svg
  var code_default = "./code-PAX667R5.svg";

  // ../../../packages/assets/icons/icon/collab.svg
  var collab_default = "./collab-AWBOOTTN.svg";

  // ../../../packages/assets/icons/icon/color.svg
  var color_default = "./color-C2MERTHH.svg";

  // ../../../packages/assets/icons/icon/comment.svg
  var comment_default = "./comment-PZLNENXF.svg";

  // ../../../packages/assets/icons/icon/cross-2.svg
  var cross_2_default = "./cross-2-WTELNK2S.svg";

  // ../../../packages/assets/icons/icon/cross.svg
  var cross_default = "./cross-XALPFMSI.svg";

  // ../../../packages/assets/icons/icon/dash-dashed.svg
  var dash_dashed_default = "./dash-dashed-T4FQN6V6.svg";

  // ../../../packages/assets/icons/icon/dash-dotted.svg
  var dash_dotted_default = "./dash-dotted-S6I3OK6V.svg";

  // ../../../packages/assets/icons/icon/dash-draw.svg
  var dash_draw_default = "./dash-draw-J433ABMT.svg";

  // ../../../packages/assets/icons/icon/dash-solid.svg
  var dash_solid_default = "./dash-solid-A2CYPN3Y.svg";

  // ../../../packages/assets/icons/icon/discord.svg
  var discord_default = "./discord-GTFVFCES.svg";

  // ../../../packages/assets/icons/icon/distribute-horizontal.svg
  var distribute_horizontal_default = "./distribute-horizontal-VVKJEIWP.svg";

  // ../../../packages/assets/icons/icon/distribute-vertical.svg
  var distribute_vertical_default = "./distribute-vertical-KIBWN6LC.svg";

  // ../../../packages/assets/icons/icon/dot.svg
  var dot_default = "./dot-JIBX5YKB.svg";

  // ../../../packages/assets/icons/icon/dots-horizontal.svg
  var dots_horizontal_default = "./dots-horizontal-TJ5CT2HQ.svg";

  // ../../../packages/assets/icons/icon/dots-vertical.svg
  var dots_vertical_default = "./dots-vertical-HFP5CX3R.svg";

  // ../../../packages/assets/icons/icon/drag-handle-dots.svg
  var drag_handle_dots_default = "./drag-handle-dots-5SIPN6GZ.svg";

  // ../../../packages/assets/icons/icon/duplicate.svg
  var duplicate_default = "./duplicate-7PYPTSEE.svg";

  // ../../../packages/assets/icons/icon/edit.svg
  var edit_default = "./edit-UMAZLCJY.svg";

  // ../../../packages/assets/icons/icon/external-link.svg
  var external_link_default = "./external-link-BMQKUVXV.svg";

  // ../../../packages/assets/icons/icon/file.svg
  var file_default = "./file-LTENAHJE.svg";

  // ../../../packages/assets/icons/icon/fill-none.svg
  var fill_none_default = "./fill-none-QXN252XI.svg";

  // ../../../packages/assets/icons/icon/fill-pattern.svg
  var fill_pattern_default = "./fill-pattern-ZQVGLBIQ.svg";

  // ../../../packages/assets/icons/icon/fill-semi.svg
  var fill_semi_default = "./fill-semi-3TBWK7BX.svg";

  // ../../../packages/assets/icons/icon/fill-solid.svg
  var fill_solid_default = "./fill-solid-CM3AOVVJ.svg";

  // ../../../packages/assets/icons/icon/follow.svg
  var follow_default = "./follow-SO6ZXSIY.svg";

  // ../../../packages/assets/icons/icon/following.svg
  var following_default = "./following-3XSTNMGV.svg";

  // ../../../packages/assets/icons/icon/font-draw.svg
  var font_draw_default = "./font-draw-3A77N2BF.svg";

  // ../../../packages/assets/icons/icon/font-mono.svg
  var font_mono_default = "./font-mono-ZGMLFTH2.svg";

  // ../../../packages/assets/icons/icon/font-sans.svg
  var font_sans_default = "./font-sans-IBKENC3S.svg";

  // ../../../packages/assets/icons/icon/font-serif.svg
  var font_serif_default = "./font-serif-H5DCWABA.svg";

  // ../../../packages/assets/icons/icon/geo-arrow-down.svg
  var geo_arrow_down_default = "./geo-arrow-down-MKGVU75B.svg";

  // ../../../packages/assets/icons/icon/geo-arrow-left.svg
  var geo_arrow_left_default = "./geo-arrow-left-PIJP74PH.svg";

  // ../../../packages/assets/icons/icon/geo-arrow-right.svg
  var geo_arrow_right_default = "./geo-arrow-right-M65DKF6Q.svg";

  // ../../../packages/assets/icons/icon/geo-arrow-up.svg
  var geo_arrow_up_default = "./geo-arrow-up-5IN7Z4LD.svg";

  // ../../../packages/assets/icons/icon/geo-check-box.svg
  var geo_check_box_default = "./geo-check-box-IL7YZFE5.svg";

  // ../../../packages/assets/icons/icon/geo-diamond.svg
  var geo_diamond_default = "./geo-diamond-4TYP6MOF.svg";

  // ../../../packages/assets/icons/icon/geo-ellipse.svg
  var geo_ellipse_default = "./geo-ellipse-Q23XPT2V.svg";

  // ../../../packages/assets/icons/icon/geo-hexagon.svg
  var geo_hexagon_default = "./geo-hexagon-XMFBQVVM.svg";

  // ../../../packages/assets/icons/icon/geo-octagon.svg
  var geo_octagon_default = "./geo-octagon-YJ44SLUA.svg";

  // ../../../packages/assets/icons/icon/geo-oval.svg
  var geo_oval_default = "./geo-oval-SYOXXWFS.svg";

  // ../../../packages/assets/icons/icon/geo-pentagon.svg
  var geo_pentagon_default = "./geo-pentagon-43OK57W2.svg";

  // ../../../packages/assets/icons/icon/geo-rectangle.svg
  var geo_rectangle_default = "./geo-rectangle-FI77PTXK.svg";

  // ../../../packages/assets/icons/icon/geo-rhombus-2.svg
  var geo_rhombus_2_default = "./geo-rhombus-2-CPKCBYZS.svg";

  // ../../../packages/assets/icons/icon/geo-rhombus.svg
  var geo_rhombus_default = "./geo-rhombus-V3CIWP3W.svg";

  // ../../../packages/assets/icons/icon/geo-star.svg
  var geo_star_default = "./geo-star-RJCHP24Q.svg";

  // ../../../packages/assets/icons/icon/geo-trapezoid.svg
  var geo_trapezoid_default = "./geo-trapezoid-KQL3QW3P.svg";

  // ../../../packages/assets/icons/icon/geo-triangle.svg
  var geo_triangle_default = "./geo-triangle-XQNOYI6T.svg";

  // ../../../packages/assets/icons/icon/geo-x-box.svg
  var geo_x_box_default = "./geo-x-box-HGEG6XBE.svg";

  // ../../../packages/assets/icons/icon/github.svg
  var github_default = "./github-RDJM6DMJ.svg";

  // ../../../packages/assets/icons/icon/group.svg
  var group_default = "./group-JGT3FVEG.svg";

  // ../../../packages/assets/icons/icon/hidden.svg
  var hidden_default = "./hidden-EADDQTOH.svg";

  // ../../../packages/assets/icons/icon/image.svg
  var image_default = "./image-EUCUCPPZ.svg";

  // ../../../packages/assets/icons/icon/info-circle.svg
  var info_circle_default = "./info-circle-P6JHAA4T.svg";

  // ../../../packages/assets/icons/icon/leading.svg
  var leading_default = "./leading-MBFJWTTL.svg";

  // ../../../packages/assets/icons/icon/link.svg
  var link_default = "./link-52VYRTL2.svg";

  // ../../../packages/assets/icons/icon/lock-small.svg
  var lock_small_default = "./lock-small-2MVIZCHG.svg";

  // ../../../packages/assets/icons/icon/lock.svg
  var lock_default = "./lock-SW5QRVCW.svg";

  // ../../../packages/assets/icons/icon/menu.svg
  var menu_default = "./menu-CPW3VEJN.svg";

  // ../../../packages/assets/icons/icon/minus.svg
  var minus_default = "./minus-6LPEEEM3.svg";

  // ../../../packages/assets/icons/icon/mixed.svg
  var mixed_default = "./mixed-AHWYMJE7.svg";

  // ../../../packages/assets/icons/icon/pack.svg
  var pack_default = "./pack-EIZVYEVQ.svg";

  // ../../../packages/assets/icons/icon/page.svg
  var page_default = "./page-ZUNLFK67.svg";

  // ../../../packages/assets/icons/icon/plus.svg
  var plus_default = "./plus-EPRFWZ4V.svg";

  // ../../../packages/assets/icons/icon/question-mark-circle.svg
  var question_mark_circle_default = "./question-mark-circle-XHRXDOE6.svg";

  // ../../../packages/assets/icons/icon/question-mark.svg
  var question_mark_default = "./question-mark-W645ZCFD.svg";

  // ../../../packages/assets/icons/icon/redo.svg
  var redo_default = "./redo-K6YZSD6B.svg";

  // ../../../packages/assets/icons/icon/reset-zoom.svg
  var reset_zoom_default = "./reset-zoom-ZLHUIWNH.svg";

  // ../../../packages/assets/icons/icon/rotate-ccw.svg
  var rotate_ccw_default = "./rotate-ccw-FU4E7RON.svg";

  // ../../../packages/assets/icons/icon/rotate-cw.svg
  var rotate_cw_default = "./rotate-cw-BJSZSRHL.svg";

  // ../../../packages/assets/icons/icon/ruler.svg
  var ruler_default = "./ruler-NYH6HO34.svg";

  // ../../../packages/assets/icons/icon/search.svg
  var search_default = "./search-NXQFUKLM.svg";

  // ../../../packages/assets/icons/icon/send-backward.svg
  var send_backward_default = "./send-backward-EACD3M2B.svg";

  // ../../../packages/assets/icons/icon/send-to-back.svg
  var send_to_back_default = "./send-to-back-EJSAMA6K.svg";

  // ../../../packages/assets/icons/icon/settings-horizontal.svg
  var settings_horizontal_default = "./settings-horizontal-PU4HGHHB.svg";

  // ../../../packages/assets/icons/icon/settings-vertical-1.svg
  var settings_vertical_1_default = "./settings-vertical-1-24HP5CDI.svg";

  // ../../../packages/assets/icons/icon/settings-vertical.svg
  var settings_vertical_default = "./settings-vertical-BPYUUUAQ.svg";

  // ../../../packages/assets/icons/icon/share-1.svg
  var share_1_default = "./share-1-G7XIMHPX.svg";

  // ../../../packages/assets/icons/icon/share-2.svg
  var share_2_default = "./share-2-LB4XZCZM.svg";

  // ../../../packages/assets/icons/icon/size-extra-large.svg
  var size_extra_large_default = "./size-extra-large-L4T2H4MR.svg";

  // ../../../packages/assets/icons/icon/size-large.svg
  var size_large_default = "./size-large-W4KDQJNO.svg";

  // ../../../packages/assets/icons/icon/size-medium.svg
  var size_medium_default = "./size-medium-I7S2MCK6.svg";

  // ../../../packages/assets/icons/icon/size-small.svg
  var size_small_default = "./size-small-RNHTL6ZK.svg";

  // ../../../packages/assets/icons/icon/spline-cubic.svg
  var spline_cubic_default = "./spline-cubic-UXHEP6GI.svg";

  // ../../../packages/assets/icons/icon/spline-line.svg
  var spline_line_default = "./spline-line-EH2NJTGI.svg";

  // ../../../packages/assets/icons/icon/stack-horizontal.svg
  var stack_horizontal_default = "./stack-horizontal-KHHCBUXI.svg";

  // ../../../packages/assets/icons/icon/stack-vertical.svg
  var stack_vertical_default = "./stack-vertical-K3UYO556.svg";

  // ../../../packages/assets/icons/icon/stretch-horizontal.svg
  var stretch_horizontal_default = "./stretch-horizontal-O4PJOCNI.svg";

  // ../../../packages/assets/icons/icon/stretch-vertical.svg
  var stretch_vertical_default = "./stretch-vertical-NFU642RD.svg";

  // ../../../packages/assets/icons/icon/text-align-center.svg
  var text_align_center_default = "./text-align-center-NW5IGQZD.svg";

  // ../../../packages/assets/icons/icon/text-align-justify.svg
  var text_align_justify_default = "./text-align-justify-6B4B3UTH.svg";

  // ../../../packages/assets/icons/icon/text-align-left.svg
  var text_align_left_default = "./text-align-left-QJDWTFIL.svg";

  // ../../../packages/assets/icons/icon/text-align-right.svg
  var text_align_right_default = "./text-align-right-AWHH4ZWF.svg";

  // ../../../packages/assets/icons/icon/tool-arrow.svg
  var tool_arrow_default = "./tool-arrow-OWX4B7S3.svg";

  // ../../../packages/assets/icons/icon/tool-embed.svg
  var tool_embed_default = "./tool-embed-BGTKSDSH.svg";

  // ../../../packages/assets/icons/icon/tool-eraser.svg
  var tool_eraser_default = "./tool-eraser-6MM27NOP.svg";

  // ../../../packages/assets/icons/icon/tool-frame.svg
  var tool_frame_default = "./tool-frame-XDCS2VOF.svg";

  // ../../../packages/assets/icons/icon/tool-hand.svg
  var tool_hand_default = "./tool-hand-EAE5EAA2.svg";

  // ../../../packages/assets/icons/icon/tool-highlighter.svg
  var tool_highlighter_default = "./tool-highlighter-AIZKI5CN.svg";

  // ../../../packages/assets/icons/icon/tool-line.svg
  var tool_line_default = "./tool-line-UTQVG34M.svg";

  // ../../../packages/assets/icons/icon/tool-media.svg
  var tool_media_default = "./tool-media-EUCUCPPZ.svg";

  // ../../../packages/assets/icons/icon/tool-note.svg
  var tool_note_default = "./tool-note-QJOEKCF3.svg";

  // ../../../packages/assets/icons/icon/tool-pencil.svg
  var tool_pencil_default = "./tool-pencil-BSFYMW7W.svg";

  // ../../../packages/assets/icons/icon/tool-pointer.svg
  var tool_pointer_default = "./tool-pointer-YPWFLMHG.svg";

  // ../../../packages/assets/icons/icon/tool-text.svg
  var tool_text_default = "./tool-text-23UD26ZV.svg";

  // ../../../packages/assets/icons/icon/trash.svg
  var trash_default = "./trash-2SG6GG6P.svg";

  // ../../../packages/assets/icons/icon/triangle-down.svg
  var triangle_down_default = "./triangle-down-WWGDWHTE.svg";

  // ../../../packages/assets/icons/icon/triangle-up.svg
  var triangle_up_default = "./triangle-up-W2RPUBB3.svg";

  // ../../../packages/assets/icons/icon/twitter.svg
  var twitter_default = "./twitter-LG52VQSV.svg";

  // ../../../packages/assets/icons/icon/undo.svg
  var undo_default = "./undo-3DFGMHOZ.svg";

  // ../../../packages/assets/icons/icon/ungroup.svg
  var ungroup_default = "./ungroup-LF5HAADT.svg";

  // ../../../packages/assets/icons/icon/unlock-small.svg
  var unlock_small_default = "./unlock-small-5TT2XZKU.svg";

  // ../../../packages/assets/icons/icon/unlock.svg
  var unlock_default = "./unlock-4QZDZP67.svg";

  // ../../../packages/assets/icons/icon/visible.svg
  var visible_default = "./visible-2VDOMDS5.svg";

  // ../../../packages/assets/icons/icon/warning-triangle.svg
  var warning_triangle_default = "./warning-triangle-XMI6G2GK.svg";

  // ../../../packages/assets/icons/icon/zoom-in.svg
  var zoom_in_default = "./zoom-in-LZHUWGO6.svg";

  // ../../../packages/assets/icons/icon/zoom-out.svg
  var zoom_out_default = "./zoom-out-WIBPXGGZ.svg";

  // ../../../packages/assets/translations/ar.json
  var ar_default = "./ar-VOSRY4W4.json";

  // ../../../packages/assets/translations/ca.json
  var ca_default = "./ca-NZIXUUUM.json";

  // ../../../packages/assets/translations/da.json
  var da_default = "./da-LPPYLI6B.json";

  // ../../../packages/assets/translations/de.json
  var de_default = "./de-5BD6WGEY.json";

  // ../../../packages/assets/translations/en.json
  var en_default = "./en-PVCBWCM4.json";

  // ../../../packages/assets/translations/es.json
  var es_default = "./es-JLD5SLUL.json";

  // ../../../packages/assets/translations/fa.json
  var fa_default = "./fa-XJUTEWT7.json";

  // ../../../packages/assets/translations/fi.json
  var fi_default = "./fi-5XD6N2AX.json";

  // ../../../packages/assets/translations/fr.json
  var fr_default = "./fr-T7Y7TWDV.json";

  // ../../../packages/assets/translations/gl.json
  var gl_default = "./gl-R7SP2OGE.json";

  // ../../../packages/assets/translations/he.json
  var he_default = "./he-EOVECWK2.json";

  // ../../../packages/assets/translations/hi-in.json
  var hi_in_default = "./hi-in-TPBLGCVY.json";

  // ../../../packages/assets/translations/hu.json
  var hu_default = "./hu-RWQGTMFT.json";

  // ../../../packages/assets/translations/it.json
  var it_default = "./it-4PH4C55E.json";

  // ../../../packages/assets/translations/ja.json
  var ja_default = "./ja-LNIENWNB.json";

  // ../../../packages/assets/translations/ko-kr.json
  var ko_kr_default = "./ko-kr-KR4STE5N.json";

  // ../../../packages/assets/translations/ku.json
  var ku_default = "./ku-YDV2MT34.json";

  // ../../../packages/assets/translations/languages.json
  var languages_default = "./languages-W42A3KLE.json";

  // ../../../packages/assets/translations/main.json
  var main_default = "./main-CDT52CVI.json";

  // ../../../packages/assets/translations/my.json
  var my_default = "./my-F6IIYM24.json";

  // ../../../packages/assets/translations/ne.json
  var ne_default = "./ne-GQHITCAM.json";

  // ../../../packages/assets/translations/no.json
  var no_default = "./no-IAKVOKY6.json";

  // ../../../packages/assets/translations/pl.json
  var pl_default = "./pl-AC4KFR3W.json";

  // ../../../packages/assets/translations/pt-br.json
  var pt_br_default = "./pt-br-RXGTOYMH.json";

  // ../../../packages/assets/translations/pt-pt.json
  var pt_pt_default = "./pt-pt-K2243WHY.json";

  // ../../../packages/assets/translations/ro.json
  var ro_default = "./ro-5ZHBLSMT.json";

  // ../../../packages/assets/translations/ru.json
  var ru_default = "./ru-LKXK7C3F.json";

  // ../../../packages/assets/translations/sv.json
  var sv_default = "./sv-EDIPKQSY.json";

  // ../../../packages/assets/translations/te.json
  var te_default = "./te-AJVYJ424.json";

  // ../../../packages/assets/translations/th.json
  var th_default = "./th-TNSAMBXT.json";

  // ../../../packages/assets/translations/tr.json
  var tr_default = "./tr-KR4RQMSL.json";

  // ../../../packages/assets/translations/uk.json
  var uk_default = "./uk-NUOI6P36.json";

  // ../../../packages/assets/translations/vi.json
  var vi_default = "./vi-4JSRDEJ5.json";

  // ../../../packages/assets/translations/zh-cn.json
  var zh_cn_default = "./zh-cn-BHBINMCV.json";

  // ../../../packages/assets/translations/zh-tw.json
  var zh_tw_default = "./zh-tw-DFQP5PF3.json";

  // ../../../packages/assets/imports.js
  function formatAssetUrl(assetUrl, format = {}) {
    const assetUrlString = typeof assetUrl === "string" ? assetUrl : assetUrl.src;
    if (typeof format === "function")
      return format(assetUrlString);
    const { baseUrl = "" } = format;
    if (assetUrlString.startsWith("data:"))
      return assetUrlString;
    if (assetUrlString.match(/^https?:\/\//))
      return assetUrlString;
    return `${baseUrl.replace(/\/$/, "")}/${assetUrlString.replace(/^\.?\//, "")}`;
  }
  function getAssetUrlsByImport(opts) {
    return {
      fonts: {
        monospace: formatAssetUrl(IBMPlexMono_Medium_default, opts),
        sansSerif: formatAssetUrl(IBMPlexSans_Medium_default, opts),
        serif: formatAssetUrl(IBMPlexSerif_Medium_default, opts),
        draw: formatAssetUrl(Shantell_Sans_Normal_SemiBold_default, opts)
      },
      icons: {
        "align-bottom-center": formatAssetUrl(align_bottom_center_default, opts),
        "align-bottom-left": formatAssetUrl(align_bottom_left_default, opts),
        "align-bottom-right": formatAssetUrl(align_bottom_right_default, opts),
        "align-bottom": formatAssetUrl(align_bottom_default, opts),
        "align-center-center": formatAssetUrl(align_center_center_default, opts),
        "align-center-horizontal": formatAssetUrl(align_center_horizontal_default, opts),
        "align-center-left": formatAssetUrl(align_center_left_default, opts),
        "align-center-right": formatAssetUrl(align_center_right_default, opts),
        "align-center-vertical": formatAssetUrl(align_center_vertical_default, opts),
        "align-left": formatAssetUrl(align_left_default, opts),
        "align-right": formatAssetUrl(align_right_default, opts),
        "align-top-center": formatAssetUrl(align_top_center_default, opts),
        "align-top-left": formatAssetUrl(align_top_left_default, opts),
        "align-top-right": formatAssetUrl(align_top_right_default, opts),
        "align-top": formatAssetUrl(align_top_default, opts),
        "arrow-left": formatAssetUrl(arrow_left_default, opts),
        "arrowhead-arrow": formatAssetUrl(arrowhead_arrow_default, opts),
        "arrowhead-bar": formatAssetUrl(arrowhead_bar_default, opts),
        "arrowhead-diamond": formatAssetUrl(arrowhead_diamond_default, opts),
        "arrowhead-dot": formatAssetUrl(arrowhead_dot_default, opts),
        "arrowhead-none": formatAssetUrl(arrowhead_none_default, opts),
        "arrowhead-square": formatAssetUrl(arrowhead_square_default, opts),
        "arrowhead-triangle-inverted": formatAssetUrl(arrowhead_triangle_inverted_default, opts),
        "arrowhead-triangle": formatAssetUrl(arrowhead_triangle_default, opts),
        "aspect-ratio": formatAssetUrl(aspect_ratio_default, opts),
        avatar: formatAssetUrl(avatar_default, opts),
        blob: formatAssetUrl(blob_default, opts),
        "bring-forward": formatAssetUrl(bring_forward_default, opts),
        "bring-to-front": formatAssetUrl(bring_to_front_default, opts),
        check: formatAssetUrl(check_default, opts),
        "checkbox-checked": formatAssetUrl(checkbox_checked_default, opts),
        "checkbox-empty": formatAssetUrl(checkbox_empty_default, opts),
        "chevron-down": formatAssetUrl(chevron_down_default, opts),
        "chevron-left": formatAssetUrl(chevron_left_default, opts),
        "chevron-right": formatAssetUrl(chevron_right_default, opts),
        "chevron-up": formatAssetUrl(chevron_up_default, opts),
        "chevrons-ne": formatAssetUrl(chevrons_ne_default, opts),
        "chevrons-sw": formatAssetUrl(chevrons_sw_default, opts),
        "clipboard-copied": formatAssetUrl(clipboard_copied_default, opts),
        "clipboard-copy": formatAssetUrl(clipboard_copy_default, opts),
        code: formatAssetUrl(code_default, opts),
        collab: formatAssetUrl(collab_default, opts),
        color: formatAssetUrl(color_default, opts),
        comment: formatAssetUrl(comment_default, opts),
        "cross-2": formatAssetUrl(cross_2_default, opts),
        cross: formatAssetUrl(cross_default, opts),
        "dash-dashed": formatAssetUrl(dash_dashed_default, opts),
        "dash-dotted": formatAssetUrl(dash_dotted_default, opts),
        "dash-draw": formatAssetUrl(dash_draw_default, opts),
        "dash-solid": formatAssetUrl(dash_solid_default, opts),
        discord: formatAssetUrl(discord_default, opts),
        "distribute-horizontal": formatAssetUrl(distribute_horizontal_default, opts),
        "distribute-vertical": formatAssetUrl(distribute_vertical_default, opts),
        dot: formatAssetUrl(dot_default, opts),
        "dots-horizontal": formatAssetUrl(dots_horizontal_default, opts),
        "dots-vertical": formatAssetUrl(dots_vertical_default, opts),
        "drag-handle-dots": formatAssetUrl(drag_handle_dots_default, opts),
        duplicate: formatAssetUrl(duplicate_default, opts),
        edit: formatAssetUrl(edit_default, opts),
        "external-link": formatAssetUrl(external_link_default, opts),
        file: formatAssetUrl(file_default, opts),
        "fill-none": formatAssetUrl(fill_none_default, opts),
        "fill-pattern": formatAssetUrl(fill_pattern_default, opts),
        "fill-semi": formatAssetUrl(fill_semi_default, opts),
        "fill-solid": formatAssetUrl(fill_solid_default, opts),
        follow: formatAssetUrl(follow_default, opts),
        following: formatAssetUrl(following_default, opts),
        "font-draw": formatAssetUrl(font_draw_default, opts),
        "font-mono": formatAssetUrl(font_mono_default, opts),
        "font-sans": formatAssetUrl(font_sans_default, opts),
        "font-serif": formatAssetUrl(font_serif_default, opts),
        "geo-arrow-down": formatAssetUrl(geo_arrow_down_default, opts),
        "geo-arrow-left": formatAssetUrl(geo_arrow_left_default, opts),
        "geo-arrow-right": formatAssetUrl(geo_arrow_right_default, opts),
        "geo-arrow-up": formatAssetUrl(geo_arrow_up_default, opts),
        "geo-check-box": formatAssetUrl(geo_check_box_default, opts),
        "geo-diamond": formatAssetUrl(geo_diamond_default, opts),
        "geo-ellipse": formatAssetUrl(geo_ellipse_default, opts),
        "geo-hexagon": formatAssetUrl(geo_hexagon_default, opts),
        "geo-octagon": formatAssetUrl(geo_octagon_default, opts),
        "geo-oval": formatAssetUrl(geo_oval_default, opts),
        "geo-pentagon": formatAssetUrl(geo_pentagon_default, opts),
        "geo-rectangle": formatAssetUrl(geo_rectangle_default, opts),
        "geo-rhombus-2": formatAssetUrl(geo_rhombus_2_default, opts),
        "geo-rhombus": formatAssetUrl(geo_rhombus_default, opts),
        "geo-star": formatAssetUrl(geo_star_default, opts),
        "geo-trapezoid": formatAssetUrl(geo_trapezoid_default, opts),
        "geo-triangle": formatAssetUrl(geo_triangle_default, opts),
        "geo-x-box": formatAssetUrl(geo_x_box_default, opts),
        github: formatAssetUrl(github_default, opts),
        group: formatAssetUrl(group_default, opts),
        hidden: formatAssetUrl(hidden_default, opts),
        image: formatAssetUrl(image_default, opts),
        "info-circle": formatAssetUrl(info_circle_default, opts),
        leading: formatAssetUrl(leading_default, opts),
        link: formatAssetUrl(link_default, opts),
        "lock-small": formatAssetUrl(lock_small_default, opts),
        lock: formatAssetUrl(lock_default, opts),
        menu: formatAssetUrl(menu_default, opts),
        minus: formatAssetUrl(minus_default, opts),
        mixed: formatAssetUrl(mixed_default, opts),
        pack: formatAssetUrl(pack_default, opts),
        page: formatAssetUrl(page_default, opts),
        plus: formatAssetUrl(plus_default, opts),
        "question-mark-circle": formatAssetUrl(question_mark_circle_default, opts),
        "question-mark": formatAssetUrl(question_mark_default, opts),
        redo: formatAssetUrl(redo_default, opts),
        "reset-zoom": formatAssetUrl(reset_zoom_default, opts),
        "rotate-ccw": formatAssetUrl(rotate_ccw_default, opts),
        "rotate-cw": formatAssetUrl(rotate_cw_default, opts),
        ruler: formatAssetUrl(ruler_default, opts),
        search: formatAssetUrl(search_default, opts),
        "send-backward": formatAssetUrl(send_backward_default, opts),
        "send-to-back": formatAssetUrl(send_to_back_default, opts),
        "settings-horizontal": formatAssetUrl(settings_horizontal_default, opts),
        "settings-vertical-1": formatAssetUrl(settings_vertical_1_default, opts),
        "settings-vertical": formatAssetUrl(settings_vertical_default, opts),
        "share-1": formatAssetUrl(share_1_default, opts),
        "share-2": formatAssetUrl(share_2_default, opts),
        "size-extra-large": formatAssetUrl(size_extra_large_default, opts),
        "size-large": formatAssetUrl(size_large_default, opts),
        "size-medium": formatAssetUrl(size_medium_default, opts),
        "size-small": formatAssetUrl(size_small_default, opts),
        "spline-cubic": formatAssetUrl(spline_cubic_default, opts),
        "spline-line": formatAssetUrl(spline_line_default, opts),
        "stack-horizontal": formatAssetUrl(stack_horizontal_default, opts),
        "stack-vertical": formatAssetUrl(stack_vertical_default, opts),
        "stretch-horizontal": formatAssetUrl(stretch_horizontal_default, opts),
        "stretch-vertical": formatAssetUrl(stretch_vertical_default, opts),
        "text-align-center": formatAssetUrl(text_align_center_default, opts),
        "text-align-justify": formatAssetUrl(text_align_justify_default, opts),
        "text-align-left": formatAssetUrl(text_align_left_default, opts),
        "text-align-right": formatAssetUrl(text_align_right_default, opts),
        "tool-arrow": formatAssetUrl(tool_arrow_default, opts),
        "tool-embed": formatAssetUrl(tool_embed_default, opts),
        "tool-eraser": formatAssetUrl(tool_eraser_default, opts),
        "tool-frame": formatAssetUrl(tool_frame_default, opts),
        "tool-hand": formatAssetUrl(tool_hand_default, opts),
        "tool-highlighter": formatAssetUrl(tool_highlighter_default, opts),
        "tool-line": formatAssetUrl(tool_line_default, opts),
        "tool-media": formatAssetUrl(tool_media_default, opts),
        "tool-note": formatAssetUrl(tool_note_default, opts),
        "tool-pencil": formatAssetUrl(tool_pencil_default, opts),
        "tool-pointer": formatAssetUrl(tool_pointer_default, opts),
        "tool-text": formatAssetUrl(tool_text_default, opts),
        trash: formatAssetUrl(trash_default, opts),
        "triangle-down": formatAssetUrl(triangle_down_default, opts),
        "triangle-up": formatAssetUrl(triangle_up_default, opts),
        twitter: formatAssetUrl(twitter_default, opts),
        undo: formatAssetUrl(undo_default, opts),
        ungroup: formatAssetUrl(ungroup_default, opts),
        "unlock-small": formatAssetUrl(unlock_small_default, opts),
        unlock: formatAssetUrl(unlock_default, opts),
        visible: formatAssetUrl(visible_default, opts),
        "warning-triangle": formatAssetUrl(warning_triangle_default, opts),
        "zoom-in": formatAssetUrl(zoom_in_default, opts),
        "zoom-out": formatAssetUrl(zoom_out_default, opts)
      },
      translations: {
        ar: formatAssetUrl(ar_default, opts),
        ca: formatAssetUrl(ca_default, opts),
        da: formatAssetUrl(da_default, opts),
        de: formatAssetUrl(de_default, opts),
        en: formatAssetUrl(en_default, opts),
        es: formatAssetUrl(es_default, opts),
        fa: formatAssetUrl(fa_default, opts),
        fi: formatAssetUrl(fi_default, opts),
        fr: formatAssetUrl(fr_default, opts),
        gl: formatAssetUrl(gl_default, opts),
        he: formatAssetUrl(he_default, opts),
        "hi-in": formatAssetUrl(hi_in_default, opts),
        hu: formatAssetUrl(hu_default, opts),
        it: formatAssetUrl(it_default, opts),
        ja: formatAssetUrl(ja_default, opts),
        "ko-kr": formatAssetUrl(ko_kr_default, opts),
        ku: formatAssetUrl(ku_default, opts),
        languages: formatAssetUrl(languages_default, opts),
        main: formatAssetUrl(main_default, opts),
        my: formatAssetUrl(my_default, opts),
        ne: formatAssetUrl(ne_default, opts),
        no: formatAssetUrl(no_default, opts),
        pl: formatAssetUrl(pl_default, opts),
        "pt-br": formatAssetUrl(pt_br_default, opts),
        "pt-pt": formatAssetUrl(pt_pt_default, opts),
        ro: formatAssetUrl(ro_default, opts),
        ru: formatAssetUrl(ru_default, opts),
        sv: formatAssetUrl(sv_default, opts),
        te: formatAssetUrl(te_default, opts),
        th: formatAssetUrl(th_default, opts),
        tr: formatAssetUrl(tr_default, opts),
        uk: formatAssetUrl(uk_default, opts),
        vi: formatAssetUrl(vi_default, opts),
        "zh-cn": formatAssetUrl(zh_cn_default, opts),
        "zh-tw": formatAssetUrl(zh_tw_default, opts)
      },
      embedIcons: {
        codepen: formatAssetUrl(codepen_default, opts),
        codesandbox: formatAssetUrl(codesandbox_default, opts),
        excalidraw: formatAssetUrl(excalidraw_default, opts),
        felt: formatAssetUrl(felt_default, opts),
        figma: formatAssetUrl(figma_default, opts),
        github_gist: formatAssetUrl(github_gist_default, opts),
        google_calendar: formatAssetUrl(google_calendar_default, opts),
        google_maps: formatAssetUrl(google_maps_default, opts),
        google_slides: formatAssetUrl(google_slides_default, opts),
        observable: formatAssetUrl(observable_default, opts),
        replit: formatAssetUrl(replit_default, opts),
        scratch: formatAssetUrl(scratch_default, opts),
        spotify: formatAssetUrl(spotify_default, opts),
        tldraw: formatAssetUrl(tldraw_default, opts),
        vimeo: formatAssetUrl(vimeo_default, opts),
        youtube: formatAssetUrl(youtube_default, opts)
      }
    };
  }

  // src/app.tsx
  var import_react116 = __toESM(require_react());

  // ../../../packages/file-format/src/lib/file.ts
  var LATEST_TLDRAW_FILE_FORMAT_VERSION = 1;
  var tldrawFileValidator = validation_exports.object({
    tldrawFileFormatVersion: validation_exports.nonZeroInteger,
    schema: validation_exports.object({
      schemaVersion: validation_exports.positiveInteger,
      storeVersion: validation_exports.positiveInteger,
      recordVersions: validation_exports.dict(
        validation_exports.string,
        validation_exports.object({
          version: validation_exports.positiveInteger,
          subTypeVersions: validation_exports.dict(validation_exports.string, validation_exports.positiveInteger).optional(),
          subTypeKey: validation_exports.string.optional()
        })
      )
    }),
    records: validation_exports.arrayOf(
      validation_exports.object({
        id: validation_exports.string,
        typeName: validation_exports.string
      }).allowUnknownProperties()
    )
  });
  function isV1File(data) {
    var _a5;
    try {
      if ((_a5 = data.document) == null ? void 0 : _a5.version) {
        return true;
      }
      return false;
    } catch (e2) {
      return false;
    }
  }
  function parseTldrawJsonFile({
    config,
    json,
    userId,
    instanceId
  }) {
    let data;
    try {
      data = tldrawFileValidator.validate(JSON.parse(json));
    } catch (e2) {
      try {
        data = JSON.parse(json);
        if (isV1File(data)) {
          return Result.err({ type: "v1File", data });
        }
      } catch (e3) {
      }
      return Result.err({ type: "notATldrawFile", cause: e2 });
    }
    if (data.tldrawFileFormatVersion > LATEST_TLDRAW_FILE_FORMAT_VERSION) {
      return Result.err({
        type: "fileFormatVersionTooNew",
        version: data.tldrawFileFormatVersion
      });
    }
    let migrationResult;
    try {
      const storeSnapshot = Object.fromEntries(data.records.map((r3) => [r3.id, r3]));
      migrationResult = config.storeSchema.migrateStoreSnapshot(storeSnapshot, data.schema);
    } catch (e2) {
      return Result.err({ type: "invalidRecords", cause: e2 });
    }
    if (migrationResult.type === "error") {
      return Result.err({ type: "migrationFailed", reason: migrationResult.reason });
    }
    try {
      return Result.ok(config.createStore({ initialData: migrationResult.value, userId, instanceId }));
    } catch (e2) {
      return Result.err({ type: "invalidRecords", cause: e2 });
    }
  }
  function serializeTldrawJson(store) {
    return __async(this, null, function* () {
      const recordsToSave = [];
      for (const record of store.allRecords()) {
        switch (record.typeName) {
          case "asset":
            if (record.type !== "bookmark" && record.props.src && !record.props.src.startsWith("data:")) {
              let assetSrcToSave;
              try {
                assetSrcToSave = yield fileToBase64(yield (yield fetch(record.props.src)).blob());
              } catch (e2) {
                assetSrcToSave = record.props.src;
              }
              recordsToSave.push(__spreadProps(__spreadValues({}, record), {
                props: __spreadProps(__spreadValues({}, record.props), {
                  src: assetSrcToSave
                })
              }));
            } else {
              recordsToSave.push(record);
            }
            break;
          default:
            recordsToSave.push(record);
            break;
        }
      }
      return JSON.stringify({
        tldrawFileFormatVersion: LATEST_TLDRAW_FILE_FORMAT_VERSION,
        schema: store.schema.serialize(),
        records: recordsToSave
      });
    });
  }
  function parseAndLoadDocument(app, document2, msg2, addToast, onV1FileLoad, forceDarkMode) {
    return __async(this, null, function* () {
      const parseFileResult = parseTldrawJsonFile({
        config: TldrawEditorConfig.default,
        json: document2,
        instanceId: app.instanceId,
        userId: app.userId
      });
      if (!parseFileResult.ok) {
        let description;
        switch (parseFileResult.error.type) {
          case "notATldrawFile":
            app.annotateError(parseFileResult.error.cause, {
              origin: "file-system.open.parse",
              willCrashApp: false,
              tags: { parseErrorType: parseFileResult.error.type }
            });
            reportError(parseFileResult.error.cause);
            description = msg2("file-system.file-open-error.not-a-tldraw-file");
            break;
          case "fileFormatVersionTooNew":
            description = msg2("file-system.file-open-error.file-format-version-too-new");
            break;
          case "migrationFailed":
            if (parseFileResult.error.reason === "target-version-too-new" /* TargetVersionTooNew */) {
              description = msg2("file-system.file-open-error.file-format-version-too-new");
            } else {
              description = msg2("file-system.file-open-error.generic-corrupted-file");
            }
            break;
          case "invalidRecords":
            app.annotateError(parseFileResult.error.cause, {
              origin: "file-system.open.parse",
              willCrashApp: false,
              tags: { parseErrorType: parseFileResult.error.type }
            });
            reportError(parseFileResult.error.cause);
            description = msg2("file-system.file-open-error.generic-corrupted-file");
            break;
          case "v1File": {
            buildFromV1Document(app, parseFileResult.error.data.document);
            onV1FileLoad == null ? void 0 : onV1FileLoad();
            return;
          }
          default:
            exhaustiveSwitchError(parseFileResult.error, "type");
        }
        addToast({
          title: msg2("file-system.file-open-error.title"),
          description
        });
        return;
      }
      app.replaceStoreContentsWithRecordsForOtherDocument(parseFileResult.value.allRecords());
      if (forceDarkMode)
        app.setDarkMode(true);
    });
  }

  // src/ChangeResponder.tsx
  var import_react114 = __toESM(require_react());
  var ChangeResponder = ({
    syncedStore,
    userId,
    instanceId
  }) => {
    const app = useApp();
    const { addToast, clearToasts, msg: msg2 } = useDefaultHelpers();
    import_react114.default.useEffect(() => {
      function handleMessage({ data: message }) {
        switch (message.type) {
          case "vscode:revert": {
            parseAndLoadDocument(app, message.data.fileContents, msg2, addToast);
            break;
          }
        }
      }
      window.addEventListener("message", handleMessage);
      return () => {
        clearToasts();
        window.removeEventListener("message", handleMessage);
      };
    }, [app, userId, instanceId, msg2, addToast, clearToasts]);
    import_react114.default.useEffect(() => {
      const handleChange = debounce(() => __async(void 0, null, function* () {
        if (syncedStore.store) {
          vscode.postMessage({
            type: "vscode:editor-updated",
            data: {
              fileContents: yield serializeTldrawJson(syncedStore.store)
            }
          });
        }
      }), 250);
      vscode.postMessage({
        type: "vscode:editor-loaded"
      });
      app.on("change-history", handleChange);
      return () => {
        handleChange();
        app.off("change-history", handleChange);
      };
    }, [app, syncedStore, userId, instanceId]);
    return null;
  };

  // src/FileOpen.tsx
  var import_react115 = __toESM(require_react());
  function FileOpen({
    userId,
    fileContents,
    instanceId,
    forceDarkMode
  }) {
    const app = useApp();
    const { msg: msg2, addToast, clearToasts } = useDefaultHelpers();
    const [isFileLoaded, setIsFileLoaded] = import_react115.default.useState(false);
    import_react115.default.useEffect(() => {
      if (isFileLoaded)
        return;
      function onV1FileLoad() {
        vscode.postMessage({
          type: "vscode:v1-file-opened",
          data: {
            description: msg2("vscode.file-open.desc"),
            backup: msg2("vscode.file-open.backup"),
            backupSaved: msg2("vscode.file-open.backup-saved"),
            backupFailed: msg2("vscode.file-open.backup-failed"),
            dontAskAgain: msg2("vscode.file-open.dont-show-again"),
            open: msg2("vscode.file-open.open")
          }
        });
      }
      function loadFile() {
        return __async(this, null, function* () {
          yield parseAndLoadDocument(app, fileContents, msg2, addToast, onV1FileLoad, forceDarkMode);
        });
      }
      loadFile();
      setIsFileLoaded(true);
      return () => {
        clearToasts();
      };
    }, [
      fileContents,
      app,
      userId,
      instanceId,
      addToast,
      msg2,
      clearToasts,
      forceDarkMode,
      isFileLoaded
    ]);
    return null;
  }

  // src/FullPageMessage.tsx
  var import_jsx_runtime114 = __toESM(require_jsx_runtime());
  function FullPageMessage({ children }) {
    return /* @__PURE__ */ (0, import_jsx_runtime114.jsx)(
      "div",
      {
        style: {
          backgroundColor: "var(--vscode-editor-background)",
          color: "var(--vscode-editor-foreground)",
          position: "fixed",
          top: "50%",
          left: "50%",
          WebkitTransform: "translate(-50%, -50%)",
          transform: "translate(-50%, -50%)"
        },
        children
      }
    );
  }

  // src/utils/rpc.ts
  var SimpleRpcError = class extends Error {
    constructor(id, data) {
      super(`Failed ${id}`);
      __publicField(this, "id");
      __publicField(this, "data");
      this.id = id;
      this.data = data;
    }
  };
  function rpc(id, data, opts = { timeout: 5 * 1e3 }) {
    const { timeout } = opts;
    const type = id + "/request";
    const uuid = nanoid();
    return new Promise((resolve, reject) => {
      const inMessage = {
        uuid,
        type,
        data
      };
      vscode.postMessage(inMessage);
      const handler = ({ data: response }) => {
        if (uuid === response.uuid) {
          return;
        }
        const cleanup = () => {
          window.removeEventListener("message", handler);
        };
        if (response.type === `${id}/response`) {
          cleanup();
          resolve(response.data);
        }
        if (response.type === `${id}/error`) {
          cleanup();
          reject(new SimpleRpcError(id, response.data));
        }
        setTimeout(() => {
          cleanup();
          reject(new SimpleRpcError(id, { timeout: true }));
        }, timeout);
      };
      window.addEventListener("message", handler);
    });
  }

  // src/utils/bookmarks.ts
  function onCreateBookmarkFromUrlFallback(url) {
    return __async(this, null, function* () {
      var _a5, _b2, _c;
      const meta = {
        image: "",
        title: "",
        description: ""
      };
      try {
        const resp = yield fetch(url, { method: "GET", mode: "no-cors" });
        const html = yield resp.text();
        const doc = new DOMParser().parseFromString(html, "text/html");
        meta.image = (_a5 = doc.head.querySelector('meta[property="og:image"]')) == null ? void 0 : _a5.getAttribute("content");
        meta.title = (_b2 = doc.head.querySelector('meta[property="og:title"]')) == null ? void 0 : _b2.getAttribute("content");
        meta.description = (_c = doc.head.querySelector('meta[property="og:description"]')) == null ? void 0 : _c.getAttribute("content");
        return meta;
      } catch (error) {
        console.error(error);
      }
      return meta;
    });
  }
  function onCreateBookmarkFromUrl(url) {
    return __async(this, null, function* () {
      try {
        const data = yield rpc("vscode:bookmark", { url });
        return {
          title: data.title || "",
          description: data.description || "",
          image: data.image || ""
        };
      } catch (error) {
        return onCreateBookmarkFromUrlFallback(url);
      }
    });
  }

  // src/app.tsx
  var import_jsx_runtime115 = __toESM(require_jsx_runtime());
  setRuntimeOverrides({
    openWindow: (url, target) => {
      vscode.postMessage({
        type: "vscode:open-window",
        data: {
          url,
          target
        }
      });
    },
    refreshPage: () => {
      vscode.postMessage({
        type: "vscode:refresh-page"
      });
    },
    hardReset: () => __async(void 0, null, function* () {
      var _a5;
      yield (_a5 = window.__tldraw__hardReset) == null ? void 0 : _a5.call(window);
      vscode.postMessage({
        type: "vscode:hard-reset"
      });
    })
  });
  var handleError = (error) => {
    console.error(error.message);
  };
  function WrappedTldrawEditor() {
    return /* @__PURE__ */ (0, import_jsx_runtime115.jsx)("div", { className: "tldraw--editor", children: /* @__PURE__ */ (0, import_jsx_runtime115.jsx)(
      ErrorBoundary,
      {
        fallback: () => /* @__PURE__ */ (0, import_jsx_runtime115.jsx)(FullPageMessage, { children: "Fallback" }),
        onError: handleError,
        children: /* @__PURE__ */ (0, import_jsx_runtime115.jsx)(TldrawWrapper, {})
      }
    ) });
  }
  var menuOverrides = {
    menu: (_app, schema, _helpers) => {
      schema.forEach((item) => {
        if (item.id === "menu" && item.type === "group") {
          item.children = item.children.filter((menuItem2) => {
            if (menuItem2.id === "file" && menuItem2.type === "submenu") {
              return false;
            }
            return true;
          });
        }
      });
      return schema;
    }
  };
  var TldrawWrapper = () => {
    const [tldrawInnerProps, setTldrawInnerProps] = (0, import_react116.useState)(null);
    (0, import_react116.useEffect)(() => {
      function handleMessage({ data: message }) {
        switch (message.type) {
          case "vscode:opened-file": {
            setTldrawInnerProps({
              assetSrc: message.data.assetSrc,
              fileContents: message.data.fileContents,
              uri: message.data.uri,
              userId: message.data.userId,
              isDarkMode: message.data.isDarkMode
            });
            window.removeEventListener("message", handleMessage);
            break;
          }
        }
      }
      window.addEventListener("message", handleMessage);
      vscode.postMessage({ type: "vscode:ready-to-receive-file" });
      return () => {
        window.removeEventListener("message", handleMessage);
      };
    }, [setTldrawInnerProps]);
    return tldrawInnerProps === null ? /* @__PURE__ */ (0, import_jsx_runtime115.jsx)(FullPageMessage, { children: "Loading" }) : /* @__PURE__ */ (0, import_jsx_runtime115.jsx)(TldrawInner, __spreadValues({}, tldrawInnerProps));
  };
  function TldrawInner({ uri, assetSrc, userId, isDarkMode, fileContents }) {
    const instanceId = TAB_ID;
    const syncedStore = useLocalSyncClient({
      universalPersistenceKey: uri,
      instanceId,
      userId
    });
    const assetUrls = (0, import_react116.useMemo)(() => getAssetUrlsByImport({ baseUrl: assetSrc }), [assetSrc]);
    return /* @__PURE__ */ (0, import_jsx_runtime115.jsx)(
      TldrawEditor,
      {
        assetUrls,
        instanceId: TAB_ID,
        userId,
        store: syncedStore,
        onCreateBookmarkFromUrl,
        autoFocus: true,
        children: /* @__PURE__ */ (0, import_jsx_runtime115.jsxs)(TldrawUi, { assetUrls, overrides: [menuOverrides, linksUiOverrides], children: [
          /* @__PURE__ */ (0, import_jsx_runtime115.jsx)(
            FileOpen,
            {
              instanceId,
              userId,
              fileContents,
              forceDarkMode: isDarkMode
            }
          ),
          /* @__PURE__ */ (0, import_jsx_runtime115.jsx)(ChangeResponder, { syncedStore, userId, instanceId }),
          /* @__PURE__ */ (0, import_jsx_runtime115.jsx)(ContextMenu, { children: /* @__PURE__ */ (0, import_jsx_runtime115.jsx)(Canvas, {}) })
        ] })
      }
    );
  }

  // src/index.tsx
  var import_jsx_runtime116 = __toESM(require_jsx_runtime());
  import_client.default.createRoot(document.getElementById("root")).render(
    /* @__PURE__ */ (0, import_jsx_runtime116.jsx)(React73.StrictMode, { children: /* @__PURE__ */ (0, import_jsx_runtime116.jsx)(WrappedTldrawEditor, {}) })
  );
})();
/*! Bundled license information:

react/cjs/react.production.min.js:
  (**
   * @license React
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

scheduler/cjs/scheduler.production.min.js:
  (**
   * @license React
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.min.js:
  (**
   * @license React
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.min.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

is-plain-object/dist/is-plain-object.mjs:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)
*/
